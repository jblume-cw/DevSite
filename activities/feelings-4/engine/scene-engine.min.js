(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SceneEngine = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js":[function(require,module,exports){
/*
  Based on Base.js 1.1a (c) 2006-2010, Dean Edwards
  Updated to pass JSHint and converted into a module by Kenneth Powers
  License: http://www.opensource.org/licenses/mit-license.php
*/
/*global define:true module:true*/
/*jshint eqeqeq:true*/
(function (name, global, definition) {
  if (typeof module !== 'undefined') {
    module.exports = definition();
  } else if (typeof define !== 'undefined' && typeof define.amd === 'object') {
    define(definition);
  } else {
    global[name] = definition();
  }
})('Base', this, function () {
  // Base Object
  var Base = function () {};

  // Implementation
  Base.extend = function (_instance, _static) { // subclass
    var extend = Base.prototype.extend;
    // build the prototype
    Base._prototyping = true;
    var proto = new this();
    extend.call(proto, _instance);
    proto.base = function () {
      // call this method from any other method to invoke that method's ancestor
    };
    delete Base._prototyping;
    // create the wrapper for the constructor function
    //var constructor = proto.constructor.valueOf(); //-dean
    var constructor = proto.constructor;
    var klass = proto.constructor = function () {
        if (!Base._prototyping) {
          if (this._constructing || this.constructor === klass) { // instantiation
            this._constructing = true;
            constructor.apply(this, arguments);
            delete this._constructing;
          } else if (arguments[0] !== null) { // casting
            return (arguments[0].extend || extend).call(arguments[0], proto);
          }
        }
      };
    // build the class interface
    klass.ancestor = this;
    klass.extend = this.extend;
    klass.forEach = this.forEach;
    klass.implement = this.implement;
    klass.prototype = proto;
    klass.toString = this.toString;
    klass.valueOf = function (type) {
      return (type === 'object') ? klass : constructor.valueOf();
    };
    extend.call(klass, _static);
    // class initialization
    if (typeof klass.init === 'function') klass.init();
    return klass;
  };

  Base.prototype = {
    extend: function (source, value) {
      if (arguments.length > 1) { // extending with a name/value pair
        var ancestor = this[source];
        if (ancestor && (typeof value === 'function') && // overriding a method?
        // the valueOf() comparison is to avoid circular references
        (!ancestor.valueOf || ancestor.valueOf() !== value.valueOf()) && /\bbase\b/.test(value)) {
          // get the underlying method
          var method = value.valueOf();
          // override
          value = function () {
            var previous = this.base || Base.prototype.base;
            this.base = ancestor;
            var returnValue = method.apply(this, arguments);
            this.base = previous;
            return returnValue;
          };
          // point to the underlying method
          value.valueOf = function (type) {
            return (type === 'object') ? value : method;
          };
          value.toString = Base.toString;
        }
        this[source] = value;
      } else if (source) { // extending with an object literal
        var extend = Base.prototype.extend;
        // if this object has a customized extend method then use it
        if (!Base._prototyping && typeof this !== 'function') {
          extend = this.extend || extend;
        }
        var proto = {
          toSource: null
        };
        // do the "toString" and other methods manually
        var hidden = ['constructor', 'toString', 'valueOf'];
        // if we are prototyping then include the constructor
        for (var i = Base._prototyping ? 0 : 1; i < hidden.length; i++) {
          var h = hidden[i];
          if (source[h] !== proto[h])
            extend.call(this, h, source[h]);
        }
        // copy each of the source object's properties to this object
        for (var key in source) {
          if (!proto[key]) extend.call(this, key, source[key]);
        }
      }
      return this;
    }
  };

  // initialize
  Base = Base.extend({
    constructor: function () {
      this.extend(arguments[0]);
    }
  }, {
    ancestor: Object,
    version: '1.1',
    forEach: function (object, block, context) {
      for (var key in object) {
        if (this.prototype[key] === undefined) {
          block.call(context, object[key], key, object);
        }
      }
    },
    implement: function () {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === 'function') {
          // if it's a function, call it
          arguments[i](this.prototype);
        } else {
          // add the interface using the extend method
          this.prototype.extend(arguments[i]);
        }
      }
      return this;
    },
    toString: function () {
      return String(this.valueOf());
    }
  });

  // Return Base implementation
  return Base;
});

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\inherits\\inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\jquery\\dist\\jquery.js":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js":[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel], false);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level, persist) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            if (persist !== false) {  // defaults to true
                persistLevelIfPossible(level);
            }
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function(persist) {
        self.setLevel(self.levels.TRACE, persist);
    };

    self.disableAll = function(persist) {
        self.setLevel(self.levels.SILENT, persist);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js":[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\process\\browser.js":[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\support\\isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\support\\isBufferBrowser.js","_process":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\process\\browser.js","inherits":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\inherits\\inherits_browser.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-channel.js":[function(require,module,exports){
/**
 * @author George Frick
 * Represent a playable set of sounds including a descriptive key, an audio sprite, and the set of sound keys.
 */
(function () {

    var _ = require('lodash');
    var Base = require('basejs');

    module.exports = Base.extend({
        constructor: function (key, sprite, sounds) {
            this.key = key;
            this.sprite = sprite;
            this.sounds = sounds; // json set of sounds.

            _.each(sounds, function (timing, key) {
                this.sprite.addMarker(key, timing[0], timing[1], 1, timing[2]);
            }, this);

            this.events = {
                onStop: new Phaser.Signal()
            };
            this.sprite.onStop.add(this.onSoundFinished, this);
        },
        allowMultiple: function() {
            this.sprite.allowMultiple = true;
        },
        isCurrentMarker: function(key) {
            return this.sprite.currentMarker === key;
        },
        isPlaying: function() {
            return this.sprite.isPlaying;
        },
        getKey: function() {
            return this.key;
        },
        getChannel: function() {
            return this.sprite;
        },
        hasKey: function( key ) {
            return !!(this.sounds[key]);
        },
        play: function( key ) {
            this.sprite.play(key);
        },
        stop: function() {
            this.sprite.stop();
        },
        stopNoEvent: function() {
            this.sprite.onStop.removeAll();
            this.sprite.stop();
            this.sprite.onStop.add(this.onSoundFinished, this);
        },
        onSoundFinished: function (stoppedSound, marker) {
            this.events.onStop.dispatch(stoppedSound, marker);
        },
        destroy: function() {
            this.sprite.onStop.removeAll();
            this.sprite.stop();
            this.sprite.destroy();
        }
    });

}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-service.js":[function(require,module,exports){
/**
 * @author George Frick
 * https://phasergames.com/phaser-audio-delay/
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');
    var AudioChannel = require('./audio-channel');
    var CHANNEL_PRIMARY = "primary";
    var CHANNEL_MUSIC = "secondary";
    var CHANNEL_SFX = "sfx";
    //var buildAudioLipSyncArray = require('../tools/audio-lip-sync'); //comment out when done

    var AudioService = Base.extend({
        constructor: function (game, themeData) {
            if (!game) {
                throw "AudioService requires game constructor argument.";
            }
            if (!themeData) {
                throw "AudioService requires themeData constructor argument.";
            }
            this.game = game;
            this.theme = themeData;
            this.audioQueue = [];
            this.channels = {};

            this.events = {
                soundFinished: new Phaser.Signal(),
                onSceneAudioReady: new Phaser.Signal()
            };
        },
        /**
         * If there is a scene showing, end it.
         * @TODO allow this to remove from cache?
         */
        stopAndUnload: function () {
            _.each(this.channels, function (channel) {
                channel.destroy();
            }, this);
        },
        // Stop the current scene and clean it up.
        stopScene: function () {
            if (this.channels[CHANNEL_PRIMARY]) {
                this.channels[CHANNEL_PRIMARY].stopNoEvent();
            }
            if (this.channels[CHANNEL_MUSIC]) {
                this.channels[CHANNEL_MUSIC].stop();
            }
            if (this.channels[CHANNEL_SFX]) {
                this.channels[CHANNEL_SFX].stop();
            }
        },
        /**
         * If something starts to play audio, it does it via an event, this allows for telling the other actors, the
         * scene, act and the play. In this case, we also want to stop any previously playing sound.
         * The current speech is always tracked so we can have eventing on when it stops.
         * @param data {
         *  text: "",
         *  "audio": "",
         *  "key": "",
         *  "channel": optional channel, defaults to primary, switched to sfx for sfx
         *  "priority": stop | restart | queue | low | with | stopall
         *  "stop":  => stop audio if playing the same sound.
         *  "restart":  Restart audio if playing the same sound.
         *  "queue": Queue the audio to play next, will play now if no queue.
         *  "low": Ignore request if sound is playing
         *  "stopall" : stopall sound, ignore audio key.
         *  default/interrupt: Interrupt the current sound and play the new one, emptying the queue.
         * }
         */
        playAudio: function (audio, data) {

            if (!data) {
                throw "data is required when calling playAudio";
            }

            if (!data.priority) {
                data.priority = "interrupt";
            }

            if (!data.channel) {
                data.channel = CHANNEL_PRIMARY;
            }

            if (!this.channels[CHANNEL_PRIMARY]) {
                throw "Attempting to play audio before game sounds are initialized.";
            }

            var channel = this.findChannelForKey(audio, data.channel);
            if (!channel ) {
                // Some activities play "silence", rather than adjusting the converted XML, we support it.
                if( audio === "silence" ) {
                    channel = this.channels[CHANNEL_PRIMARY];
                    data.priority = "stopall";
                } else {
                    throw "Request to play unknown key: " + audio;
                }
            }

            var gameSounds = this.channels[CHANNEL_PRIMARY];
            switch (data.priority) {
                case 'stopall': {
                    channel.stop();
                    this.audioQueue = [];
                    return;
                }
                case 'stop': {
                    // A stop is always a stop, so either stop or do nothing.
                    if (channel.isPlaying && channel.isCurrentMarker(audio) ) {
                        channel.stop();
                    }
                    return;
                }
                case 'restart': {
                    if (channel.isPlaying && channel.isCurrentMarker(audio)) {
                        channel.stop();
                    }
                    break;
                }
                case 'queue': {
                    if (channel.isPlaying() && !channel.isCurrentMarker(audio)) {
                        this.audioQueue.push(data);
                        return;
                    }
                    // Will fall through and play the sound.
                    break;
                }
                case 'low': {
                    if (channel.isPlaying()) {
                        return;
                    }
                    break;
                }
                case 'sfx': {
                    channel = this.findChannelForKey(audio, 'sfx');
                    if (!channel) {
                        throw "Request to play unknown sfx key: " + audio;
                    }
                    channel.play(audio);
                    return;
                }
                default:
                case 'interrupt': {
                    if (channel.isPlaying() && channel.isCurrentMarker(audio) ) {
                        // Already playing, just keep playing.
                        return;
                    }
                    channel.stop();
                    break;
                }
            }

            log.warn("Playing audio " + audio);
            channel.play(audio);
        },
        /**
         * Start by trying to get the preferred channel, but otherwise search.
         */
        findChannelForKey: function (key, preferredChannel) {
            var preferred = this.channels[preferredChannel];
            if (preferred && preferred.hasKey(key)) {
                return preferred;
            }
            return _.find(this.channels, function (channel) {
                return channel.hasKey(key);
            });
        },
        onGameMusic: function (audio) {
            this.channels[CHANNEL_MUSIC].play(audio);
        },
        /**
         * When audio finishes playing, actors need to know, in case they are animating speech/etc.
         */
        onSoundFinished: function (stoppedSound, marker) {
            log.warn("On sound Finished called for: " + marker);
            log.warn(stoppedSound);

            this.events.soundFinished.dispatch(stoppedSound, marker);

            if (this.audioQueue.length > 0) {
                var data = this.audioQueue.pop();
                this.playAudio(data.audio, data);
            }
        },
        initSounds: function () {
            // Uncomment this line and you will produce lip sync data.
            //buildAudioLipSyncArray(this.theme.soundFile[0], this.theme.sounds, this.theme.soundSyncData); //comment out when done
            this.channels[CHANNEL_PRIMARY] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_MUSIC] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_SFX] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_PRIMARY].allowMultiple();
            this.channels[CHANNEL_MUSIC].allowMultiple();
            //this.gameSounds.onMarkerComplete.add(this.onSoundFinished, this); This event doesn't do what you think.
            this.channels[CHANNEL_PRIMARY].events.onStop.add(this.onSoundFinished, this);
        },
        /**
         * These three functions are the old loading functions used by play-act
         */
        loadAudio: function (soundKey, soundFile) {
            this.game.load.audio(soundKey, soundFile);
        },
        unloadAudio: function (soundKey) {
            this.game.cache.removeSound(soundKey);
        },
        isReady: function (soundKey) {
            return this.game.cache.isSoundDecoded(soundKey)
                && this.game.cache.isSoundReady(soundKey);
        },
        /**
         * These are the newer functions which show the loading screen during dynamic loading
         */
        showLoading: function () {
            this.game.loadingScreen.show();
        },
        loadAdditionalAudio: function (audioList) {
            if (audioList && audioList.length > 0) {
                this.showLoading();

                _.each(audioList, function (audioKey) {
                    var actorSoundData = this.theme.actorSounds[audioKey];
                    if (!actorSoundData) {
                        throw "No audio entry for audio key: " + audioKey;
                    }
                    // @TODO just go ahead and load the json as well so they don't need to be copied in!
                    this.game.load.audio(audioKey, actorSoundData.soundFile);
                }, this);

                this.audioList = audioList;
                this.game.load.onLoadComplete.addOnce(this.waitForAudioDecode, this);
                this.game.load.start();
            } else {
                this.debugOutput();
                this.events.onSceneAudioReady.dispatch(true);
            }
        },
        unloadAdditionalAudio: function (audioList) {
            if (audioList && audioList.length > 0) {

                _.each(audioList, function (audioKey) {
                   if( this.channels[audioKey] ) {
                       this.channels[audioKey].destroy();
                       delete this.channels[audioKey];
                       this.game.cache.removeSound(audioKey);
                   }
                }, this);
            }
        },
        waitForAudioDecode: function () {
            var allReady = true;

            this.game.loadingScreen.showDecoding();
            _.each(this.audioList, function (audioKey) {
                if (this.game.cache.checkSoundKey(audioKey) === false) {
                    // Scene was somehow destroyed before it finished loading it's audio.
                    return;
                }
                if (!this.game.cache.isSoundDecoded(audioKey) || !this.game.cache.isSoundReady(audioKey)) {
                    allReady = false;
                }
            }, this);

            if (allReady) {
                this.createChannels(this.audioList);
                this.audioList = null;
                this.game.loadingScreen.destroy();
                this.debugOutput();
                this.events.onSceneAudioReady.dispatch(true);
            } else {
                setTimeout(_.bind(this.waitForAudioDecode, this), 500);
            }
        },
        debugOutput: function() {
            // var channelNames = [];
            // var cacheNames = [];
            // _.each( this.channels, function(channel, key) {
            //     channelNames.push(key);
            // }, this);
            // _.each( this.game.cache.getKeys(Phaser.Cache.SOUND), function( key) {
            //     cacheNames.push(key);
            // }, this);
            // console.log( "Available Channels for scene: " + channelNames.join(", "));
            // console.log( "Available Channels in cache: " + channelNames.join(", "));
        },
        createChannels: function( audioList ) {
            _.each(audioList, function (audioKey) {
                var actorSoundData = this.theme.actorSounds[audioKey];
                if (!actorSoundData) {
                    throw "No audio entry for LOADED audio key: " + audioKey;
                }
                this.channels[audioKey] = new AudioChannel(audioKey, this.game.add.audio(audioKey), actorSoundData.sounds);
            }, this);
        }
    });

    module.exports = AudioService;
}());

},{"./audio-channel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-channel.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act-manager.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/22/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Return an act instance given a type.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
    PlayAct = require('./play-act');

    module.exports = {
        getActInstance: function (type, game, themeData, actName) {
            if( type && type !== "PlayAct" ) {
                var clazz = window[type];
                if( clazz ) {
                    var actInstance = new clazz(game,  themeData, actName);
                    actInstance.actName = actName; // make sure there is no funny business.
                    return actInstance;
                } else {
                    window.alert("Unable to load activity: " + type);
                }
            } else {
                return new PlayAct(game, themeData, actName);
            }
        }
    };
}());

},{"./play-act":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent an entire ACT. An act coordinates a set of scenes.
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Base = require("basejs"),
		PlayScene = require("../scene/play-scene"),
		PlayAction = require("../scene/play-action"),
		PlayModel = require("../play/model"),
		ActValidator = require("./validator");
	var AudioService = require("./audio-service");

	var PlayAct = Base.extend({
		constructor: function (game, themeData, actName) {
			if (!game) {
				throw "PlayAct requires game constructor argument.";
			}
			if (!themeData) {
				throw "PlayAct requires themeData constructor argument.";
			}
			this.game = game;
			this.theme = themeData;
			this.actName = actName;
			this.audioService = new AudioService(this.game, this.theme);

			this.events = {
				onGameChoice: new Phaser.Signal(),
				onActStatus: new Phaser.Signal(),
			};

			this.isPreloaded = false;
		},
		setScormString: function (suspendData) {
			this.suspendData = suspendData;
		},
		getScormString: function () {
			return this.model.getSuspendData();
		},
		/**
		 * Show the current scene, clearing out any old scene. If there is a sound playing, stop it. This frees up
		 * memory, but in the future it could possibly recycle actors.
		 */
		start: function (isRestart) {
			log.warn("showCurrentScene called.");

			if (this.suspendData) {
				this.model.restoreData(this.suspendData);
				this.suspendData = null;
			}
			this.model.events.onGameOutcome.add(this.onGameOutcome, this);
			this.audioService.initSounds();
			this.audioService.events.onSceneAudioReady.add(
				this.onSceneStartAudioReady,
				this
			);
			this.audioService.events.soundFinished.add(this.onSoundFinished, this);

			if (isRestart) {
				log.warn("Trying to restart..." + this.model.getCurrentSceneName());
				this.model.tryResume();
				log.warn("....." + this.model.getCurrentSceneName());
			}
			this.startScene();
		},
		startScene: function () {
			var newSceneData = this.model.getCurrentScene();
			if (this.currentScene) {
				this.currentScene.showNewSceneData(newSceneData);
			} else {
				this.currentScene = new PlayScene(
					this.game,
					newSceneData,
					this.model.getVarInterface(),
					this.theme
				);
			}
			this.audioService.loadAdditionalAudio(
				this.currentScene.getAdditionalAudio()
			);
		},
		/**
		 * This is the other half of "startScene", which now waits for audio...
		 */
		onSceneStartAudioReady: function () {
			if (this.model.isShowPlayThrough()) {
				this.currentScene.showPlayThrough();
			}

			this.currentScene.events.onGameChoice.add(this.onGameChoice, this);
			this.currentScene.events.onGameSpeech.add(this.onGameSpeech, this);
			this.currentScene.events.onGameMusic.add(this.onGameMusic, this);
			this.currentScene.showScene();
			this.runSceneStartActions();
			this.events.onActStatus.dispatch("save");
		},
		/**
		 * When a scene starts, run any starting actions.
		 */
		runSceneStartActions: function () {
			var actions = this.currentScene.getActions();
			_.each(
				actions,
				function (singleAction) {
					log.warn("executing starting action:");
					log.warn(singleAction);
					PlayAction.getAction(singleAction).execute(this);
				},
				this
			);
			actions = this.model.getGlobalActions();
			_.each(
				actions,
				function (singleAction) {
					log.warn("executing starting global action:");
					log.warn(singleAction);
					PlayAction.getAction(singleAction).execute(this);
				},
				this
			);
			// The scene is done starting up, allow input.
			this.game.input.disabled = false;
		},
		/**
		 * If there is a scene showing, end it.
		 */
		stop: function () {
			this.audioService.stopAndUnload();

			// If we're not in a scene, then no input!
			this.game.input.disabled = true;
			if (this.currentScene) {
				this.currentScene.destroy();
				this.currentScene = null;
			}
			this.unload(); // remove everything that was preloaded.
		},
		// Stop the current scene and clean it up.
		stopScene: function () {
			this.audioService.stopScene();
			this.audioService.unloadAdditionalAudio(
				this.currentScene.getAdditionalAudio()
			);
			this.game.input.disabled = true;
			if (this.currentScene) {
				this.currentScene.clearForReuse();
			}
		},
		/**
		 * An outcome or starting action has set a variable (game choice). Other actors in the scene need to
		 * know about it.
		 * @param data
		 */
		onGameChoiceAction: function (data) {
			this.onGameChoice(data);
			if (!data.consumed) {
				this.currentScene.sendGameChoiceToActors("!ACTION!", data);
			}
		},
		/**
		 * Something in the game has made a choice. This choice is recorded as the setting of a variable, we then
		 * run an update in case that choice led to an action, (events bubble up, actions happen down)
		 * @param data
		 */
		onGameChoice: function (data) {
			log.warn("game choice");
			log.warn(data);

			this.events.onGameChoice.dispatch(data);
			if (data.consumed) {
				return;
			}

			var tempVars = _.pairs(data)[0];
			log.warn(tempVars);
			data.consumed = this.actCommand(tempVars[0], tempVars[1]);

			// Only record the variable if it wasn't a command, which does NOT consume it. It may result in an event,
			// otherwise, check for completed outcomes.
			if (!data.consumed) {
				var event = this.model.handleSpecialVar(tempVars[0], tempVars[1]);
				// var event = this.model.setVar(tempVars[0], tempVars[1]);
				if (event) {
					this.events.onActStatus.dispatch(event);
				}
				if (this.model.setVar(tempVars[0], tempVars[1])) {
					this.checkCurrentSceneOutcomes(tempVars[0]);
				}
			}
		},
		checkCurrentSceneOutcomes: function (variable) {
			this.model.checkForCompletedOutcomes(variable);
		},
		/**
		 * this function clears a variable out of the model manually. It should almost never be used.
		 * @param name
		 */
		clearVariable: function (name) {
			this.model.variables[name] = undefined;
		},
		/**
		 * Run an Act level command. Return true if a command happened, otherwise false.
		 * @param command
		 * @param arg
		 * @returns {boolean} true if the command was consumed.
		 */
		actCommand: function (command, arg) {
			log.warn("Act command: " + command + " / " + arg);
			if (command === "remove-actor" && this.currentScene) {
				this.currentScene.removeActorByName(arg);
			} else if (command === "add-actor" && this.currentScene) {
				this.currentScene.addActor(arg);
			} else if (
				command === "objective_complete" ||
				command === "activity_complete"
			) {
				// objective_complete => "finished this act", not a scorm objective.
				this.events.onActStatus.dispatch("complete");
				// objective => "finish a scorm objective"
			} else if (command === "objective") {
				this.events.onActStatus.dispatch("objective", arg);
			} else {
				return false;
			}
			return true;
		},
		/**
		 * If something starts to play audio, it does it via an event, this allows for telling the other actors, the
		 * scene, act and the play. In this case, we also want to stop any previously playing sound.
		 * The current speech is always tracked so we can have eventing on when it stops.
		 * @param data
		 */
		onGameSpeech: function (data) {
			log.warn("on game speech");
			log.warn(data);

			var audio = this.model.getValue(data.audio);
			if (data.key) {
				audio = this.model.getValue(data.key) + "_" + audio;
			}

			this.audioService.playAudio(audio, data);
		},
		onGameMusic: function (audio) {
			this.audioService.onGameMusic(audio);
		},
		/**
		 * When audio finishes playing, actors need to know, in case they are animating speech/etc.
		 */
		onSoundFinished: function (stoppedSound, marker) {
			// _tempMarker because currentMarker is now blank...
			if (this.currentScene) {
				this.currentScene.onGameSpeechStop(marker);
			}
		},
		/**
		 * The model has signaled that outcomes need to execute actions. Execute those actions.
		 * @param pendingActions
		 * Will look like:
		 * [
		 *  [ "outcome_1": [ { ACTION } , { ACTION } ],
		 *    "outcome_2": [ { ACTION } , { ACTION } ], ... ]
		 */
		onGameOutcome: function (pendingActions) {
			_.each(
				pendingActions,
				function (actionData) {
					log.warn("executing actions for " + actionData.name);
					_.each(
						actionData.actions,
						function (singleAction) {
							log.warn("executing action:");
							log.warn(actionData);
							PlayAction.getAction(singleAction).execute(this);
						},
						this
					);
				},
				this
			);
		},
		showNewScene: function (scene) {
			if (this.model.setCurrentScene(scene)) {
				this.stopScene();
				this.startScene();
			}
		},
		/**
		 * This returns the paths to everything, based on the theme/
		 * @returns {{textureKey: string, texture: string, textureMap: string, soundKey: string, soundFile: string}}
		 */
		getMediaData: function () {
			var soundFiles = null;
			if (this.theme.hasOwnProperty("soundFile")) {
				soundFiles = [];
				for (var i = 0; i < this.theme.soundFile.length; i++) {
					soundFiles[i] = this.game.config.assetPath + this.theme.soundFile[i];
				}
			}

			var animationFiles = null;
			if (this.theme.hasOwnProperty("animations")) {
				animationFiles = [];
				for (var i = 0; i < this.theme.animations.length; i++) {
					animationFiles.push({
						texture:
							this.game.config.assetPath + this.theme.animations[i].texture,
						textureMap:
							this.game.config.assetPath + this.theme.animations[i].textureMap,
						textureKey: this.theme.animations[i].textureKey,
					});
				}
			}

			return {
				textureKey: this.theme.textureKey,
				texture: this.game.config.assetPath + this.theme.texture,
				textureMap: this.game.config.assetPath + this.theme.textureMap,
				soundKey: this.theme.soundKey,
				soundFile: soundFiles,
				dataFile: this.game.config.assetPath + this.theme.data,
				animations: animationFiles,
			};
		},
		/**
		 * Allow the current scene to perform timed operations. The size of a "tick" is defined in main.js, but think of
		 * it as a millisecond.
		 *
		 * STRONG WARNING: Don't do much here - it's called from the main update loop. Any extensive operations will
		 * cause the user interface to lag.
		 */
		tickUpdate: function (tick) {
			if (!(typeof this.currentScene === "undefined")) {
				this.currentScene.tickUpdate(tick);
			}
		},
		renderDebug: function () {
			//if( this.gameSounds  ) {
			//    this.game.debug.soundInfo(this.gameSounds, 10, 20);
			//}
		},
		preload: function () {
			if (!this.isPreloaded) {
				log.warn("!!! Called Preload in Act " + this.actName);
				this.mediaData = this.getMediaData();
				this.game.load.text(
					this.actName + "_scene_data",
					this.mediaData.dataFile
				);
				this.game.load.atlasJSONHash(
					this.mediaData.textureKey,
					this.mediaData.texture,
					this.mediaData.textureMap
				);
				if (this.mediaData.soundFile) {
					this.audioService.loadAudio(
						this.mediaData.soundKey,
						this.mediaData.soundFile
					);
				}
				if (this.mediaData.animations) {
					_.each(
						this.mediaData.animations,
						function (animationSet) {
							this.game.load.atlasJSONHash(
								animationSet.textureKey,
								animationSet.texture,
								animationSet.textureMap
							);
						},
						this
					);
				}
				this.isPreloaded = true;
			}
		},
		onPreloadFinished: function () {
			this.model = new PlayModel(
				JSON.parse(this.game.cache.getText(this.actName + "_scene_data"))
			);
			this.validator = new ActValidator(this.model.getRawData());
			this.validator.validate();
		},
		unload: function () {
			if (this.isPreloaded) {
				this.mediaData = this.getMediaData();
				this.game.cache.removeImage(this.mediaData.textureKey);
				if (this.mediaData.animations) {
					_.each(
						this.mediaData.animations,
						function (animationSet) {
							this.game.cache.removeImage(animationSet.textureKey);
						},
						this
					);
				}
				this.game.cache.removeText(this.mediaData.textureMap);
				this.game.cache.removeText(this.actName + "_scene_data");
				if (this.mediaData.soundFile) {
					this.audioService.unloadAudio(this.mediaData.soundKey);
				}
				this.isPreloaded = false;
			}
		},
		/**
		 * Check that sound has decoded.
		 */
		isPreloadComplete: function () {
			if (this.isPreloaded !== true) {
				return false;
			}
			/**
			 * @TODO GJF this was incorrect before, (act + "_..."), Was it being reached or just failing?
			 * Should the above line be removed/changed? (probably)
			 */
			if (!this.game.cache.getText(this.actName + "_scene_data")) {
				return false;
			}
			return (
				!this.mediaData.soundFile ||
				this.audioService.isReady(this.mediaData.soundKey)
			);
		},
		setStandAlone: function (isStandAlone) {},
	});

	module.exports = PlayAct;
})();

},{"../play/model":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\model.js","../scene/play-action":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-action.js","../scene/play-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-scene.js","./audio-service":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-service.js","./validator":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\validator.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\validator.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A validator for the sceneData.json (act) file to make sure the basic
 * fields are there for each object.
 *
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    // A small validation model for a set of sceneData.
    var actValidationModel =
        {
            "play": {
                "description": "Top level container for all scene data",
                "validationModel": {
                    "start": { "description": "act.play.start specifies the starting scene."},
                    "scenes": { "description": "act.play.scenes specified all scenes." }
                }
            }
        };

    var sceneValidationModel = {
        "id": { "description": "Unique identifier for a scene." },
        "background": { "description": "Reference background image for a scene." },
        "actors": { "description": "Set of actors to add to a scene." },
        "outcomes": { "description": "Set of possible outcomes from a scene." }
    };

    var actorValidationModel = {
        "name": { "description": "Identifier for actor." },
        "type": { "description": "Type of actor to be created." }
    };

    var outcomeValidationModel = {
        "events": { "description": "Set of variables/value pairs that trigger the outcome." },
        "actions": { "description": "Array of actions to take when outcome is triggered." }
    };

    var ActValidator = Base.extend( {
        constructor: function( jsonData) {
            this.rawData = jsonData;
        },
        /**
         * run some basic validation on the available data.
         */
        validate: function() {
            if( ! this.rawData ) {
                throw "PlayModel requires game data constructor argument.";
            }

            var data = this.rawData;
            this.runActValidator( data, actValidationModel);
            _.each( data.play.scenes, function(scene) {
                this.runSceneValidator(scene, sceneValidationModel);
            },this);
            log.warn("Validation complete.");
        },
        runActValidator: function( entryPoint, validationModel ) {
            _.each( validationModel, function( toValidate, index ) {
                if( !entryPoint[index]) {
                    throw "Missing: " + toValidate.description;
                } else if( toValidate.validationModel ) {
                    this.runActValidator( entryPoint[index], toValidate.validationModel );
                }
            }, this);
        },
        runSceneValidator: function( entryPoint, validationModel ) {
            _.each( validationModel, function( toValidate, index ) {
                if( !entryPoint[index]) {
                    throw "Missing: " + toValidate.description;
                }
            }, this);
            _.each( entryPoint.actors, function (actor, actorIndex) {
                _.each( actorValidationModel, function( toValidate, index ) {
                    if( !actor[index]) {
                        throw "Missing: " + toValidate.description;
                    }
                }, this);
            }, this);
            _.each( entryPoint.outcomes, function (outcome, outcomeIndex) {
                _.each( outcomeValidationModel, function( toValidate, index ) {
                    if( !outcome[index]) {
                        throw "Missing: " + toValidate.description;
                    }
                }, this);
            }, this);
        }
    });

    module.exports = ActValidator;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/21/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 *  Draw a loading screen in Phaser. Expects resources to already be loaded.
 */
(function () {
	"use strict";
	var Base = require("basejs");

	var LoadingScreen = Base.extend({
		constructor: function (game, settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.loading_bg_color ||
				!settings.loading_text ||
				!settings.loading_font
			) {
				throw "Loading screen is missing a required configuration field.";
			}
			this.game = game;
			this.settings = settings;
			this.progress = 0;
			this.spinner = [".", "..", "...", "...."];
		},
		show: function () {
			// 1. Create solid background.
			this.bgColor = this.game.add.graphics(0, 0);
			this.bgColor.beginFill(this.settings.loading_bg_color);
			this.bgColor.drawRect(
				0,
				0,
				this.game.world.width,
				this.game.world.height
			);
			this.bgColor.endFill();
			this.bgColor.inputEnabled = true;
			this.game.input.disabled = true;

			// 2. Create a loading image/icon/splash
			this.splashImage = this.game.add.sprite(
				this.game.world.centerX,
				this.game.world.centerY,
				this.settings.loading_image_key
			);
			this.splashImage.anchor.setTo(0.5, 0);
			// this.splashImage.alpha = 0;
			// this.tween = this.game.add.tween(this.splashImage).to({alpha: 1}, 2000, "Linear", true, 0, -1);

			//  And this tells it to repeat, i.e. fade in again 10 times.
			//  The 1000 tells it to wait for 1 second before restarting the fade.
			// this.tween.yoyo(true, 1000);

			// 3. Add a progress indicator
			this.progressText = this.game.add.text(
				this.game.world.centerX,
				this.game.world.centerY,
				this.settings.loading_text,
				this.settings.loading_font
			);
			this.progressText.anchor.setTo(0.5, 0);

			var jointHeight = this.splashImage.height + this.progressText.height;
			this.splashImage.y = this.game.world.centerY - jointHeight / 2;
			this.progressText.y = this.splashImage.y + this.splashImage.height + 25;
			this.game.load.onFileComplete.add(this.fileComplete, this);
		},
		showComplete: function () {
			this.game.input.disabled = false;
			// https://phaser.io/docs/2.4.4/Phaser.Cache.html#onSoundUnlock
			// but can't use :-(
			if (this.game.device.desktop) {
				this.progressText.setText("");
			} else {
				this.progressText.setText("");
			}
			// this.progressText.setText("");
		},
		showClickthrough: function () {
			this.game.input.disabled = false;
			// https://phaser.io/docs/2.4.4/Phaser.Cache.html#onSoundUnlock
			// but can't use :-(
			if (this.game.device.desktop) {
				this.progressText.setText("Click here to begin.");
			} else {
				this.progressText.setText("Touch screen to begin.");
			}
			// this.progressText.setText("");
		},
		showDecoding: function () {
			//this.progressText.setText("Preparing Audio: " + this.getFakeProgress());
		},
		getFakeProgress: function () {
			//return this.spinner[this.progress++ % 4];
		},
		destroy: function () {
			this.game.input.disabled = false;
			// this.tween.stop();
			// this.tween.target = null; // disconnect from splash image.
			// this.tween = null;
			this.splashImage.cropEnabled = false;
			this.splashImage.destroy();
			this.splashImage = null;
			this.bgColor.destroy();
			this.bgColor = null;
			this.progressText.destroy();
			this.progressText = null;
			this.game.load.onFileComplete.removeAll();
		},
		fileComplete: function (
			progress,
			cacheKey,
			success,
			totalLoaded,
			totalFiles
		) {
			// this.progressText.setText(this.settings.loading_text + progress + "%");
		},
	});

	module.exports = LoadingScreen;
})();

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\model.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a Play as a model, this is the collection of scene data, etc.
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        util = require('util'),
        Base = require('basejs'),
        ModelRegistry = require('./models/model-registry'),
        NO_CHAR = "none";

    var PlayModel = Base.extend( {
        constructor: function( jsonData) {
            this.rawData = jsonData;

            if( !jsonData ) {
                throw "PlayModel requires game data constructor argument.";
            }

            if( !jsonData.play ) {
                throw "PlayModel has no play data.";
            }

            this.events = {
                onGameOutcome: new Phaser.Signal()
            };
            var modelClass = ModelRegistry.getModel(this.getModelType());
            this.dataModel = new modelClass();
            this.dataModel.setVar("start_scene", this.getDefaultSceneName());
            this.setPreviousSceneName( "!NONE!");
            this.setCurrentSceneName( this.getDefaultSceneName() );
            this.dataModel.setVar("default_scene_name", this.getDefaultSceneName());
        },
        getRawData: function() {
            return this.rawData;
        },
        getModelType: function() {
            // Default to "actnow", since that was the original and makes all play files backwards compatible.
          return this.rawData.play.modelType || "actnow";
        },
        /**
         * @returns the current scene object
         */
        getCurrentScene: function() {
            var scene = this.getSceneByName(this.getCurrentSceneName());
            if( !scene ) {
                log.error("getCurrentScene failed to return a scene.");
            }
            return scene;
        },
        getSceneByName: function( sceneName ) {
            if( !sceneName ) {
                return undefined;
            }
            return this.rawData.play.scenes[sceneName];
        },
        getGlobalActions: function() {
            var actions = [];
            if( this.rawData.play.global ) {
                actions = this.rawData.play.global.actions || [];
            }
           return actions;
        },
        getGlobalOutcomes: function() {
            if( this.rawData.play && this.rawData.play.global ) {
                return this.rawData.play.global.outcomes;
            }
            return null;
        },
        /**
         * Provide a an interface to the model that doesn't allow for anything but
         * read-only access. This returns a function that allows the referencing object
         * to use getValue
         * @returns {{getVar: Function}}
         */
        getVarInterface: function() {
            var that = this;
            return {
                getActorByRef: function( actorName ) {
                    return that.rawData.play.global.actors[actorName];
                },
                getValue: function( varName ) {
                    return that.getValue(varName);
                },
                clearValue: function( varName ) {
                    that.setVar(varName, null);
                }
            }
        },
        /**
         * Get a true value for a field that may be a variable.
         */
        getValue: function( varName ) {
            if( varName && typeof varName === 'string' && varName.indexOf('$') === 0 ) {
                return this.getVar(varName.substr(1));
            }
            return varName;
        },
        /**
         * Set a new scene in the model. This only affects tracking until getCurrentScene is called.
         * Attempting to switch to the same scene is ignored.
         * @param newSceneId
         * @returns {boolean} try is scene changed.
         */
        setCurrentScene: function( newSceneId ) {
            if( newSceneId ) {
                var newSceneName = this.getValue(newSceneId);
                if ( newSceneName !== this.getCurrentSceneName() && this.getSceneByName(newSceneName) ) {
                    var currentSceneName = this.getCurrentSceneName();
                    this.setCurrentSceneName(newSceneName);
                    this.setPreviousSceneName(currentSceneName);
                    return true;
                }
            } else {
                log.error("setCurrentScene called without newSceneId");
            }
            return false;
        },
        handleSpecialVar: function( variable, value ) {
            return this.dataModel.handleSpecialVar(variable, value);
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         */
        setVar: function( variable, value ) {
            return this.dataModel.setVar(variable, value);
        },
        getVar: function( variable ) {
            return this.dataModel.getVar(variable);
        },
        /**
         * Check for outcomes that were completed by changing a variable.
         * @param variable
         */
        checkForCompletedOutcomes: function( variable ) {
            log.warn("checking for completed outcome: " + variable);
            var scene = this.getCurrentScene(),
                gOutcomes = this.getGlobalOutcomes(),
                pendingActions = [];

            if( !scene.outcomes && !gOutcomes) {
                log.error("Scene with no outcomes in checkForCompletedOutcomes.");
                log.error(scene);
                return;
            }

            if( gOutcomes  ) {
                _.each(gOutcomes, function (outcome, outcomeName) {
                    log.warn("Checking global outcome: " + outcomeName);
                    if (this.checkOutcome(outcome, variable) === true) {
                        log.warn("Pending action on outcome: " + outcomeName);
                        pendingActions.push({"name": outcomeName, "actions": outcome.actions});
                    }
                }, this);
            }

            _.each( scene.outcomes, function(outcome, outcomeName) {
                 log.warn("Checking outcome: " + outcomeName);
                if( this.checkOutcome(outcome, variable) === true  ) {
                    log.warn("Pending action on outcome: " + outcomeName);
                    pendingActions.push( { "name": outcomeName, "actions": outcome.actions } );
                }
            },this);

            if( pendingActions.length > 0 ) {
                this.events.onGameOutcome.dispatch( pendingActions );
            }
        },
        /**
         * Check all of the variables in an outcome against the variables in the model.
         *
         * @param outcome object that should have 'events' object on it.
         * @variable This is the variable that changed, a variable involved in the outcome has to have changed.
         * @returns {boolean} true if the outcome is currently matches the model's state.
         */
        checkOutcome: function( outcome , variable ) {
            if( !outcome.events ) {
                return false;
            }
            var arrays = _.pairs( outcome.events),
                matched = true,
                answer,
                foundVar = false;
            _.each( arrays, function( singleVar ) {
                answer = this.getVar(singleVar[0]);
                // The outcome can only match if one of the variables involved is the one chat changed.
                if( singleVar[0] === variable ) {
                    foundVar = true;
                }
                matched = matched && this.matchSingleOutcome( answer, singleVar[1]);
            }, this );
            return matched && foundVar;
        },
        matchSingleOutcome: function( leftSide, rightSide ) {
            // log.warn("matchSingleOutcome: " + leftSide + " / " + rightSide);
            if( leftSide === null || leftSide === undefined ) {
                return (typeof rightSide === "string" && (rightSide[0] === '!' || rightSide === 'undefined'));
            }

            if( typeof rightSide === "string") {
                if( leftSide === rightSide || rightSide === '*' || (rightSide[0] === '!' && leftSide !== _.trim(rightSide,"!") ) ) {
                    return true;
                }

            } else if( typeof rightSide === "number" ) {
                if( parseInt(leftSide,10) === parseInt(rightSide,10) ) {
                    return true;
                }
            } else if(_.isArray( rightSide ) ) {
                var innerMatch = false;
                _.each( rightSide , function( singleRightSide ) {
                    innerMatch = innerMatch || this.matchSingleOutcome(leftSide, singleRightSide);
                }, this);
                return innerMatch;
            }

            return false;
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: SCENE,[... depends on data model]
         * SCENE = current scene. Handle the scene at the base model level because we always store scene, regardless
         * of current activity.
         */
        restoreData: function (suspendData) {
            log.warn(suspendData);
            if (suspendData) {
                this.dataModel.restoreData( suspendData );
            }
        },
        /**
         * calling this will attempt to divert the model to setting the current scene to the
         * special resume scene. The current scene will be saved as the 'restore' scene.
         */
        tryResume: function() {
            if ( this.getCurrentSceneName() !== this.getDefaultSceneName() && this.getResumeScene() ) {
                log.warn(this.getCurrentSceneName());
                this.setCurrentSceneName( this.getResumeScene() );
            }
        },
        getResumeScene: function() {
            return this.rawData.play.resume;
        },
        getSuspendData: function () {
            return this.dataModel.getSuspendData(this.getPersistList());
        },
        /**
         * Clear out any saved choices to undefined. currently this involves which characters the
         * player selected.
         */
        clearSavedChoices: function() {
            this.dataModel.clearSavedChoices();
        },
        isShowPlayThrough: function() {
            return this.rawData && this.rawData.play && this.rawData.play.showPlayThrough;
        },
        getDefaultSceneName: function() {
            return this.rawData.play.start;
        },
        getPersistList: function() {
            return this.rawData.play.persist;
        },
        getCurrentSceneName: function() {
            return this.dataModel.getVar("current_scene_name");
        },
        setCurrentSceneName: function( sceneName ) {
            this.dataModel.setVar("current_scene_name", sceneName);
        },
        setPreviousSceneName: function( sceneName ) {
            this.dataModel.setVar("previous_scene_name", sceneName);
        }
    });

    module.exports = PlayModel;
}());

},{"./models/model-registry":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\model-registry.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","util":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\actnow.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a specific Play Model strategy for a set of courses/activities.
 *
 * PA = Participate
 * DI = Discourage
 * AL = Allow
 * EN = Encourage
 * PR = Prevent
 * XX = Unanswered
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        util = require('util'),
        Base = require('basejs'),
        NO_CHAR = "none";

    var ActNowData = Base.extend( {
        constructor: function() {

            this.variables = {
                "score": 0,
                "playThrough": 1,
                "decisionsCurrent": ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"],
                "decisionsPrevious": ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"],
                "phoneRingerIndex": 0,
                "phoneBgIndex": 0
            };

            this.scores = {
                "PA": -2,
                "DI": 1,
                "AL": 0,
                "EN": -1,
                "PR": 2,
                "XX": 0
            };

        },
        /**
         * This is the special behavior for actnow based acts which expect decision points
         * and special act_complete / complete variables.
         * @param variable
         * @param value
         * @returns {*}
         */
        handleSpecialVar: function( variable, value ) {
            var returnValue = null;
            if( variable.substr(0,2) === "dp" ) {
                this.recordDecision(variable, value);
                returnValue = "save";
            } else if( variable === "act_complete" ) {
                this.clearSavedChoices();
                if( this.incrementPlaythrough(value) ) {
                    returnValue = "complete";
                }
            }
            return returnValue;
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         * Returns TRUE if the variable was changed.
         */
        setVar: function( variable, value ) {
            //log.warn("Set Variable: " + variable + " = " + value);
            if( variable === "score" ) {
                this.variables["score"] += parseInt(value,10);
                return true;
            } else if( this.variables[variable] !== value )  {
                // Do not act on a value staying the same.
                this.variables[variable] = value;
                return true;
            }
            return false;
        },
        getVar: function( variable ) {
            return this.variables[variable];
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: [playThrough,char1,char2,char3,1|2|3|4|5|6|7|8|9,1|2|3|4|5|6|7|8|9,1|2|3|4|5|6|7|8|9]
         * 1|2|3|4|5|6|7|8|9 = answers per play through.
         */
        restoreData: function (unparsedSuspendData) {
            log.warn(unparsedSuspendData);
            var  splitData = unparsedSuspendData.split(",");
            this.variables['current_scene_name'] = splitData[0];
            var suspendData = _.drop(splitData,1);
            if (suspendData) {
                this.variables.playThrough = parseInt(suspendData[0], 10);
                this.variables['character_1'] = this.resolveCharacter(suspendData[1]);
                this.variables['character_2'] = this.resolveCharacter(suspendData[2]);
                this.variables['character_3'] = this.resolveCharacter(suspendData[3]);
                this.variables.decisionsPrevious = suspendData[4].split("|");
                this.variables.decisionsCurrent = suspendData[5].split("|");
                this.variables.score = 0;
                _.each( this.variables.decisionsCurrent , function(score) {
                    this.variables.score += this.convertToPoints(score);
                }, this);
            }
        },
        /**
         * Unchosen characters are saved as NO_CHAR, resolve them back to 'undefined' or their
         * actual value.
         */
        resolveCharacter: function( value ) {
            if( value === NO_CHAR ) {
                return undefined;
            } else {
                return value;
            }
        },
        convertToPoints: function(str) {
            if( this.scores[str] !== undefined ) {
                return this.scores[str];
            }
            return "0";
        },
        getSuspendData: function (persistList) {
            // persistList is not used in ActNow!, which has a fixed set of saves.
            var character1 = this.variables['character_1'] || NO_CHAR,
                character2 = this.variables['character_2'] || NO_CHAR,
                character3 = this.variables['character_3'] || NO_CHAR;

            var suspendData = this.variables['current_scene_name']
                + "," + this.variables.playThrough
                + "," + character1
                + "," + character2
                + "," + character3
                + "," + this.variables.decisionsPrevious.join("|")
                + "," + this.variables.decisionsCurrent.join("|");
            log.warn(suspendData);
            return suspendData;
        },
        recordDecision: function (dp, answer) {
            log.warn("Recording decision " + dp + " / " + answer);
            var dIndex = parseInt(dp.substr(2), 10);
            this.variables.decisionsCurrent[dIndex-1] = answer;
            this.variables.score += this.scores[answer];
        },
        /**
         * Increase the playthrough count, optionally marking this act complete.
         * This function assumes the numbers may be strings, and forces them to numbers.
         * @param completeCount optional value at which to mark the act complete.
         */
        incrementPlaythrough: function( completeCount ) {
            log.warn("increasing play through");
            if( !completeCount ) {
                throw "You must provide a complete count.";
            }
            var completed = false;
            this.variables.playThrough = parseInt(this.variables.playThrough, 10);

            completeCount = parseInt(completeCount,10);

            // If we've completed the desired number of play throughs, mark complete.
            if( this.variables.playThrough === completeCount ) {
                log.warn("Target playthroughs reached");
                this.variables.playThrough = 0;
                completed = true;
            }

            // Now go to the next playThrough.
            this.variables.playThrough++;
            this.variables['current_scene_name'] = this.variables['default_scene_name'];
            // Copy the decision points and start a new set.
            this.variables.decisionsPrevious = this.variables.decisionsCurrent;
            this.variables.decisionsCurrent =  ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"];
            return completed;
        },
        /**
         * Clear out any saved choices to undefined. currently this involves which characters the
         * player selected.
         */
        clearSavedChoices: function() {
            this.variables['character_1'] = undefined;
            this.variables['character_2'] = undefined;
            this.variables['character_3'] = undefined;
        }
    });

    module.exports = ActNowData;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","util":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\basic.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 10/30/2017
 * Copyright 2017 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a specific Play Model strategy for a set of courses/activities.
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    var BasicData = Base.extend( {
        constructor: function() {
            this.variables = {
                score: 0
            };
        },
        /**
         * This is where you would implement special behavior for a custome model strategy.
         * You can return an event string from this and it will be dispatched.
         */
        handleSpecialVar: function( variable, value ) {
           return null;
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         */
        setVar: function( variable, value ) {
            //log.warn("Set Variable: " + variable + " = " + value);
            if( variable === "score" ) {
                this.variables["score"] += parseInt(value,10);
                return true;
            } else if( this.variables[variable] !== value )  {
                // Do not act on a value staying the same.
                this.variables[variable] = value;
                return true;
            }
            return false;
        },
        getVar: function( variable ) {
            var temp = this.variables[variable];
            return temp;
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: [VAR:VALUE|VAR:VALUE]
         */
        restoreData: function (suspendData) {
            if( suspendData ) {
                var suspendSet = suspendData.split("|");
                var pair;
                _.each(suspendSet, function (valuePair) {
                    pair = valuePair.split(":");
                    if (pair.length === 2 && pair[1] !== 'undefined' && pair[1] !== "null") {
                        this.variables[pair[0]] = pair[1];
                    }
                }, this);
                log.warn(suspendData);
                if (suspendData) {
                    this.variables.score = 0;
                }
            }
        },
        /**
         * For the basic model, save everything that it's told to save.
         * @param persistList
         * @returns {string}
         */
        getSuspendData: function (persistList) {
            var suspendData = "";
            var suspendEntries = [];
            _.each( persistList, function( keyValue ) {
                // only save defined variables.
                if( this.variables[keyValue] ) {
                    suspendEntries.push(keyValue + ":" + this.variables[keyValue]);
                }
            }, this);
            if( suspendEntries.length > 0 ) {
                suspendData = suspendEntries.join("|");
            }
            return suspendData;
        }
    });

    module.exports = BasicData;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\model-registry.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/11/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a registry and construction factory for Model Strategies; which should not be instantiated on their own, only
 * from this creation point.
 */
(function () {
    'use strict';
    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    var ActNow = require('./actnow');
    var Basic = require('./basic');

    var ModelRegistry = Base.extend( {
        constructor: function() {
            this.models = {};
            this.modelTypes = [];
        },
        registerModel: function( type, model ) {
            _.each( this.modelTypes, function(knownType) {
                if( knownType === type ) {
                    throw "You are registering a model type that already exists: " + type;
                }
            });
            this.modelTypes.push(type);
            this.models[type] = model;
        },
        getModel: function( type ) {
            log.warn("Returning model of type: " + type);
            return this.models[type];
        },
        isAvailableType: function(type) {
            var found = false;
            _.each( this.modelTypes, function(knownType) {
                if( knownType === type ) {
                    found = true;
                }
            });
            return found;
        },
        getAvailableTypes: function() {
            // Return a clone, to make it read only.
            return _.clone(this.modelTypes);
        }
    });

    var ModelFactory = new ModelRegistry();

    /* General Actors, or reusable across courses */
    ModelFactory.registerModel("actnow", ActNow );
    ModelFactory.registerModel("basic", Basic );

    module.exports = ModelFactory;
}());

},{"./actnow":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\actnow.js","./basic":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\basic.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\play.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 2.0.0
 * @creation 10/27/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the top level controller for the scene engine, Play->Act(s)->Scene(s)->Actors
 * The Play object manages all of the Acts in a Play, showing one act at a time and accepting events from Act objects.
 *
 * The general idea is that an Act is allowed to use the game object for drawing to the screen, sound, and I/O. There
 * can be more than one act instantiated, and they are stacked on top of each other (z-index). Each Act is responsible
 * for cleaning itself up and removing from the game anything it added. An Act must only conform to the act interface,
 * it does not have to be a play-scene.
 *
 * If any of the acts have objectives, then the entire play (scorm activity) will not be marked complete until all
 * objective acts have reported as completed. If no acts have objectives, then the entire play will be marked complete
 * when the default act reports complete.
 *
 * This what the configuration should look like. In the general case, this will come from phaser. But you could just
 * pass a configuration object in.
 * {
 *   "name": "Name of the play",
 *   "description": "You may use this line as in-data documentation.",
 *   "scorm": true|false,
 *   "logging": true|false,
 *   "acts": {
 *     "default": { // You MUST have an act called 'default' !
 *       "id": "default", // this is an internal ID used to store things in the phaser cache. It should be unique among acts.
 *       "description": "Every set of acts has a default, which is the act that is started by default.",
 *       "name": "Grade 6 Act Now!",
 *       "data": "media/sceneData.json",
 *       "theme": "media/theme.json",
 *       "objective": "x", // Optional, object to complete when act is complete
 *       "objectives": [ "a", "b", c"] // optional, may still have "objective" as well.
 *       "type": "scene" // optional, defaults to "scene", specifies what type of Act to instantiate.
 *     },
 *     "act2": {
 *       "id": "act2",
 *       "description": "this is the exciting second act!",
 *       "name": "Act Two!",
 *       "data": "media/sceneData.json",
 *       "theme": "media/theme.json"
 *     },
 *     ...
 *   }
 * }
 */
(function () {
	"use strict";
	var log = require("loglevel"),
		_ = require("lodash"),
		Base = require("basejs"),
		ActManager = require("../act/play-act-manager"),
		ScormService = require("./scorm-service");

	var OBJECTIVE_PREFIX = "objective_";

	var Play = Base.extend({
		/**
		 * Creations of the Play object, requiring both a Phaser game and a configuration object (JSON)
		 * the configuration should include a name, description and a set of acts. The acts MUST include
		 * an act labelled 'default'.
		 */
		constructor: function (game, config, settings) {
			if (!game || !config || !settings) {
				throw "Creating a Play requires a Phaser game instance, configuration object and settings.";
			}
			if (!config.acts) {
				throw "There is no 'acts' field in the play.json";
			}
			this.game = game;
			this.config = config;
			this.playActSet = config.acts;
			this.settings = settings;
			this.actInstances = {};
			this.previousAct = null;
			this.waitingOn = [];
			this.scormService = new ScormService(
				this.game.scorm,
				this.settings,
				this.playActSet
			);

			this.commands = {
				change_act: "change_act",
				mute_game: "mute_game",
				mute_game_on: "mute_on",
				save: "save",
				complete: "complete",
				objective: "objective",
			};

			if (!this.playActSet[this.settings.default_act_name]) {
				throw "Play could not start. You do not have a default ACT. See play.js header.";
			}

			if (config.autoScale) {
				this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
			}
		},
		/**
		 * Set the Default Act as the next Act.
		 */
		selectDefaultAct: function () {
			this.selectNextAct(this.settings.default_act_name);
		},
		/**
		 * Creates or looks up an existing Act. Any currently running Act will
		 * be stopped. When a new Act is created, it is cached.
		 * This does NOT start the Act, after selectNextAct(), startNextAct() must be called.
		 * @param actName Name of Act from Play.json to start.
		 */
		selectNextAct: function (actName) {
			// Exit any current act.
			if (this.currentAct) {
				// the default act should not be stopped.
				if (this.currentAct.actName !== this.settings.default_act_name) {
					this.currentAct.stop();
				}
				this.previousAct = this.currentAct;
			}

			// Don't create an act that already exists.
			if (this.actInstances[actName]) {
				this.currentAct = this.actInstances[actName];
				this.currentAct.setScormString(this.playActSet[actName].suspendData);
				return;
			}

			// Look up and create an Act that doesn't exist.
			var nextActData = this.playActSet[actName];
			var nextActTheme = JSON.parse(
				this.game.cache.getText(this.settings.theme_prefix + nextActData.id)
			);
			if (this.config.autoScale) {
				// If autoScale is set to true in the play.json file add a property to the theme to smuggle it into the act for use by actors, who do not have access to the play.json settings. For example, the WISTIA actor sizes the video div differently according to the autoScale setting.
				nextActTheme.internal_autoScale = true;
			}

			this.currentAct = ActManager.getActInstance(
				nextActData.type,
				this.game,
				nextActTheme,
				actName
			);
			// Only the default Act counts as stand alone.
			if (this.currentAct.setStandAlone) {
				this.currentAct.setStandAlone(
					actName === this.settings.default_act_name
				);
			}
			// Subscribe to all events.
			this.currentAct.events.onGameChoice.add(this.onGameChoiceEvent, this);
			this.currentAct.events.onActStatus.add(this.onActStatusEvent, this);
			// Restore the Act from the "Save" point.
			this.currentAct.setScormString(nextActData.suspendData);
			this.actInstances[actName] = this.currentAct;
		},
		/**
		 *  This is the hook into restarting the main Phaser state and launching a new Act.
		 *  The new Act should have already been selected using selectNextAct().
		 *  This will lead to showAct() being called from the main state.
		 */
		startNextAct: function (isRestart) {
			this.game.state.restart(false, false, isRestart); // true, false means "clear world, keep cache"
		},
		/**
		 * This functional will actually start an act up, and then provide it with information on the other acts.
		 * It will tell an act which previous act exited, allowing an act to know both which act came before and
		 * that it isn't first.
		 * Second, it will inform a non-first act if the previous acts objective status (act_exited + objective status)
		 * For a first (Default) act, the status of every other act objective will be passed in, but only if that
		 * act is tracking by objective.
		 * @param isRestart
		 */
		showNextAct: function (isRestart) {
			if (!this.currentAct) {
				throw "No current Act to start!";
			}

			var singleActData = this.playActSet[this.currentAct.actName];

			// If we have an objective, it may need to be marked as started.
			this.scormService.markActStarted(singleActData.id);

			// There is no need to start the default act, it's not stopped. But this may be the first call.
			if (
				!this.previousAct ||
				this.currentAct.actName !== this.settings.default_act_name
			) {
				if (this.currentAct.onPreloadFinished) {
					this.currentAct.onPreloadFinished();
				}
				this.currentAct.start(isRestart);
			}
		},
		/**
		 * This will send variables to the current act from the previous or all acts, so when the default
		 * act starts, it will know about all tracked objective variables in other acts.
		 */
		sendCrossActVariables: function () {
			var objectiveSet = [];
			var temp;

			if (this.previousAct) {
				this.currentAct.onGameChoice({ act_exited: this.previousAct.actName });
				var previousActData = this.playActSet[this.previousAct.actName];
				objectiveSet = this.scormService.getActObjectiveStatusSet(
					previousActData.id
				);
			} /* default act */ else {
				objectiveSet = this.scormService.getPlayObjectiveStatusSet();
			}
			_.each(
				objectiveSet,
				function (eachObjective) {
					temp = {};
					temp[OBJECTIVE_PREFIX + eachObjective.getId()] =
						eachObjective.getStatus();
					this.currentAct.onGameChoice(temp);
				},
				this
			);
		},
		/**
		 * The player made a game choice. This may be a special command for the Play.
		 * Attempt to execute it, and allow the execution to determine if the event was
		 * consumed.
		 * @param eventPair
		 */
		onGameChoiceEvent: function (eventPair) {
			var tempVars = _.pairs(eventPair)[0];
			eventPair.consumed = this.playCommand(tempVars[0], tempVars[1]);
		},
		/**
		 * The player caused a status event; usually either a save or a completion of an activity. These aren't
		 * caued by player's directly, but by the Scenes/Acts.
		 * "act_complete" -> increment playthrough -> "complete" status event.
		 * @param eventCommand
		 */
		onActStatusEvent: function (eventCommand, eventArg) {
			if (eventCommand === this.commands.save) {
				this.saveScormData();
			} else if (eventCommand === this.commands.complete) {
				this.scormService.handleActComplete(this.currentAct.actName); // actName === actId
			} else if (eventCommand === this.commands.objective) {
				this.scormService.markObjectiveComplete(eventArg);
				this.saveScormData();
			}
		},
		/**
		 * Execute a Play level command, such as saving or changing acts.
		 * Returns true if it consumes the command/choice.
		 */
		playCommand: function (command, arg) {
			log.warn("play command: " + command + " / " + arg);
			if (command === this.commands.change_act) {
				log.warn("Changing act to " + arg);
				if (this.playActSet[arg]) {
					this.selectNextAct(arg);
					this.startNextAct(true);
				} else {
					log.error("Request to change to non-existant act: " + arg);
				}
			} else if (command === this.commands.save) {
				this.saveScormData();
			} else if (command === this.commands.mute_game) {
				// GJF - 09/20/17 - I may have just broke mute for all past activities by fixing this line.
				this.game.sound.mute =
					arg === this.commands.mute_game_on ? true : false;
				return false; // Return false because this isn't 'consuming', it's a side effect special case.
			} else {
				return false;
			}
			return true;
		},
		/**
		 * Load the theme and data files for each act in play.json
		 * This used to "preload", but now it returns a set, the play is no longer responsible for loading
		 * resources.
		 * This can't be done for the act because it would break backwards compatibility :-(
		 */
		getRequiredResourceList: function () {
			var preloadSet = [];
			_.each(
				this.getActsList(),
				function (act) {
					log.warn(
						"loading text " +
							act.theme +
							" as " +
							(this.settings.theme_prefix + act.id)
					);
					preloadSet.push({
						key: this.settings.theme_prefix + act.id,
						file: this.game.config.assetPath + act.theme,
						type: "json",
					});
				},
				this
			);
			return preloadSet;
		},
		/**
		 * When the main Phaser state is restarted, during the Phaser preload function, this preload will be called
		 * so that the new Act has a valid entry point to loading assets. The Act can load any resources necessary.
		 */
		preloadAct: function () {
			if (this.currentAct) {
				this.currentAct.preload();
			}
		},
		/**
		 * The act determines when it is done loading, so when asked, delegate to the Act.
		 */
		isPreloadActComplete: function () {
			return this.currentAct && this.currentAct.isPreloadComplete();
		},
		isLogging: function () {
			return this.config && this.config.logging === true;
		},
		getActsList: function () {
			return this.playActSet;
		},
		isScormEnabled: function () {
			return this.config && this.config.scorm === true;
		},
		renderDebug: function () {
			if (this.currentAct && this.settings.debug === true) {
				this.currentAct.renderDebug();
			}
		},
		/**
		 * this is the game loop. If the act is a game, or has a delay, or needs to do timing, it SHOULD NOT
		 * use its own update function, but should instead provide a tickUpdate. This will be called here so
		 * that the update() calls are controlled from the play.
		 * @param time
		 */
		tickUpdate: function (time) {
			if (this.currentAct) {
				this.currentAct.tickUpdate(this.game.time.now);
			}
		},
		loadScormData: function () {
			this.scormService.loadScormObjectiveData();
			this.scormService.loadScormSuspendData();
		},
		saveScormData: function () {
			this.scormService.saveScormObjectiveData();
			var scormString = this.currentAct.getScormString();
			if (scormString && scormString.length > 0) {
				this.scormService.saveScormSuspendData(
					this.currentAct.actName,
					scormString
				);
			}
		},
	});

	module.exports = Play;
})();

},{"../act/play-act-manager":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act-manager.js","./scorm-service":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\scorm-service.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\scorm-service.js":[function(require,module,exports){
/**
 * Represent the set of scorm operations that are required by a Play. This involves the saving, loading and updating
 * of all objectives and suspend data.
 *
 * This service does not handle game events or send game notifications to acts/scenes/etc. It only manages scorm
 * related data as required.
 */
(function () {
    'use strict';
    var log = require('loglevel');
    var _ = require('lodash');
    var Base = require("basejs");

    var STATUS_NOT_ATTEMPTED = "not attempted";
    var STATUS_ATTEMPTED = "incomplete";
    var STATUS_COMPLETED = "completed";

    var ScormObjective = Base.extend({
        constructor: function( actId, index, id, status ) {
            this.actId = actId;
            this.index = index;
            this.id = id;
            this.status = status;
        },
        setStatus: function( newValue ) {
            this.status = newValue;
        },
        getStatus: function() {
            return this.status;
        },
        getId: function() {
            return this.id;
        },
        getIndex: function() {
            return this.index;
        },
        getActId: function() {
            return this.actId;
        }
    });

    var ScormService = Base.extend({
        constructor: function (scorm, settings, playActSet) {
            if (!scorm || !settings || !playActSet) {
                throw "You must provide an interface to scorm and settings.";
            }
            this.scorm = scorm;
            this.settings = settings;
            this.playActSet = playActSet;
            this.objectiveSet = [];
        },
        markActStarted: function (actId) {
            _.each( this.getActObjectiveStatusSet(actId), function(objective) {
                if (objective.getStatus() !== STATUS_COMPLETED) {
                    objective.setStatus(STATUS_ATTEMPTED);
                    this.saveObjective(objective);
                }
            }, this);
        },
        markObjectiveComplete: function( objectiveId ) {
            var objective = _.findWhere( this.objectiveSet, { id: objectiveId});
            if( objective ) {
                objective.setStatus(STATUS_COMPLETED);
                this.saveObjective(objective);
                this.checkPlayComplete();
            }
        },
        getActObjectiveStatusSet: function (actId) {
            return _.where(this.objectiveSet, {actId: actId});
        },
        getPlayObjectiveStatusSet: function () {
           return this.objectiveSet;
        },
        playHasObjectives: function() {
           return (this.objectiveSet.length > 0);
        },
        /**
         * This should be private, it's part of the startup of this service and outside sources should not access
         * the raw data like this; which is in json that should be considered read only.
         * This builds a raw list of objective names based on every act in the play data.
         */
        getRawObjectiveList: function( actData ) {
          var objectList = [];
          if( actData.objective ) {
              objectList.push(actData.objective);
          }
          if( actData.objectives ) {
              objectList = objectList.concat(actData.objectives);
          }
          return objectList;
        },
        /**
         * This will load or initialize an objective object for every objective in the play. It will initialize
         * the object with SCORM if it hasn't been previously initialized.
         */
        loadScormObjectiveData: function() {
            var objectiveIndex = 0;
            var existingObjective;
            var actObjectiveList;
            var newObjective;

            _.each( this.playActSet, function( singleAct ) {
                actObjectiveList = this.getRawObjectiveList(singleAct);
                _.each( actObjectiveList, function( eachObjective ) {
                    newObjective = new ScormObjective(singleAct.id, objectiveIndex, eachObjective, STATUS_NOT_ATTEMPTED);
                    existingObjective = this.loadObjective(objectiveIndex);

                    // Already existed, otherwise we wouldn't have a matching id!
                    if( existingObjective.status && existingObjective.id === newObjective.getId() ) {
                        newObjective.setStatus(existingObjective.status);
                    } else {
                        this.saveObjective(newObjective);
                    }
                    objectiveIndex++;
                    this.objectiveSet.push(newObjective);
                }, this);

            }, this);
        },
        saveScormObjectiveData: function() {
            // Scorm objectives are not regularly saved.
        },
        loadScormSuspendData: function() {
             var scormData = this.scorm.getSuspendData() || "";
            var index = 0;
            log.warn(scormData);

            scormData = scormData.split(this.settings.scorm_separator_char);

            _.each( this.playActSet, function( singleAct ) {
                singleAct.suspendData = scormData[index] || "";
                index++;
            }, this);
        },
        saveScormSuspendData: function( actId, scormString ) {
            var scormData = [];
            var saveString;

            this.playActSet[actId].suspendData = scormString;

            _.each( this.playActSet, function(singleAct) {
                scormData.push(singleAct.suspendData);
            }, this);

            saveString = scormData.join(this.settings.scorm_separator_char);
            log.warn(saveString);
            this.scorm.setSuspendData(saveString);
        },
        /**
         * An act complete event has been sent, generally meaning "complete the only objective for this act".
         * If there is more than on objective in the act, this function only checks for 'all complete'.
         *
         * In "Act Now", both "objective_complete" and "act_complete" would lead to this. For non-actnow, currently
         * only "objective_complete" will lead to this, but other models may act differently. This depends on a
         *  "complete" act-status event.
         * @param actId
         */
        handleActComplete: function(actId) {
            var actObjectives = [];
            if( this.playHasObjectives() ) {
                actObjectives =  this.getActObjectiveStatusSet(actId);

                // There is only one objective, so mark it complete.
                if( actObjectives.length === 1 ) {
                    actObjectives[0].setStatus(STATUS_COMPLETED);
                    this.saveObjective(actObjectives[0]);
                }
                this.checkPlayComplete();
            } else {
                // No objectives - you're done!
                this.scorm.markComplete();
            }
        },
        checkPlayComplete: function() {
            var allComplete = true;
            _.each( this.objectiveSet, function(objective) {
                if( objective.getStatus() !== STATUS_COMPLETED ) {
                    allComplete = false;
                }
            }, this);
            if( allComplete ) {
                this.scorm.markComplete();
            }
        },
        loadObjective: function( objectiveIndex ) {
            return this.scorm.getObjective(objectiveIndex);
        },
        saveObjective: function( objective ) {
            this.scorm.setObjective(objective.getIndex(), objective.getId(), objective.getStatus());
        }
    });

    module.exports = ScormService;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene-engine.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 */
(function () {
	var BootState = require("./states/boot.js"),
		PreloadState = require("./states/preload.js"),
		MainState = require("./states/main.js"),
		Scorm = require("./scorm");

	module.exports = function (domElement, width, height) {
		var config = {
			width: width,
			height: height,
			renderer: Phaser.CANVAS, // Set to Canvas to help IE.
			parent: domElement,
			transparent: false,
			antialias: true,
			forceSetTimeOut: false,
			assetPath: _environmentSettings.assetPath, // not a standard Phaser property - used to pass in relative loading paths for different host environments (LMS, CMS, etc.). _environmentSettings.assetPath is declared in HTML file.
		};

		var settings = {
			play_json_key: "playData",
			loading_image_key: "preloaderBar",
			loading_image_url: config.assetPath + "media/cwlogo.png",
			loading_bg_color: "0x0074c8",
			loading_font: {
				font: "Arial, Helvetica, Sans",
				fontSize: 26,
				fill: "#ffffff",
			},
			loading_text: "Loading...",
			play_json_url: config.assetPath + "media/play.json",
			theme_prefix: "theme_",
			data_prefix: "data_",
			preload_state_name: "preload",
			main_state_name: "main",
			boot_state_name: "boot",
			default_act_name: "default",
			scorm_separator_char: "$",
			logging: true,
		};

		var game = new Phaser.Game(config);
		game.scorm = new Scorm();
		game.state.add(settings.boot_state_name, new BootState(settings));
		game.state.add(settings.preload_state_name, new PreloadState(settings));
		game.state.add(settings.main_state_name, new MainState(settings));
		game.state.start(settings.boot_state_name);

		return game;
	};
})();

},{"./scorm":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scorm.js","./states/boot.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\boot.js","./states/main.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\main.js","./states/preload.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\preload.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\add-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var AddActorAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("add-actor", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = AddActorAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-objective.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var ChangeObjectiveAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("objective", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = ChangeObjectiveAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-scene.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that changes the scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var SceneAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            act.showNewScene(this.args[0]);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = SceneAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\check-outcomes.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that does an additional outcome check based on given variable(s), can be used to force the check
 * of outcomes even when the player hasn't directly acted on it.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var CheckOutcomesAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.checkCurrentSceneOutcomes(eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = CheckOutcomesAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The most basic of actions, record a variable.
 * This action takes three arguments.
 * 1 - name of variable|choice|command
 * 2 - value of variable|choice|command
 * 3 - boolean force value, optional.
 *
 * If you set the 'force value', the value will first be removed from the model manually. This would allow you to
 * set a value (and cause an outcome) multiple times in a row. This would normally be blocked because the model
 * ignores values being set repeatedly.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var VariableAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            var temp = {};
            temp[act.model.getValue(this.args[0])] = act.model.getValue(this.args[1]);
            if( this.args[3] === true ) {
                act.clearVariable(this.args[0]);
            }
            act.onGameChoiceAction(temp);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = VariableAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mark-complete.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var MarkCompleteAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("activity_complete", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = MarkCompleteAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mh\\mh-change-scene.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 12/20/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This action is customized for Mission-Health and used
 * to update SCORM data prior to switching scenes. This was needed
 * because setting the SCORM "completed" flag (at the end of the lesson)
 * may take 1-2 seconds.  Consequently, we need to set this immediately
 * prior to switching to the mission-completed scene AND we need to stop
 * audio first to avoid it being interfered with by the synchronous HTTP request
 * that SCORM uses. Refer to GitLab Issue #427.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        VariableAction = require('../game-choice.js'),
        Base = require('basejs');

    var MhSceneAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }

            var newSceneName = this.args[0];
            var varsMap = this.args[1] || {};

            _.forOwn(varsMap, function(value, varName) {
                (new VariableAction([varName, value])).execute(act);
            });

            act.audioService.stopScene(); // Stop audio before sending SCORM updates to avoid interrupted audio

            act.events.onActStatus.dispatch("save");

            act.showNewScene(newSceneName);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = MhSceneAction;
}());

},{"../game-choice.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\remove-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that changes the scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var RemoveActorAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("remove-actor",act.model.getValue(eachArg));
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = RemoveActorAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\variable-increment.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 10/15/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This action adds a value to a numeric variable.
 * Since all variables are stored as strings, it will first be parsed into a number.
 * 
 * This action takes three arguments.
 * 1 - name of the variable to increment
 * 2 - numeric amount of the increment (or decrement, if negative)
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var VariableIncrementAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }

            var numericValue = Number(act.model.getValue('$'+this.args[0]));
            if (isNaN(numericValue)) {
                throw "action requires the variable to be number.";
            }

            var increment = Number(this.args[1]);
            if (isNaN(increment)) {
                throw "action requires the increment to be number.";
            }

            numericValue += increment;

            var temp = {};
            temp[act.model.getValue(this.args[0])] = numericValue.toString();

            act.onGameChoiceAction(temp);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = VariableIncrementAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-announcer.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An announcer bubble. The announcer box is optional.
 * It will display text and optionally play audio.
 * This is very similar to the speech bubble, only it isn't listening for events to change its text.
 *
 * {
 *    "name": "announcerBox",
 *     "type": "announcer",
 *     "location": [ 2, 5 ], // location on screen.
 *     "text": "Welcome to Newbridge Middle School.", // text to display.
 *     "audio": "nar_6th_int_01", // Audio to play
 *     "announcerBox": true // show the announcer box
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * },
 *
 * @TODO update this class to show any icon as the 'announcer'.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var AnnouncerActor = Actor.extend({
        // Constructor is in parent.
        enterScene: function () {
            this.text = this.data.text;
            this.audio = this.data.audio;
            this.key = this.data.key;

            this.currentX = this.data.location[0];
            this.currentY = this.data.location[1];
            if (this.data.announcerBox) {
                this.addAnnouncerBox();
            }
            this.data.inverseSoundEvents = true;
            this.addWindow();
            this.setSpeech();
        },
        getRequiredFields: function() {
            return [ "location" ];
        },
        addAnnouncerBox: function () {
            this.announcerBox = this.game.add.sprite(this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.getImage( 'announcer-box', 'actorImages') );
            this.currentX += this.announcerBox.width - 10;
        },
        /**
         * Add 5 things to a group:
         * 1. A top "sprite" which is the top of the text bubble.
         * 2. Text, representing the text for this sprite and wrapping its font.
         * 3. A middle "tilesprite" which is a repeating middle sprite made to match the height of the text.
         * 4. A bottom "sprite" which is the bottom of the text bubble.
         */
        addWindow: function () {
            if( !this.theme.textWindows || !this.theme.textWindows.announce ) {
                throw "Announcer actor requires textWindows theme entry, and announce section inside it.";
            }
            var windowGroup = this.game.add.group();
            windowGroup.x = this.currentX;
            windowGroup.y = this.currentY;

            var marginX = 8,
                marginY = 20;
            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.announce.top);

            this.fStyle = this.getFont('bubbleText');
            this.rStyle = this.getFont('replayAudio');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * .85;

            this.currentText = new Phaser.Text(this.game, marginX + 50, marginY, this.text, this.fStyle);
            windowGroup.add(this.currentText);

            var middleHeight = this.currentText.height - (topWindow.height - marginY);
            if( middleHeight < 5 ) {
                middleHeight = 5;
            }
            var middleWindow = new Phaser.TileSprite(this.game, 0, topWindow.height,
                topWindow.width, middleHeight, this.theme.textureKey, this.theme.textWindows.announce.middle);
            windowGroup.add(middleWindow);

            var bottomY = this.currentText.y + this.currentText.height + marginY;
            var bottomWindow = windowGroup.create(0, topWindow.height + middleWindow.height, this.theme.textureKey, this.theme.textWindows.announce.bottom);

            // 5. Add eventing.
            this.windows = {
                top: topWindow,
                middle: middleWindow,
                bottom: bottomWindow
            };

            _.each(this.windows, function (bubble) {
                bubble.inputEnabled = true;
                bubble.events.onInputOver.add(this.onMouseIn, this);
                bubble.events.onInputOut.add(this.onMouseOut, this);
                bubble.events.onInputUp.add(this.onPointerUp, this);
            }, this);

            this.replayText = new Phaser.Text(this.game, (bottomWindow.x + bottomWindow.width - 40) / 2,
                (topWindow.height + bottomWindow.height + middleWindow.height) / 2, "Replay Audio", this.rStyle);
            this.replayText.anchor.setTo(0.5, 0.5);
            windowGroup.add(this.replayText);
            this.replayText.visible = false;

            this.currentText.bringToTop();
            this.replayText.bringToTop();
            this.windowGroup = windowGroup;
        },
        onMouseIn: function () {
            this.fStyle.fill = this.theme.tints.bubbleText;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = true;
        },
        onMouseOut: function () {
            this.fStyle.fill = this.getFont('bubbleText').fill;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = false;
        },
        onPointerUp: function () {
            this.dispatchGameSpeech( {text: this.text, audio: this.audio, key: this.key});
        },
        setSpeech: function () {
            this.currentText.setText(this.text);
            // may need to adjust heights/etc.
            this.dispatchGameSpeech( {text: this.text, audio: this.audio, key: this.key});
        },
        destroy: function () {
            this.rStyle = null;
            this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            if( this.announcerBox ) {
                this.announcerBox.destroy();
                this.announcerBox = null;
            }
            this.freeBaseActor();
        }
    });

    module.exports = AnnouncerActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-choice.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the choice actor, which will show the player a multiple choice question. It will also
 * play any audio/text associated with asking question.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "choice", // required type.
 *     "startChoice": "dp1", // which choice to start with from the choiceMap set.
 *     "choiceMap": {
 *         "dp1": { // this is the name of this choice, used when linking choices
 *             "text": "Im Mandy. Click one of the response bubbles below to respond to me.", // question. It can be blank.
 *             "audio": "6th_int_01", // audio, it is optional.
 *             "key": "mandy", // a key into a set of audio. optional.
 *             "decisionPoint": true, // mark this option for saving.
 *             "choices": [
 *                 {
 *                    "link": "dp2",  // which question/choices to show next.
 *                    "text": "One of these?" // displayed text of this choice.
 *                    "decision": "PR"event | "AL"low | "EN"courage | "PA"rticpate | "DI"scourage  (Required if decisionPoint === true )
 *                 },
 *                 {
 *                    "link": "dp2",
 *                    "text": "So, this is how we talk?"*
 *                 },
 *                 {
 *                    "text": "You mean these bubbles?", // text to show for this choice.
 *                    "variable": "choice_2", // variable to set when this choice is selected.
 *                    "value": "zink_mandy"   // value to set variable to.
 *                }
 *              ]
 *            },
 *            ... // as many choices as you want.
 *          }
 *         },
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *
 *  For a decision point, you can stll do a variable/value and link.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var MAX_CHOICES = 5,
        choiceMap = { "PR" : 0, "DI" : 1, "AL": 2, "EN": 3, "PA": 4},
        marginY = 6,
        marginFont = 25;

    var ChoiceActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "choiceMap", "startChoice" ];
        },
        enterScene: function() {
            this.choiceMap = this.data.choiceMap;
            this.currentChoice = this.choiceMap[this.data.startChoice];

            /**
             * Determine the number of questions and build the correct choice list.
             * If this is a decision point choice, use the previous choices per the formula..
             */
            this.buildActor();
            this.populateChoice();
        },
        buildActor: function () {
            this.buttons = [];
            this.text = [];
            var locationY = 50,
                buttonCnt,
                currButton,
                currText,
                locationX = 0;
            this.fStyle = this.getFont('bubbleText');

            for( buttonCnt = MAX_CHOICES; buttonCnt > 0; buttonCnt-- ) {
                currButton = this.game.add.button(0, 0, this.theme.textureKey, this.onChoice, this,
                    'response-bg-over.png', 'response-bg-up.png', 'response-bg-down.png', 'response-bg-up.png');
                // this.theme.buttons.responses.over, this.theme.buttons.responses.out, this.theme.buttons.responses.down, this.theme.buttons.responses.up
                locationX = (this.game.world.width - currButton.width ) / 2;
                locationY = this.game.world.height - ( (currButton.height + marginY) * buttonCnt);
                currButton.x = locationX;
                currButton.y = locationY;

                currText = new Phaser.Text(this.game, marginFont, currButton.height / 2, "", this.fStyle);
                currButton.addChild(currText);
                currText.anchor.setTo(0, 0.5);

                this.buttons.push(currButton);
                this.text.push(currText);
            }
        },
        populateChoice: function () {
            var index,
                options = this.currentChoice,
                buttonHideCount = MAX_CHOICES - options.choices.length,// how many choices to hide.
                buttonCnt,
                answer,
                showQuestions = [ true, true, true, true, true],
                dpChoices = [],
                chosenIndex,
                previousPlayHidden = -1;

            if( options.decisionPoint === true || options.decisionPoint === "true") {
                this.dpIndex = this.getDecisionIndex();
                log.warn("Showing decision point: " + this.dpIndex);

                // The first two questions are a special case, and we'll only hide one...
                if( this.dpIndex === 0 || this.dpIndex === 1 ) {
                    answer = this.getPreviousPlayAnswer( this.dpIndex );
                    if( answer && answer !== "XX" ) {
                        log.warn("Hiding answer " + answer + " from previous playthrough.");
                        previousPlayHidden = choiceMap[answer];
                    }
                }
                // The questions after that, just use the previous answer.
                if( this.dpIndex > 0 ) {
                    answer = this.getPreviousAnswer( this.dpIndex );
                    log.warn("got previous answer of " + answer);
                    chosenIndex = choiceMap[answer];

                    // if index is the beginning or end, go up/down 2, otherwise, go both sides.
                    if( chosenIndex === 0) {
                        showQuestions[3] = false;
                        showQuestions[4] = false;
                    } else if( chosenIndex === 4 ) {
                        showQuestions[0] = false;
                        showQuestions[1] = false;
                    } else {
                        showQuestions = [ false, false, false, false, false];
                        showQuestions[chosenIndex] = true;
                        showQuestions[chosenIndex+1] = true;
                        showQuestions[chosenIndex-1] = true;
                    }
                }

                /**
                 * Since we may have overriden the hide with a true, hide AFTER parsing previous.
                 */
                if( previousPlayHidden !== -1 ) {
                    showQuestions[previousPlayHidden] = false;
                }

                for (index = 0; index < options.choices.length; index++) {
                    if( showQuestions[index] ) {
                        dpChoices.push( options.choices[index]);
                    }
                }
                // redo the offset, now that choices are being hidden.
                buttonHideCount = MAX_CHOICES - dpChoices.length;
                log.warn("determined button offset of " + buttonHideCount);
            } else {
                for (index = 0; index < options.choices.length; index++) {
                    dpChoices.push( options.choices[index]);
                }
            }

            // Had button up to the count.
            for( buttonCnt = 0; buttonCnt < buttonHideCount; buttonCnt++ ) {
                if( this.buttons[buttonCnt]) {
                    this.buttons[buttonCnt].visible = false;
                    this.buttons[buttonCnt].inputEnabled = false;
                } else {
                    log.error("Bad button count: " + buttonCnt );
                }
            }

            /**
             * Make a list of the indexes, and then randomize that list.
             * This is randomize the order the answers are presented to the user.
             */
            var randomizedIndex = [];
            for (index = 0; index < dpChoices.length; index++) {
                randomizedIndex.push( index );
            }
            Phaser.ArrayUtils.shuffle(randomizedIndex);

            var randomKey;
            for (index = 0; index < dpChoices.length; index++) {
                randomKey = randomizedIndex[index];
                this.text[index + buttonHideCount].setText(dpChoices[randomKey].text);
                this.buttons[index + buttonHideCount].currentOption = dpChoices[randomKey];
                this.buttons[index + buttonHideCount].visible = true;
                this.buttons[index + buttonHideCount].inputEnabled = true;
            }

            if( options.text || options.audio ) {
                var eventData = {"text": options.text, "audio": options.audio, "key": options.key};
                //log.warn("Choice actor sending game speech");
                //log.warn(eventData);
                this.playAudio( eventData );
            }
        },
        destroy: function () {
            var temp;
            while( this.text.length > 0 ) {
                temp = this.text.shift();
                temp.destroy();
                temp = null;
            }
            while( this.buttons.length > 0 ) {
                temp = this.buttons.shift();
                temp.destroy();
                temp = null;
            }
            this.freeBaseActor();
        },
        onChoice: function (data) {
            //log.warn("Choice made, popuplating new choice");
            //log.warn(_.cloneDeep(data.currentOption));
            var choice = data.currentOption;
            if( choice.variable ) {
                var varSet = {};
                varSet[choice.variable] = choice.value;
                this.events.onGameChoice.dispatch( this.data.name, varSet );
            }
            if( choice.link ) {
                this.currentChoice = this.choiceMap[choice.link];
                this.populateChoice();
            }
        },
        /**
         * Figure out which decision the player is making, by assuming they make them in order.
         * So find the first index that is XX.
         * @returns {number} index of next decision point.
         */
        getDecisionIndex: function() {
            var decisionSet = this.modelInterface.getValue("$decisionsCurrent"),
                dpIndex;

            for( dpIndex = 0; dpIndex < decisionSet.length; dpIndex++ ) {
                if( decisionSet[dpIndex] === "XX" ) {
                    return dpIndex;
                }
            }
            return -1;
        },
        /**
         * For a given decision index, find the answer from the previous play through.
         */
        getPreviousPlayAnswer: function(decisionIndex) {
            return this.modelInterface.getValue("$decisionsPrevious")[decisionIndex];
        },
        /**
         * Get the answer to the previous decision from this play through.
         */
        getPreviousAnswer: function( decisionIndex ) {
            return this.modelInterface.getValue("$decisionsCurrent")[decisionIndex-1];
        }
    });

    module.exports = ChoiceActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-chooser.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 04/23/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 *  A chooser actor which randomly toggles a hi-lited selection through a specified number of changes before
 *  ultimately ending on a selection which will either be (not rigged) always random or (rigged) unique first and then random.
 *  The "toggling" action will increase in interval until stopping, that is, the chooser decelerates until it stops, somewhat 
 *  like a roulette wheel.
 * 
 * Creating a Chooser actor:
 * {
 *      "name": "chooser1",             // A unique name for the actor
 *      "type": "chooser",              // Required type
 *      "startButton": {                // The image which should trigger the choosing sequence, and where to put it
 *          "image": "choose_button",
 *          "location": [ 300, 200 ]
 *      },
 *      "images": "chooser_1",          // Refers to theme.images.chooserImages.chooser_1 which is a collection of objects 
 *                                          { "base": "image1.png", "hi": "image1_hi.png"  }
 *      "location": [ 100, 100 ],       // Where the first image is positioned
 *      "audio": "tick_sound",          // An optional sound to play for each change
 *      "numChanges": 24,               // How many different events are emited before reaching the ultimate selection. If this is too much it could cause performance issues
 *      "rigged": true,                 // Optional, if this is true the chooser will select each option once until each is used, then begin randomly selecting things.
 *      "variable": "chooser_value",    // When actor is added, the variable 'chooser_value' will be set to a number between 0 and numOptions - 1 .
 *      "startDelay": 1000              // Optional delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var ChooserActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "variable", "numChanges", "images", "location", "startButton" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        randomIntFromInterval: function(min,max)
        {
            return Math.floor(Math.random() * ( max - min));
        },
        buildActor: function() {
            this.riggedSpinValues = this.data.rigged ? _.shuffle(_.range(0, this.theme.images.chooserImages[this.data.images].length)) : [];
            
            var i = 0;
            this.choice = [];
            this.hi_choice = [];
            while (i < this.theme.images.chooserImages[this.data.images].length) {

                var x_pos = this.data.location[0] + (i % 2) * this.game.cache.getFrameByName(this.theme.textureKey, this.theme.images.chooserImages[this.data.images][i].base).width;
                var y_pos = this.data.location[1];
                if (i > 1) {
                    y_pos += this.game.cache.getFrameByName(this.theme.textureKey, this.theme.images.chooserImages[this.data.images][i].base).height;
                }
                this.choice.push(this.game.add.sprite( x_pos, y_pos,
                    this.theme.textureKey, this.getImage( this.theme.images.chooserImages[this.data.images][i].base, null)));
                this.hi_choice.push(this.game.add.sprite( x_pos, y_pos,
                    this.theme.textureKey, this.getImage( this.theme.images.chooserImages[this.data.images][i].hi, null)));
                this.hi_choice[i].visible = false;
                i++;

            }
            this.startButton = this.game.add.button( this.data.startButton.location[0], this.data.startButton.location[1], this.theme.textureKey,
                this.onClick, this,
                this.theme.buttons[this.data.startButton.image].over, this.theme.buttons[this.data.startButton.image].out,
                this.theme.buttons[this.data.startButton.image].down, this.theme.buttons[this.data.startButton.image].up);

        },
        choiceIterator: function (choices, cb) {
            var start = 10;
            for (var i = 1; i < choices.length; i++) {
                if (i === choices.length - 1) {
                    this.game.time.events.add(start, this.toggleSelection, this, choices[i - 1], choices[i], cb.bind(this));
                } else {
                    this.game.time.events.add(start, this.toggleSelection, this, choices[i - 1], choices[i]);
                    start += 12 * i;
                }
            }
        },
        toggleSelection: function (last, next, done) {
            if (this.data.audio) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": "stopAll" };
                this.playAudio( eventData);
            }
            this.hi_choice[last].visible = false;
            this.hi_choice[next].visible = true;
            if (typeof done === 'function') {
                done();
            }
        },
        onClick: function () {
            var numOptions = this.theme.images.chooserImages[this.data.images].length
            if (this.isChoosing) {
                return;
            };
            var varSet = {};
            varSet[this.data.variable] = 100;
            this.dispatchGameChoice(varSet);
            this.isChoosing = true;
            for (var i = 0; i < numOptions; i++) {
                this.hi_choice[i].visible = false;
            }
            var randomInt = this.riggedSpinValues.length ? this.riggedSpinValues.pop() : this.randomIntFromInterval(1, numOptions);
            var choices = [Math.floor(Math.random() * numOptions)];

            for (var i = 1; i < this.data.numChanges - 1; i++) {
                var choice = Math.floor(Math.random() * numOptions);
                while (choice === choices[i - 1]) {
                    choice = Math.floor(Math.random() * numOptions);
                }
                choices.push(choice);
            }
            while (randomInt === choices[choices.length -1]) {
                choices.push(Math.floor(Math.random() * numOptions));
            }

            choices.push(randomInt);

            this.choiceIterator(choices, function() {
                this.isChoosing = false;
            });
            var varSet = {};
            varSet[this.data.variable] = randomInt.toString();
            this.dispatchGameChoice(varSet);
        },
        destroy: function() {
            if (this.center) {
                this.center.destroy();
            }
            if (this.arrow) {
                this.arrow.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ChooserActor;
}());
},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The phone button actor. This actor is used for opening the phone and showing phone alerts.
 *
 * Creating a phone button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "phone-button", // the required type.
 *     "images": "phone", // where in the theme to find the images.
 *     "location": [ x, y ],
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  Handles special variables:
 *  phone_alert : type // show an alert, of the type given.
 */
(function () {

    var Actor = require('../actor');

    var PhoneButtonActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location", "image" ];
        },
        enterScene: function() {
            this.isAlerted = false;
            this.buildActor();
            if( this.data.alert ) {
                this.onGameChoice( { 'phone_alert': this.data.alert });
            }
        },
        buildActor: function() {
            this.alertGroup = null;
            this.buttonAnimation = null;
            var tLoc = this.data.image;

            this.button = this.game.add.button( this.data.location[0], this.data.location[1] + 36, this.theme.textureKey,
                this.onPointerUp, this,
                this.theme[tLoc].button.over, this.theme[tLoc].button.out,
                this.theme[tLoc].button.down, this.theme[tLoc].button.up);
            this.button.inputEnabled = true;
        },
        buildActorAlerts: function() {
            this.alertGroup = this.game.add.group();
            this.alertGroup.x = this.data.location[0];
            this.alertGroup.y = this.data.location[1];
            var tLoc = this.data.image;

            this.alerts = {
                game: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.game),
                message: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.message),
                pdf: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.pdf),
                video: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.video),
                gtfs: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.gtfs)
            };

            this.alertGroup.add(this.alerts.game);
            this.alertGroup.add(this.alerts.message);
            this.alertGroup.add(this.alerts.pdf);
            this.alertGroup.add(this.alerts.video);
            this.alertGroup.add(this.alerts.gtfs);
            this.showAlert(false);
        },
        /**
         * Any game choice during an alert will cause the phone to 'vibrate' on screen.
         * @param choice
         */
        onGameChoice: function( choice ) {
            if( this.isAlerted ) {
                this.playAlert();
            } else if( choice['phone_alert'] ) {
                this.isAlerted = true;
                this.showAlert(choice['phone_alert']);
                this.playAlert();
            }
        },
        /**
         * Show one of the alerts, or hide them all if no type (or false) is passed.
         * @param type game|message|pdf|video|false
         */
        showAlert: function( type ) {
            if( this.alertGroup === null ) {
                this.buildActorAlerts();
            }
            this.alerts.game.visible = false;
            this.alerts.message.visible = false;
            this.alerts.pdf.visible = false;
            this.alerts.video.visible = false;
            this.alerts.gtfs.visible = false;
            if( type ) {
                this.alerts[type].visible = true;
            }
        },
        /**
         * Play the ring animation and current ring tone.
         */
        playAlert: function() {
            var ringToneIndex = parseInt(this.modelInterface.getValue("$phoneRingerIndex"), 10);
            if( this.buttonAnimation === null) {
                this.buttonAnimation = this.button.animations.add('ring', this.theme[this.data.image].ring);
            }
            this.button.animations.play('ring', 4);
            var eventData = {"text": "", "audio" : this.theme.phone.ringtones[ringToneIndex] };
            this.playAudio( eventData);
        },
        /**
         * When the player clicks the phone button, stop any alert and then send out the game choice.
         * @param event
         */
        onPointerUp: function( event ) {
            this.isAlerted = false;
            this.showAlert(false);
            this.button.animations.stop();

            var varSet = {};
            varSet['show_cell_phone'] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            this.alerts = null;
            if ( this.alertGroup ) {
                this.alertGroup.destroy();
            }
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = PhoneButtonActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/20/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a very specialized actor for use with Welcome To Newbridge and Act Now! it shows a cell phone that sends out
 * special events, responds to events, and can interact with the user by drawing over the scene. The user can interact
 * with the phone and possibly launch sub-activities from it. Because of this, the phone must block user input, which
 * is the purpose of the blockingSprite(s).
 *
 * ringtone and background are now stored on the play-model of the current scene.
 *
 *  {
 *     "name": "phone_1",
 *     "type": "phone",
 *     "help": {
 *       "variable": "phone_1", // these variables will be set to 'open' or 'closed' automatically. It's optional.
 *       "text" : "You'll find good advice here." // text to display for this 'icon'
 *     },
 *     "gtfs": {
 *       "variable": "phone_2",
 *       "text": "You'll be notified when it's time to learn some facts about bullying."
 *     },
 *     "games": {
 *       "text": "Sometimes you can choose this icon to play another game within the school day."
 *    },
 *     "messages": {
 *       "variable": "phone_3",
 *       "from": "anonymous", // messages has a 'from'; since they are displayed as text messages.
 *       "text": "this is a text message."
 *     },
 *     "videos": {
 *       "link": "",
 *       "text": "You'll be directed when to watch videos about bullying. Click this icon when told to see a video on your phone."
 *     },
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 *  Special data stored on model. These data are stored on the model to make them stateful between instances:
 *     "phoneRingerIndex": the index of the current ring tone.
 *     "phoneBgIndex": the index of the current background image.
 *
 */
(function () {
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor'),
        moment = require('moment');

    var Phone = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ ]; // no required fields
        },
        enterScene: function () {
            this.fontHeader = this.getFont('phoneHeader');
            this.fontBody = this.getFont('phoneBody');
            this.fontBodyLink = this.getFont('phoneBodyLink');
            this.isInitialized = false;

            if( this.data.open ) {
                this.showPhone();
            }
        },
        onGameChoice: function( choice ) {
            if( choice['show_cell_phone'] ) {
                if( this.isInitialized && this.phoneGroup.visible ) {
                    this.onClickClose();
                } else {
                    this.showPhone();
                }
            }
        },
        dispatch: function (data, value) {
            var varSet = {};
            varSet[data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onClickHelp: function () {
            this.currentIcon = this.data.help;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Help", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickGtfs: function () {
            this.currentIcon = this.data.gtfs;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Get The Facts", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickMessages: function () {
            this.currentIcon = this.data.messages;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText(this.currentIcon.from, this.currentIcon.text, true, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickVideos: function () {
            this.currentIcon = this.data.videos;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Videos", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickRingtone: function () {
            var ringToneIndex = parseInt(this.modelInterface.getValue("$phoneRingerIndex"), 10);
            ringToneIndex++;
            ringToneIndex %= this.theme.phone.ringtones.length;
            this.playAudio(  { "audio": this.theme.phone.ringtones[ringToneIndex]});
            this.events.onGameChoice.dispatch(this.data.name, {"phoneRingerIndex": ringToneIndex });
        },
        onClickBackground: function () {
            var phoneBgIndex = parseInt(this.modelInterface.getValue("$phoneBgIndex"), 10);
            phoneBgIndex++;
            phoneBgIndex %= this.theme.phone.backgrounds.length;
            this.phoneBg.frameName = this.theme.phone.backgrounds[phoneBgIndex];
            this.events.onGameChoice.dispatch(this.data.name, {"phoneBgIndex": phoneBgIndex});
        },
        onClickClose: function () {
            this.phoneGroup.visible = false;
            this.textGroup.visible = false;
            this.blockingSprite.visible = false;
            this.blockingSprite2.visible = false;
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "closed"});
        },
        createPhoneButton: function (key, callback, context) {
            var button = new Phaser.Button(this.game, 0, 0, this.theme.textureKey,
                callback, context,
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0],
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0]);
            button.input.useHandCursor = true;
            return button;
        },
        /**
         * Showing the phone is a bit complicated. Everything has to be brought to the top in
         * reverse order.
         */
        showPhone: function () {
            if( this.isInitialized === false ) {
                this.initHomeScreenGroup();
                this.initBlockingGroup();
                this.initMessageWindowGroup();
            }
            this.phoneGroup.visible = true;
            this.blockingSprite.visible = true;
            this.blockingSprite2.visible = false;
            this.blockingSprite.bringToTop();
            this.game.world.bringToTop(this.phoneGroup);
            this.blockingSprite2.bringToTop();
            this.game.world.bringToTop(this.textGroup);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "open"});
        },
        /**
         * Create the main screen, including all of the buttons.
         */
        initHomeScreenGroup: function() {
            var phoneBgIndex = parseInt(this.modelInterface.getValue("$phoneBgIndex"), 10);
            this.phoneGroup = this.game.add.group();
            this.phoneGroup.x = this.game.world.centerX;

            this.phoneBg = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.backgrounds[phoneBgIndex]);
            this.phoneBg.anchor.setTo(0.5, 0.0);
            this.phoneGroup.add(this.phoneBg);

            this.helpButton = this.createPhoneButton('help', this.onClickHelp, this, 2);
            this.phoneGroup.add(this.helpButton);
            this.helpButton.x = -this.helpButton.width;
            this.helpButton.y = 50;
            this.helpButton.anchor.setTo(0.5, 0);
            this.helpButton.bringToTop();

            this.gtfsButton = this.createPhoneButton('gtfs', this.onClickGtfs, this, 2);
            this.phoneGroup.add(this.gtfsButton);
            this.gtfsButton.x = 0;
            this.gtfsButton.y = 50;
            this.gtfsButton.anchor.setTo(0.5, 0);
            this.gtfsButton.bringToTop();

            this.messagesButton = this.createPhoneButton('messages', this.onClickMessages, this, 2);
            this.phoneGroup.add(this.messagesButton);
            this.messagesButton.x = this.messagesButton.width;
            this.messagesButton.y = 50;
            this.messagesButton.anchor.setTo(0.5, 0);
            this.messagesButton.bringToTop();

            this.videosButton = this.createPhoneButton('videos', this.onClickVideos, this, 2);
            this.phoneGroup.add(this.videosButton);
            this.videosButton.x = -this.videosButton.width;
            this.videosButton.y = 50 + this.videosButton.height;
            this.videosButton.anchor.setTo(0.5, 0);
            this.videosButton.bringToTop();

            this.ringtoneButton = this.createPhoneButton('ringtones', this.onClickRingtone, this, 2);
            this.phoneGroup.add(this.ringtoneButton);
            this.ringtoneButton.x = 0;
            this.ringtoneButton.y = 50 + this.videosButton.height;
            this.ringtoneButton.anchor.setTo(0.5, 0);
            this.ringtoneButton.bringToTop();

            this.backgroundButton = this.createPhoneButton('background', this.onClickBackground, this, 2);
            this.phoneGroup.add(this.backgroundButton);
            this.backgroundButton.x = this.messagesButton.width; // this is on purpose.
            this.backgroundButton.y = 50 + this.videosButton.height;
            this.backgroundButton.anchor.setTo(0.5, 0);
            this.backgroundButton.bringToTop();

            this.closeButton = this.createPhoneButton('close', this.onClickClose, this, 2);
            this.phoneGroup.add(this.closeButton);
            this.closeButton.x = 0;
            this.closeButton.y = 50 + (this.gtfsButton.height * 3);
            this.closeButton.anchor.setTo(0.5, 0);
            this.closeButton.bringToTop();
            this.phoneGroup.visible = false;


        },
        initBlockingGroup: function() {
            this.blockingSprite = this.createBlockingSprite();
            this.blockingSprite2 = this.createBlockingSprite();
            this.game.add.existing(this.blockingSprite);
            this.game.add.existing(this.blockingSprite2);
            this.blockingSprite.visible = false;
            this.blockingSprite2.visible = false;
        },
        initMessageWindowGroup: function () {
            var width = this.phoneBg.width - 32;
            var x = this.game.world.centerX - (width / 2),
                y = this.phoneBg.y + 32,
                height = this.phoneBg.height - 74,
                heightHeading = height / 7,
                margin = 10;

            height -= (heightHeading);

            this.textGroup = this.game.add.group();
            this.textGroup.x = x;
            this.textGroup.y = y;

            this.headingText = new Phaser.Text(this.game, width / 2, heightHeading / 2, "HEADING TEST", this.fontHeader);
            this.headingText.anchor.setTo(0.5, 0.5);

            this.fontBody.wordWrap = true;
            this.fontBody.wordWrapWidth = width * 0.9;
            this.fontBodyLink.wordWrap = true;
            this.fontBodyLink.wordWrapWidth = width * 0.9;
            this.bodyText = new Phaser.Text(this.game, margin, heightHeading + margin, "THIS IS A TEXT MESSAGE FOR YOU TO SEE TEST", this.fontBody);
            this.bodyText.anchor.setTo(0.0, 0.0);
            this.bodyText.inputEnabled = true;
            this.bodyText.events.onInputDown.add(this.clickedBodyText, this);

            var graphics = new Phaser.Graphics(this.game);
            this.textGroup.add(graphics);

            // set a fill and line style
            graphics.beginFill(0x353535);
            graphics.lineStyle(1, 0x000000, 1);
            graphics.drawRect(0, 0, width, heightHeading);
            graphics.beginFill(0xFFFFFF, 0.9);
            graphics.drawRect(0, heightHeading, width, height);
            graphics.endFill();

            var buttonSprite = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.messages.button);
            buttonSprite.x = width - buttonSprite.width - margin;
            buttonSprite.y = heightHeading + height - margin - buttonSprite.height;
            buttonSprite.inputEnabled = true;
            buttonSprite.events.onInputDown.add(this.chooseOk, this);

            this.playButton = new Phaser.Sprite(this.game, margin, 0, this.theme.textureKey, this.theme.phone.playButton);
            this.playButton.inputEnabled = true;
            this.playButton.events.onInputDown.add(this.clickedBodyText, this);
            this.playButton.visible = false;

            this.textGroup.add(this.headingText);
            this.textGroup.add(this.bodyText);
            this.textGroup.add(buttonSprite);
            this.textGroup.add(this.playButton);

            this.hideText();
        },
        showText: function (heading1, body, isTextMessage, link, valueIn) {
            var value = null;
            if( valueIn ) {
                value = this.modelInterface.getValue( valueIn);
            }
            this.headingText.setText(heading1);
            this.setBodyText( body, link, valueIn );

            this.textGroup.visible = true;
            this.blockingSprite2.visible = true;
            if( isTextMessage ) {
                var dt = "Received: " + moment().format("MMM Do YYYY, h:mm a "); // Jul 21st 2015, 11:12 am
                var from = this.modelInterface.getValue(heading1);
                from = from.charAt(0).toUpperCase() + from.slice(1);
                this.headingText.setText( "From: " + from + "\n" + dt);
            }
        },
        setBodyText: function( text, isLink, useValue) {
            log.warn("In set body text.");
            if( isLink === true ) {
                this.bodyText.inputEnabled = true;
                this.playButton.visible = true;
                this.playButton.inputEnabled = true;
            } else {
                this.bodyText.inputEnabled = false;
                this.playButton.visible = false;
                this.playButton.inputEnabled = false;
            }
            if( typeof text === 'string') {
                log.warn("Setting as simple string");
                this.bodyText.setStyle( this.fontBody );
                this.bodyText.setText( this.substituteText(text) );
            } else {
                log.warn("not a string, parsing everything..");
                this.bodyText.setStyle( this.fontBodyLink );
                if( useValue ) {
                    log.warn("useValue defined, as: " + useValue);
                    var value = parseInt(this.modelInterface.getValue(useValue), 10);
                    log.warn("value is " + value);
                    var foundScoreRange = false;
                    _.each( text, function(singleEntry) {
                        if( value >= singleEntry[0] && value <= singleEntry[1] ) {
                            this.bodyText.setText( this.substituteText(singleEntry[2]));
                            foundScoreRange = true;
                        }
                    }, this);
                    if (foundScoreRange === false) {
                        //log.warn("$$$$$$$$$$$ noted value out of range");
                        // The score wasn't within any range. It could be higher than any or lower than
                        // any, or there could be a hole in the ranges.
                        var highestScore = 0;
                        var lowestScore = 0;
                        var highestText = "";
                        var lowestText = "";
                        _.each( text, function(singleEntry) {
                            if( singleEntry[0] > highestScore ) {
                                highestScore = singleEntry[0];
                                highestText = singleEntry[2];
                            }
                            if( singleEntry[1] > highestScore ) {
                                highestScore = singleEntry[1];
                                highestText = singleEntry[2];
                            }
                            if ( singleEntry[0] < lowestScore ) {
                                lowestScore = singleEntry[0];
                                lowestText = singleEntry[2];
                            }
                            if ( singleEntry[1] < lowestScore ) {
                                lowestScore = singleEntry[1];
                                lowestText = singleEntry[2];
                            }
                        }, this);
                        if (value > highestScore) {
                            // score is higher than highest range; use highest range text
                            this.bodyText.setText( this.substituteText(highestText));
                        } else if (value < lowestScore) {
                            // score is lower than lowest range; use lowest range text
                            this.bodyText.setText( this.substituteText(lowestText));
                        } else {
                            // there must be a hole in the ranges; just use the first entry
                            this.bodyText.setText(this.substituteText(text[0][2]));
                        }
                    }
                } else {
                    this.bodyText.setText( this.substituteText(text[0][2])); // just use first entry.
                }
            }
            this.playButton.y = this.bodyText.y + this.bodyText.height + 5;
        },
        substituteText: function( text ) {
            log.warn("Doing substitution on: " + text);
            var leftIndex, rightIndex;
            leftIndex = text.indexOf("$");
            if( leftIndex === -1 ) {
                return text;
            }
            rightIndex = text.indexOf("$", leftIndex + 1);
            if( rightIndex === -1 ) {
                return text;
            }
            var key = text.substring( leftIndex, rightIndex +1);
            var key2 = key.substring(0, key.length - 1); // remove trailing dollarsign.
            var finalText = this.modelInterface.getValue(key2);
            finalText = finalText.charAt(0).toUpperCase() + finalText.slice(1);
            return text.replace(key, finalText );
        },
        hideText: function () {
            this.textGroup.visible = false;
            this.blockingSprite2.visible = false;
        },
        chooseOk: function () {
            if (this.currentIcon && this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "closed");
                this.currentIcon = null;
            }
            this.hideText();
        },
        clickedBodyText: function() {
            this.dispatch(this.currentIcon, "clicked");
            /**
             * Phone links must behave differently than other buttons in the scene engine.
             * They can be clicked over and over. So, after sending the clicked event, we send an
             * afterClicked event, which forces the variable to change, so that the next time the
             * link is clicked, the 'clicked' event is seen as a change again.
             */
            this.dispatch(this.currentIcon, "afterClicked");
        },
        destroy: function () {
            this.fontHeader = null;
            this.fontBody = null;
            if ( this.phoneGroup ) {
                this.phoneGroup.destroy();
            }
            if ( this.textGroup ) {
                this.textGroup.destroy();
            }
            if ( this.blockingSprite ) {
                this.blockingSprite.destroy(true);
            }
            if ( this.blockingSprite2 ) {
                this.blockingSprite2.destroy(true);
            }
            if ( this.playButton ) {
                this.playButton.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = Phone;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","moment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-playthrough.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The decoration actor. Just an image on the screen.
 *
 * Creating a button actor:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "decoration", // the required type.
 *     "image": "phone", // the images to use from the button section of the theme.
 *     "key": "something", // an optional key to look under for the image.
 *     "location": [ x, y ],
 *     "scale": [ x, y], // optional x/y scale.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var PlayThroughActor = Actor.extend( {
        constructor: function(game, theme) {
            if( !game ) {
                throw "actor requires game constructor argument.";
            }
            this.game = game;
            this.data = {
                "name": "playthroughdisplay"
            };
            this.theme = theme;
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            if( !this.theme.playthroughDisplayContainer ) {
                throw "You cannot display playthrough without providing an image in the theme.";
            }

            this.sprite = this.game.add.sprite( 0, 0, this.theme.textureKey, this.theme.playthroughDisplayContainer );
            this.sprite.x = this.game.world.width - this.sprite.width;
            this.sprite.y = 0;
            var fStyle = this.getFont('playThrough');
            var currentText = new Phaser.Text(this.game, this.sprite.width/2, this.sprite.height/2, "Playthrough: " + this.modelInterface.getValue("$playThrough"), fStyle);
            currentText.anchor.setTo(0.5,0.5);
            this.sprite.addChild(currentText);
            this.sprite.visible = false;
        },
        hide: function() {
            if( this.sprite ) {
                this.sprite.visible = false;
            }
        },
        show: function() {
            if( this.sprite ) {
                this.sprite.visible = true;
                this.sprite.bringToTop();
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = PlayThroughActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-spinner.js":[function(require,module,exports){
/**
 * @author David Lee
 * @version 1.0.0
 * @creation 04/03/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 * A spinner actor with a central button and a pointer that extends off it.
 * 
 * Creating a Spinner actor:
 * {
 *      "name": "spinner1",             // A unique name for the actor
 *      "type": "spinner",              // Required type
 *      "images": "spinner",            // The key to use from the spinners section of the theme
 *      "centerImage": "center"         // The key to use within the theme file for the center image
 *      "arrowImage": "arrow"           // The key to use within the theme file for the arrow image
 *      "offset": 0.25                  // Offset in radians used by the starting position / when spinning
 *      "numOptions": 4                 // How many different options the spinner uses. Defaults to 4
 *      "audio": "spin",                // An optional sound to play when the spinner is clicked. Don't play long audio!
 *      "audioPriority": "sfx",         // An optional priority to use for the spinner audio property. If this is not set, it defaults to "sfx"
 *      "location": [ x, y ],           // Where to put the center of the spinner
 *      "spinDuration": 3600,           // How long the spin animation should take. If this is not specified, a duration based on the number of spins will be used by default
 *      "fakeSpinsRange": [2, 5],       // Range [min, max] of fake spins to show before the arrow is set to the randomly selected section. This defaults to [2, 5] if not specified
 *      "rigged": true,                 // Optional, if this is true the spinner will select each option once until each is used, then begin randomly selecting things.
 *      "clickValue": "reset",          // Optional, if this is set, when the center is clicked the variable will be set to this value. This is useful to trigger events on click that must happen before the spin is completed and the variable is updated to the final value
 *      "variable": "spinner_value"     // if you click the spinner, the variable 'spinner_value' will be set to a number between 1 and 4.
 *      "startDelay": 1000              // optional delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 *      "arrowOffsetX": 0.05            // optional offset for spinner arrowX
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var DEFAULT_NUM_OPTIONS = 4;

    var SpinnerActor = Actor.extend({
        // constructor in parent.

        getRequiredFields: function() {
            return [ "location", "images", "centerImage", "arrowImage", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        randomIntFromInterval: function(min,max)
        {
            return Math.floor(Math.random() * ( max - min + 1)) + min;
        },
        buildActor: function() {
            if( !this.theme.spinners || !this.theme.spinners[this.data.images] ) {
                throw "Spinner Actor requires spinners entry in theme, with specific entry matching " + this.data.images;
            }
            if (!this.theme.spinners[this.data.images][this.data.centerImage]) {
                throw "Spinner Actor requires spinner entry to have a center image, with a specific entry matching " + this.data.images + "." + this.data.centerImage;
            }
            if (!this.theme.spinners[this.data.images][this.data.arrowImage]) {
                throw "Spinner Actor requires spinner entry to have an arrow image, with a specific entry matching " + this.data.images + "." + this.data.arrowImage;
            }

            if(!this.data.numOptions) {
                this.data.numOptions = DEFAULT_NUM_OPTIONS;
            }

            if(!this.data.fakeSpinsRange) {
                this.data.fakeSpinsRange = [2, 5];
            }

            if(!this.data.audioPriority) {
                this.data.audioPriority = "sfx";
            }

            this.riggedSpinValues = this.data.rigged ? _.shuffle(_.range(1, this.data.numOptions + 1)) : [];

            var anchorX = 0.5,
                anchorY = 0.5;

            var x = this.data.location[0];
            var y = this.data.location[1];

            this.arrow = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.spinners[this.data.images][this.data.arrowImage]);
            this.center = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.spinners[this.data.images][this.data.centerImage]);
            
            this.center.anchor.setTo(anchorX, anchorY);

            if (this.data.arrowOffsetX) {
                this.arrow.anchor.setTo(anchorX - this.data.arrowOffsetX, anchorY);
            } else {
                this.arrow.anchor.setTo(anchorX, anchorY);
            }

            this.arrow.rotation = Math.PI * this.data.offset;

            this.center.inputEnabled = true;
            this.center.input.useHandCursor = true;
            this.arrow.inputEnabled = true;
            this.arrow.input.useHandCursor = true;
            
            this.center.events.onInputDown.add(this.onClick, this);
            this.arrow.events.onInputDown.add(this.onClick, this);

        },
        onClick: function( event ) {

            if (this.spinning) {
                return;
            }

            if (this.data.clickValue) {
                var varSet = {};
                varSet[this.data.variable] = this.data.clickValue;
                this.dispatchGameChoice(varSet);
            }
            
            this.spinning = true;

            if (this.data.audio) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": this.data.audioPriority };
                this.playAudio( eventData);
            }

            var randomInt = this.riggedSpinValues.length ? this.riggedSpinValues.shift() : this.randomIntFromInterval(1, this.data.numOptions);

            var randomFullSpins = this.randomIntFromInterval(this.data.fakeSpinsRange[0], this.data.fakeSpinsRange[1]);

            var randomRotation = ((Math.PI * 2) / this.data.numOptions) * randomInt;
            var rotation = (2 * randomFullSpins * Math.PI) + randomRotation + (Math.PI * this.data.offset);

            if (! this.data.spinDuration) {
                // If the spinDuration isn't passed in, override it with the old code by default
                this.data.spinDuration = (rotation / (2 * Math.PI)) * 1000;
            }
            this.tween = this.game.add.tween(this.arrow).to( { rotation: rotation }, this.data.spinDuration, Phaser.Easing.Quadratic.Out, true, 0, 0, false);
            this.tween.onComplete.add( function() {
                    this.arrow.rotation = this.arrow.rotation % (2 * Math.PI);
                    this.spinning = false;
                    var varSet = {};
                    varSet[this.data.variable] = randomInt.toString();
                    this.dispatchGameChoice(varSet);
            }, this);
        },
        destroy: function() {
            if (this.center) {
                this.center.destroy();
            }
            if (this.arrow) {
                this.arrow.destroy();
            }
            if (this.tween) {
                this.tween.stop();
            }
            this.freeBaseActor();
        }
    });

    module.exports = SpinnerActor;
}());
},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-computer.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble. It displays text and requests that audio be played. A speech bubble can have its own text/audio
 * and can also listen for text/audio events to show.
 * The speech bubble will adjust its size to fit the provided/set text.
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "speech-bubble",
 *    "text": "", // text to show.
 *    "audio": "", // audio key to play.
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var marginX = 15, marginY = 20;

    var ZinkComputerActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location" ];
        },
        enterScene: function () {
            this.text = this.data.text || " ";
            this.key = this.data.key;

            this.addWindow(this.data.location[0], this.data.location[1]);
            this.setSpeech();
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.zink ) {
                throw "Instruction actor requires textWindows theme entry, and zink definition inside it.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.zink);

            this.fStyle = this.getFont('bubbleText');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * 0.55;

            this.currentText = new Phaser.Text(this.game, marginX, marginY, " ", this.fStyle);
            windowGroup.add(this.currentText);

            this.currentText.bringToTop();
            this.windowGroup = windowGroup;
        },
        setSpeech: function () {
            this.currentText.setText( this.getText(this.text, this.key) );
            this.playAudio( {text: this.text, audio: this.audio, key: this.key});
        },
        onGameSpeech: function (speech) {
            this.text = speech.text;
            this.key = speech.key;
            this.currentText.setText( this.getText(this.text, this.key) );
        },
        destroy: function () {
            this.fStyle = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.windowGroup = null;
            this.currentText = null;
            this.freeBaseActor();
        }
    });

    module.exports = ZinkComputerActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-poster.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The zink poster actor. This is a special actor that requires only text and font configuration. It will show a
 * zink poster with text on it.
 *
 * Creating a zink poster actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "zink-poster", // the required type.
 *     "text": "Yo, I'm zink", // what to put on the poster.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var ZinkPosterActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ ]; // no required fields.
        },
        enterScene: function() {
            this.buildActor();
            if( this.data.text ) {
                this.addTextBox();
            }
        },
        buildActor: function() {
            this.darkOut = new Phaser.Graphics(this.game, 0,0);
            this.darkOut.beginFill( 0x000000, 0.4 );
            this.darkOut.drawRect( 0,  0, this.game.world.width, this.game.world.height );
            this.darkOut.endFill();
            this.game.add.existing(this.darkOut);
            this.sprite = this.game.add.sprite( (this.game.world.centerX), 0, this.theme.textureKey,
                this.getImage('zink-poster', 'actorImages'));
            this.sprite.x = this.game.world.centerX - (this.sprite.width / 2);
            this.sprite.angle -= 3;
        },
        addTextBox: function() {
            this.font = this.getFont('zinkPoster');

            this.boxY = this.sprite.y + (this.sprite.height * 0.75);
            this.boxWidth = this.sprite.width - 2;
            this.boxHeight = 115;

            this.font.wordWrap = true;
            this.font.wordWrapWidth = this.boxWidth * 0.9;

            this.text = new Phaser.Text(this.game, 10 , 5, this.data.text , this.font);

            this.graphics = new Phaser.Graphics(this.game, 1, this.boxY);
            this.graphics.beginFill( 0xEFEFEF, 1.0 );
            this.graphics.drawRect( 0,  0, this.boxWidth, this.boxHeight );
            this.graphics.endFill();

            this.graphics.addChild(this.text);
            this.sprite.addChild(this.graphics);
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy();
            }
            if( this.darkOut ) {
                this.darkOut.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ZinkPosterActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-animation.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 10/023/2017
 * Copyright 2017 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The animation actor. Will run it's animation, and can optionally be clicked.
 *
 * Creating a click-animation actor, a starting, animation set, and ending image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "animation", // the required type.
 *     "images": "phone", // the images to use
 *     "key": "whatevs", // optional image key
 *     "textureKey": "key", // optional text key to get animation from
 *     "location": [ x, y ],
 *     "scale": [ x, y], // optional x/y scale.
 *     "fps": 10, // frames were second, will default to 30
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "variable": "x", // variable to send out 2nd click events, will be name + "_playing" and name + "_finished"
 *     "loop": true // true=loop indefinitly, false=no loop, or number of times to play the animation; defaults to true.
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		Actor = require("./actor"),
		TweenHelper = require("./tween-helper");

	var AnimationActor = Actor.extend({
		// constructor in parent
		getRequiredFields: function () {
			return ["location", "images"];
		},
		getVariableList: function () {
			return this.data.variable
				? [this.data.variable + "_playing", this.data.variable + "_finished"]
				: [];
		},
		enterScene: function () {
			this.buildActor();
			var loopIndefinitely =
				this.data.loop === undefined || this.data.loop == true;
			this.sprite.animations.play("animation", this.fps, loopIndefinitely);
		},
		buildActor: function () {
			this.fps = 30;

			this.sprite = this.game.add.sprite(
				this.data.location[0],
				this.data.location[1],
				this.getTextureKey(this.data),
				this.getImage(this.data.images, this.data.key)[0]
			);

			this.sprite.inputEnabled = true;
			this.sprite.input.pixelPerfectOver = false;
			this.sprite.events.onInputUp.add(this.onPointerUp, this);
			if (this.data.variable) {
				this.sprite.input.useHandCursor = true;
			}

			this.animation = this.sprite.animations.add(
				"animation",
				this.getImage(this.data.images, this.data.key)
			);
			this.animation.onStart.add(this.animationStarted, this);
			this.animation.onComplete.add(this.animationStopped, this);

			if (this.data.fps) {
				this.fps = this.data.fps;
			}

			var anchorX = 0,
				anchorY = 0;
			var x = this.data.location[0],
				y = this.data.location[1];
			this.scaleX = 1.0;
			this.scaleY = 1.0;

			if (this.data.scale) {
				this.scaleX = this.data.scale[0];
				this.scaleY = this.data.scale[1];
			}
			this.sprite.scale.setTo(this.scaleX, this.scaleY);

			if (x === "center") {
				x = this.game.world.centerX;
				anchorX = 0.5;
			}

			if (y === "center") {
				y = this.game.world.centerY;
				anchorY = 0.5;
			}

			if (this.data.anchor) {
				anchorX = this.data.anchor[0];
				anchorY = this.data.anchor[1];
			}

			this.sprite.anchor.setTo(anchorX, anchorY);
			this.sprite.x = x;
			this.sprite.y = y;

			if (this.data.loop) {
				var repeatCount = Number(this.data.loop);
				if (repeatCount > 1) {
					this.repeatCount = repeatCount;
				}
			}

			if (this.data.tween) {
				if (_.isUndefined(this.tweenHelper)) {
					this.tweenHelper = new TweenHelper(this.game, this);
				}
				this.tweenHelper.addTweens(this.data.tween, this.sprite);
			}
		},
		animationStarted: function () {
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable + "_playing"] = this.data.name;
				this.events.onGameChoice.dispatch(this.data.name, varSet, this);
			}
		},
		animationStopped: function () {
			if (this.repeatCount && --this.repeatCount) {
				this.animation.restart();
			} else if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable + "_finished"] = this.data.name;
				this.events.onGameChoice.dispatch(this.data.name, varSet, this);
			}
		},
		onPointerUp: function () {
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable] = this.data.name;
				this.events.onGameChoice.dispatch(this.data.name, varSet, this);
			}
		},
		destroy: function () {
			if (!_.isUndefined(this.tweenHelper)) {
				this.tweenHelper.removeTweens(this.sprite);
			}
			if (this.sprite) {
				this.sprite.destroy(true);
			}
			this.freeBaseActor();
		},
	});

	module.exports = AnimationActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./tween-helper":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-audio.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An audio actor. It will play a sound(s) and then set the variable.
 * It is up to the user/script writer to make sure this audio isn't being interrupted by other audio.
 *
 *{
 *    "name": "audio_actor_1", // name.
 *    "type": "audio",
 *    "audio": ["sound1, sound2"], // audio key(s) to play.
 *    "variable": "x", // variable to set when sounds have completed playing.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *    "priority": sfx | interrupt | queue | stop | stopall | low
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var AudioActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "audio", "variable" ];
        },
        enterScene: function () {
            this.audio = this.data.audio;
            // Allow a single string through.
            if( typeof this.audio === 'string' ) {
                this.audio = [ this.audio ];
            }
            this.audioIndex = 0;
            this.playCurrent();
        },
        playCurrent: function() {
            if( this.audioIndex > (this.audio.length-1) ) {
                log.warn("Setting audio sprite variable");
                var varSet = {};
                varSet[this.data.variable] = "played";
                this.events.onGameChoice.dispatch( this.data.name, varSet );
                return;
            }
            var audioKey = this.audio[this.audioIndex];
            this.playAudio({ audio: audioKey, key: null, priority: this.data.priority} );
        },
        onGameSpeechStop: function( speech ) {
            // log.warn("On game speech reached audio actor: " + speech);
            if( speech === this.audio[this.audioIndex] ) {
                this.audioIndex++;
                this.playCurrent();
            }
        },
        destroy: function () {
            this.audio = null;
            this.freeBaseActor();
        }
    });

    module.exports = AudioActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-blocker.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 09/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The blocker actor. This actor can be used to block input events from the actors behind it.
 *
 * Creating a blocker actor:
 *
 * {
 *     "name": "alertBlocker", // a unique identifier
 *     "type": "blocker", // the required type.
 *     "location": [ 0, 0 ], // optional, default is [0,0]; where on the screen to play this actor
 *     "size": [ 800, 600 ], // optional, default is [game.world.width,game.world.height] how large
 *     "blockerTint" : "0x000000", // optional, default is black (0x000000)
 *     "blockerAlpha" : 0.5, // optional, default is 0.5
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

     var BlockerActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [];
        },
        buildActor: function() {
            var blockerX = (typeof this.data.location === 'undefined') ? 0 : this.data.location[0];
            var blockerY = (typeof this.data.location === 'undefined') ? 0 : this.data.location[1];
            var blockerWidth = (typeof this.data.size === 'undefined') ? this.game.world.width : this.data.size[0];
            var blockerHeight = (typeof this.data.size === 'undefined') ? this.game.world.height : this.data.size[1];
            var blockerTint = (typeof this.data.blockerTint === 'undefined') ? 0x000000 : this.data.blockerTint;
            var blockerAlpha = (typeof this.data.blockerAlpha === 'undefined') ? 0.5 : this.data.blockerAlpha;

            this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            this.blockerSprite.addChild(graphics);
            graphics.beginFill( blockerTint, blockerAlpha );
            graphics.drawRect( blockerX, blockerY, blockerWidth, blockerHeight );
            graphics.endFill();
            this.blockerSprite.inputEnabled = true;

            this.blockerSprite.bringToTop();

            this.game.add.existing(this.blockerSprite);

            this.addDebugBox();
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        destroy: function() {
            if ( this.blockerSprite ) {
                this.blockerSprite.inputEnabled = false;
                this.blockerSprite.destroy(true);
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = BlockerActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button-character.js":[function(require,module,exports){
/**
 * @author Zack biernat
 * @version 1.0.0
 * @creation 04/18/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The button-character actor. This actor can be used for selecting a character, and can be
 * used for animating a character that is talking (provide mouth animation). It is differentiated from the
 * NoInputCharacter Actor by allowing the image field to access "buttons" from the theme instead of "actorImages".
 * This allows button-like behavior for the graphic.
 *
 * Creating a button-character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "button-character", // the required type.
 *     "image": "mandy", // the button image to use from the theme (should include "up", "down", "over", "out").
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "frameRate": 24 // optional frame rate for the speech animation, defaults to 10.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "speechAudio": "6th_01", // The actor should animate this piece of audio.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "variable": "character_2", // if you click this character, the variable 'character_2' will be set to 'mandy'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  If you set speechAnimation to true, -talk must be appended to the button-character's image name to differentiate
 *  from the non-speaking version (which may have a different mouth graphic!)
 *
 *  For the speech animations to work, you'll need a speechAnimations section in the theme.json, which specifies
 *  speaking-animation images and location offsets for the mouth:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 *
 *  There must additionally be "Sound Sync Data", defining which image to show...
 *
 * "soundSyncData": {
 *   "6th_01": [
 *     0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1
 *   ], ...
 * }
 *
 *  The 0s and 1s represent which image, and could be 0,1,2,3 etc if there are more than 2. They key should match
 *  the "speechAudio" of this actor as well as the audio being played.
 *  NOTE: Most of the speechSyncData does not contain '1's and looks like [0,0,2,3,3,3,2,0,2,3,2,0,0,0,2,3,4,4,3,4,2,0].
 *  In this case it is advised to use the [A, B, B, C, D] pattern for the different frames in your theme.
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor");

	var ButtonCharacterActor = Actor.extend({
		// constructor is now in base class!
		enterScene: function () {
			this.buildActor();
			if (this.data.speechAnimation) {
				this.addSpeechAnimation();
			}
		},
		getRequiredFields: function () {
			return ["location", "variable"];
		},
		buildActor: function () {
			var imageId = this.modelInterface.getValue(this.data.image);
			if (imageId) {
				if (this.data.speechAnimation) {
					imageId += "-talk";
				}
				this.sprite = this.game.add.button(
					this.data.location[0],
					this.data.location[1],
					this.theme.textureKey,
					this.onClick,
					this,
					this.theme.buttons[this.data.image].over,
					this.theme.buttons[this.data.image].out,
					this.theme.buttons[this.data.image].down,
					this.theme.buttons[this.data.image].up
				);

				if (this.data.scale) {
					this.sprite.scale.setTo(this.data.scale[0], this.data.scale[1]);
				}
			} else {
				this.sprite = this.game.add.button(
					this.data.location[0],
					this.data.location[1],
					this.theme.textureKey,
					this.onClick,
					this,
					this.theme.buttons[this.data.image].over,
					this.theme.buttons[this.data.image].out,
					this.theme.buttons[this.data.image].down,
					this.theme.buttons[this.data.image].up
				);
				this.sprite.width = this.data.size[0];
				this.sprite.height = this.data.size[1];
				this.addDebugBox();
			}
			this.sprite.inputEnabled = true;
			this.sprite.input.useHandCursor = true;
			/**
			 * This is one of the most CPU/expensive things you can do in phaser.
			 */
			this.sprite.input.pixelPerfectOver = false;
		},
		addDebugBox: function () {
			if (window.isDebugging) {
				this.debugBox = new Phaser.Graphics(
					this.game,
					this.data.location[0],
					this.data.location[1]
				);
				this.debugBox.beginFill(0x000000, 1.0);
				this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
				this.debugBox.endFill();
				this.game.add.existing(this.debugBox);
			}
		},
		addSpeechAnimation: function () {
			var aSpeechAnimation =
				this.theme.speechAnimations[
					this.modelInterface.getValue(this.data.image)
				];
			if (!aSpeechAnimation) {
				log.error(
					"Could not add speech animation for character: " + this.data.name
				);
				log.error("Speech animation not found for " + this.data.image);
				log.error(
					"Check that you have a speechAnimations section in your theme."
				);
				return;
			}
			this.speechAnimation = this.game.add.sprite(
				this.data.location[0] + aSpeechAnimation.mouthOffset[0],
				this.data.location[1] + aSpeechAnimation.mouthOffset[1],
				this.theme.textureKey,
				aSpeechAnimation.images[0]
			);
			this.speechAnimation.animations.add("talk", aSpeechAnimation.images);
			this.speechAnimationSet = aSpeechAnimation.images;
			this.speechAnimationDefault = aSpeechAnimation.images[0];

			if (this.data.scale) {
				this.speechAnimation.scale.setTo(
					this.data.scale[0],
					this.data.scale[1]
				);
				this.speechAnimation.x =
					this.data.location[0] +
					aSpeechAnimation.mouthOffset[0] * this.data.scale[0];
				this.speechAnimation.y =
					this.data.location[1] +
					aSpeechAnimation.mouthOffset[1] * this.data.scale[1];
			}
		},
		onGameSpeech: function (speech) {
			var audio = this.modelInterface.getValue(speech.audio);
			if (speech.key) {
				audio = this.modelInterface.getValue(speech.key) + "_" + audio;
			}
			log.warn("On game speech: " + audio);
			if (
				this.speechAnimation &&
				this.theme.soundSyncData &&
				this.theme.soundSyncData[audio] &&
				this.data.speechAudio === audio
			) {
				this.soundSyncData = this.theme.soundSyncData[audio];
				if (!this.timer) {
					var FRAME_RATE = this.data.frameRate ? this.data.frameRate : 10;
					this.timer = this.game.time.create(false);
					this.speechIndex = 0;
					this.timer.loop(1000 / FRAME_RATE, this.incrementSpeech, this);
					this.timer.start();
				}
			}
		},
		incrementSpeech: function () {
			if (this.soundSyncData) {
				this.speechIndex++;
				this.speechAnimation.frameName =
					this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
			}
		},
		onGameSpeechStop: function (speech) {
			if (this.speechAnimation && this.soundSyncData) {
				this.timer.stop();
				this.timer.destroy();
				this.timer = null;
				this.soundSyncData = null;
				this.speechAnimation.frameName = this.speechAnimationDefault;
			}
		},
		onClick: function (event) {
			var varSet = {};
			varSet[this.data.variable] = this.data.name;
			this.dispatchGameChoice(varSet);
		},
		destroy: function () {
			if (this.sprite) {
				this.sprite.inputEnabled = false;
				this.sprite.destroy();
			}
			if (this.speechAnimation) {
				this.speechAnimation.destroy();
			}
			if (this.debugBox) {
				this.debugBox.destroy();
			}
			if (this.timer) {
				this.timer.destroy();
			}
			this.freeBaseActor();
		},
	});

	module.exports = ButtonCharacterActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The button actor. This actor can be used for simple actions, such as opening the cell phone. In many 'plays', this actors
 * isn't needed.
 *
 * Creating a button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "button", // the required type.
 *     "image": "phone", // the images to use from the button section of the theme.
 *     "audio": "ring", // an optional sound to play when the button is clicked. Don't play long audio!***
 *     "sfx": {
 *        "over": "ding" // optional sounds to play on up/over/down/out. Add support as needed. Over added.
 *     },
 *     "location": [ x, y ],
 *     "variable": "show_cell_phone" // if you open the phone, the variable 'show_cell_phone' will be set to 'phone1'.
 *     "animated": "true", // optional; theme.buttonAnimations.<image> item name containing a list of images
 *     "animationFrameRate": 30, // optional, default is 30 fps; ignored if animated is not true
 *     "animationLoop": "true", // optional, default is false; ignored if animated is not true
 *     "animationRepeat": 4000, // optional, time in seconds, default is no repeat; overrides animationLoop if both are specified; ignored if animated is not true
 *     "alpha": 0.4 // optional, opacity coefficient
 *     // optional "scale": [ 1.1, 1.1 ], // Use negative scales to 'flip' the images.
 *     // optional "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 * }
 *
 *  *** If you want to play long audio on a button, use an event and add the audio actor. This is meant for things like
 *      clicks and beeps that play for about a second.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor'),
        TweenHelper = require("./tween-helper");

    var BUTTON_TIMEOUT = 200; // Use this so the audio has a chance to play.

    var ButtonActor = Actor.extend( {
        // constructor is in parent.
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [ "location", "image", "variable" ];
        },
        buildActor: function() {
            if( !this.theme.buttons || !this.theme.buttons[this.data.image] ) {
                throw "Button Actor requires buttons entry in theme, with specific entry matching " + this.data.image;
            }

            var x = this.data.location[0],
                y = this.data.location[1],
                anchorX = 0,
                anchorY = 0;

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if (this.data.anchor === "left") {
                anchorX = 0;
            } else if (this.data.anchor === "center") {
                anchorX = 0.5;
            } else if (this.data.anchor === "right") {
                anchorX = 1;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.button = this.game.add.button( x,y, this.getTextureKey(this.data),
                this.onPointerUp, this,
                this.theme.buttons[this.data.image].over, this.theme.buttons[this.data.image].out,
                this.theme.buttons[this.data.image].down, this.theme.buttons[this.data.image].up);
            this.buttonIsAnimated = ( typeof this.data.animated !== "undefined" ) && ( this.data.animated === true );
            if ( this.buttonIsAnimated ) {
                this.button.animations.add(this.data.image, this.theme.buttonAnimations[this.data.image]);
                this.animationFrameRate = ( typeof this.data.animationFrameRate !== "undefined" ) ? this.data.animationFrameRate : 30;
                this.loopAnimation = ( typeof this.data.animationLoop !== "undefined" ) ? this.data.animationLoop : false;
                this.animationRepeat = ( typeof this.data.animationRepeat !== "undefined" ) ? this.data.animationRepeat : 0;
                if ( this.animationRepeat > 0 ) {
                    this.loopAnimation = false; // timed repeat overrides looping
                    this.animationTimerEvent = this.game.time.events.loop( this.animationRepeat, this.animateButton, this );
                }
                this.animateButton();
            }
            this.button.inputEnabled = true;
            this.button.input.useHandCursor = true;
            this.button.anchor.setTo( anchorX, anchorY );

            if( this.data.scale ) {
                this.button.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if (this.data.alpha) {
                this.button.alpha = this.data.alpha;
            }

            var fontName;
            var textX = this.button.width / 2;
            var textY = this.button.height / 2;
            var anchor = [0.5, 0.45];

            /**
             * GJF - this was already here and I don't want to break backwards compatibility. so I'm adding a
             * "textData" section below.
             */
            if( this.data.text ) {
                fontName = this.data.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");
                this.textSprite = this.game.add.text(textX, textY, this.data.text, this.style);
            }

            if( this.data.textData ) {
                var textData = this.data.textData;
                fontName = textData.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

                if( textData.textX ) {
                    textX = textData.textX;
                }
                if( textData.textY ) {
                    textY = textData.textY;
                }
                if( textData.anchor ) {
                    anchor = textData.anchor;
                }
                this.textSprite = this.game.add.text(textX, textY, textData.text, this.style);
            }

            if( this.textSprite ) {
                this.textSprite.anchor.setTo( anchor[0], anchor[1] );
                this.button.addChild(this.textSprite);
            }

            this.button.onInputOver.add(this.onMouseOver, this);

            if( this.data.tween ) {
                if (_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper = new TweenHelper(this.game, this);
                }
                this.tweenHelper.addTweens(this.data.tween, this.button);
                if (this.textSprite) {
                    this.tweenHelper.addTweens(this.data.tween, this.textSprite);
                }
            }
        },
        onMouseOver: function() {
           if( this.data.sfx && this.data.sfx.over ) {
               var eventData = {"text": "", "audio" : this.data.sfx.over, "priority": "sfx" };
               this.playAudio( eventData);
           }
        },
        animateButton: function() {
            if ( this.buttonIsAnimated ) {
                this.button.animations.play(this.data.image, this.animationFrameRate, this.loopAnimation, false);
            }
        },
        onPointerUp: function( event ) {

            if( this.data.audio ) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": "sfx" };
                this.playAudio( eventData);
            }

            this.button.inputEnabled = false;
            var that = this;
            setTimeout( function() {
                that.button.inputEnabled = true;
                var varSet = {};
                varSet[that.data.variable] = that.data.name;
                that.events.onGameChoice.dispatch( that.data.name, varSet );

            }, BUTTON_TIMEOUT);

        },
        destroy: function() {
            if ( this.button ) {
                if (!_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper.removeTweens(this.button);
                }
                if ( typeof this.animationTimerEvent != 'undefined' ) {
                    this.game.time.events.remove( this.animationTimerEvent );
                }
                this.button.destroy();
            }
            if( this.textSprite ) {
                if (!_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper.removeTweens(this.textSprite);
                }
                this.textSprite.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ButtonActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./tween-helper":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-character.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The character actor. This actor can be used for selecting a character (clickable with text bubble), or can be
 * used for animating a character that is talking (provide mouth animation)
 *
 * Creating a character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "character", // the required type.
 *     "image": "mandy", // the image to use from the theme.
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "text": "Mandy", // what to put in a text bubble during mouse over.
 *     "audio": "6th_01", // optional audio to speak on mouse over.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "variable": "character_2", // if you click this character, the variable 'character_2' will be set to 'mandy'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *
 * }
 *
 *  If you set speechAnimation to true, -talk will be appended to the characters image name.
 * speechAnimation/speechLocation are optional.
 *
 * See also theme.json's speechAnimations, which specify speaking-animation images and location offsets:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 *
 *  Your theme should have a 'bubbleTextWidth' entry to specify how wide to make the text bubble.
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor");

	var CharacterActor = Actor.extend({
		// constructor is now in base class!
		enterScene: function () {
			this.buildActor();
			if (this.data.text) {
				this.addTextBox();
			}
			if (this.data.speechAnimation) {
				this.addSpeechAnimation();
			}
		},
		getRequiredFields: function () {
			return ["location"];
		},
		buildActor: function () {
			var imageId = this.modelInterface.getValue(this.data.image);
			if (imageId) {
				if (this.data.speechAnimation) {
					imageId += "-talk";
				}
				this.sprite = this.game.add.sprite(
					this.data.location[0],
					this.data.location[1],
					this.theme.textureKey,
					this.getImage(imageId, "actorImages")
				);

				if (this.data.scale) {
					this.sprite.scale.setTo(this.data.scale[0], this.data.scale[1]);
				}
			} else {
				this.sprite = this.game.add.sprite(
					this.data.location[0],
					this.data.location[1]
				);
				this.sprite.width = this.data.size[0];
				this.sprite.height = this.data.size[1];
				this.addDebugBox();
			}

			if (this.data.text) {
				this.sprite.events.onInputOver.add(this.onMouseIn, this);
				this.sprite.events.onInputOut.add(this.onMouseOut, this);
			}
			if (this.data.variable) {
				this.sprite.events.onInputUp.add(this.onPointerUp, this);
			}

			if (this.data.text || this.data.variable) {
				this.sprite.inputEnabled = true;
				this.sprite.input.useHandCursor = true;
				/**
				 * This is one of the most CPU/expensive things you can do in phaser.
				 */
				this.sprite.input.pixelPerfectOver = false;
			}
		},
		addDebugBox: function () {
			if (window.isDebugging) {
				this.debugBox = new Phaser.Graphics(
					this.game,
					this.data.location[0],
					this.data.location[1]
				);
				this.debugBox.beginFill(0x000000, 1.0);
				this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
				this.debugBox.endFill();
				this.game.add.existing(this.debugBox);
			}
		},
		addTextBox: function () {
			if (!this.theme.bubbleTextWidth) {
				log.error(
					"You must specify a bubbleTextWidth in your theme when using character labels."
				);
			}
			var boxY = this.sprite.height / 4,
				boxX = this.sprite.width / 2,
				boxWidth = this.theme.bubbleTextWidth,
				font = this.getFont("bubbleIcon"),
				labelX = this.data.location[0] + boxX,
				labelY = this.data.location[1] + boxY;

			font.wordWrap = true;
			font.wordWrapWidth = boxWidth * 0.9;

			var text = new Phaser.Text(
				this.game,
				boxWidth / 2,
				10,
				this.data.text,
				font
			);
			text.anchor.setTo(0.5, 0);

			var boxHeight = text.height + 10;

			// ACT-353 If it is overlapping the edge of the screen, adjust the location.
			if (labelX + boxWidth + 3 > this.game.world.width) {
				labelX = this.game.world.width - boxWidth - 3;
			}

			if (labelY + boxHeight + 3 > this.game.world.height) {
				labelY = this.game.world.height - boxHeight - 3;
			}

			this.graphics = new Phaser.Graphics(this.game, labelX, labelY);
			this.graphics.beginFill(0x000000, 1.0);
			this.graphics.drawRoundedRect(3, 3, boxWidth, boxHeight, 9);
			this.graphics.endFill();
			this.graphics.beginFill(0xffffff);
			this.graphics.drawRoundedRect(0, 0, boxWidth, boxHeight, 9);
			this.graphics.endFill();
			this.graphics.visible = false;
			this.graphics.addChild(text);
			this.game.add.existing(this.graphics);
		},
		addSpeechAnimation: function () {
			var aSpeechAnimation =
				this.theme.speechAnimations[
					this.modelInterface.getValue(this.data.image)
				];
			if (!aSpeechAnimation) {
				log.error(
					"Could not add speech animation for character: " + this.data.name
				);
				log.error("Speech animation not found for " + this.data.image);
				log.error(
					"Check that you have a speechAnimations section in your theme."
				);
				return;
			}
			this.speechAnimation = this.game.add.sprite(
				this.data.location[0] + aSpeechAnimation.mouthOffset[0],
				this.data.location[1] + aSpeechAnimation.mouthOffset[1],
				this.theme.textureKey,
				aSpeechAnimation.images[0]
			);
			this.speechAnimation.animations.add("talk", aSpeechAnimation.images);
			this.speechAnimationSet = aSpeechAnimation.images;
			this.speechAnimationDefault = aSpeechAnimation.images[0];

			if (this.data.scale) {
				this.speechAnimation.scale.setTo(
					this.data.scale[0],
					this.data.scale[1]
				);
				this.speechAnimation.x =
					this.data.location[0] +
					aSpeechAnimation.mouthOffset[0] * this.data.scale[0];
				this.speechAnimation.y =
					this.data.location[1] +
					aSpeechAnimation.mouthOffset[1] * this.data.scale[1];
			}
		},
		onGameSpeech: function (speech) {
			var audio = this.modelInterface.getValue(speech.audio);
			if (speech.key) {
				audio = this.modelInterface.getValue(speech.key) + "_" + audio;
			}
			log.warn("On game speech: " + audio);
			if (
				this.speechAnimation &&
				this.theme.soundSyncData &&
				this.theme.soundSyncData[audio]
			) {
				this.soundSyncData = this.theme.soundSyncData[audio];
				if (!this.timer) {
					this.timer = this.game.time.create(false);
					this.speechIndex = 0;
					this.timer.loop(100, this.incrementSpeech, this);
					this.timer.start();
				}
			}
		},
		incrementSpeech: function () {
			if (this.soundSyncData) {
				this.speechIndex++;
				this.speechAnimation.frameName =
					this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
			}
		},
		onGameSpeechStop: function (speech) {
			if (this.speechAnimation && this.soundSyncData) {
				this.timer.stop();
				this.timer.destroy();
				this.timer = null;
				this.soundSyncData = null;
				this.speechAnimation.frameName = this.speechAnimationDefault;
			}
		},
		onMouseIn: function (event) {
			if (this.graphics) {
				this.graphics.visible = true;
				this.game.world.bringToTop(this.graphics);
				if (this.data.audio) {
					this.dispatchGameSpeech({
						text: this.data.text,
						audio: this.data.audio,
						key: this.data.key || this.data.name,
					});
				}
			}
		},
		onMouseOut: function (event) {
			if (this.graphics && this.graphics.visible === true) {
				this.graphics.visible = false;
			}
		},
		onPointerUp: function (event) {
			var varSet = {};
			varSet[this.data.variable] = this.data.name;
			this.dispatchGameChoice(varSet);
		},
		destroy: function () {
			if (this.sprite) {
				this.sprite.inputEnabled = false;
				this.sprite.destroy();
			}
			if (this.data.text) {
				this.graphics.destroy(true);
			}
			if (this.speechAnimation) {
				this.speechAnimation.destroy();
			}
			if (this.debugBox) {
				this.debugBox.destroy();
			}
			if (this.timer) {
				this.timer.destroy();
			}
			this.freeBaseActor();
		},
	});

	module.exports = CharacterActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-click-animation.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The click-animation actor. Will start with an image, and when clicked; will animate and then set to final image.
 * Will generate events for each
 *
 * Creating a click-animation actor, a starting, animation set, and ending image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "click-animation", // the required type.
 *     "images": "phone", // the images to use from the button section of the theme.
 *     "key": "whatevs", // optional image key
 *     "textureKey": "key", // optional text key to get animation from
 *     "location": [ x, y ],
 *     "audio": "audio", // optional audio to play during animation.
 *     "scale": [ x, y], // optional x/y scale.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "variable": "x" // variable to send out 2nd click events, will be name + "_playing" and name + "_finished"
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		Actor = require("./actor");

	var ClickAnimationActor = Actor.extend({
		// constructor in parent
		getRequiredFields: function () {
			return ["location", "images"];
		},
		enterScene: function () {
			this.buildActor();
		},
		buildActor: function () {
			this.sprite = this.game.add.sprite(
				this.data.location[0],
				this.data.location[1],
				this.getTextureKey(this.data),
				this.getImage(this.data.images, this.data.key)[0]
			);
			this.sprite.inputEnabled = true;
			/**
			 * This is one of the most CPU/expensive things you can do in phaser.
			 */
			this.sprite.input.pixelPerfectOver = false;
			this.sprite.input.useHandCursor = true;

			this.sprite.events.onInputUp.add(this.onPointerUp, this);

			this.animation = this.sprite.animations.add(
				"animation",
				this.getImage(this.data.images, this.data.key)
			);
			this.animation.onComplete.add(this.onAnimationComplete, this);

			var anchorX = 0,
				anchorY = 0;
			var x = this.data.location[0],
				y = this.data.location[1];
			this.scaleX = 1.0;
			this.scaleY = 1.0;

			if (this.data.scale) {
				this.scaleX = this.data.scale[0];
				this.scaleY = this.data.scale[1];
			}
			this.sprite.scale.setTo(this.scaleX, this.scaleY);

			if (x === "center") {
				x = this.game.world.centerX;
				anchorX = 0.5;
			}

			if (y === "center") {
				y = this.game.world.centerY;
				anchorY = 0.5;
			}

			if (this.data.anchor) {
				anchorX = this.data.anchor[0];
				anchorY = this.data.anchor[1];
			}

			this.sprite.anchor.setTo(anchorX, anchorY);
			this.sprite.x = x;
			this.sprite.y = y;
			this.animated = false;
		},
		onPointerUp: function () {
			var varSet = {};
			var suffix;
			if (this.isAnimated === true) {
				suffix = "_finished";
			} else {
				suffix = "_playing";
				varSet[this.data.variable] = this.data.name + "_playing";
				this.sprite.animations.play("animation", 10, false);
				this.isAnimated = true;
				if (this.data.audio) {
					this.playAudio({ audio: this.data.audio, key: null });
				}
			}
			varSet[this.data.variable] = this.data.name + suffix;
			this.events.onGameChoice.dispatch(this.data.name, varSet, this);
		},
		onAnimationComplete: function () {
			this.isAnimated = true;
		},
		destroy: function () {
			if (this.sprite) {
				this.sprite.destroy();
			}
			this.freeBaseActor();
		},
	});

	module.exports = ClickAnimationActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-decoration.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The decoration actor. Just an image on the screen.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1",     // a unique identifier
 *     "type": "decoration",    // the required type.
 *     "image": "phone",        // the images to use from the button section of the theme.
 *     "key": "something",      // an optional key to look under for the image.
 *     "location": [ x, y ],
 *     "scale": [ x, y],        // optional x/y scale.
 *     "angle": -30,            // optional, degrees from north (-180 to 180)
 *     "rotation": 0.5,         // optional, radians in units of PI. This overrides angle if both are set.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "alpha": 0.5 // optional alpha transparency
 *     "tween": [Object] // optional transition object
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor');

    var DecorationActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "image" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            this.sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.getTextureKey(this.data), this.getImage( this.data.image, this.data.key));
            var anchorX = 0, anchorY = 0;
            var x = this.data.location[0],
                y = this.data.location[1];

            if( this.data.scale ) {
                this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.sprite.anchor.setTo( anchorX, anchorY);
            this.sprite.x = x;
            this.sprite.y = y;

            if ( this.data.alpha ) {
                this.sprite.alpha = this.data.alpha;
            }

            if ( this.data.angle ) {
                this.sprite.angle = this.data.angle;
            }

            if ( this.data.rotation ) {
                this.sprite.rotation = Math.PI * this.data.rotation;
            }

            if( this.data.tween ) {
                var tweenData = this.data.tween;

                var delay = tweenData.delay ? tweenData.delay : 0;
                var easing = ( typeof tweenData.easing != "undefined" ) ? tweenData.easing : "Linear";

                if( tweenData.location ) {
                    this.game.add.tween(this.sprite).to( { x: tweenData.location[0], y: tweenData.location[1]  }, tweenData.time, easing, true, delay);
                }
                if( tweenData.scale ) {
                    this.game.add.tween(this.sprite.scale).to( { x: tweenData.scale[0], y: tweenData.scale[1]  }, tweenData.time, easing, true, delay);
                }
                if( !_.isUndefined(tweenData.alpha) ) {
                    this.game.add.tween(this.sprite).to( {alpha: tweenData.alpha}, tweenData.time, easing, true, delay);
                }
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = DecorationActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drag.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The drag actor. An image on the screen with optional text that can be dragged around.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drag", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "dragging" : "phone", // optional image while dragging
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "variable": "string" // name of variable to be set when this is dragging/dropped/etc.
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor");

	var DragActor = Actor.extend({
		// constructor in parent
		getRequiredFields: function () {
			return ["location", "images", "variable"];
		},
		enterScene: function () {
			this.buildActor();
		},
		buildActor: function () {
			var sprite = this.game.add.sprite(
				this.data.location[0],
				this.data.location[1],
				this.theme.textureKey,
				this.getImage(this.getFrame(), this.data.key)
			);
			this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
			sprite.body.setSize(1, 1, sprite.width / 2, sprite.height / 2);
			sprite.inputEnabled = true;
			sprite.input.pixelPerfectOver = false;
			sprite.input.enableDrag(true, true);
			sprite.input.useHandCursor = true;
			sprite.events.onDragStop.add(this.itemDragStop, this);
			sprite.events.onDragStart.add(this.itemDragStart, this);
			sprite.origLoc = [sprite.x, sprite.y];
			this.sprite = sprite;

			var fontName;
			var textX = this.sprite.width / 2;
			var textY = this.sprite.height / 2;
			var anchor = [0.5, 0.5];

			if (this.data.textData) {
				var textData = this.data.textData;
				fontName = textData.font;
				this.style = this.getFont(
					typeof fontName !== "undefined" ? fontName : "questionText"
				);

				if (textData.textX) {
					textX = textData.textX;
				}
				if (textData.textY) {
					textY = textData.textY;
				}
				if (textData.anchor) {
					anchor = textData.anchor;
				}
				this.textSprite = this.game.add.text(
					textX,
					textY,
					textData.text,
					this.style
				);
			}

			if (this.textSprite) {
				this.textSprite.anchor.setTo(anchor[0], anchor[1]);
				this.sprite.addChild(this.textSprite);
			}
		},
		returnToHome: function () {},
		itemDragStop: function () {
			this.isDragging = false;
			this.updateImage();
			var temp = {};
			temp["dropped"] = this.data.name;
			this.dispatchGameChoice(temp);
			// It will have been dropped, and possibly removed from scene.
			if (this.sprite) {
				this.sprite.x = this.sprite.origLoc[0];
				this.sprite.y = this.sprite.origLoc[1];
			}
		},
		itemDragStart: function () {
			this.isDragging = true;
			this.updateImage();
			var temp = {};
			temp["dragging"] = this.data.name;
			this.dispatchGameChoice(temp);
		},
		destroy: function () {
			if (this.sprite) {
				this.sprite.body.destroy();
				this.sprite.inputEnabled = false;
				this.sprite.events.onDragStop.removeAll();
				this.sprite.events.onDragStart.removeAll();
				this.sprite.destroy(true);
				this.sprite = null;
			}
			if (this.textSprite) {
				this.textSprite.destroy();
			}
			this.style = null;
			this.freeBaseActor();
		},
		getFrame: function (type) {
			var frameName = this.data.images.normal;
			if (type === "overlap" && this.data.images.overlap) {
				frameName = this.data.images.overlap;
			} else if (
				(type === "dragging" || !frameName) &&
				this.data.images.dragging
			) {
				frameName = this.data.images.dragging;
			}
			return frameName;
		},
		updateImage: function () {
			var frame;
			if (this.isOverlapping !== null) {
				frame = this.getFrame("overlap");
			} else if (this.isDragging === true) {
				frame = this.getFrame("dragging");
			} else {
				frame = this.getFrame("normal");
			}
			this.sprite.frameName = this.getImage(frame, this.data.key);
			this.sprite.body.setSize(
				1,
				1,
				this.sprite.width / 2,
				this.sprite.height / 2
			);
		},
		getBody: function () {
			if (this.sprite) {
				return this.sprite.body;
			}
			return null;
		},
		onOverlapping: function (otherActor) {
			if (this.isOverlapping === otherActor) {
				return;
			}
			this.isOverlapping = otherActor;
			// change to overlapping image.
			this.updateImage();
		},
	});

	module.exports = DragActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-draw.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 6/26/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The blocker actor. This actor can be used to block input events from the actors behind it.
 *
 * Creating a draw actor:
 *
 * {
 *     "name": "draw-demo", // a unique identifier
 *     "type": "draw", // the required type.
 *     "fieldLocations": [[400, 300], [500, 300]], // The target coordinates for each selectable field
 *     "fieldSize": 50, // the radius of each area
 *     "variable": "drawChooser" // The variable name for dispatched events
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

     var DrawActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [];
        },
        buildActor: function() {
            if (!this.data.fieldSize || !this.data.fieldLocations) {
                throw "Required field size or field locations not found";
            }
            this.bmd = this.game.make.bitmapData(this.game.width, this.game.height);
            this.bmd.addToWorld();
            this.addDebugBox();
            this.game.input.onDown.add(this.onMouseDown, this);
            this.game.input.onUp.add(this.onMouseUp, this);

            this.positions = [];
        },
        onMouseDown: function(pointer) {
            if (this.bmd) {
                this.bmd.clear();
            }

            this.bmd.ctx.beginPath();
            this.bmd.ctx.strokeStyle = "#005996"
            this.bmd.ctx.lineWidth = 8;
            this.bmd.ctx.moveTo(pointer.x, pointer.y);

            this.game.input.addMoveCallback(this.onDraw, this);
        },
        onDraw: function(pointer, x, y) {
            if (this.positions.length < 100) {
                this.positions.push([x, y])
            }
            this.bmd.ctx.lineTo(x, y);
            this.bmd.ctx.stroke();
        },
        onMouseUp: function() {
            this.calculateAverage();
            this.bmd.ctx.closePath();
            this.game.input.deleteMoveCallback(this.onDraw, this);
        },
        calculateAverage: function() {
            if (this.positions.length < 20) {
                return;
            }
            var aveX = 0;
            var aveY = 0;
            for (var i = 0; i < this.positions.length; i++) {
                aveX += this.positions[i][0];
                aveY += this.positions[i][1];
            }
            aveX /= this.positions.length;
            aveY /= this.positions.length;

            this.positions = [];

            this.checkTargets(aveX, aveY);
            
        },
        checkTargets: function(x, y) {
            var targets = this.data.fieldLocations;
            var range = this.data.fieldSize;
            var choice = targets.length;

            for (var i = 0; i < targets.length; i++) {
                if (y < range + targets[i][1] && 
                    targets[i][1] < y && 
                    x < 100 + targets[i][0] && 
                    targets[i][0] < x) {
                    choice = i;
                }
            }

            var varSet = {};
            varSet[this.data.variable] = choice; //This needs to determine which thing was selected
            this.dispatchGameChoice(varSet);
            this.game.time.events.add(10, function() {
                this.lastBmd = this.bmd;
                this.lastBmd.addToWorld(); 
            }, this)
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        destroy: function() {
            if ( this.bmd ) {
                this.bmd.clear();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            this.game.input.deleteMoveCallback(this.onDraw, this);
            this.game.input.onDown.remove(this.onMouseDown, this);
            this.game.input.onUp.remove(this.onMouseUp, this);
            this.freeBaseActor();
        }
    });

    module.exports = DrawActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drop.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The drop actor. You can drop drag actors onto this one, triggering it's variable and optional image stage.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drop", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "body": [ width%, height%, offsetx, offsety ], // optional body.
 *     "variable": "string" // name of variable to be set when this is dropped/etc.
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor");

	var DropActor = Actor.extend({
		// constructor in parent
		getRequiredFields: function () {
			return ["location", "images", "variable"];
		},
		enterScene: function () {
			this.buildActor();
		},
		buildActor: function () {
			var sprite = this.game.add.sprite(
				this.data.location[0],
				this.data.location[1],
				this.theme.textureKey,
				this.getImage(this.data.images.overlap, this.data.key)
			);
			this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
			var body = [
				sprite.width * 0.6,
				sprite.height * 0.6,
				sprite.width * 0.2,
				sprite.height * 0.2,
			];
			if (this.data.body) {
				body[0] = sprite.width * this.data.body[0];
				body[1] = sprite.height * this.data.body[1];
				body[2] = this.data.body[2] || body[2];
				body[3] = this.data.body[3] || body[3];
			}
			sprite.body.setSize(body[0], body[1], body[2], body[3]);
			sprite.inputEnabled = true;
			sprite.input.pixelPerfectOver = false;
			this.sprite = sprite;
			sprite.visible = false;

			var fontName;
			var textX = this.sprite.width / 2;
			var textY = this.sprite.height / 2;
			var anchor = [0.5, 0.5];

			if (this.data.textData) {
				var textData = this.data.textData;
				fontName = textData.font;
				this.style = this.getFont(
					typeof fontName !== "undefined" ? fontName : "questionText"
				);

				if (textData.textX) {
					textX = textData.textX;
				}
				if (textData.textY) {
					textY = textData.textY;
				}
				if (textData.anchor) {
					anchor = textData.anchor;
				}
				this.textSprite = this.game.add.text(
					textX,
					textY,
					textData.text,
					this.style
				);
				if (typeof this.style["lineSpacing"] !== "undefined") {
					this.textSprite.lineSpacing = this.style["lineSpacing"];
				}
			}

			if (this.textSprite) {
				this.textSprite.anchor.setTo(anchor[0], anchor[1]);
				this.sprite.addChild(this.textSprite);
			}
		},
		getFrame: function (type) {
			var frameName = null;
			if (type === "normal" && this.data.images.normal) {
				frameName = this.data.images.normal;
			} else if (type === "overlap" && this.data.images.overlap) {
				frameName = this.data.images.overlap;
			} else if (
				(type === "dragging" || !frameName) &&
				this.data.images.dragging
			) {
				frameName = this.data.images.dragging;
			}
			return frameName;
		},
		updateImage: function () {
			var frame = null;
			if (this.isOverlapping !== null) {
				frame = this.getFrame("overlap");
			} else if (this.isDragging === true) {
				frame = this.getFrame("dragging");
			} else {
				frame = this.getFrame("normal");
			}
			if (frame !== null) {
				this.sprite.visible = true;
				this.sprite.frameName = this.getImage(frame, this.data.key);
			} else {
				this.sprite.visible = false;
			}
		},
		getBody: function () {
			if (this.sprite) {
				return this.sprite.body;
			}
			return null;
		},
		onOverlapping: function (otherActor) {
			if (this.isOverlapping === otherActor) {
				return;
			}
			this.isOverlapping = otherActor;
			// change to overlapping image.
			this.updateImage();
		},
		onReceiveDrop: function (otherActorName) {
			log.warn("Received drop? " + otherActorName);
			var temp = {};
			temp[this.data.variable] = otherActorName;
			this.dispatchGameChoice(temp);
		},
		destroy: function () {
			this.isOverlapping = null;
			if (this.sprite) {
				this.sprite.body.destroy();
				this.sprite.inputEnabled = false;
				this.sprite.destroy(true);
				this.sprite = null;
			}
			if (this.textSprite) {
				this.textSprite.destroy();
			}
			this.style = null;
			this.freeBaseActor();
		},
	});

	module.exports = DropActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-fadeout.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 09/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The fadeout actor. This actor can be used to fade out the screen
 *
 * Creating a blocker actor:
 *
 * {
 *     "name": "alertBlocker", // a unique identifier
 *     "type": "fadeout", // the required type.
 *     "location": [ 0, 0 ], // optional, default is [0,0]; where on the screen to play this actor
 *     "size": [ 800, 600 ], // optional, default is [game.world.width,game.world.height] how large
 *     "color" : "0x000000", // optional, default is black (0x000000)
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "fadePeriod": 3000, //  how long to fade over.
 *     "variable": "x" // variable to set upon completion.
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

    var FadeoutActor = Actor.extend({
        // constructor is now in base class!
        enterScene: function () {
            this.buildActor();
        },
        getRequiredFields: function () {
            return ["fadePeriod", "variable"];
        },
        buildActor: function () {
            var blockerX = (typeof this.data.location === 'undefined') ? 0 : this.data.location[0];
            var blockerY = (typeof this.data.location === 'undefined') ? 0 : this.data.location[1];
            var blockerWidth = (typeof this.data.size === 'undefined') ? this.game.world.width : this.data.size[0];
            var blockerHeight = (typeof this.data.size === 'undefined') ? this.game.world.height : this.data.size[1];
            var blockerTint = (typeof this.data.blockerTint === 'undefined') ? 0x000000 : this.data.blockerTint;

            this.graphics = this.game.add.graphics(0, 0);
            this.graphics.beginFill(blockerTint);
            this.graphics.drawRect(blockerX, blockerY, blockerWidth, blockerHeight);
            this.graphics.endFill();
            this.graphics.inputEnabled = true;

            if (this.data.fadePeriod) {
                this.graphics.alpha = 0;
                this.fadeTween = this.game.add.tween(this.graphics).to({alpha: 1}, this.data.fadePeriod, 'Linear', false);
                this.fadeTween.onComplete.add(this.onComplete, this);
                this.fadeTween.start();
            }
        },
        onComplete: function () {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        destroy: function () {
            if (this.graphics) {
                this.graphics.inputEnabled = false;
                this.graphics.destroy(true);
            }
            if( this.fadeTween ) {
                this.fadeTween.stop();
                this.fadeTween = null;
            }
            this.freeBaseActor();
        }
    });

    module.exports = FadeoutActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-input-field.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 11/02/2018
 * Copyright Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This actor uses the phaser-input.js extension to add a text input field to the scene.
 *
 * {
 *     "name": "textInput1", // unique name for this actor.
 *     "type": "input-field", // required type.
 *     "location": [ x, y ],
 *     "options": {padding: 8, borderWidth: 1, borderColor: '#000'} // optional options to be passed to the InputField, refer to phaser-input.js docs for full details: https://github.com/orange-games/phaser-input
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var InputFieldActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "location" ]
        },
        enterScene: function() {
            this.location = this.data.location;
            this.options = this.data.options;

            this.buildActor();
        },
        buildActor: function () {
            this.inputField = this.game.add.inputField(
                this.location[0], this.location[1], this.options);
        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.location = null;
            this.options = null;
            this.inputField.destroy();
            this.freeBaseActor();
        }
    });

    module.exports = InputFieldActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-instruction-bubble.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An instruction bubble. This is a specialized actor for showing large font text with no speech in a fixed size
 * bubble. Normally used for the end of an activity.
 *
 *  Creating an instruction bubble actor:
 *
 * {
 *     "name": "endofactivity", // a unique identifier
 *     "type": "instruction", // the required type.
 *     "text": "Please move on to next activity", // text to show.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 8,
        marginY = 12;

    var InstructionBubbleActor = Actor.extend({
        getRequiredFields: function() {
            return [ "text", "location" ];
        },
        enterScene: function () {
            this.text = this.data.text;
            this.addWindow(this.data.location[0], this.data.location[1]);
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.instruction ) {
                throw "Instruction actor requires textWindows theme entry, and instruction area inside it.";
            }

            this.window = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.textWindows.instruction);
            this.fStyle = this.getFont('moveOn');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = this.window.width * 0.9;
            this.currentText = new Phaser.Text(this.game, this.window.width / 2, this.window.height/2, this.text, this.fStyle);
            this.currentText.anchor.setTo(0.5,0.5);
            this.window.addChild(this.currentText);
        },
        destroy: function () {
            if ( this.window ) {
                this.window.destroy(true);
            }
            this.fStyle = null;
            this.freeBaseActor();
        }
    });

    module.exports = InstructionBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-line.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/17/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the line actor, which will:
 *   - Draw a line on the screen
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01", // unique name for this actor.
 *     "type": "line", // required type.
 *     "start": [ x, y ], // or "center" for either field.
 *     "end": [ x, y ], // or "center" for either field.
 *     "color": "rgba(0,0,0,1)", // optional, default is black
 *     "width": "5", // optional, default is 1
 *     "alpha": "0.5", // optional, default is 1.0
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var LineActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "start", "end"]
        },
        enterScene: function() {
            this.startLoc = this.data.start;
            this.endLoc = this.data.end;

            this.buildActor();
        },
        buildActor: function () {
            this.graphics = this.game.add.graphics( 0,0);
            var color = 0xFF3300;
            var width = 20;
            var alpha = 1;

            if( this.data.color ) {
                color = this.data.color;
            }

            if( this.data.width ) {
                width = parseInt(this.data.width, 10);
            }

            if( this.data.alpha ) {
                alpha = parseFloat(this.data.alpha);
            }

            this.graphics.lineStyle(width, color, alpha);
            this.graphics.moveTo(this.startLoc[0], this.startLoc[1]);
            this.graphics.lineTo(this.endLoc[0], this.endLoc[1]);

        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.startLoc = null;
            this.endLoc = null;
            this.graphics.destroy();
            this.freeBaseActor();
        }
    });

    module.exports = LineActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-no-input-character.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 04/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The no-input-character actor. This actor cannot be interacted with. It speaks when it's audio bit is played, but is otherwise a decoration.
 * Creating a no-input-character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "character", // the required type.
 *     "image": "mandy", // the image to use from the theme.
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "frameRate": 24 // optional frame rate for the speech animation, defaults to 10.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "audio": "6th_01", // optional audio to speak on mouse over.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  If you set speechAnimation to true, -talk will be appended to the characters image name.
 * speechAnimation/speechLocation are optional.
 *
 * See also theme.json's speechAnimations, which specify speaking-animation images and location offsets:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 * 
 * There must additionally be "Sound Sync Data", defining which image to show...
 *
 * "soundSyncData": {
 *   "6th_01": [
 *     0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1
 *   ], ...
 * }
 *
 *  The 0s and 1s represent which image, and could be 0,1,2,3 etc if there are more than 2. The key should match
 *  the "speechAudio" of this actor as well as the audio being played. 
 *  NOTE: Most of the speechSyncData does not contain '1's and looks like [0,0,2,3,3,3,2,0,2,3,2,0,0,0,2,3,4,4,3,4,2,0].
 *  In this case it is advised to use the [A, B, B, C, D] pattern for the different frames in your theme.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

     var NoInputCharacterActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            if( this.data.speechAnimation ) {
                this.addSpeechAnimation();
            }
        },
        getRequiredFields: function() {
            return [ "location" ];
        },
        buildActor: function() {
            var imageId = this.data.image;
            if( imageId ) {
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1], this.theme.textureKey,
                    this.getImage(imageId, 'actorImages'));
                
                if( this.data.scale ) {
                    this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
                }
            } else {
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1]);
                this.sprite.width = this.data.size[0];
                this.sprite.height = this.data.size[1];
                this.addDebugBox();
            }
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        addSpeechAnimation: function() {
            var aSpeechAnimation = this.theme.speechAnimations[this.modelInterface.getValue(this.data.image)];
            if( !aSpeechAnimation ) {
                log.error("Could not add speech animation for character: " + this.data.name);
                log.error("Speech animation not found for " + this.data.image );
                log.error("Check that you have a speechAnimations section in your theme.");
                return;
            }
            this.speechAnimation = this.game.add.sprite(
                this.data.location[0] + aSpeechAnimation.mouthOffset[0],
                this.data.location[1] + aSpeechAnimation.mouthOffset[1],
                this.theme.textureKey,
                aSpeechAnimation.images[0]);
            this.speechAnimation.animations.add('talk', aSpeechAnimation.images);
            this.speechAnimationSet = aSpeechAnimation.images;
            this.speechAnimationDefault = aSpeechAnimation.images[0];
            if (this.data.flipMouth && this.data.scale) {
                this.speechAnimation.scale.setTo( this.data.scale[0] * -1, this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            } else if( this.data.scale ) {
                this.speechAnimation.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            }
        },
        onGameSpeech: function (speech) {
            var audio = this.modelInterface.getValue(speech.audio);
            if( speech.key ) {
                audio = this.modelInterface.getValue(speech.key) + "_" + audio;
            }
            log.warn("On game speech: " + audio);
            if( this.speechAnimation && this.theme.soundSyncData && this.theme.soundSyncData[audio] && this.data.speechAudio === audio ) {
                this.soundSyncData = this.theme.soundSyncData[audio];
                if( ! this.timer ) {
                    var FRAME_RATE = this.data.frameRate ? this.data.frameRate : 10;
                    this.timer = this.game.time.create(false);
                    this.speechIndex = 0;
                    this.timer.loop(1000 / FRAME_RATE, this.incrementSpeech, this);
                    this.timer.start();
                }
            }
        },
        incrementSpeech: function() {
            if( this.soundSyncData ) {
                this.speechIndex++;
                this.speechAnimation.frameName = this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
            }
        },
        onGameSpeechStop: function (speech) {
            if( this.speechAnimation && this.soundSyncData) {
                this.timer.stop();
                this.timer.destroy();
                this.timer = null;
                this.soundSyncData = null;
                this.speechAnimation.frameName = this.speechAnimationDefault;
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.inputEnabled = false;
                this.sprite.destroy();
            }
            if( this.data.text ) {
                this.graphics.destroy(true);
            }
            if( this.speechAnimation ) {
                this.speechAnimation.destroy();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            if( this.timer ) {
                this.timer.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = NoInputCharacterActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-question.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/05/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the question actor, which will:
 *   - show the player a (single selection/radio) multiple choice question
 *   - play any audio/text associated with asking question
 *
 * {
 *     "name": "questions_snitchingOrTelling_01",      // unique name for this actor.
 *     "type": "question", // required type.
 *     "font": "questionText",
 *     "submitButtonImage": "submit",                  // button image from theme.buttons
 *     "submitButtonID": "snitOrTellSubmitButton",     // to identify the text event coming from it
 *     "submitButtonLocation": [ 546, 255 ],
 *     "location": [ 90, 35 ],
 *     "startQuestion": "snitOrTell_question_01",      // which choice to start with from the choiceMap set.
 *     "choiceMap": {
 *       "snitOrTell_question_01": { // this is the name of this question, used when linking questions
 *          "text": (optional) "Shandra stumbled upon some pretty nasty comments online about Brianna. They were calling her a slut, among other things. Shandra decides to mention it to her mom.[br][br]Is this snitching or telling?" // question
 *          "audio": (optional) "snitchingOrTelling_question_01", // audio key.
 *          "key": (optional) "mandy", // a prefix for the audio key. (becomes "mandy_snitchingOrTelling_question_01" in this example)
 *          "choices": [
 *            {
 *               "text": "Snitching",                  // displayed text of this choice.
 *               "variable": "snitOrTell_question_01", // variable to set when chosen
 *               "value": "incorrect"                  // value to set variable to when chosen
 *            },
 *            {
 *               "text": "Telling",                    // displayed text of this choice.
 *               "variable": "snitOrTell_question_01", // variable to set when chosen
 *               "value": "correct"                    // value to set variable to when chosen
 *            }
 *            ... // as many choices as you want.
 *         ]
 *       },
 *     },
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 *  For a decision point, you can stll do a variable/value and link.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var QuestionActor = Actor.extend({
        constructor: function (game, data, theme) {
            if (!game) {
                throw "Decoration actor requires game constructor argument.";
            }
            if (!data) {
                throw "Decoration actor requires data constructor argument.";
            }

            this.game = game;
            this.theme = theme;
            this.data = data;
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal()
            };
            this.choiceMap = this.data.choiceMap;
            this.currentQuestionName = this.data.startQuestion;
            this.currentQuestion = this.choiceMap[this.currentQuestionName];
            this.marginY = 6;

            var fontName = this.data.font;
            this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

            this.location = this.data.location;

            this.radioGroup = this.game.add.group();
            this.radioTextGroup = this.game.add.group();

            // Track where we are at moving down the screen.
            this.currentX = (this.location !== 'undefined') ?
                this.location[0] : this.theme.snitchingOrTellingleftMargin * 3;
            this.currentY = (this.location !== 'undefined') ? this.location[1] : 35;
        },
        enterScene: function() {
            // Determine the number of questions and build the correct choice list.
            this.determineChoiceList();
            this.buildActor();
            this.populateChoices();
        },
        determineChoiceList: function() {
        },
        buildActor: function () {
            if (typeof this.currentQuestion.text !== 'undefined') {
                this.questionText = this.game.add.text(this.currentX, this.currentY,
                    this.currentQuestion.text, this.style);
                this.currentY += (this.questionText.height + this.marginY);
            }

            if( !this.data.submitButtonImage || !this.data.submitButtonID || !this.data.submitButtonLocation) {
                throw "Question Actor requires submit button configuration in scene data";
            }
            if( !this.theme.buttons || !this.theme.buttons[this.data.submitButtonImage]) {
                throw "Question Actor requires a submit button entry in theme";
            }

            this.submitButton = this.game.add.button( this.data.submitButtonLocation[0], this.data.submitButtonLocation[1],
                this.theme.textureKey, this.onSubmitButtonPointerUp, this,
                this.theme.buttons[this.data.submitButtonImage].over, this.theme.buttons[this.data.submitButtonImage].out,
                this.theme.buttons[this.data.submitButtonImage].down, this.theme.buttons[this.data.submitButtonImage].up);
            this.submitButton.inputEnabled = false;
        },
        populateChoices: function () {
            var question = (this.currentQuestion);

            // Build a list of options.
            var startY = this.currentY,
                currRadioButton,
                currText,
                optionIndex = 0;

            var choices = question.choices;
            _.each(choices, function (choice) {
                currRadioButton = this.radioGroup.create(0, 0,
                    this.theme.textureKey, this.theme.buttons.radioButtonGroup.unselected);
                currRadioButton.inputEnabled = true;
                currRadioButton.events.onInputDown.add(this.onChooseOption, this);
                currRadioButton.group = this.radioGroup;
                currRadioButton.x = this.theme.snitchingOrTellingleftMargin * 3;
                currRadioButton.y = this.currentY + 2;
                currRadioButton.frameName = this.theme.buttons.radioButtonGroup.unselected;
                currRadioButton.variable = choice.variable;
                currRadioButton.value = choice.value;
                currRadioButton.scale.set(0.75 , 0.75 );

                currText = new Phaser.Text(this.game, this.theme.snitchingOrTellingleftMargin * 4, 0,
                    choice.text, this.style);
                this.radioTextGroup.add(currText);
                currText.y = this.currentY;
                currText.inputEnabled = true;
                currText.events.onInputDown.add(this.onChooseOption, this);
                currText.group = this.radioTextGroup;
                currText.variable = choice.variable;
                currText.value = choice.value;
                currText.radioButton = currRadioButton; // link the text and radio button together.
                currRadioButton.optionText = currText;
                this.currentY += currRadioButton.optionText.height;
                optionIndex++;
            }, this);

            if( question.text || question.audio ) {
                var eventData = {"text": question.text, "audio": question.audio, "key": question.key};
                this.playAudio( eventData);
            }
        },
        onChooseOption: function (selectedInput) {
            // Adjust the other radio buttons.
            if( selectedInput.radioButton ) {
                selectedInput.radioButton.group.setAll('frameName', this.theme.buttons.radioButtonGroup.unselected);
                selectedInput.radioButton.frameName = this.theme.buttons.radioButtonGroup.selected;
            } else {
                selectedInput.group.setAll('frameName', this.theme.buttons.radioButtonGroup.unselected);
                selectedInput.frameName = this.theme.buttons.radioButtonGroup.selected;
            }
            // Save the whether the selected answer is correct.
            var varSet = {};
            varSet[selectedInput.variable] = selectedInput.value;

            this.events.onGameChoice.dispatch( this.data.name, varSet );

            this.lastResponseValue = selectedInput.value;
            this.submitButton.inputEnabled = true;
        },
        onSubmitButtonPointerUp: function( event ) {
            var eventData = {"text": this.lastResponseValue };
            this.playAudio(  eventData);
        },
        destroy: function () {
            if (this.radioGroup) {
                this.radioGroup.forEachExists(function (radio) {
                    if (radio.optionText) {
                        radio.optionText = null;
                    }
                    radio.destroy();
                },this);
                this.radioGroup.destroy();
            }
            if( this.radioTextGroup ) {
                this.radioTextGroup.forEachExists(function (radioText) {
                    if (radioText.radioButton) {
                        radioText.radioButton = null;
                    }
                    radioText.destroy();
                },this);
                this.radioTextGroup.destroy();
            }
            if ( this.submitButton ) {
                this.submitButton.destroy();
            }
            if ( this.questionText ) {
                this.questionText.destroy();
            }
            this.events.onGameChoice.dispose();
            this.events.onGameSpeech.dispose();
            this.events.length = 0;
        }
    });

    module.exports = QuestionActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-rectangle.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/19/2017
 * Copyright Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the rectangle actor, which will:
 *   - Draw a rectangle on the screen, with optional border.
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01", // unique name for this actor.
 *     "type": "rectangle", // required type.
 *     "start": [ x, y ],
 *     "color": "rgba(0,0,0,1)", // optional, default is black
 *     "width": "5", // optional, default is 1
 *     "height": "5", // optional, default is 1
 *     "alpha": "0.5", // optional, default is 1.0
 *     "border" : "1", // optional, thickness of border (none of not provided)
 *     "borderColor": "rbga(0,0,0,1)", // optional, default is black
 *     "roundness": "28", // default 28
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var RectangleActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "start"]
        },
        enterScene: function() {
            this.startLoc = this.data.start;
            this.endLoc = this.data.end;

            this.buildActor();
        },
        buildActor: function () {
            this.graphics = this.game.add.graphics( 0,0);
            var color = 0xFF3300, borderColor = 0xFF3300;
            var alpha = 1;
            var roundness = 28;
            var width = 440, height = 200;
            var x = this.startLoc[0], y = this.startLoc[1];
            var border = 0;

            this.rectangle = this.game.add.group();

            if( this.data.color ) {
                color = this.data.color;
            }

            if( this.data.borderColor ) {
                borderColor = this.data.borderColor;
            }

            if( this.data.width ) {
                width = parseInt(this.data.width, 10);
            }

            if( this.data.height ) {
                height = parseInt(this.data.height, 10);
            }

            if( this.data.roundness ) {
                roundness = parseInt(this.data.roundness, 10);
            }

            if( this.data.alpha ) {
                alpha = parseFloat(this.data.alpha);
            }

            if( this.data.border ) {
                border = parseInt(this.data.border, 10);
            }

            this.graphics.beginFill(color);
            this.graphics.drawRoundedRect(x, y, width, height, roundness); // draw a rounded rect mask
            this.graphics.endFill();
            if( border && border > 0 ) {
                this.graphics.lineStyle( border, borderColor, 1);
                this.graphics.drawRoundedRect(x, y, width, height, roundness);
            }
            this.graphics.alpha = alpha;

        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.startLoc = null;
            this.endLoc = null;
            if(this.graphics){
                this.graphics.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = RectangleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-speech-bubble.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble. It displays text and requests that audio be played. A speech bubble can have its own text/audio
 * and can also listen for text/audio events to show.
 * The speech bubble will adjust its size to fit the provided/set text.
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "speech-bubble",
 *    "text": "", // text to show.
 *    "audio": "", // audio key to play.
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 12, marginY = 12;

    var SpeechBubbleActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return []; // No required fields.
        },
        enterScene: function () {
            this.text = this.data.text || " ";
            this.audio = this.data.audio || "";
            this.key = this.data.key;

            this.addWindow(200, 50);
            this.setSpeech();
            // ACT-352 Hide empty speech bubbles.
            if( this.data.hidden || !this.text || this.text === " " ) {
                this.windowGroup.visible = false;
            }
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.small ) {
                throw "Instruction actor requires textWindows theme entry, and small definition inside it.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.small.top);

            this.fStyle = this.getFont('bubbleText');
            this.rStyle = this.getFont('replayAudio');

            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * 0.85;

            this.currentText = new Phaser.Text(this.game, marginX, marginY, " ", this.fStyle);
            windowGroup.add(this.currentText);

            var bottomWindow = windowGroup.create(0, 0 , this.theme.textureKey, this.theme.textWindows.small.bottom);

            // subtract 30 because the top speech bubble is 40 px tall.
            var middleWindow = new Phaser.TileSprite(this.game, 0, topWindow.height,
                338, this.currentText.height - 30, this.theme.textureKey, this.theme.textWindows.small.middle);
            windowGroup.add(middleWindow);

            bottomWindow.y = topWindow.height + middleWindow.height;

            // 5. Add eventing.
            this.windows = {
                top: topWindow,
                middle: middleWindow,
                bottom: bottomWindow
            };

            _.each(this.windows, function (bubble) {
                bubble.inputEnabled = true;
                bubble.events.onInputOver.add(this.onMouseIn, this);
                bubble.events.onInputOut.add(this.onMouseOut, this);
                bubble.events.onInputUp.add(this.onPointerUp, this);
            }, this);


            this.replayText = new Phaser.Text(this.game, (bottomWindow.x + bottomWindow.width - 40) / 2,
                (topWindow.height + bottomWindow.height + middleWindow.height) / 2, "Replay Audio", this.rStyle);
            this.replayText.anchor.setTo(0.5,0.5);
            windowGroup.add(this.replayText);
            this.replayText.visible = false;

            this.currentText.bringToTop();
            this.replayText.bringToTop();
            this.windowGroup = windowGroup;
            windowGroup.x -= topWindow.width / 2;
        },
        resize: function() {
            // subtract 30 because the top speech bubble is 40 px tall.
            this.windows.middle.height = this.currentText.height - 30;
            this.windows.bottom.y = this.windows.top.height + this.windows.middle.height;
        },
        onMouseIn: function () {
            this.fStyle.fill = this.theme.tints.bubbleText;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = true;
        },
        onMouseOut: function () {
            this.fStyle.fill = this.getFont('bubbleText').fill;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = false;
        },
        onPointerUp: function () {
            this.playAudio(  {text: this.text, audio: this.audio, key: this.key});
        },
        setSpeech: function () {
            var text = this.substituteText(this.getText(this.text, this.key));
            this.currentText.setText( text );
            this.playAudio( {text: text, audio: this.audio, key: this.key});
            this.resize();
        },
        onGameSpeech: function (speech) {
            //log.warn("speech bubble received");
            //log.warn(speech);
            this.text = speech.text;
            this.key = speech.key;
            this.audio = speech.audio;
            this.currentText.setText( this.substituteText(this.getText(this.text, this.key)) );
            this.resize();
            // ACT-352 Hide empty speech bubbles, here, show it if there is text.
            if(  this.text && this.text !== " " ) {
                this.windowGroup.visible = true;
            }
        },
        destroy: function () {
            this.rStyle = null;
            this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;
            this.currentText = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = SpeechBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text-bubble.js":[function(require,module,exports){
/**
 * @author Jeff Blume
 * @version 1.0.0
 * @creation 07/24/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble that only displays text and a bubble behind it. Allows for movable carrot. Auto adjusts to text size.
 * NOTE: NEEDS DEFAULT PARAMETER VALUES AND/OR REQUIREMENT CHECKING AND ERROR HANDLING
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "text-bubble",
 *    "carrotSide": "bottom", // "top", "bottom", "left" or "right" - side of bubble the carrot is to be positioned
 *    "location": [0,0],
 *    "carrotPosition": 0.5, // location, as percentage of length or width of carrotSide
 *    "centerFill": "0xffffff",
 *    "text": "", // text to show.
 *    "bubbleWidth": 200,
 *    "textPadding": 20, // Padding between bubble and text
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 12, marginY = 12;

    var TextBubbleActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return []; // No required fields.
        },
        enterScene: function () {
            this.carrotSide = this.data.carrotSide;
            this.location = this.data.location;
            this.carrotPosition = this.data.carrotPosition;
            this.centerFill = this.data.centerFill;
            this.text = this.data.text;
            this.bubbleWidth = this.data.bubbleWidth
            this.textPadding = this.data.textPadding;
            this.hidden = this.data.hidden;
            this.startDelay = this.data.startDelay;


            this.addWindow(this.location[0], this.location[1]);
            //this.setSpeech();
            // ACT-352 Hide empty speech bubbles.
            if( this.data.hidden ) {
                this.windowGroup.visible = false;
            }
        },
        addWindow: function (x, y) {
            if( !this.theme.textBubbleImages ) {
                throw "Instruction actor requires textBubbleImages theme entry.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var bubbleTopLeft = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textBubbleImages.topLeft);
            var bubbleTop = windowGroup.create(bubbleTopLeft.width, 0, this.theme.textureKey, this.theme.textBubbleImages.top);
            var bubbleTopRight = windowGroup.create(bubbleTopLeft.width + bubbleTop.width, 0, this.theme.textureKey, this.theme.textBubbleImages.topRight);
            var bubbleRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height, this.theme.textureKey, this.theme.textBubbleImages.right);
            var bubbleBottomRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height + bubbleRight.height, this.theme.textureKey, this.theme.textBubbleImages.bottomRight);
            var bubbleBottom = windowGroup.create(bubbleTop.x, bubbleBottomRight.y, this.theme.textureKey, this.theme.textBubbleImages.bottom);
            var bubbleBottomLeft = windowGroup.create(0, bubbleBottomRight.y, this.theme.textureKey, this.theme.textBubbleImages.bottomLeft);
            var bubbleLeft = windowGroup.create(0, bubbleTopLeft.height, this.theme.textureKey, this.theme.textBubbleImages.left);
            var bubbleCenter = this.game.add.graphics(bubbleTopLeft.width, bubbleTopLeft.height, windowGroup);

            this.fStyle = this.getFont('textBubbleText');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = this.bubbleWidth - (this.textPadding * 2);

            this.currentText = new Phaser.Text(this.game, this.textPadding, this.textPadding, this.text, this.fStyle);
            windowGroup.add(this.currentText);

            var bubbleTopWidth = this.bubbleWidth - bubbleTopLeft.width - bubbleTopRight.width;
            var tops = Math.ceil(bubbleTopWidth / bubbleTop.width);
            var topRemainder = bubbleTopWidth % bubbleTop.width;
            for (var i = 1; i < tops; i++) {
                var thisTop = windowGroup.create(bubbleTopLeft.width + (i * bubbleTop.width), 0, this.theme.textureKey, this.theme.textBubbleImages.top);
            }
            if(topRemainder !== 0){
                thisTop.x -= bubbleTop.width - topRemainder;
            }

            bubbleTopRight.x = this.bubbleWidth - bubbleTopRight.width;
            bubbleRight.x = bubbleBottomRight.x = bubbleTopRight.x;
            var bubbleRightHeight = this.currentText.height + (2 * this.textPadding) - bubbleTop.height - bubbleBottom.height;
            var rights = Math.ceil(bubbleRightHeight / bubbleRight.height);
            var rightRemainder = bubbleRightHeight % bubbleRight.height;
            for (i = 1; i < rights; i++) {
                var thisRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height + (bubbleRight.height * i), this.theme.textureKey, this.theme.textBubbleImages.right);
            }
            if(rightRemainder !== 0){
                thisRight.y -= bubbleRight.height - rightRemainder;
            }


            bubbleBottomRight.y = bubbleTopRight.height + bubbleRightHeight;
            bubbleBottom.y = bubbleBottomRight.y;
            for (i = 1; i < tops; i++) {
                var thisBottom = windowGroup.create(bubbleTopLeft.width + (i * bubbleTop.width), bubbleBottom.y, this.theme.textureKey, this.theme.textBubbleImages.bottom);
            }
            if(topRemainder !== 0){
                thisBottom.x -= bubbleTop.width - topRemainder;
            }


            bubbleBottomLeft.y = bubbleBottomRight.y;
            for (i = 1; i < rights; i++) {
                var thisLeft = windowGroup.create(0, bubbleTopRight.height + (bubbleRight.height * i), this.theme.textureKey, this.theme.textBubbleImages.left);
            }
            if(rightRemainder !== 0){
                thisLeft.y -= bubbleRight.height - rightRemainder;
            }

            var carrot = null;
            switch(this.carrotSide){
                case "top":
                    carrot = windowGroup.create(this.bubbleWidth * this.carrotPosition, this.theme.textBubbleImages.carrotOverlap, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.scale.y = -1;
                    carrot.anchor.x = 0.5;
                    break;
                case "right":
                    carrot = windowGroup.create(this.bubbleWidth - this.theme.textBubbleImages.carrotOverlap, (bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height) * this.carrotPosition, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    carrot.rotation = -90 * (Math.PI/180);
                    break;
                case "bottom":
                    carrot = windowGroup.create(this.bubbleWidth * this.carrotPosition, bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height - this.theme.textBubbleImages.carrotOverlap, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    break;
                case "left":
                    carrot = windowGroup.create(this.theme.textBubbleImages.carrotOverlap, (bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height) * this.carrotPosition, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    carrot.rotation = 90 * (Math.PI/180);
                    break;
            }

            bubbleCenter.beginFill(this.centerFill);
            bubbleCenter.drawRect(0, 0, bubbleTopWidth, bubbleRightHeight);
            bubbleCenter.endFill();

            windowGroup.bringToTop(this.currentText);
            this.windowGroup = windowGroup;
        },
        destroy: function () {
            this.rStyle = null;
            /*this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;*/
            this.currentText = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = TextBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the text actor, which will:
 *   - show the specified text
 *   - play any audio/text associated with the text
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01",    // unique name for this actor.
 *     "type": "text",                              // required type.
 *     "text": "Correct. Click the Next button to find out why."
 *     "font": "questionText",
 *     "location": [ x, y ],    // or "center" for either field.
 *     "angle": -30,            // optional, degrees from north (-180 to 180)
 *     "rotation": 0.5,         // optional, radians in units of PI. This overrides angle if both are set.
 *     "anchor": (optional) "left",     // which side to anchor the text sprite. Can also set anchor to specific position [x,y]
 *     "audio": (optional) "snitchingOrTelling_feedback_01",    // audio key.
 *     "key": (optional) "mandy", // a prefix for the audio key. (becomes "mandy_snitchingOrTelling_feedback_01" in this example),
 *     "wordWrapWidth": #,  // optionally set a wrapping width
 *     "bullet": true,
 *     "bulletOffset": 3, // optional, space in pixels after bullet if you want other than default spacing
 *     "shadowX": 5, // optional, drop shadow width in pixels; default is no shadow - same as shadowY if only one is specified - 5 if only color is specified
 *     "shadowY": 5, // optional, drop shadow height in pixels; default is no shadow - same as shadowX if only one is specified - 5 if only color is specified
 *     "shadowColor": "rgba(0,0,0,1)", // optional, default is black with alpha 1.0
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "tween": {                      // optional, tween to be applied to the text
 *       "time": 300,                  // (required for tween) duration of the tween
 *       "location": [ 190, 150 ],     // (required for tween) location to tween to, required
 *       "delay": 10000,               // (optional for tween) delay in milliseconds before tweening
 *       "yoyo": true                  // (optional for tween) return to original position after tween?
 *       "align": "left"               // optional, align value that will override the style setting in the theme (added by Jeff Blume 12.17.2019)
 *     }
 *  }
 *
 *  Note that this actor recognizes optional properties in the font style:
 *
 *      "lineSpacing" (a number of pixels to add to the normal wrapped text line spacing). For example, to reduce line spacing by 15 pixels:
 *
 *          "lesson_light": { "font": "35px flashdligregular", "wordWrap": true, "wordWrapWidth": 200, "lineSpacing": -15 }
 *
 *     "alpha" (opacity, a number between 0 and 1)
 *
 *          "lesson_light": { "font": "35px flashdligregular", "alpha": 0.5 }
 *
 *     "shadowX": (include a drop shadow with this width, in pixels) This will be set to the value in shadowY if only
 *          one is specified, or set to 5 pixels if only shadowColor is specified.
 *     "shadowY": (include a drop shadow with this height, in pixels) This will be set to the value in shadowX if only
 *          one is specified, or set to 5 pixels if only shadowColor is specified.
 *     "shadowColor": (include a drop shadow with this color and alpha value) If shadowX and/or shadowY are specified
 *          but shadowColor is not specified, default is black with alpha 1.0
 *     "shadowBlur": (gaussian blur to soften shadow) optional, A number from 0 (no blur) up to approximately
 *          10 (depending on scene).
 *
 *     For example, to specify an 8-pixel wide and 3-pixel high blurred drop shadow in red:
 *
 *          "lesson_redShadow": { "font": "35px flashdligregular", "shadowX": 8, "shadowY": 3, "shadowColor": "rgba(255,0,0,1)", "shadowBlur": 5 }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var TextActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "font", "text" ]
        },
        enterScene: function() {
            this.text = this.data.text;
            this.location = this.data.location;
            this.audio = this.data.audio;
            this.key = this.data.key;

            var fontName = this.data.font;
            this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

            if( this.data.wordWrapWidth ) {
                this.style.wordWrap = true;
                this.style.wordWrapWidth = parseInt(this.data.wordWrapWidth, 10);
            }

            if(this.data.align){
                this.style.align = this.data.align;
            }

            this.buildActor();
        },
        buildActor: function () {
            
            this.text = this.substituteText(this.text); 

            var x = this.location[0],
                y = this.location[1],
                anchorX = 0,
                anchorY = 0;

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if (this.data.anchor === "left") {
              anchorX = 0;
            } 
            else if (this.data.anchor === "center") {
              anchorX = 0.5;
            } 
            else if (this.data.anchor === "right") {
              anchorX = 1;
            }
            else if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.bulletX = x;
            if( this.data.bullet ) {
                var useBulletOffset = ((typeof (this.data.bulletOffset)) !== 'undefined');
                var bulletText = useBulletOffset ? "" : " ";
                var bulletOffsetWidth = 0; //initialize width from bullet to text
                if(useBulletOffset){
                    bulletOffsetWidth = this.data.bulletOffset; //sets bulletOffset from theme.json
                }
                var anchorFactor = anchorX; 
                
                if(anchorX === 0.5)
                {
                    //for centered text only
                    this.textSprite = this.game.make.text(x, y, this.text, this.style);
                    this.bulletSprite = this.game.make.text(x, y,bulletText, this.style);  
                    var alignmentAdjustment = ((this.bulletSprite.width + bulletOffsetWidth + this.textSprite.width)/2); // length to center
                    this.bulletSprite.destroy();
                    this.bulletSprite = this.game.add.text(x - alignmentAdjustment, y, bulletText, this.style); 
                    var calculatedTextX = x - (this.bulletSprite.position.x - (this.bulletSprite.width /2)); // get x position of text
                    this.textSprite.destroy();
                    this.textSprite = this.bulletSprite.addChild(this.game.make.text(calculatedTextX , y - this.bulletY, this.text, this.style));
                }
                else
                {
                    //for left OR right aligned text
                    this.bulletSprite = this.game.add.text(x  + bulletOffsetWidth, y, bulletText, this.style);
                    this.textSprite = this.bulletSprite.addChild(this.game.make.text(this.bulletSprite.width, y - this.bulletY, this.text, this.style));
                }
            }
            else
            {
                this.textSprite = this.game.add.text(x, y, this.text, this.style);
            }

            this.textX = x;

            if ( (typeof (this.style.lineSpacing)) !== 'undefined' ) {
                this.textSprite.lineSpacing = this.style.lineSpacing;
            }

            if ( (typeof (this.style.alpha)) !== 'undefined' ) {
                this.textSprite.alpha = this.style.alpha;
            }

            var hasX = (( typeof (this.style.shadowX)) !== undefined );
            var hasY = (( typeof (this.style.shadowY)) !== undefined );
            var hasColor = (( typeof (this.style.shadowColor)) !== undefined );
            var hasBlur = (( typeof (this.style.shadowBlur)) !== undefined );
            if ( hasX || hasY || hasColor || hasBlur ) {
                var shadowX = 5;
                var shadowY = 5;
                if ( hasX ) {
                    shadowX = this.style.shadowX;
                    if ( !hasY ) {
                        shadowY = shadowX;
                    }
                }
                if ( hasY ) {
                    shadowY = this.style.shadowY;
                    if ( !hasX ) {
                        shadowX = shadowY;
                    }
                }
                var shadowColor = "rgba(0,0,0,1)";
                if ( hasColor ) {
                    shadowColor = this.style.shadowColor;
                }
                var shadowBlur = 0;
                if ( hasBlur ) {
                    shadowBlur = this.style.shadowBlur;
                }
                this.textSprite.setShadow( shadowX, shadowY, shadowColor, shadowBlur );
            }
            this.textSprite.anchor.setTo( anchorX, anchorY );

            if( this.data.scale ) {
                this.textSprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if( this.audio ) {
                var eventData = {"audio": this.audio, "key": this.key};
                this.playAudio( eventData);
            }

            if ( this.data.angle ) {
                if (this.bulletSprite) {
                    this.bulletSprite.angle = this.data.angle;
                }
                else {
                    this.textSprite.angle = this.data.angle;
                }
            }
            

            if ( this.data.rotation ) {
                if (this.bulletSprite) {
                    this.bulletSprite.rotation = Math.PI * this.data.rotation;
                }
                else {
                    this.textSprite.rotation = Math.PI * this.data.rotation;
                }
            }
            

            if( this.data.tween ) {
                var tweenData = this.data.tween;

                var textOffset = this.textX - this.bulletX;
                var yoyo = ( typeof tweenData.yoyo != "undefined" ) ? tweenData.yoyo : false;
                var delay = ( typeof tweenData.delay != "undefined" ) ? tweenData.delay : 0;
                var easing = ( typeof tweenData.easing != "undefined" ) ? tweenData.easing : "Linear";

                if( tweenData.location ) {
                    if( this.data.bullet ) {
                        this.game.add.tween(this.bulletSprite).to( { x: tweenData.location[0], y: tweenData.location[1]  },
                            tweenData.time, easing, true, delay, 0, yoyo);
                    }else{
                        this.game.add.tween(this.textSprite).to( { x: (tweenData.location[0] + textOffset), y: tweenData.location[1]  },
                        tweenData.time, easing, true, delay, 0, yoyo);
                    }
                }

                if( tweenData.scale ) {
                    this.game.add.tween(this.textSprite.scale).to( { x: tweenData.scale[0], y: tweenData.scale[1]  }, tweenData.time, easing, true, delay);
                }

                if( !_.isUndefined(tweenData.alpha) ) {
                    this.game.add.tween(this.textSprite).to( { alpha: tweenData.alpha }, tweenData.time, easing, true, delay);
                }
            }
        },
        onGameSpeech: function( choice ) {
            if( choice && choice.text ) {
                this.textSprite.setText(choice.text);
            }
        },
        destroy: function () {
            if ( this.textSprite ) {
                this.textSprite.destroy();
            }
            if( this.bulletSprite ) {
                this.bulletSprite.destroy();
            }
            if( this.audio ) {
                var eventData = { "audio": this.audio, "key": this.key, "priority": "stop"};
                this.playAudio(  eventData);
            }
            this.location = null;
            this.freeBaseActor();
        }
    });

    module.exports = TextActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-timeline.js":[function(require,module,exports){
/**
 * @author David Lee
 * @version 1.0.0
 * @creation 04/04/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 * A timeline actor that updates a variable after a given period (in ms) has elapsed. 
 * This actor has no visible rendered component.
 * It does *NOT* remove itself once the variable has been set; this is left to the scripter if that behavior is desired.
 * 
 * Creating a Timeline actor:
 * {
 *      "name": "event1",               // A unique name for the actor
 *      "type": "timeline",             // Required type
 *      "period": 1000,                 // Number of miliseconds to wait before 
 *      "variable": "timeline_event"    // After the given period has elapsed, update this variable with the name of this actor
 *
 *      "startDelay": 0                 // I *STRONGLY* recommend against using this value, but if you do, remember the event will not fire until period + startDelay ms have elapsed since the actor was added to the scene.
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');


    var TimelineActor = Actor.extend({
        // constructor in parent.

        getRequiredFields: function() {
            return [ "period", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            if (!this.data.period) {
                throw "Timer Actor requires a period to be set";
            }
            if (!this.data.variable) {
                throw "Timer Actor requires a variable to be set";
            }
            // There may be some use for period == 0, in the same vein as setTimeout(fn, 0) so I'll allow it for now
            if (this.data.period < 0 ) {
                throw "Timer Actor requires period to be >= 0";
            }

            this.timerEvent = this.game.time.events.add(this.data.period, this.timerFired, this);
        },
        timerFired: function() {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.dispatchGameChoice(varSet);
        },
        destroy: function() {
            if (this.timerEvent) {
                this.game.time.events.remove(this.timerEvent);
            }
            this.freeBaseActor();
        }
    });

    module.exports = TimelineActor;
}());
},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-toggle-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The toggle button actor. This actor can be used for simple actions, such as opening the cell phone, and will
 * remember its internal state of on or off. In many 'plays', this actors isn't needed.
 *
 * Creating a toggle button actor:
 * {
 *     "name": "mute1", // a unique identifier
 *     "type": "toggle-button", // the required type.
 *     "images": {
 *      "on": "muteon",
 *      "off": "muteoff"
 *     }, // the images to use from the button section of the theme.
 *     "location": [ x, y ],
 *     "variable": "mute_game",
 *     "values": {
 *          "on": "mute_on",  // the value used instead of the name when the variable is set.
 *          "off": "mute_off"
 *     }
 *     // optional "scale": [ 1.1, 1.1 ] // Use negative scales to 'flip' the images.
 *     // optional: "active": true/false, // will default to false.
 *     // optional: "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var ToggleActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location", "images", "values", "variable" ];
        },
        enterScene: function() {
            this.isActive = false;
            if( this.data.active && this.data.active === true) {
                this.isActive = true;
            }

            this.buildActor();
            // Even though the user could set active, check the model...
            if( this.data.variable === "mute_game"   ) {
                this.isActive = !this.game.sound.mute;
            }
            this.buttonOn.visible = this.isActive;
            this.buttonOff.visible = !this.isActive;
        },
        buildActor: function() {
            if( !this.theme.buttons || !this.theme.buttons[this.data.images.off] || !this.theme.buttons[this.data.images.on]) {
                throw "Button Actor requires buttons entry in theme, with specific entry matching images off/on";
            }

            this.buttonOff = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons[this.data.images.off].over, this.theme.buttons[this.data.images.off].out,
                this.theme.buttons[this.data.images.off].down, this.theme.buttons[this.data.images.off].up);
            this.buttonOff.inputEnabled = true;

            this.buttonOn = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons[this.data.images.on].over, this.theme.buttons[this.data.images.on].out,
                this.theme.buttons[this.data.images.on].down, this.theme.buttons[this.data.images.on].up);
            this.buttonOn.inputEnabled = true;

            if( this.data.scale ) {
                this.buttonOff.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.buttonOn.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }
        },
        onAction: function() {
            var varSet = {};
            varSet[this.data.variable] = this.isActive ? this.data.values["on"] : this.data.values["off"];
            this.events.onGameChoice.dispatch( this.data.name, varSet );
            this.buttonOn.visible = this.isActive;
            this.buttonOff.visible = !this.isActive;
        },
        onPointerUp: function(  ) {
            this.isActive = !this.isActive;
            this.onAction();
        },
        destroy: function() {
            if ( this.buttonOff ) {
                this.buttonOff.inputEnabled = false;
                this.buttonOff.destroy();
            }
            if ( this.buttonOn ) {
                this.buttonOn.inputEnabled = false;
                this.buttonOn.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ToggleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button-invisible.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The invisible button url actor. Place it over text to provide hyperlink-like functionality, opening
 * the specified link in a new window or tab.
 *
 * Creating a url-button-invisible actor:
 * {
 *     "name": "href1", // a unique identifier
 *     "type": "urlInvisible", // the required type.
 *     "location": [ x, y ],
 *     "width": w,
 *     "height": h,
 *     "url": "www.google.com",
 *     "variable": "show_url", // if you click the button, the variable 'show_url' will be set to 'href1'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor');

    var UrlButtonInvisibleActor = Actor.extend( {
        // constructor is in parent.
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [ "location", "width", "height", "url", "variable" ];
        },
        buildActor: function() {
            this.button = this.game.add.button( this.data.location[0], this.data.location[1],
                null,
                this.onPointerUp, this,
                null, null, null, null);
            this.button.inputEnabled = true;
            this.button.width = this.data.width;
            this.button.height = this.data.height;
        },
        onPointerUp: function( event ) {
            window.open(this.data.url, "_blank");
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = UrlButtonInvisibleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/20/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The url actor. This actor can be used to provide a button; when clicked, open a url in a new window/tab.
 *
 * Creating a url actor:
 * {
 *     "name": "href1", // a unique identifier
 *     "type": "url-button", // the required type.
 *     "image": "resourceImage", // the images to use from the buttons section of the theme.
 *     "location": [ x, y ],
 *     "url": "www.google.com",
 *     "variable": "show_url" // if you click the button, the variable 'show_url' will be set to 'href1'.
 *     // optional "scale": [ 1.1, 1.1 ] // Use negative scales to 'flip' the images.
 *     // optional "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		ButtonActor = require("./actor-button");

	var UrlButtonActor = ButtonActor.extend({
		getRequiredFields: function () {
			var myRequired = ["url"];
			var baseRequired = this.base();
			var allRequired =
				typeof baseRequired != "undefined"
					? baseRequired.concat(myRequired)
					: myRequired;
			return allRequired;
		},
		onPointerUp: function (event) {
			window.open(this.game.config.assetPath + this.data.url, "_blank");
			this.base(event);
		},
	});

	module.exports = UrlButtonActor;
})();

},{"./actor-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-wistia.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A a video actor usin Wistia.
 *
 * {
 *    "name": "video1",
 *     "type": "wistia",
 *     "location": [ 2, 5 ], // location on screen.
 *     "size": [ 300, 200 ],
 *     "video" : "dun1fuu253",
 *     "closeButtonLocation" : [ 70, 44 ], // optional, default is top right of video
 *     "hideCloseButton": true, // optional, will hide the close button.
 *     "blockerTint" : "0x000000", // optional, default is black (0x000000)
 *     "blockerAlpha" : 0.5, // optional, default is 0.5
 *     "blockInput": false, // block input until video is done, optional
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "autoplay": true, // optional. will automatically start the video.
 *     "variable": "string", // optional variable. If present, will be set to started and finished
 *     "markers": [ 5, 15, 20 ] // optional. At specified markers, variable will be set to marker value.
 * },
 *
 */
(function () {
	"use strict";
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor"),
		$ = require("jquery");

	var WistiaActor = Actor.extend({
		// constructor in parent.
		getRequiredFields: function () {
			return ["location", "size", "video"];
		},
		enterScene: function () {
			if (!Wistia) {
				throw "Wistia appears to be missing, cannot create wistia actor.";
			}
			this.video = this.data.video;
			this.blockInput = this.data.blockInput || false;
			this.element = $(this.game.canvas.parentElement);

			if (this.blockInput) {
				this.blockingSprite = this.createBlockingSprite();
				this.blockingSprite.bringToTop();
				this.blockingSprite.visible = false;
			}

			this.currentX = this.data.location[0];
			this.currentY = this.data.location[1];
			this.width = this.data.size[0];
			this.height = this.data.size[1];
			if (this.currentX === "center") {
				this.currentX = this.game.world.centerX - this.width / 2;
			}
			if (this.currentY === "center") {
				this.currentY = this.game.world.centerY - this.height / 2;
			}

			_.bindAll(this, "addWindow");
			window.wistiaInit = this.addWindow;
		},
		addListeners: function () {
			// Bind these, otherwise "this" will be lost. Wistia doesn't accept a context!
			_.bindAll(this, "onWistiaEnd");
			_.bindAll(this, "onWistiaPlay");
			this.wistiaEmbed.bind("play", this.onWistiaPlay);
			this.wistiaEmbed.bind("end", this.onWistiaEnd);
			if (this.data.variable) {
				_.bindAll(this, "onWistiaMarker");
				if (this.data.markers && _.isArray(this.data.markers)) {
					this.wistiaEmbed.bind("secondchange", this.onWistiaMarker);
				}
			}
		},
		onGameSpeech: function (speech) {
			if (speech.audio && speech.audio !== this.video) {
				this.pause();
			}
		},
		pause: function () {
			if (typeof this.wistiaEmbed != "undefined") {
				this.wistiaEmbed.pause();
			}
		},
		onWistiaMute: function (isMuted) {
			log.warn("Called onWistiaMute: " + isMuted);
			if (isMuted) {
				this.wistiaEmbed.volume(0);
			} else {
				this.wistiaEmbed.volume(1);
			}
		},
		onWistiaMarker: function (seconds) {
			_.each(
				this.data.markers,
				function (marker) {
					if (parseInt(marker, 10) === seconds) {
						var varSet = {};
						varSet[this.data.variable] = seconds;
						this.dispatchGameChoice(varSet);
						return false; // exit loop.
					}
				},
				this
			);
		},
		onWistiaEnd: function () {
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable] = "finished";
				this.dispatchGameChoice(varSet);
			}
		},
		onWistiaPlay: function () {
			this.onWistiaMute(this.game.sound.mute);
			this.playAudio({ audio: this.video, key: null });
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable] = "started";
				this.dispatchGameChoice(varSet);
			}
		},
		addWindow: function () {
			/**
			 * This should be a handlebars template but we're having internet trouble so here it is... text.
			 * @type {string}
			 */
			//console.log("wistia api loaded");
			if (this.element) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it.

				var videoContainer = document.createElement("div");
				if (this.theme.internal_autoScale == true) {
					// This property is tacked onto the theme by play.js if set to true in the play.json settings.
					console.log(
						"currentX: " + this.currentX + " - currentY: " + this.currentY
					);
					console.log("this.data.size[0]: " + this.data.size[0]);
					var leftPct = (this.currentX / this.game.world.width) * 100;
					var topPct = (this.currentY / this.game.world.height) * 100;
					var scalePct = (this.data.size[0] / this.game.world.width) * 100;
					videoContainer.setAttribute(
						"style",
						"position: absolute; z-index: 150; width: " +
							scalePct +
							"%; top: " +
							topPct +
							"%; left: " +
							leftPct +
							"%;"
					);
				} else {
					videoContainer.setAttribute(
						"style",
						"position: absolute; z-index: 150; width: " +
							this.width +
							"px; height: " +
							this.height +
							"px; top: " +
							this.currentY +
							"px; left: " +
							this.currentX +
							"px;"
					);
				}

				videoContainer.setAttribute("id", "videoContainer");

				this.videoElement = document.createElement("div");
				var classString = "wistia_embed wistia_async_" + this.video;
				//classString += " endVideoBehavior=reset";
				//classString += " playbar=false";
				if (this.game.device.iPad) {
					classString += " qualityMax=360";
				}
				if (this.data.autoScale == true || this.data.autoScale == null) {
					// enable by default, even if not declared
					classString += " videoFoam=true";
				}
				this.videoElement.setAttribute("class", classString);
				this.videoElement.setAttribute(
					"style",
					"width:" + this.width + "px; height:" + this.height + "px;"
				);
				this.videoElement.setAttribute("id", "videoElement");

				videoContainer.appendChild(this.videoElement);
				var gameContainer = document.querySelector("#gameContainer");
				gameContainer.appendChild(videoContainer);

				window._wq = window._wq || [];
				_.bindAll(this, "onWistiaEmbed");
				_wq.push({ id: this.video, onReady: this.onWistiaEmbed });
			}
		},
		onWistiaEmbed: function (video) {
			//console.log("wistia video loaded");
			if (this.element && !this.wistiaEmbed) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it. this.wistiaEmbed checked to keep function from running multiple times when slide is revisited - Wistia seems to doesn't clear the onReady event binding.
				this.wistiaEmbed = video;

				this.showBlockingSprite();
				this.addCloseButton();

				if (this.blockInput) {
					this.blockingSprite.visible = true;
				}

				this.addListeners();
				if (this.data.autoplay === true) {
					this.wistiaEmbed.play();
				}
			}
		},
		showBlockingSprite: function () {
			if (this.blockInput) {
				this.game.add.existing(this.blockingSprite);
			}
		},
		addCloseButton: function () {
			if (this.data.hideCloseButton !== true) {
				var closeButtonX, closeButtonY;
				if (typeof this.data.closeButtonLocation === "undefined") {
					closeButtonX = this.currentX + this.width;
					closeButtonY = this.currentY;
				} else {
					closeButtonX = this.data.closeButtonLocation[0];
					closeButtonY = this.data.closeButtonLocation[1];
				}

				this.button = new Phaser.Button(
					this.game,
					closeButtonX,
					closeButtonY,
					this.theme.textureKey,
					this.onClose,
					this,
					this.theme.buttons.videoClose.over,
					this.theme.buttons.videoClose.out,
					this.theme.buttons.videoClose.down,
					this.theme.buttons.videoClose.up
				);
				if (typeof this.data.closeButtonLocation == "undefined") {
					// We're using the default close button location, so move it up by its height to sit above the video.
					this.button.y -= this.button.height;
				}
				this.button.bringToTop();
				this.button.input.useHandCursor = true;
				this.game.add.existing(this.button);
			}
		},
		createBlockingSprite: function () {
			var blockerTint =
				typeof this.data.blockerTint === "undefined"
					? 0x000000
					: this.data.blockerTint;
			var blockerAlpha =
				typeof this.data.blockerAlpha === "undefined"
					? 0.5
					: this.data.blockerAlpha;

			var sprite = new Phaser.Sprite(this.game, 0, 0);
			var graphics = new Phaser.Graphics(this.game, 0, 0);
			sprite.addChild(graphics);
			graphics.beginFill(blockerTint, blockerAlpha);
			graphics.drawRect(0, 0, this.game.world.width, this.game.world.height);
			graphics.endFill();
			sprite.inputEnabled = true;
			return sprite;
		},
		onClose: function () {
			this.destroy();
		},
		destroy: function () {
			if (this.element) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it.
				if (this.wistiaEmbed) {
					this.wistiaEmbed.unbind();
					this.wistiaEmbed.remove();
					this.wistiaEmbed = null;
				}
				if (this.blockInput) {
					this.blockingSprite.visible = false;
				}
				if (this.button) {
					this.button.visible = false;
					this.button.destroy();
					this.button = null;
				}
				//log.warn(this.videoElement.attr('id'));
				$("#videoContainer").hide();
				var temp = {};
				temp[this.data.name] = "closed";
				this.events.onGameChoice.dispatch(this.data.name, temp);
				// Now, delete it all.
				if (this.blockInput) {
					this.blockingSprite.destroy(true);
				}
				//log.warn(this.videoElement.attr('id'));
				$("#videoContainer").remove();
				this.element = null;
				this.freeBaseActor();
			}
		},
	});

	module.exports = WistiaActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","jquery":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\jquery\\dist\\jquery.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An generic actor. It cannot be instantiated. It provides functionality to all actors
 *
 *  "inverseEvents": true // optional. Events will go only to this sprite, instead of only to others.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var DEFAULT_FONT = { "font": "20px Tahoma", "fill": "#000000",  "fontWeight": "bold"},
        DEFAULT_TEXT = "Text Not Found.",
        DEFAULT_IMAGE = "Image Not Found.";

    var Actor = Base.extend({
        constructor: function(game,  data, theme) {
            if( !game ) {
                throw "Actor requires game constructor argument.";
            }
            if( !data ) {
                throw "Actor requires data constructor argument.";
            }
            if( !theme ) {
                throw "Actor requires data constructor argument.";
            }
            this.game = game;
            this.theme = theme;
            this.data = data;
            this.validate();
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal()
            };
        },
        freeBaseActor: function() {
            if (this.events) {
                if (this.events.onGameChoice) {
                    this.events.onGameChoice.removeAll();
                    this.events.onGameChoice.dispose();
                }
                if (this.events.onGameSpeech) {
                    this.events.onGameSpeech.removeAll();
                    this.events.onGameSpeech.dispose();
                }
            }
            this.events = null;
            this.theme = null;
            //this.game = null;
            //this.data = null;
        },
        /**
         * A basic validation function.
         * This will check some basic/common data errors, including required fields.
         */
        validate: function() {
            if( !this.data.name ) {
                throw "Actor has data, but no name. Name is required.";
            }

            if( !this.data.type ) {
                throw "Actor has data, but no name. Name is required.";
            }

            _.each( this.getRequiredFields(), function(field) {
                if( this.data[field] === undefined || this.data[field] === null ) {
                    throw "[" + this.data.type + "] Actor [" + this.data.name + "] is missing required field: " + field;
                }
            }, this);

            if( this.data.name && this.data.name.charAt(0) === "$" ) {
                throw "Actor names cannot be variables, and will not be resolved.";
            }
        },
        getType: function() {
            return this.data.type;
        },
        getName: function() {
            return this.data.name;
        },
        getPrimarySprite: function() {
            return this.sprite;
        },
        /**
         * An abstract method for children to implement.
         * ex: return [ "name", "location" ];
         */
        getRequiredFields: function() {
            throw "You must implement this function. Return an array of field names.";
        },
        setModelInterface: function( modelInterface ) {
            this.modelInterface = modelInterface;
        },
        getFont: function(name) {
            log.warn("Asking for font with " + name );
            if( this.theme && this.theme.fonts && this.theme.fonts[name] ) {
                return _.clone(this.theme.fonts[name]);
            }
            log.error("Font not found for " + name);
            return _.clone(DEFAULT_FONT);
        },
        /**
         * Look up a piece of text in the theme.
         * If not there, treat as literal.
         *
         */
        getText: function( name, key ) {
            log.warn("Asking for text with " + name + " / " + key);
            var sName = name,
                sKey = key;
            if( this.modelInterface ) {
                sName = this.modelInterface.getValue(name);
                sKey = this.modelInterface.getValue(key);
            }
            log.warn("--> Asking for text with " + sName + " / " + sKey);
            if( !this.theme || (!this.theme.texts && !sKey) ) {
                log.error("text unavailable for " + sName + " / " + sKey);
                return (DEFAULT_TEXT);
            }
            var text = this.theme.texts[sName];
            if( !text && !sKey ) {
                return sName; // might be a string literal.
            } else if( sKey && this.theme.texts[sKey] ) {
                text = this.theme.texts[sKey][sName];
            }
            log.warn("returning " + text);
            return text || sName;
        },
        getTextureKey: function( spriteData ) {
            if( spriteData && spriteData.textureKey ) {
                return spriteData.textureKey;
            }
            return this.theme.textureKey;
        },
        /**
         * Look up an image in the theme.
         * If not there, treat as literal.
         */
        getImage: function( name, key ) {
            log.warn("Asking for image with " + name + " / " + key);
            var sName = name,
                sKey = key;
            if( this.modelInterface ) {
                sName = this.modelInterface.getValue(name);
                sKey = this.modelInterface.getValue(key);
            }
            log.warn("--> Asking for image with " + sName + " / " + sKey);
            if( !this.theme || (!this.theme.images && !sKey) ) {
                log.error("image not found for " + sName + " / " + sKey);
                return (DEFAULT_IMAGE);
            }
            var image = this.theme.images[sName];
            if( !image && !sKey ) {
                return sName; // might be a string literal, so return it.
            } else if( sKey ) {
                image = this.theme.images[sKey][sName];
            }
            if (!isNaN(Number(image.endIndex))) {
                var start = Number(image.startIndex) || 1;
                var end = Number(image.endIndex);
                var zeroPad = image.zeroPad || 4;
                var prefix = image.filenamePrefix || "";
                var suffix = image.filenameSuffix || ".png";
                image = Phaser.Animation.generateFrameNames(prefix, start, end, suffix, zeroPad);
            }
            return image;
        },
        getMyValue: function() {
            var value;
            if( this.data.variable && this.modelInterface ) {
                value = this.modelInterface.getValue("$" + this.data.variable);
            }
            return value;
        },
        destroy: function() {
            log.error("Failed to implement destroy for actor type: " + this.data.type);
        },
        createBlockingSprite: function() {
            var sprite = new Phaser.Sprite(this.game, 0,0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            sprite.addChild(graphics);
            graphics.beginFill(0x000000, 0.01);
            graphics.drawRect(0, 0, this.game.world.width, this.game.world.height);
            graphics.endFill();
            sprite.inputEnabled = true;
            return sprite;
        },
        substituteText: function( text ) {
            log.warn("Doing substitution on: " + text);
            var leftIndex, rightIndex;
            leftIndex = text.indexOf("$");
            if( leftIndex === -1 ) {
                return text;
            }
            rightIndex = text.indexOf("$", leftIndex + 1);
            if( rightIndex === -1 ) {
                return text;
            }
            var key = text.substring( leftIndex, rightIndex +1);
            var key2 = key.substring(0, key.length - 1); // remove trailing dollarsign.
            var finalText = this.modelInterface.getValue(key2);
            if(typeof finalText === 'undefined' || finalText === null)
            {
                return text;
            }
            finalText = finalText.charAt(0).toUpperCase() + finalText.slice(1);
            return text.replace(key, finalText );
        },
        dispatchGameChoice: function(data) {
            this.events.onGameChoice.dispatch( this.data.name, data, this );
        },
        dispatchGameSpeech: function(data) {
            this.playAudio(  data, this);
        },
        isSoundEventInverse: function() {
            return this.data && this.data.inverseSoundEvents === true;
        },
        // override if you have physics.
        getBody: function() {
            return null;
        },
        /**
         * This will be called if this sprite is overlapping another sprite and getBody() does not return null;
         * The other sprite will also not be returning null for getBody().
         * @param otherActor
         */
        onOverlapping: function( otherActorName ) {

        },
        /**
         * Receive a dropped sprite.
         */
        onReceiveDrop: function( otherActorName ) {

        },
        playAudio: function( eventData ) {
            if( this.data.audioKey ) {
                eventData.channel = this.data.audioKey;
            }
            this.events.onGameSpeech.dispatch(this.data.name, eventData);
        },
        getVariableList: function() {
            return [];
        },
        clearVariables: function() {
            if( this.data.variable) {
                this.modelInterface.clearValue(this.data.variable);
            }
            _.each( this.getVariableList(), function( eachVar) {
                this.modelInterface.clearValue(eachVar);
            }, this);
        }
    });

    module.exports = Actor;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-book.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the book actor, which will show the player a book with flippable pages. It will also
 * play any audio/text associated with asking questions and text.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "iucbook", // required type.
 *     "pages":  [
 *     {
 *     "title": "What are Drugs?",
 *     "subtitle": "This is a subtitle!",
 *     "type": "question"|"information" // will there be questions?
 *
 *     }
 *     ]
 * }
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Actor = require('../actor');

    var ItsUrChoiceBookActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function () {
            return ["pages"];
        },
        enterScene: function () {
            this.pages = this.data.pages;
            this.buildActor();
        },
        buildActor: function () {
            this.buttons = [];
            this.pages = [];
            this.currentPageIndex = 0;
            this.fonts = {
                "bookQuestionTitle": this.getFont("bookQuestionTitle"),
                "bookQuestionSubtitle": this.getFont("bookQuestionSubtitle"),
                "bookQuestionText": this.getFont("bookQuestionText"),
                "bookQuestionRemediation": this.getFont("bookQuestionRemediation"),
                "bookPageTitle": this.getFont("bookPageTitle"),
                "bookPageSubtitle": this.getFont("bookPageSubtitle"),
                "bookPageContent": this.getFont("bookPageContent"),
                "bookPageNumber": this.getFont("bookPageNumber")
            };
            this.PAGE_FLIP_SOUND = this.theme.bookSounds.pageFlipSound;
            this.ANSWER_CORRECT_SOUND = this.theme.bookSounds.correctSound;
            this.ANSWER_INCORRECT_SOUND = this.theme.bookSounds.incorrectSound;

            this.addBackground();          // 01. Background image. This may also later need a border drawn?
            this.addActionButtons();       // 02. Turn pages.
            this.addPages();
            this.setCurrentPage(0);
        },
        addBackground: function () {
            this.bgImage = this.game.add.sprite(this.game.world.width/2, 15, this.theme.textureKey, this.getImage("background", "book"));
            this.bgImage.anchor.setTo(0.5, 0);
            this.leftPageImage = this.game.add.sprite(90, 28, this.theme.textureKey, this.getImage("left-page", "book"));
            this.rightPageImage = this.game.add.sprite(402, 28, this.theme.textureKey, this.getImage("right-page", "book"));
        },
        addActionButtons: function () {
            this.nextPageButton = this.game.add.button(750, 175, this.theme.textureKey,
                this.onNextPageAction, this,
                this.theme.buttons['nextPage'].over, this.theme.buttons['nextPage'].out,
                this.theme.buttons['nextPage'].down, this.theme.buttons['nextPage'].up);
            this.previousPageButton = this.game.add.button(10, 175, this.theme.textureKey,
                this.onPreviousPageAction, this,
                this.theme.buttons['previousPage'].over, this.theme.buttons['previousPage'].out,
                this.theme.buttons['previousPage'].down, this.theme.buttons['previousPage'].up);
        },
        addPages: function() {
            var pageGroup;
            var title, subtitle, content, remediation, pageNumber;
            var bulletImages, bullet;
            _.each( this.data.pages, function(page, pageIndex) {
                pageGroup = this.game.add.group();
                pageGroup.audio = page.audio;

                if( page.content ) {
                    // Title.
                    title = new Phaser.Text(this.game, 565, 50, page.title, this.fonts.bookPageTitle);
                    title.anchor.setTo( 0.5, 0);
                    pageGroup.add(title);

                    // Subtitle.
                    subtitle = new Phaser.Text(this.game, 410, 85, page.subtitle, this.fonts.bookPageSubtitle);
                    pageGroup.add(subtitle);

                    // Content!
                    content = new Phaser.Text(this.game, 412, 110, page.content, this.fonts.bookPageContent);
                    pageGroup.add(content);

                } else if( page.questions ) {
                    // Title.
                    title = new Phaser.Text(this.game, 565, 50, page.title, this.fonts.bookQuestionTitle);
                    title.anchor.setTo( 0.5, 0);
                    pageGroup.add(title);

                    // Subtitle.
                    subtitle = new Phaser.Text(this.game, 565, 85, page.subtitle, this.fonts.bookQuestionSubtitle);
                    subtitle.anchor.setTo( 0.5, 0);
                    pageGroup.add(subtitle);

                    // Content!
                    _.each( page.questions , function( eachQuestion, questionIndex) {
                        bulletImages = this.theme.buttons['bookChoice' + questionIndex];
                        bullet = this.game.add.button( 410, 110 + (questionIndex * 35), this.theme.textureKey,
                            this.onPointerUp, this,
                            bulletImages.over, bulletImages.out,
                            bulletImages.down, bulletImages.up);
                        bullet.inputEnabled = true;
                        bullet.events.onInputOver.add( this.onMouseIn, this);

                        content = new Phaser.Text(this.game, 435, 120 + (questionIndex * 35),
                            eachQuestion.text, this.fonts.bookQuestionText);
                        content.lineSpacing = -6;
                        bullet.answer = eachQuestion;
                        pageGroup.add(bullet);
                        pageGroup.add(content);
                    }, this);

                    // Remediation
                    remediation = new Phaser.Text(this.game, 413, 265,
                        "nothing", this.fonts.bookQuestionRemediation);
                    remediation.lineSpacing = -3;
                    pageGroup.add(remediation);
                    pageGroup.remediation = remediation;
                    remediation.visible = false;
                }

                // Page #
                pageNumber = new Phaser.Text(this.game, 690, 448, pageIndex + 1, this.fonts.bookPageNumber);
                pageGroup.add(pageNumber);

                pageGroup.visible = false;
                this.pages.push(pageGroup);
            }, this);
            this.pages[0].visible = true;
        },
        setCurrentPage: function( pageIndex ) {
            if( pageIndex < 0 || pageIndex >= this.pages.length ) {
                return;
            }
            this.pages[this.currentPageIndex].visible = false;
            this.currentPageIndex = pageIndex;
            this.pages[this.currentPageIndex].visible = true;

            this.previousPageButton.visible = (this.currentPageIndex !== 0);
            this.nextPageButton.visible = (this.currentPageIndex !== (this.pages.length - 1));

            this.playAudio( { audio: this.pages[this.currentPageIndex].audio, key: null, priority: 'queue' });

        },
        onNextPageAction: function() {
            this.playAudio({audio: this.PAGE_FLIP_SOUND, key: null, "priority": "stopall" });
            this.playAudio({ audio: this.PAGE_FLIP_SOUND, key: null });
            this.setCurrentPage(this.currentPageIndex + 1);
        },
        onPreviousPageAction: function() {
            this.playAudio({audio: this.PAGE_FLIP_SOUND, key: null, "priority": "stopall" });
            this.playAudio( { audio: this.PAGE_FLIP_SOUND, key: null});
            this.setCurrentPage(this.currentPageIndex - 1);
        },
        onMouseIn: function() {
            // currently, clicking the answer also causes as mouse in? This is causing problems...
            // this.events.onGameSpeech.dispatch(this.data.name, { audio: "bubble_slow", key: null, restart: true});
        },
        onPointerUp: function (choice) {
           // this.events.onGameSpeech.dispatch(this.data.name, { audio: "bubble_slow", key: null, stop: true});
            var page = this.pages[this.currentPageIndex];
            page.remediation.setText(choice.answer.response.text);
            page.remediation.visible = true;
            this.playAudio( {audio: this.ANSWER_CORRECT_SOUND, key: null, "priority": "stopall" });
            if( choice.answer.response.correct ) {
                this.playAudio( {audio: this.ANSWER_CORRECT_SOUND, key: null});
            } else {
                this.playAudio(  { audio: this.ANSWER_INCORRECT_SOUND, key: null});
            }
            this.playAudio(  { audio: choice.answer.response.audio, key: null, "priority": 'queue' });
        },
        destroy: function () {
            this.bgImage.destroy();
            this.leftPageImage.destroy();
            this.rightPageImage.destroy();
            this.nextPageButton.destroy();
            this.previousPageButton.destroy();

            var temp;
            while( this.pages.length > 0 ) {
                temp = this.pages.pop();
                temp.remediation = null;
                temp.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoiceBookActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-chat.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the chat actor, which will show the player a conversation. It will also
 * play any audio/text associated with asking question.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "iucchat", // required type.
 *     "background": "purpleWall",
 *     "portrait": "mrsRiley",
 *     "portraitLabel": "Mrs. Riley",
 *     "chooseLabel": "Choose your response.",
 *     "variable": "x", // the variable to set when the user leaves
 *     "conversation":  {
              "responses": [
                {
                  "text": {
                    "audio": "audio/day1/melissa_intro.mp3",
                    "text": "Oh, hi. I was just asking your dad if I could borrow his toolbox. I'm fixing some shelves in Josh's room. Your dad will be right back. How's it going? How's school? I'm kind of worried about Seth because he hasn't even thought of college yet, much less his Algebra homework tomorrow. I wish he could be more like Josh and develop some short and long-term goals. He once told me that he felt like everything was out of control and nothing mattered. I hope he was just in a bad mood and that he's not experimenting with anything."
                  },
                  "triggers": "q1,q2,q3,q4,q5",
                  "name": "intro"
                },
                {
                  "text": {
                    "audio": "audio/day1/melissa_1r.mp3",
                    "text": "A short-term goal is simply a goal you want to achieve in a few days, a few weeks or a few months."
                  },
                  "triggers": "q1_a,q2,q3,q4,q5",
                  "name": "r1"
                },

              ],
              "questions": [
                  {
                    "text": "Maybe Seth doesn't know what a short-term goal is. I know I don't.",
                    "name": "q1",
                    "response": "r1",
                    "value": "X" // set the variable to X.
                  },
                  {
                    "text": "All right, Mrs. Riley. I'm going to need an example.",
                    "name": "q1_a",
                    "response": "r1_a"
                  },
                  {
                    "text": "What's a long-term goal?",
                    "name": "q2",
                    "objectiveMet": "4",
                    "response": "r2"
                  }
                ]
            }
 * }
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        RoundedChatRect = require('./rounded-chat-rect');
    Actor = require('../actor');

    var MAX_CHOICES = 5,
        marginY = 3,
        RESPONSE_START_Y = 323;
    var RESPONSE_TEXT_X = 40;
    var COLOR_VISITED_OPTION = "#b5b3b2";
    var COLOR_ACTIVE_OPTION = "#000000";

    var ChatActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function () {
            return ["conversation", "background", "portrait", "portraitLabel", "chooseLabel", "variable"];
        },
        enterScene: function () {
            this.conversation = this.data.conversation;
            this.currentResponse = this.findResponse("intro");
            if (!this.currentResponse) {
                throw "You must have an intro response: " + this.data.name;
            }
            this.isMuted = this.game.sound.mute;

            this.buildActor();
            this.populateChoice();
        },
        buildActor: function () {
            this.buttons = [];
            this.text = [];
            this.completed = [];

            this.addBackground();          // 01. Background image. This may also later need a border drawn?
            this.addPortrait();            // 02, 03. Portrait + Label
            this.addSpeechBubble();        // 04. Speech Bubble (and 10. speech text)
            this.addResponseTitle();       // 05, 06. "Choose your response." w/line
            this.addChoiceBox();           // 07. Choice box
            this.addActionButtons();       // 08, 09. Audio Mute and Leave Conversation button
            this.addChoiceText();          // 11. Current Choice(s) text / Links, possibly grayed out.
        },
        addBackground: function () {
            this.bgImage = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage(this.data.background, this.data.key));
        },
        addPortrait: function () {
            this.portrait = this.game.add.sprite(581, 43, this.theme.textureKey, this.getImage(this.data.portrait, this.data.key));

            // 03. Portrait label
            var fontName = this.data.portraitFont;
            this.labelStyle = this.getFont((typeof fontName !== 'undefined') ? fontName : "chatLabel");
            this.labelStyle.align = "center";
            var labelX = this.portrait.x + (this.portrait.width / 2);
            var labelY = this.portrait.y + this.portrait.height + 15;
            this.portraitLabel = this.game.add.text(labelX, labelY, this.data.portraitLabel, this.labelStyle);
            this.portraitLabel.anchor.setTo(0.5, 0.0);
        },
        addSpeechBubble: function () {
            this.speechBubble = new RoundedChatRect(this.game, this.theme);
            this.speechBubble.show();
        },
        addResponseTitle: function () {
            var fontName = this.data.chooseFont;
            var styleChoose = this.getFont((typeof fontName !== 'undefined') ? fontName : "chatLabel");
            var chooseLabelX = 150;
            var chooseLabelY = this.portrait.y + this.portrait.height + 65;
            this.chooseLabel = this.game.add.text(chooseLabelX, chooseLabelY, this.data.chooseLabel, styleChoose);
            this.chooseLabel.anchor.setTo(0.5, 1.0);
        },
        addChoiceBox: function () {
            var choiceGraphics = this.game.add.graphics(0, 0);
            choiceGraphics.lineStyle(3, 0xc73248, 1);
            choiceGraphics.moveTo(40, RESPONSE_START_Y - 15);
            choiceGraphics.lineTo(760, RESPONSE_START_Y - 15);
            choiceGraphics.lineStyle(1, 0xffffff, 1);
            choiceGraphics.beginFill(0xFFFFFF, 1);
            choiceGraphics.drawRect(30, RESPONSE_START_Y - 5, 740, 150);
            this.choiceGraphics = choiceGraphics;
        },
        addActionButtons: function () {
            this.muteOnButton = this.game.add.button(450, 535, this.theme.textureKey,
                this.onMuteAction, this,
                this.theme.buttons['soundOff'].over, this.theme.buttons['soundOff'].out,
                this.theme.buttons['soundOff'].down, this.theme.buttons['soundOff'].up);
            this.muteOffButton = this.game.add.button(450, 535, this.theme.textureKey,
                this.onMuteAction, this,
                this.theme.buttons['soundOn'].over, this.theme.buttons['soundOn'].out,
                this.theme.buttons['soundOn'].down, this.theme.buttons['soundOn'].up);
            var text;
            if (this.isMuted) {
                this.muteOnButton.visible = false;
                text = "Audio Off";
            } else {
                this.muteOffButton.visible = false;
                text = "Audio On";
            }

            var buttons = this.theme.buttons.leaveChat;
            if( this.data.button ) {
                buttons = this.theme.buttons[this.data.button];
            }
            this.leaveButton = this.game.add.button(560, 547, this.theme.textureKey,
                this.onLeaveAction, this, buttons.over, buttons.out, buttons.down, buttons.up);

            var styleChoose = this.getFont("chatMute");

            this.muteText = this.game.add.text(450, 520, text, styleChoose);
        },
        addChoiceText: function () {
            var locationY = RESPONSE_START_Y,
                buttonCnt,
                currButton;
            this.styleChoose = this.getFont("chatOption");
            this.styleChoose.wordWrap = true;
            this.styleChoose.wordWrapWidth = 725;
            for (buttonCnt = 0; buttonCnt < MAX_CHOICES; buttonCnt++) {
                currButton = this.game.add.text(RESPONSE_TEXT_X, locationY, "answer text", this.styleChoose);
                currButton.lineSpacing = -6;
                locationY += currButton.height + marginY;
                this.buttons.push(currButton);
                currButton.answerIndex = buttonCnt;
            }
        },
        addTextAnswerBox: function (answerText) {
            if (answerText.buttonGraphics) {
                answerText.buttonGraphics.borderGraphic.destroy();
                answerText.buttonGraphics.borderGraphic = null;
                answerText.buttonGraphics.destroy();
                answerText.buttonGraphics = null;

            }
            var choiceGraphics = this.game.add.graphics(30, answerText.y - 3);
            choiceGraphics.beginFill(0xffffff, 1);
            choiceGraphics.drawRect(2, 0, 736, answerText.height + 1);
            choiceGraphics.endFill();

            var choiceGraphics2 = this.game.add.graphics(30, answerText.y - 3);
            choiceGraphics2.lineStyle(2, 0xffffff);
            choiceGraphics2.drawRect(2, 0, 736, answerText.height + 1);

            choiceGraphics.inputEnabled = true;
            choiceGraphics.input.useHandCursor = true;
            choiceGraphics.isTopButton = true;
            choiceGraphics.borderGraphic = choiceGraphics2;

            choiceGraphics.events.onInputOver.add(this.onMouseOver, this);
            choiceGraphics.events.onInputOut.add(this.onMouseOut, this);
            choiceGraphics.events.onInputUp.add(this.onMouseUp, this);

            answerText.buttonGraphics = choiceGraphics;
            answerText.bringToTop();
        },
        onMouseOver: function (x) {
            if (x.isTopButton === true) {
                x.tint = 0xffd480;
                x.borderGraphic.tint = 0xffaa00;
            }
        },
        onMouseOut: function (x) {
            if (x.isTopButton === true) {
                x.tint = 0xfeffff;
                x.borderGraphic.tint = 0xfeffff;
            }
        },
        onMouseUp: function (x) {
            this.onChoice(x.question);
        },
        findResponse: function (name) {
            var response = null;
            _.each(this.conversation.responses, function (eachResponse, responseIndex) {
                if (eachResponse.name === name) {
                    response = eachResponse;
                    return false;
                }
            }, this);
            return response;
        },
        findQuestions: function (setName) {
            if (!setName) {
                return [];
            }
            var names = setName.split(",");
            var questions = [];
            _.each(names, function (eachName) {
                _.each(this.conversation.questions, function (eachQuestion) {
                    if (eachQuestion.name === eachName) {
                        questions.push(eachQuestion);
                    }
                }, this);
            }, this);
            return questions;
        },
        populateChoice: function () {

            var questions = [];
            if (this.currentResponse) {
                this.speechBubble.showResponse(this.currentResponse);
                if (this.currentResponse.triggers) {
                    questions = this.findQuestions(this.currentResponse.triggers);
                    var y = RESPONSE_START_Y;
                    // questions = _.shuffle(questions);
                    _.each(questions, function (eachQuestion, questionIndex) {
                        var prefix = eachQuestion.name;
                        this.buttons[questionIndex].visible = true;
                        this.buttons[questionIndex].setText(eachQuestion.text);
                        this.buttons[questionIndex].y = y;
                        y += this.buttons[questionIndex].height + marginY;
                        this.addTextAnswerBox(this.buttons[questionIndex]);
                        this.buttons[questionIndex].buttonGraphics.question = eachQuestion;
                        var found = false;
                        _.each( this.completed, function(eachCompleted) {
                            if( prefix.startsWith(eachCompleted) ) {
                                found = true;
                            }
                        }, this);
                        if (found) {
                            this.buttons[questionIndex].addColor(COLOR_VISITED_OPTION, 0);
                        } else {
                            this.buttons[questionIndex].addColor(COLOR_ACTIVE_OPTION, 0);
                        }
                    }, this);
                }
            }

            for (var loop = MAX_CHOICES - 1; loop >= questions.length; loop--) {
                this.buttons[loop].visible = false;
                if (this.buttons[loop].buttonGraphics) {
                    this.buttons[loop].buttonGraphics.borderGraphic.destroy();
                    this.buttons[loop].buttonGraphics.borderGraphic = null;
                    this.buttons[loop].buttonGraphics.destroy();
                    this.buttons[loop].buttonGraphics = null;
                }
            }

            if (this.currentResponse && this.currentResponse.text && this.currentResponse.text.audio) {
                var eventData = { "audio": this.currentResponse.text.audio};
                this.playAudio( eventData );
            }
        },
        destroy: function () {
            var temp;
            while (this.text.length > 0) {
                temp = this.text.shift();
                temp.destroy();
                temp = null;
            }
            while (this.buttons.length > 0) {
                temp = this.buttons.shift();
                if (temp.buttonGraphics) {
                    temp.buttonGraphics.borderGraphic.destroy();
                    temp.buttonGraphics.borderGraphic = null;
                    temp.buttonGraphics.destroy();
                    temp.buttonGraphics = null;
                }
                temp.destroy();
                temp = null;
            }
            this.bgImage.destroy();
            this.portrait.destroy();
            this.portraitLabel.destroy();
            this.speechBubble.destroy();
            this.chooseLabel.destroy();
            this.choiceGraphics.destroy();
            this.muteOnButton.destroy();
            this.muteOffButton.destroy();
            this.leaveButton.destroy();
            this.muteText.destroy();
            this.freeBaseActor();
        },
        onLeaveAction: function () {

            var eventData = {"text": "", "audio": this.theme.chat.exit};
            this.playAudio(eventData);

            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onMuteAction: function () {
            var text;
            this.isMuted = !this.isMuted;
            if (this.isMuted) {
                text = "Audio Off";
            } else {
                text = "Audio On";
            }
            var varSet = {"mute_game": this.isMuted ? "mute_on" : "mute_off"};
            this.events.onGameChoice.dispatch(this.data.name, varSet);
            this.muteOnButton.visible = !this.isMuted;
            this.muteOffButton.visible = this.isMuted;
            this.muteText.setText(text);
        },
        onChoice: function (data) {
            var eventData = {"text": "", "audio": this.theme.chat.sound};
            this.playAudio(  eventData);


            if (data.branched) {
                this.completed.push(data.branched);
            }

            if (data.objectiveMet) {
                var varSet = {};
                varSet[data.objectiveMet] = "complete";
                this.events.onGameChoice.dispatch(this.data.name, varSet);
            }

            if (data.response) {
                this.currentResponse = this.findResponse(data.response);
                this.populateChoice();
            }

            if (data.value) {
                var valueSet = {};
                valueSet[this.data.variable] = data.value;
                this.events.onGameChoice.dispatch(this.data.name, valueSet);
            }

        }
    });

    module.exports = ChatActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./rounded-chat-rect":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\rounded-chat-rect.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-file-drag.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The custom file cabinet drag actor. Dragged around the screen, represented by image, has heading and text.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drag", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "dragging" : "phone", // optional image while dragging
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "variable": "string" // name of variable to be set when this is dragging/dropped/etc.
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("../actor");

	var ItsUrChoiceDragActor = Actor.extend({
		// constructor in parent
		getRequiredFields: function () {
			return ["location", "images", "variable"];
		},
		enterScene: function () {
			this.buildActor();
			this.isOverlapping = null;
			if (this.data.audio) {
				this.playAudio({ audio: this.data.audio, key: null });
			}
		},
		buildActor: function () {
			var sprite = this.game.add.sprite(
				this.data.location[0],
				this.data.location[1],
				this.theme.textureKey,
				this.getImage(this.getFrame(), this.data.key)
			);
			this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
			sprite.body.setSize(1, 1, sprite.width / 2, sprite.height / 2);
			sprite.inputEnabled = true;
			sprite.input.pixelPerfectOver = false;
			sprite.input.enableDrag(false, true);
			sprite.events.onDragStop.add(this.itemDragStop, this);
			sprite.events.onDragStart.add(this.itemDragStart, this);
			sprite.events.onDragUpdate.add(function (sprite, pointer, x, y) {
				var pos = sprite.game.input.getLocalPosition(sprite.parent, pointer);
				sprite.x = pos.x - sprite.width / 2;
				sprite.y = pos.y - sprite.height / 2;
			}, sprite);
			sprite.origLoc = [sprite.x, sprite.y];
			this.sprite = sprite;

			var fontHeaderName, fontBodyName;
			if (this.data.textData) {
				var textData = this.data.textData;
				fontHeaderName = textData.fontHeading;
				fontBodyName = textData.fontBody;
				this.headerStyle = this.getFont(
					typeof fontHeaderName !== "undefined"
						? fontHeaderName
						: "questionText"
				);
				this.bodyStyle = this.getFont(
					typeof fontBodyName !== "undefined" ? fontBodyName : "questionText"
				);

				this.headingSprite = this.game.add.text(
					8,
					8,
					textData.heading,
					this.headerStyle
				);
				this.bodySprite = this.game.add.text(
					9,
					35,
					textData.body,
					this.bodyStyle
				);

				this.sprite.addChild(this.headingSprite);
				this.sprite.addChild(this.bodySprite);
			}

			if (this.data.angle) {
				this.sprite.angle = this.data.angle;
			}
		},
		returnToHome: function () {},
		itemDragStop: function () {
			this.isDragging = false;
			this.updateImage();
			var temp = {};
			temp["dropped"] = this.data.name;
			this.dispatchGameChoice(temp);
			// It will have been dropped, and possibly removed from scene.
			if (this.sprite) {
				this.sprite.x = this.sprite.origLoc[0];
				this.sprite.y = this.sprite.origLoc[1];
			}
		},
		itemDragStart: function () {
			if (this.data.audio) {
				this.playAudio({ audio: this.data.audio, key: null });
			}
			this.isDragging = true;
			this.updateImage();
			var temp = {};
			temp["dragging"] = this.data.name;
			this.dispatchGameChoice(temp);
			this.sprite.x = this.game.input.activePointer.position.x - 10;
			this.sprite.body.x = this.game.input.activePointer.position.x - 10;
			this.sprite.y = this.game.input.activePointer.position.y - 10;
			this.sprite.body.y = this.game.input.activePointer.position.y - 10;
		},
		getFrame: function (type) {
			var frameName = this.data.images.normal;
			if (type === "overlap" && this.data.images.overlap) {
				frameName = this.data.images.overlap;
			} else if (
				(type === "dragging" || !frameName) &&
				this.data.images.dragging
			) {
				frameName = this.data.images.dragging;
			}
			return frameName;
		},
		updateImage: function () {
			var frame;
			if (this.headingSprite) {
				this.headingSprite.visible = false;
				this.bodySprite.visible = false;
			}
			if (this.isOverlapping !== null) {
				frame = this.getFrame("overlap");
			} else if (this.isDragging === true) {
				frame = this.getFrame("dragging");
			} else {
				frame = this.getFrame("normal");
				if (this.headingSprite) {
					this.headingSprite.visible = true;
					this.bodySprite.visible = true;
				}
			}
			this.sprite.frameName = this.getImage(frame, this.data.key);
			this.sprite.body.setSize(
				1,
				1,
				this.sprite.width / 2,
				this.sprite.height / 2
			);
		},
		getBody: function () {
			if (this.sprite) {
				return this.sprite.body;
			}
			return null;
		},
		onOverlapping: function (otherActor) {
			if (this.isOverlapping === otherActor) {
				return;
			}
			this.isOverlapping = otherActor;
			// change to overlapping image.
			this.updateImage();
		},
		destroy: function () {
			if (this.sprite) {
				this.sprite.input.disableDrag();
				this.sprite.body.destroy();
				this.sprite.events.onDragStop.removeAll();
				this.sprite.events.onDragStart.removeAll();
				this.sprite.events.onDragUpdate.removeAll();
				this.sprite.inputEnabled = false;
				this.sprite.destroy(true);
				this.sprite = null;
			}
			if (this.headingSprite) {
				this.headingSprite.destroy();
				this.bodySprite.destroy();
			}
			this.style = null;
			this.freeBaseActor();
		},
	});

	module.exports = ItsUrChoiceDragActor;
})();

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-map.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The map actor.
 *
 * Creating a map actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "iucmap", // the required type.
 *     "variable": "locationChoice"
 *     "night": true, // makes it night, defaults to false
 * }
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');
    var Base = require('basejs');

    var LargeBird = require('./map/actor-bird-large');
    var SmallBird = require('./map/actor-bird-small');
    var BasicCar = require('./map/actor-car-basic');
    var YellowCar = require('./map/actor-car-yellow');

    var EXTRA_WAIT_TIME = 8000;

     var MapActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            this.blueFlag.animations.play('wave', 24, true);
            this.usFlag.animations.play('wave', 24, true);
            this.mapTimer.start();
        },
        getRequiredFields: function() {
            return [  "variable" ];
        },
        buildActor: function() {
            this.bg = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage("citymap"));
            this.houses = [];
            this.labels = [];
            _.each( this.theme.mapInfo.buildings, function( building, buildingIndex ) {
                this.houses.push(
                    this.game.add.sprite(building.x, building.y, this.theme.textureKey, building.image)
                );
                var label = building.hover;
                this.labels.push(
                    this.game.add.sprite(label.x, label.y, this.theme.textureKey, label.image)
                );
                this.houses[buildingIndex].clickValue = building.key;
                this.houses[buildingIndex].isBuilding = true;
                this.houses[buildingIndex].buildingIndex = buildingIndex;
                this.houses[buildingIndex].inputEnabled = true;
                this.houses[buildingIndex].input.useHandCursor = true;
                this.houses[buildingIndex].events.onInputOver.add(this.onMouseOver, this);
                this.houses[buildingIndex].events.onInputOut.add(this.onMouseOut, this);
                this.houses[buildingIndex].events.onInputUp.add(this.onMouseUp, this);
            }, this);

            this.blueFlag = this.game.add.sprite( 180, 70, this.theme.textureKey, this.theme.mapInfo.blueFlagFrames[0]);
            this.blueFlag.animations.add('wave', this.theme.mapInfo.blueFlagFrames );

            this.usFlag = this.game.add.sprite( 180, 38, this.theme.textureKey, this.theme.mapInfo.usFlagFrames[0]);
            this.usFlag.animations.add('wave', this.theme.mapInfo.usFlagFrames );

            this.smallBird = new SmallBird(this.game, this.theme);
            this.largeBird = new LargeBird(this.game, this.theme);
            this.randomCar = new BasicCar(this.game, this.theme);
            this.yellowCar = new YellowCar(this.game, this.theme);
            this.smallBird.events.playAudio.add(this.onSubSpeech, this);
            this.largeBird.events.playAudio.add(this.onSubSpeech, this);
            this.randomCar.events.playAudio.add(this.onSubSpeech, this);
            this.yellowCar.events.playAudio.add(this.onSubSpeech, this);

            this.fg = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage("citymapfg"));

            if( this.data.night === true ) {
                this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
                var graphics = new Phaser.Graphics(this.game, 0, 0);
                this.blockerSprite.addChild(graphics);
                graphics.beginFill( 0x000000, 0.35 );
                graphics.drawRect( 0, 0, this.game.world.width, this.game.world.height );
                graphics.endFill();
                this.blockerSprite.bringToTop();
                this.game.add.existing(this.blockerSprite);
            }

            _.each( this.labels, function( eachLabel ) {
                eachLabel.scale.setTo(0.80,0.80);
                eachLabel.bringToTop();
                eachLabel.visible = false;
            }, this);

            this.mapTimer = this.game.time.create(false);
            this.mapTimer.loop(EXTRA_WAIT_TIME, this.showExtraOnMap, this);
        },
         onSubSpeech: function(name, speech) {
             if( name && speech ) {
                 this.events.onGameSpeech.dispatch(name, speech);
             }
         },
         onGameSpeech: function(speech) {
            // nothing.
         },
         showExtraOnMap: function () {
             var randomValue = this.game.rnd.integerInRange(0, 4);
             switch (randomValue) {
                 case 0: {
                     this.largeBird.play();
                     break;
                 }
                 default:
                 case 1: {
                     this.smallBird.play();
                     break;
                 }
                 case 2: {
                     this.yellowCar.play();
                     break;
                 }
                 case 4:
                 case 3: {
                     this.randomCar.play();
                     break;
                 }
             }
         },
         onMouseOver: function (x) {
             if (x.isBuilding === true) {
                 this.labels[x.buildingIndex].visible = true;
             }
         },
         onMouseOut: function (x) {
             if (x.isBuilding === true) {
                 this.labels[x.buildingIndex].visible = false;
             }
         },
         onMouseUp: function (x) {
             if (x.isBuilding === true) {
                 var varSet = {};
                 varSet[this.data.variable] = x.clickValue;
                 this.events.onGameChoice.dispatch( this.data.name, varSet );
             }
             // this.onChoice(x.question);
         },
        destroy: function() {
            if ( this.bg ) {
                this.bg.destroy();
            }
            if ( this.fg ) {
                this.fg.destroy();
            }
            var destroyBuilding = this.houses.pop();
            while( destroyBuilding ) {
                destroyBuilding.destroy();
                destroyBuilding = this.houses.pop();
            }
            this.houses = null;
            var destroyLabel = this.labels.pop();
            while( destroyLabel ) {
                destroyLabel.destroy();
                destroyLabel = this.labels.pop();
            }
            // var destroyTween = this.allTweens.pop();
            // while( destroyTween ) {
            //     destroyTween.stop();
            //     this.game.tweens.remove(destroyTween);
            // }
            this.game.tweens.removeAll();
            this.labels = null;
            this.blueFlag.destroy();
            this.usFlag.destroy();
            this.smallBird.destroy();
            this.largeBird.destroy();
            this.mapTimer.stop();
            this.mapTimer.destroy();
            this.yellowCar.destroy();
            this.randomCar.destroy();
            if( this.data.night === true ) {
                this.blockerSprite.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = MapActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./map/actor-bird-large":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-large.js","./map/actor-bird-small":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-small.js","./map/actor-car-basic":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-basic.js","./map/actor-car-yellow":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-yellow.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The phone button actor. This actor is used for opening the phone and showing phone alerts.
 *
 * Creating a phone button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "iucphone-button", // the required type.*
 *     "location": [ x, y ],
 *     "alert": any value // phone will alert immediately.
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var ItsUrChoicePhoneButtonActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location" ];
        },
        enterScene: function() {
            this.isAlerted = false;
            this.buildActor();
            if( this.data.alert ) {
                this.onGameChoice( { 'phone_alert': this.data.alert });
            }
        },
        buildActor: function() {
            this.buttonAnimation = null;
            this.button = this.game.add.button( this.data.location[0], this.data.location[1] , this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons.phone.over, this.theme.buttons.phone.out,
                this.theme.buttons.phone.down, this.theme.buttons.phone.up);
            this.button.inputEnabled = true;
        },
        /**
         * @param choice
         */
        onGameChoice: function( choice ) {
           if( choice['phone_alert'] ) {
                this.isAlerted = true;
                this.playAlert();
           }
        },
        /**
         * Play the ring animation and current ring tone.
         */
        playAlert: function() {
            if( this.buttonAnimation === null) {
                this.buttonAnimation = this.button.animations.add('ring', this.theme.phone.alerts );
            }
            this.button.animations.play('ring', 24);
            var eventData = {"text": "", "audio" : this.theme.phone.ringtone, "priority": "sfx" };
            this.playAudio(  eventData);
        },
        /**
         * When the player clicks the phone button, stop any alert and then send out the game choice.
         * @param event
         */
        onPointerUp: function( event ) {
            this.isAlerted = false;
            this.button.animations.stop();

            var varSet = {};
            varSet['show_cell_phone'] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePhoneButtonActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/22/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a very specialized actor for use with Welcome To Westpost and Its UR Choice! it shows a cell phone that
 * sends out special events, responds to events, and can interact with the user by drawing over the scene.
 * The user can interact with the phone, which must block user input.
 *
 *  {
 *     "name": "phone_1",
 *     "type": "iucphone",
 *     "helpVariable": "current_help_message",
 *     "objectives": {
 *       "obj1": "Explore Westport",
 *       "obj2": "Try out your cell phone and journal."
 *     },
 *     disablePower: true|false, // defaults to false, can keep the player from closing the phone.
 *     demoMode: true|false // defaults to false. Shows phone smaller on left side of screen.
 *  }
 *
 *
 */
(function () {
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor'),
        moment = require('moment');

    var SCREEN_X = 258;
    var SCREEN_END_X = 712;
    var SCREEN_Y = 32;
    var SCREEN_END_Y = 317;

    var ItsUrChoicePhone = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "objectives", "helpVariable", "objectiveAudio", "helpAudio"]; // no required fields
        },
        enterScene: function () {
            this.fontHeader = this.getFont('phoneHeader');
            this.fontBody = this.getFont('phoneBody');
            this.isInitialized = false;
            this.isMuted = this.game.sound.mute;
            this.objectiveMarkers = {};

            if( this.data.open ) {
                this.showPhone();
            }
        },
        onGameChoice: function( choice ) {
            if( choice['show_cell_phone'] ) {
                if( this.isInitialized && this.phoneGroup.visible ) {
                    this.onClickClose();
                } else {
                    this.showPhone();
                }
            }
        },
        dispatch: function (data, value) {
            var varSet = {};
            varSet[data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onClickHelp: function () {
            var helpText = this.modelInterface.getValue(this.data.helpVariable);
            this.hideObjectives();
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound };
            this.playAudio( eventData);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "help"});
            this.showHelp( helpText);
        },
        onClickMute: function () {
            this.isMuted = !this.isMuted;

            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);

            var varSet = {"mute_game" : this.isMuted ? "mute_on" : "mute_off"};
            this.events.onGameChoice.dispatch( this.data.name, varSet );

            if( this.isMuted ) {
                this.muteIcon.animations.play('vibrate', 24, true);
                this.muteOnButton.visible = false;
                this.muteOffButton.visible = true;
            } else {
                this.muteOnButton.visible = true;
                this.muteOffButton.visible = false;
                this.muteIcon.animations.stop();
                this.muteIcon.frameName = this.theme.phone.ringMode.muteOff;
            }
        },
        onClickObjectives: function() {
            this.hideHelp();
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);
            this.showObjectives(this.data.objectives);
        },
        onClickClose: function () {
            if( this.data.disablePower === true || this.data.disablePower === "true") {
                return; // close is turned off by this feature.
            }
            this.phoneGroup.visible = false;
            this.helpGroup.visible = false;
            this.objectivesGroup.visible = false;
            this.blockingSprite.visible = false;
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "stopall"};
            this.playAudio(  eventData);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "closed"});
        },
        createPhoneButton: function (key, callback, context) {
            var button = new Phaser.Button(this.game, 0, 0, this.theme.textureKey,
                callback, context,
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0],
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0]);
            button.input.useHandCursor = true;
            return button;
        },
        /**
         * Showing the phone is a bit complicated. Everything has to be brought to the top in
         * reverse order.
         */
        showPhone: function () {
            if( this.isInitialized === false ) {
                this.initHomeScreenGroup();
                this.initHelpWindowGroup();
                this.initObjectivesWindowGroup();
                if( this.data.demoMode === true || this.data.demoMode === "true") {
                    this.initDemoView();
                } else {
                    this.initBlockingGroup();
                }
            }
            this.phoneGroup.visible = true;
            if( this.blockingSprite ) {
                this.blockingSprite.visible = true;
                this.blockingSprite.bringToTop();
            }
            this.game.world.bringToTop(this.phoneGroup);
            this.game.world.bringToTop(this.helpGroup);
            this.game.world.bringToTop(this.objectivesGroup);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "open"});
            if( this.isMuted ) {
                this.muteIcon.animations.play('vibrate', 24, true);
                this.muteOnButton.visible = false;
                this.muteOffButton.visible = true;
            } else {
                this.muteOnButton.visible = true;
                this.muteOffButton.visible = false;
                this.muteIcon.animations.stop();
                this.muteIcon.frameName = this.theme.phone.ringMode.muteOff;
            }
            _.each( this.data.objectives, function( objective, objectiveKey) {
                var completed = this.modelInterface.getValue("$" + objectiveKey);
                if( completed === true || completed === "true" || completed === "complete" ) {
                    this.objectiveMarkers[objectiveKey].frameName = this.theme.phone.checkBoxes[1];
                }
            }, this);

            var eventData = {"text": "", "audio" : this.data.objectiveAudio };
            this.playAudio(  eventData);
        },
        initDemoView: function() {
            this.phoneGroup.scale.set( 0.5, 0.5);
            this.phoneGroup.x = 295;
            this.phoneGroup.y = 150;
            this.helpGroup.y += 145;
            this.helpGroup.x -= 35;
            this.objectivesGroup.y += 145;
            this.objectivesGroup.x -= 35;
            this.helpGroup.scale.set(0.5, 0.5);
            this.objectivesGroup.scale.set(0.5, 0.5);
        },
        /**
         * Create the main screen, including all of the buttons.
         */
        initHomeScreenGroup: function() {
            this.phoneGroup = this.game.add.group();
            this.phoneGroup.x = this.game.world.centerX;
            var buttonY = 365;

            this.phoneBg = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.background);
            this.phoneBg.anchor.setTo(0.5, 0.0);
            this.phoneGroup.add(this.phoneBg);
            
            this.muteOnButton = this.createPhoneButton('muteOn', this.onClickMute, this, 2);
            this.phoneGroup.add(this.muteOnButton);
            this.muteOnButton.x = -100;
            this.muteOnButton.y = buttonY;
            this.muteOnButton.anchor.setTo(0.5, 0);
            this.muteOnButton.bringToTop();
            
            this.muteOffButton = this.createPhoneButton('muteOff', this.onClickMute, this, 2);
            this.phoneGroup.add(this.muteOffButton);
            this.muteOffButton.x = -100;
            this.muteOffButton.y = buttonY;
            this.muteOffButton.anchor.setTo(0.5, 0);
            this.muteOffButton.bringToTop();

            this.muteIcon = new Phaser.Sprite(this.game, 0, SCREEN_Y + 2, this.theme.textureKey, this.theme.phone.ringMode.muteOff);
            this.phoneGroup.add(this.muteIcon);
            this.muteIcon.animations.add('vibrate', this.theme.phone.ringMode.muteOn );
            this.muteIcon.x = 220;
            this.muteIcon.bringToTop();

            this.helpButton = this.createPhoneButton('help', this.onClickHelp, this, 2);
            this.phoneGroup.add(this.helpButton);
            this.helpButton.x = 10;
            this.helpButton.y = buttonY;
            this.helpButton.anchor.setTo(0.5, 0);
            this.helpButton.bringToTop();
            
            this.objectivesButton = this.createPhoneButton('objectives', this.onClickObjectives, this, 2);
            this.phoneGroup.add(this.objectivesButton);
            this.objectivesButton.x = 150;
            this.objectivesButton.y = buttonY;
            this.objectivesButton.anchor.setTo(0.5, 0);
            this.objectivesButton.bringToTop();
            
            this.closeButton = this.createPhoneButton('power', this.onClickClose, this, 2);
            this.phoneGroup.add(this.closeButton);
            this.closeButton.x = 280;
            this.closeButton.y = buttonY;
            this.closeButton.anchor.setTo(0.5, 0);
            this.closeButton.bringToTop();
            this.phoneGroup.visible = false;
        },
        initBlockingGroup: function() {
            this.blockingSprite = this.createBlockingSprite();
            this.game.add.existing(this.blockingSprite);
            this.blockingSprite.visible = false;
        },
        initHelpWindowGroup: function () {
            var width = SCREEN_END_X - SCREEN_X;
            var marginX = 5;

            this.helpGroup = this.game.add.group();
            this.helpGroup.x = SCREEN_X;
            this.helpGroup.y = SCREEN_Y;

            var headingText = new Phaser.Text(this.game, marginX, 10, "Help", this.fontHeader);
            this.fontBody.wordWrap = true;
            this.fontBody.wordWrapWidth = width * 0.95;
            this.helpText = new Phaser.Text(this.game, marginX, headingText.height + 15, "BODY TEST", this.fontBody);

            this.helpGroup.add(headingText);
            this.helpGroup.add(this.helpText);

            this.hideHelp();
        },
        showHelp: function ( body) {
            this.helpGroup.visible = true;
            this.helpText.inputEnabled = false;
            this.helpText.setText( body );
            var eventData = {"text": "", "audio" : this.data.helpAudio };
            this.playAudio( eventData);
        },
        hideHelp: function () {
            this.helpGroup.visible = false;
        },
        initObjectivesWindowGroup: function () {
            var width = SCREEN_END_X - SCREEN_X;
            var marginX = 5, marginY = 10;

            this.objectivesGroup = this.game.add.group();
            this.objectivesGroup.x = SCREEN_X;
            this.objectivesGroup.y = SCREEN_Y;

            var headingText = new Phaser.Text(this.game, marginX, marginY, "Objectives", this.fontHeader);
            this.objectivesGroup.add(headingText);

            // list out the objectives, with icons.
            // update the icons when the phone is shown
            // in the onGameChoice, watch for objectives.
            var eachTextItem;
            var eachCheckBox;
            var currentY = headingText.y + headingText.height + marginY;

            _.each( this.data.objectives, function( objective, objectiveKey) {
                eachCheckBox = new Phaser.Sprite(this.game, 0, currentY - 2, this.theme.textureKey, this.theme.phone.checkBoxes[0]);
                eachTextItem = new Phaser.Text(this.game, eachCheckBox.width + marginX, currentY, this.modelInterface.getValue(objective), this.fontBody);
                currentY += eachTextItem.height + marginY;
                this.objectivesGroup.add(eachCheckBox);
                this.objectivesGroup.add(eachTextItem);
                this.objectiveMarkers[objectiveKey] = eachCheckBox;
            }, this);
        },
        showObjectives: function ( objectives ) {
            this.objectivesGroup.visible = true;
            var eventData = {"text": "", "audio" : this.data.objectiveAudio };
            this.playAudio( eventData);
        },
        hideObjectives: function () {
            this.objectivesGroup.visible = false;
        },
        destroy: function () {
            this.fontHeader = null;
            this.fontBody = null;
            if ( this.phoneGroup ) {
                this.phoneGroup.destroy();
            }
            if ( this.helpGroup ) {
                this.helpGroup.destroy(true);
            }
            if ( this.objectivesGroup ) {
                this.objectivesGroup.destroy(true);
            }
            if ( this.blockingSprite ) {
                this.blockingSprite.destroy(true);
            }

            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePhone;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","moment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-popup.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The IUC popup actor. Pops up an alert, that does not block the screen. Alert can be closed.
 *
 * Creating a phone button actor:
 * {
 *     "name": "popup11", // a unique identifier
 *     "type": "iucpopup", // the required type.*
 *     "heading": "This area is closed.",
 *     "text": "We're busy booking someone. Come back another day.",
 *     "background": "myimage",
 *     "variable": "x"
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var winX = 200, winY = 250;
    var closeX = 550, closeY = 300;

    var ItsUrChoicePopupActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "heading", "text", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            this.popupGroup = this.game.add.group();
            this.popupGroup.x = winX;
            this.popupGroup.y = winY;

            var bgFrame = this.theme.popup.background;
            if( this.data.background ) {
                bgFrame = this.getImage(this.data.background, this.data.key);
            }
            this.bg = this.game.add.sprite( 0, 0, this.theme.textureKey, bgFrame );
            this.popupGroup.add(this.bg);

            this.button = this.game.add.button( 0, 9 , this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.popup.closeButton[0], this.theme.popup.closeButton[1],
                this.theme.popup.closeButton[2], this.theme.popup.closeButton[3] );
            this.popupGroup.add(this.button);
            this.button.x = this.bg.width - this.button.width - 8;


            var headingStyle = this.getFont( "popupHeading");
            var bodyStyle = this.getFont( "popupBody");

            if( this.data.fontBody ) {
                bodyStyle = this.getFont(this.data.fontBody);
            }

            if( this.data.fontHeading ) {
                headingStyle = this.getFont(this.data.fontHeading);
            }

            var contentBodyY = 50;
            if( this.data.heading ) {
                this.heading = this.game.add.text(10, 12, this.data.heading, headingStyle);
                this.popupGroup.add(this.heading);
                contentBodyY = 65;
            }
            this.body = this.game.add.text( 15, contentBodyY, this.data.text, bodyStyle);
            this.popupGroup.add(this.body);

            this.button.inputEnabled = true;
        },
        /**
         * Any game choice during an alert will cause the phone to 'vibrate' on screen.
         * @param choice
         */
        onGameChoice: function( choice ) { },
        onPointerUp: function( event ) {
                     var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            this.popupGroup.destroy(true);
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePopupActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-window.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The IUC popup actor. Pops up an alert, that does not block the screen. Alert can be closed.
 *
 * Creating a phone button actor:
 * {
 *     "name": "window1", // a unique identifier
 *     "type": "iucwindow", // the required type.*
 *     "heading": "Day 3 Complete",
 *     "audio": "audiokey", // Play when window is initiall opened, or maximimized from min.
 *     "text": "We're busy booking someone. Come back another day.",
 *     "variable": "x",
 *     "showClose": false|true, // optional, defaults to false.
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var MAXIMIZE = "MAX";
    var MINIMIZE = "MIN";
    var CLOSE = "CLOSE";

    var ItsUrChoiceWindowActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "heading", "text" ];
        },
        enterScene: function() {
            this.buildActor();
            this.minimize();
        },
        buildActor: function() {
            this.windowGroup = this.game.add.group();
            this.windowGroup.x = 0;
            this.windowGroup.y = 0;

            this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            this.blockerSprite.addChild(graphics);
            graphics.beginFill( 0xEFEFEF, 0.75 );
            graphics.drawRect( 0, 0, this.game.world.width, this.game.world.height );
            graphics.endFill();
            this.blockerSprite.inputEnabled = true;
            this.blockerSprite.bringToTop();
            this.windowGroup.add(this.blockerSprite);

            var bgFrame = this.theme.window.background;
            if( this.data.background ) {
                bgFrame = this.getImage(this.data.background, this.data.key);
            }
            this.bg = this.game.add.sprite( 0, 0, this.theme.textureKey, bgFrame );
            this.windowGroup.add(this.bg);

            this.logo = this.game.add.sprite( this.game.world.width - 25, this.game.world.height - 25,
                this.theme.textureKey, this.theme.window.logo );
            this.logo.anchor.setTo( 1.0, 1.0);
            this.windowGroup.add(this.logo);

            var minButtonY = 20;
            if( this.data.showClose ) {
                this.closeButton = this.game.add.button(this.game.world.width - 25, 20, this.theme.textureKey,
                    this.onCloseButton, this,
                    this.theme.window.closeButton[0], this.theme.window.closeButton[1],
                    this.theme.window.closeButton[2], this.theme.window.closeButton[3]);
                this.windowGroup.add(this.closeButton);
                this.closeButton.anchor.setTo( 1.0, 0);
                this.closeButton.inputEnabled = true;
                minButtonY += this.closeButton.y + this.closeButton.height;
            }

            this.minimizeButton = this.game.add.button( this.game.world.width - 25,
                minButtonY, this.theme.textureKey,
                this.onMinimizeButton, this,
                this.theme.window.minimizeButton[0], this.theme.window.minimizeButton[1],
                this.theme.window.minimizeButton[2], this.theme.window.minimizeButton[3] );
            this.windowGroup.add(this.minimizeButton);
            this.minimizeButton.anchor.setTo( 1.0, 0);

            this.maximizeButton = this.game.add.button( this.game.world.width,
                0, this.theme.textureKey, this.onMaximizeButton, this,
                this.theme.window.maximizeButton[0], this.theme.window.maximizeButton[1],
                this.theme.window.maximizeButton[2], this.theme.window.maximizeButton[3] );
            this.windowGroup.add(this.maximizeButton);
            this.maximizeButton.anchor.setTo( 1.0, 0);
            this.maximizeButton.visible = false;

            var headingStyle = this.getFont( "windowHeading");
            var bodyStyle = this.getFont( "windowBody");

            this.heading = this.game.add.text( this.game.world.width / 2, 120, this.data.heading, headingStyle);
            this.heading.anchor.setTo( 0.5, 0.5);
            this.windowGroup.add(this.heading);

            this.body = this.game.add.text( this.game.world.width / 2, 160, this.data.text, bodyStyle);
            this.body.anchor.setTo( 0.5, 0 );
            this.windowGroup.add(this.body);

            this.minimizeButton.inputEnabled = true;

        },
        onGameChoice: function( choice ) { },
        onCloseButton: function () {
            this.dispatch(CLOSE);
        },
        onMinimizeButton: function () {
            this.dispatch(MINIMIZE);
            this.minimize();
        },
        onMaximizeButton: function () {
            this.dispatch(MAXIMIZE);
            this.maximize();
        },
        minimize: function() {
            this.toggleContent(false);
            this.onMinTweenComplete();
        },
        onMinTweenComplete: function() {
            this.bg.visible = false;
            this.maximizeButton.visible = true;
            if( this.data.audio ) {
                this.playAudio({ audio: this.data.audio, key: null, "priority": "stop"});
            }
        },
        maximize: function() {
            this.maximizeButton.visible = false;
            this.game.world.bringToTop(this.windowGroup);
            this.bg.visible = true;
            this.onMaxTweenComplete();
        },
        onMaxTweenComplete: function() {
            this.toggleContent(true);
            if( this.data.audio ) {
                this.playAudio(  { audio: this.data.audio, key: null});
            }
        },
        toggleContent: function( visible ) {
            this.heading.visible = visible;
            this.body.visible = visible;
            this.logo.visible = visible;
            if( this.data.closeButton ) {
                this.closeButton.visible = visible;
            }
            this.minimizeButton.visible = visible;
            this.blockerSprite.visible = visible;
        },
        dispatch: function (value) {
            var varSet = {};
            varSet[this.data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        destroy: function () {
            if( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoiceWindowActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-large.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var LargeBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.startLoc = [ -150, 100];
            this.endLoc = [ 850, 235];
            this.isPlaying = false;

            this.sprite = this.game.add.sprite( this.startLoc[0], this.startLoc[1] , this.theme.textureKey, this.theme.mapInfo.largeBirdFrames[0]);
            this.sprite.animations.add('fly', this.theme.mapInfo.largeBirdFrames );
            this.sprite.scale.setTo(0.3,0.3);
            this.tween1 = this.game.add.tween(this.sprite).to( { x: this.endLoc[0] }, 4000, 'Linear', false);
            this.tween2 = this.game.add.tween(this.sprite).to( { y: this.endLoc[1] }, 3500, Phaser.Easing.Cubic.In, false);
            this.tween1.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            var crowSound = this.game.rnd.integerInRange(1, 100);
            var whichSound = 'crow';
            if( crowSound > 30 ) {
                whichSound += this.game.rnd.integerInRange(1, 2);
                this.events.playAudio.dispatch("LargeBird", {text:"", audio: whichSound, key: null, priority: 'low'});
            }
            this.sprite.x = this.startLoc[0];
            this.sprite.y = this.startLoc[1];
            this.sprite.animations.play('fly', 14, true);
            this.tween1.start();
            this.tween2.start();
        },
        destroy: function() {
            this.sprite.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = LargeBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-small.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var SmallBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.startLoc = [ 805, 25];
            this.endLoc = [ -100, 75];

            this.sprite = this.game.add.sprite( this.startLoc[0], this.startLoc[1] , this.theme.textureKey, this.theme.mapInfo.smallBirdFrames[0]);
            this.sprite.animations.add('fly', this.theme.mapInfo.smallBirdFrames );

            this.tween1 = this.game.add.tween(this.sprite).to( { x: this.endLoc[0] }, 3000, 'Linear', false);
            this.tween2 = this.game.add.tween(this.sprite).to( { y: this.endLoc[1] }, 3000, Phaser.Easing.Cubic.InOut, false);
            this.tween1.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.sprite.animations.play('fly', 14, true);
            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            var birdSound = this.game.rnd.integerInRange(1, 100);
            var whichSound = 'birdChirp';
            if( birdSound > 30 ) {
                whichSound += this.game.rnd.integerInRange(1, 4);
                this.events.playAudio.dispatch("smallBird", {text:"", audio: whichSound, key: null, priority: 'low'});
            }
            this.sprite.x = this.startLoc[0];
            this.sprite.y = this.startLoc[1];
            this.tween1.start();
            this.tween2.start();

        },
        destroy: function() {
            this.sprite.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = SmallBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-basic.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var RANDOM_CAR_Y = [ 239, 236, 221, 210 ];
    var RANDOM_CAR_X = [ 801, 660, 277, -50 ];

    var LargeBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.randomCar = this.game.add.sprite( 801, 70, this.theme.textureKey, this.theme.mapInfo.vehicles[0]);
            this.randomCar.scale.setTo(0.8, 0.8);
            this.randomCar.anchor.setTo( 0, 1.0);
            this.randomCar.visible = false;

            this.randomCarTween1  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[1], x: RANDOM_CAR_X[1] }, 5500,  Phaser.Easing.Quintic.Out, false);

            this.randomCarTween2  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[2], x: RANDOM_CAR_X[2] }, 7000,  Phaser.Easing.Quintic.InOut, false, 2000);
            this.randomCarTween1.chain(this.randomCarTween2);

            this.randomCarTween3  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[3], x: RANDOM_CAR_X[3] }, 4000,  "Linear", false, 2000);
            this.randomCarTween2.chain(this.randomCarTween3);
            this.randomCarTween3.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.randomCarTween1b  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[1], x: RANDOM_CAR_X[1] }, 6000,  Phaser.Easing.Quintic.Out, false);
            this.randomCarTween2b  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[3], x: RANDOM_CAR_X[3] }, 9000,  "Linear", false, 2000);
            this.randomCarTween1b.chain(this.randomCarTween2b);
            this.randomCarTween2b.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            this.randomCar.y = RANDOM_CAR_Y[0];
            this.randomCar.x = RANDOM_CAR_X[0];
            this.randomCar.frameName = this.theme.mapInfo.vehicles[this.game.rnd.integerInRange(0, 7)];
            this.randomCar.visible = true;

            if( this.game.rnd.integerInRange(1, 3) === 2 ) {
                this.randomCarTween1b.start();
            } else {
                this.randomCarTween1.start();
            }
        },
        destroy: function() {
            this.randomCar.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = LargeBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-yellow.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    // This defines the starting point and then 4 stopping points for the yellow car.
    var YELLOW_CAR_Y = [ 650, 264, 245, 237, 255 ];
    var YELLOW_CAR_X = [ 5, 569, 592, 607, 850 ];

    var YellowCar = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.yellowCar = this.game.add.sprite( 180, 70, this.theme.textureKey, this.theme.mapInfo.yellowCarFrames[0]);
            this.yellowCar.visible = false;
            this.yellowCar.anchor.setTo(0.5, 0.5);

            this.tweenScale = this.game.add.tween(this.yellowCar.scale).to( {x: 0.746, y: 0.73} , 9000, Phaser.Easing.Quintic.Out, false);
            this.yellowCarTween1 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[1], x: YELLOW_CAR_X[1] }, 9000,  Phaser.Easing.Quintic.Out, false);

            this.yellowCarTween2 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[2], x: YELLOW_CAR_X[2] }, 750,  "Linear", false, 1000);
            this.yellowCarTween2.onComplete.add(
                function() {
                    this.yellowCar.scale.setTo( 1.0, 1.0);
                    this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[1];
                }, this);
            this.yellowCarTween1.chain(this.yellowCarTween2);

            this.yellowCarTween3 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[3], x: YELLOW_CAR_X[3] }, 500,  "Linear", false);
            this.yellowCarTween3.onComplete.add(
                function() {
                    this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[2];
                }, this);
            this.yellowCarTween2.chain(this.yellowCarTween3);

            this.yellowCarTween4 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[4], x: YELLOW_CAR_X[4] }, 3000,  "Linear", false);
            this.yellowCarTween3.chain(this.yellowCarTween4);
            this.yellowCarTween4.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[0];
            this.yellowCar.y = YELLOW_CAR_Y[0];
            this.yellowCar.x = YELLOW_CAR_X[0];
            this.yellowCar.visible = true;
            this.yellowCarTween1.start();
            this.tweenScale.start();
        },
        destroy: function() {
            this.yellowCar.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = YellowCar;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\rounded-chat-rect.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/21/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This class will create a text bubble with a gradient back fill. It reproduces a series of text bubble images
 * from Flash that were nine-sliced. In this case, the nine-slice is no longer needed and we just render a
 * rounded rectangle as a mask.
 *
 * The rectangle will be padded around the font.
 *
 */
(function () {
    'use strict';
    var log = require('loglevel'),
        _ = require('lodash'),
        Base = require("basejs");

    var RoundedChatRect = Base.extend({
        constructor: function (game, theme) {
            this.game = game;
            this.theme = theme;

            var roundness = 28;
            var width = 440, height = 200;
            var x = 15, y = 10;
            var paddingX = 60, paddingY = 20;

            var bubbleGroup = this.game.add.group();
            this.bubble = bubbleGroup;

            // Create the text, which is wrapped according to the font.
            var fontHeading = _.cloneDeep(this.theme.fonts.chatText);
            fontHeading.wordWrapWidth = 460;
            var bubbleText = game.add.text((width/2) + paddingX , y + paddingY , "No text yet.", fontHeading );
            bubbleText.anchor.setTo(0.5, 0);
            this.bubbleText = bubbleText;
            this.bubbleText.lineSpacing = -4;
            this.gradients = ['#ffffff', '#ffffff'];

            // var bubbleBorderThin = this.game.add.graphics(0, 0);
            // bubbleBorderThin.lineStyle(2, 0x000000, 1);
            // bubbleBorderThin.drawRoundedRect(x+1, y+1, width, height, roundness);
            // bubbleBorderThin.endFill();
            // bubbleGroup.add(bubbleBorderThin);

            // draw the shape that contains the gradient
            // var gradientBmp = this.game.add.bitmapData(width, height);
            //
            // var gradientFill = gradientBmp.context.createLinearGradient(0, 0, width, 0);
            // gradientFill.addColorStop(0, this.gradients[0]);
            // gradientFill.addColorStop(1, this.gradients[1]);
            // gradientBmp.context.fillStyle = gradientFill;
            // gradientBmp.context.fillRect(0, 0, width, height);
            // var gradientSprite = this.game.add.sprite(x, y, gradientBmp);
            // bubbleGroup.add(gradientSprite);

            // var gradientMask = this.game.add.graphics(0, 0);
            // gradientMask.beginFill(0x000000);
            // gradientMask.drawRoundedRect(x, y, width, height, roundness); // draw a rounded rect mask
            // gradientMask.endFill();
            // bubbleGroup.add(gradientMask);

            // gradientSprite.mask = gradientMask; // apply the mask
            //
            // this.carrot = this.game.add.sprite( 454, 150, this.theme.textureKey,"speech_arrow.png");

            bubbleGroup.add(bubbleText);
            bubbleGroup.bringToTop(bubbleText);
            // bubbleGroup.add(this.carrot);

        },
        showResponse: function( response ) {
            this.bubbleText.setText( response.text.text );
        },
        show: function () {
            this.bubble.visible = true;
        },
        hide: function () {
            this.bubble.visible = false;
        },
        destroy: function () {
            this.bubble.destroy(true);
        }
    });

    module.exports = RoundedChatRect;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 10/23/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A helper class that supports setting up Tween.  Intended to be used by Actors.
 *
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var TweenHelper = Base.extend({
        constructor: function(game, actor) {
            if( !game ) {
                throw "TweenHelper requires game constructor argument.";
            }
            if( !actor ) {
                throw "TweenHelper requires actor constructor argument.";
            }
            this.game = game;
            this.actor = actor;
        },
        addTweens: function(tweenDataArray, sprite) {
            if (_.isArray(tweenDataArray)) {
                _.each(tweenDataArray, function(tweenData) { this.addTween(tweenData, sprite); }, this);
            } else {
                this.addTween(tweenDataArray, sprite);
            }
        },
        addTween: function(tweenData, sprite) {

            var tweens = {};

            var configureTweens = function(tweenData) {
                var delay = tweenData.delay ? tweenData.delay : 0;
                var easing = tweenData.easing || "Linear";
                if (tweens.spriteTween) {
                    var newValues = {};
                    if (tweenData.location) {
                        newValues.x = tweenData.location[0];
                        newValues.y = tweenData.location[1];
                    }
                    // Support for tweenData.location is here for backwards compatibility, but
                    // separate tweenData.x and tweenData.y has been added so that each dimension can be
                    // independently "tweened" if desired.
                    if (tweenData.x) {
                        newValues.x = tweenData.x;
                    }
                    if (tweenData.y) {
                        newValues.y = tweenData.y;
                    }
                    if (!_.isUndefined(tweenData.alpha)) {
                        newValues.alpha = tweenData.alpha;
                    }
                    if (!_.isUndefined(tweenData.angle)) {
                        newValues.angle = tweenData.angle;
                    }
                    if (!_.isUndefined(tweenData.rotation)) {
                        newValues.rotation = tweenData.rotation;
                    }
                    tweens.spriteTween.to(newValues, tweenData.time, easing, false, delay);
                }
                if (tweens.scaleTween) {
                    var newValues = {};
                    if (tweenData.scale) {
                        newValues.x = tweenData.scale[0];
                        newValues.y = tweenData.scale[1];
                    }
                    tweens.scaleTween.to( newValues, tweenData.time, easing, false, delay);
                }
            };

            if (tweenData.location || !_.isUndefined(tweenData.alpha)
                || !_.isUndefined(tweenData.rotation) || !_.isUndefined(tweenData.angle)
                || !_.isUndefined(tweenData.x) || !_.isUndefined(tweenData.y)) {

                tweens.spriteTween = this.game.add.tween(sprite);
            }
            if (tweenData.scale && sprite.scale) {
                tweens.scaleTween = this.game.add.tween(sprite.scale);
            }

            configureTweens(tweenData);

            if (tweenData.chainedTweens) {
                if (_.isArray(tweenData.chainedTweens)) {
                    _.each(tweenData.chainedTweens, configureTweens, this);
                } else {
                    this.configureTweens(tweenData.chainedTweens);
                }
            }

            if (tweenData.loop === true) {
                _.each(tweens, function(tween) { tween.loop(); });
            }

            if (!_.isUndefined(tweenData.yoyo)) {
                _.each(tweens, function(tween) {
                    var millis = Number(tweenData.yoyo);
                    if (!isNaN(millis)) {
                        tween.yoyo(true, millis);
                    } else if (tweenData.yoyo) {
                        tween.yoyo(true, 1000);
                    }
                });
            }

            if (!_.isUndefined(tweenData.variable)) {
                var tween = tweens.spriteTween || tweens.scaleTween;
                tween.onComplete.add(function() {
                    var varSet = {};
                    varSet[tweenData.variable] = 'complete';
                    this.actor.dispatchGameChoice(varSet);
                }, this);
            }

            _.each(tweens, function(tween) { tween.start(); });
        },
        removeTweens: function(sprite) {
            this.game.tweens.removeFrom(sprite);
            if (!_.isUndefined(sprite.scale)) {
                this.game.tweens.removeFrom(sprite.scale);
            }
        }
    });

    module.exports = TweenHelper;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-action.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * For now, just serve as a registry for actions
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs'),
        ChoiceAction = require('./actions/game-choice'),
        RemoveActorAction = require('./actions/remove-actor'),
        AddActorAction = require('./actions/add-actor'),
        CheckOutcomeAction = require('./actions/check-outcomes'),
        ChangeObjectiveAction = require('./actions/change-objective'),
        MarkCompleteAction = require('./actions/mark-complete'),
        VariableIncrementAction = require('./actions/variable-increment'),
        MhSceneAction = require('./actions/mh/mh-change-scene'),
        SceneAction = require('./actions/change-scene');

    var PlayAction = Base.extend( {
        constructor: function() {
            this.actions = {};
        },
        registerAction: function( type, action ) {
            this.actions[type] = action;
        },
        getAction: function( data ) {
            if( !data || !data.type || !this.actions[data.type] ) {
                throw "Cannot retrieve an action without an action type. { type: '..', args: [...]} ";
            }
            var clazz = this.actions[data.type];
            return new clazz( data.args );
        }
    });

    var ActionFactory = new PlayAction();
    ActionFactory.registerAction("add-actor", AddActorAction);
    ActionFactory.registerAction("check-outcomes", CheckOutcomeAction);
    ActionFactory.registerAction("choice", ChoiceAction);
    ActionFactory.registerAction("mark-complete", MarkCompleteAction);
    ActionFactory.registerAction("objective", ChangeObjectiveAction);
    ActionFactory.registerAction("remove-actor", RemoveActorAction);
    ActionFactory.registerAction("scene", SceneAction);
    ActionFactory.registerAction("variable", ChoiceAction);
    ActionFactory.registerAction("variable-increment", VariableIncrementAction);

    // Mission-Health specific actions:
    ActionFactory.registerAction("mh-scene", MhSceneAction);

    module.exports = ActionFactory;
}());

},{"./actions/add-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\add-actor.js","./actions/change-objective":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-objective.js","./actions/change-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-scene.js","./actions/check-outcomes":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\check-outcomes.js","./actions/game-choice":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js","./actions/mark-complete":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mark-complete.js","./actions/mh/mh-change-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mh\\mh-change-scene.js","./actions/remove-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\remove-actor.js","./actions/variable-increment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\variable-increment.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0
 * @creation 07/01/2015, 09/07/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a registry and construction factory for Actors; which should not be instantiated on their own, only
 * from this creation point. This creation point also works for validation purposes.
 */
(function () {
    'use strict';
    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    /* General Actors, or reusable across courses */
    var Animation = require('./actors/actor-animation');
    var Audio = require('./actors/actor-audio');
    var Blocker = require('./actors/actor-blocker');
    var Button = require('./actors/actor-button');
    var ButtonCharacter = require('./actors/actor-button-character');
    var Character = require('./actors/actor-character');
    var ClickAnimation = require('./actors/actor-click-animation');
    var Decoration = require('./actors/actor-decoration');
    var Drag = require('./actors/actor-drag');
    var Draw = require('./actors/actor-draw');
    var Drop = require('./actors/actor-drop');
    var Fadeout = require('./actors/actor-fadeout');
    var InputField = require('./actors/actor-input-field');
    var Instructions = require('./actors/actor-instruction-bubble');
    var Line = require('./actors/actor-line');
    var NoInputCharacter = require('./actors/actor-no-input-character');
    var Question = require('./actors/actor-question');
    var Rectangle = require('./actors/actor-rectangle');
    var SpeechBubble = require('./actors/actor-speech-bubble');
    var Text = require('./actors/actor-text');
    var TextBubble = require('./actors/actor-text-bubble');
    var Timeline = require('./actors/actor-timeline');
    var ToggleButton = require('./actors/actor-toggle-button');
    var UrlButtonInvisible = require('./actors/actor-url-button-invisible');
    var UrlButton = require('./actors/actor-url-button');
    var Wistia = require('./actors/actor-wistia');

    /* Actors specifically for It's UR Choice usage */
    var Chat = require('./actors/iuc/actor-chat');
    var ItsUrChoiceBook = require('./actors/iuc/actor-book');
    var ItsUrChoiceDrag = require('./actors/iuc/actor-file-drag');
    var ItsUrChoicePhone = require('./actors/iuc/actor-phone');
    var ItsUrChoicePhoneButton = require('./actors/iuc/actor-phone-button');
    var MapActor = require('./actors/iuc/actor-map');
    var PopupActor = require('./actors/iuc/actor-popup');
    var WindowActor = require('./actors/iuc/actor-window');

    /* Actors specifically for Act Now! usage */
    var Announcer = require('./actors/actnow/actor-announcer');
    var Choice = require('./actors/actnow/actor-choice');
    var ActNowPhone = require('./actors/actnow/actor-phone');
    var PhoneButton = require('./actors/actnow/actor-phone-button');
    var Spinner = require('./actors/actnow/actor-spinner');
    var Chooser = require('./actors/actnow/actor-chooser');
    var ZinkComputer = require('./actors/actnow/actor-zink-computer');
    var ZinkPoster = require('./actors/actnow/actor-zink-poster');

    var PlayActor = Base.extend( {
        constructor: function() {
            this.actors = {};
            this.actorTypes = [];
        },
        registerActor: function( type, actor ) {
            _.each( this.actorTypes, function(knownType) {
               if( knownType === type ) {
                   throw "You are registering an actor type that already exists: " + type;
               }
            });
            this.actorTypes.push(type);
            this.actors[type] = actor;
        },
        getActor: function( type ) {
            return this.actors[type];
        },
        isAvailableType: function(type) {
            var found = false;
            _.each( this.actorTypes, function(knownType) {
                if( knownType === type ) {
                    found = true;
                }
            });
            return found;
        },
        getAvailableTypes: function() {
            // Return a clone, to make it read only.
            return _.clone(this.actorTypes);
        }
    });

    var ActorFactory = new PlayActor();

    /* General Actors, or reusable across courses */
    ActorFactory.registerActor("animation", Animation );
    ActorFactory.registerActor("audio", Audio );
    ActorFactory.registerActor("blocker", Blocker );
    ActorFactory.registerActor("button", Button );
    ActorFactory.registerActor("button-character", ButtonCharacter );
    ActorFactory.registerActor("character", Character);
    ActorFactory.registerActor("click-animation", ClickAnimation);
    ActorFactory.registerActor("decoration", Decoration );
    ActorFactory.registerActor("drag", Drag );
    ActorFactory.registerActor("draw", Draw );
    ActorFactory.registerActor("drop", Drop );
    ActorFactory.registerActor("fadeout", Fadeout );
    ActorFactory.registerActor("input-field", InputField );
    ActorFactory.registerActor("instructions", Instructions );
    ActorFactory.registerActor("line", Line );
    ActorFactory.registerActor("no-input-character", NoInputCharacter );
    ActorFactory.registerActor("rectangle", Rectangle);
    ActorFactory.registerActor("speech-bubble", SpeechBubble);
    ActorFactory.registerActor("text", Text);
    ActorFactory.registerActor("text-bubble", TextBubble);
    ActorFactory.registerActor("timeline", Timeline);
    ActorFactory.registerActor("toggle-button", ToggleButton );
    ActorFactory.registerActor("url-button", UrlButton );
    ActorFactory.registerActor("url-button-invisible", UrlButtonInvisible );
    ActorFactory.registerActor("question", Question);
    ActorFactory.registerActor("video", Wistia );
    ActorFactory.registerActor("wistia", Wistia );

    /* Actors specifically for It's UR Choice usage */
    ActorFactory.registerActor("chat", Chat);
    ActorFactory.registerActor("iucbook", ItsUrChoiceBook );
    ActorFactory.registerActor("iucdrag", ItsUrChoiceDrag );
    ActorFactory.registerActor("iucphone", ItsUrChoicePhone );
    ActorFactory.registerActor("iucphone-button", ItsUrChoicePhoneButton );
    ActorFactory.registerActor("iucmap", MapActor);
    ActorFactory.registerActor("iucpopup", PopupActor);
    ActorFactory.registerActor("iucwindow", WindowActor);

    /* Actors for Act Now! usage */
    ActorFactory.registerActor("announcer", Announcer);
    ActorFactory.registerActor("choice", Choice);
    ActorFactory.registerActor("phone-button", PhoneButton );
    ActorFactory.registerActor("phone", ActNowPhone );
    ActorFactory.registerActor("spinner", Spinner);
    ActorFactory.registerActor("chooser", Chooser);
    ActorFactory.registerActor("zink-computer", ZinkComputer );
    ActorFactory.registerActor("zink-poster", ZinkPoster);

    module.exports = ActorFactory;
}());

},{"./actors/actnow/actor-announcer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-announcer.js","./actors/actnow/actor-choice":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-choice.js","./actors/actnow/actor-chooser":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-chooser.js","./actors/actnow/actor-phone":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone.js","./actors/actnow/actor-phone-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone-button.js","./actors/actnow/actor-spinner":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-spinner.js","./actors/actnow/actor-zink-computer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-computer.js","./actors/actnow/actor-zink-poster":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-poster.js","./actors/actor-animation":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-animation.js","./actors/actor-audio":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-audio.js","./actors/actor-blocker":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-blocker.js","./actors/actor-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js","./actors/actor-button-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button-character.js","./actors/actor-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-character.js","./actors/actor-click-animation":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-click-animation.js","./actors/actor-decoration":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-decoration.js","./actors/actor-drag":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drag.js","./actors/actor-draw":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-draw.js","./actors/actor-drop":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drop.js","./actors/actor-fadeout":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-fadeout.js","./actors/actor-input-field":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-input-field.js","./actors/actor-instruction-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-instruction-bubble.js","./actors/actor-line":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-line.js","./actors/actor-no-input-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-no-input-character.js","./actors/actor-question":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-question.js","./actors/actor-rectangle":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-rectangle.js","./actors/actor-speech-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-speech-bubble.js","./actors/actor-text":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text.js","./actors/actor-text-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text-bubble.js","./actors/actor-timeline":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-timeline.js","./actors/actor-toggle-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-toggle-button.js","./actors/actor-url-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button.js","./actors/actor-url-button-invisible":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button-invisible.js","./actors/actor-wistia":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-wistia.js","./actors/iuc/actor-book":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-book.js","./actors/iuc/actor-chat":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-chat.js","./actors/iuc/actor-file-drag":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-file-drag.js","./actors/iuc/actor-map":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-map.js","./actors/iuc/actor-phone":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone.js","./actors/iuc/actor-phone-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone-button.js","./actors/iuc/actor-popup":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-popup.js","./actors/iuc/actor-window":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-window.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-scene.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a "Scene" as part of an "Act". The scene contains an array of actors and deals with brokering events.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs'),
        PlayActor = require('./play-actor'),
        PlayThroughActor = require('./actors/actnow/actor-playthrough');

    var PlayScene = Base.extend( {
        constructor: function(game, data, modelInterface, theme) {
            if( !game ) {
                throw "PlayScene requires game constructor argument.";
            }
            if( !data ) {
                throw "PlayScene requires data constructor argument.";
            }
            this.initScene(game);
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal(),
                onGameMusic: new Phaser.Signal()
            };
            this.data = data;
            this.modelInterface = modelInterface;
            this.theme = theme;
            this.actors = [];
            this.delayedActors = [];
            this.isShowPlayThrough = false;
            this.playthroughActor = null;
        },
        initScene: function(game) {
            this.game = game;
            this.bgColor = this.game.add.graphics(0,0);
            this.bgColor.beginFill("0xFFFFFF");
            this.bgColor.drawRect(0,0, this.game.world.width, this.game.world.height);
            this.bgColor.endFill();
            this.bgColor._chw_name = "SceneBackgroundGraphics";
        },
        showNewSceneData: function( newData ) {
            this.data = newData;
            this.bgColor.visible = false;
            if( this.playthroughActor ) {
                this.playthroughActor.hide();
            }
            this.sceneId = newData.id;
        },
        /**
         * Show the scene to the player by setting the background and having all actors enter the scene.
         */
        showScene: function() {

            if( this.data.background !== "none") {
                if( this.background ) {
                    this.background.frameName = this.theme.sceneImages[this.data.background];
                    this.background.visible = true;
                } else {
                    this.background = this.game.add.sprite(0, 0, this.theme.textureKey, this.theme.sceneImages[this.data.background] );
                    this.background.inputEnabled = true;
                    this.game.input.disabled = true;
                }
            } else if( this.background ) {
                this.background.visible = false;
            }
            this.bgColor.visible = true;
            _.each( this.data.actors, this.addActor, this);

            /**
             * The constant 'play-through' actor.
             */
            if( this.isShowPlayThrough ) {
                this.playthroughActor.show();
            }

            if( this.data.backgroundMusic ) {
                this.events.onGameMusic.dispatch( this.data.backgroundMusic );
            }

        },
        showPlayThrough: function() {
            if( !this.playthroughActor  ) {
                this.playthroughActor  = new PlayThroughActor(this.game, this.theme);
                this.playthroughActor.setModelInterface(this.modelInterface);
                this.playthroughActor.enterScene();
            }
            this.isShowPlayThrough = true;
        },
        /**
         * Add an individual actor to the scene. The ordering is important, the actor is created, then event listeners
         * are added, and then the actor is allowed to enter the scene. We don't want an actor that immediately acts
         * to have its events ignored because the listeners weren't yet in place.
         * @param actorData
         */
        addActor: function(actorData) {
            var actorClass, actor, newActorData = actorData;
            // Actors can also be of type reference, meaning they load an actor from the set of actors outside scenes.
            if( actorData.type === "reference" ) {
                newActorData = this.modelInterface.getActorByRef( actorData.name );
            }

            actorClass = PlayActor.getActor(newActorData.type);
            actor = new actorClass(this.game, newActorData, this.theme);
            actor.setModelInterface(this.modelInterface);
            actor.clearVariables();
            // Any given actor may or may not publish these events.
            if (actor.events) {
                if (actor.events.onGameChoice) {
                    actor.events.onGameChoice.add(this.onGameChoice, this);
                }
                if (actor.events.onGameSpeech) {
                    actor.events.onGameSpeech.add(this.onGameSpeech, this);
                }
            }

            if (typeof newActorData.startDelay === "undefined") {
                this.actors.push(actor);
                actor.enterScene();
            } else {
                var delayActor = [];
                delayActor[0] = -1; // start time in ticks, to be set in tickUpdate()
                delayActor[1] = newActorData.startDelay; // in ticks (a tick is defined in main)
                delayActor[2] = actor;
                this.delayedActors.push(delayActor);
            }
        },
        /**
         * An actor has made a choice, bubble this event up to the 'act', and inform all other
         * actors of the choice so that they can adjust any internal state.
         * @param name
         * @param choice
         */
        onGameChoice: function( name, choice ) {
            this.events.onGameChoice.dispatch(  choice );

            var tempVars = _.pairs(choice)[0];
            choice.consumed = this.sceneCommand(name, tempVars[0], tempVars[1]);

            if( !choice.consumed ) {
             this.sendGameChoiceToActors(name, choice);
            }
        },
        sendGameChoiceToActors: function(name, choice) {
            // Tell any actors with a method to handle choices.
            _.each(this.actors, function (actor) {
                if (actor.getName() !== name && actor.onGameChoice) {
                    actor.onGameChoice(choice);
                }
            }, this);
        },
        /**
         * Run an Scene level command. Return true if a command happened, otherwise false.
         * @param command
         * @param arg
         * @returns {boolean} true if the command was consumed.
         */
        sceneCommand: function( actorName, command, arg) {
            log.warn("Scene command: " + command + " / " + arg);
            if( command === "dropped" ) {
                _.each( this.actors, function(actor1) {
                    if( actor1 && actor1.getType() === "drop" ) {
                        _.each( this.actors, function(actor2) {
                            if( actor2.getType() === "drag" || actor2.getType() === "iucdrag" ) {
                                if( this.game.physics.arcade.overlap( actor1.getPrimarySprite(), actor2.getPrimarySprite()) ) {
                                    actor1.onReceiveDrop(actor2.getName());
                                    return false; // exit loop.
                                }
                            }
                        }, this);
                    }
                }, this);

                return true;
            } else if( command === "mute_game") {
                _.each(this.actors, function (actor) {
                    if ( actor.data.name !== actorName && actor.data.type === "wistia" ) {
                        actor.onWistiaMute(this.game.sound.mute);
                    }
                }, this);
            }
            return false;
        },
        /**
         * An actor is showing new text (and possibly playing new audio). some actors animate others speaking, or
         * show the text/audio that an actor is speaking. So bubble the event and also tell the other actors.
         * @param name
         * @param speech
         */
        onGameSpeech: function( name, speech, sourceActor ) {
            this.events.onGameSpeech.dispatch( speech );
            if( sourceActor && sourceActor.isSoundEventInverse()  ) {
                if( sourceActor.onGameSpeech) {
                    sourceActor.onGameSpeech(speech);
                }
            } else {
                // Tell any actors with a method to handle speech changes.
                _.each(this.actors, function (actor) {
                    if (actor.data.name !== name && actor.onGameSpeech) {
                        actor.onGameSpeech(speech);
                    }
                    if ( actor.data.type === "wistia" ) {
                        actor.onGameSpeech(speech);
                    }
                }, this);
            }
        },
        /**
         * A speech stop action has occured from further up the chain, continue passing it down to each actor.
         * @param speech
         */
        onGameSpeechStop: function( speech ) {
            _.each( this.actors, function( actor ) {
                if( actor && actor.onGameSpeechStop ) {
                    actor.onGameSpeechStop( speech );
                }
            }, this);
        },
        removeActorByName: function( name ) {
            var index,
                actor = null;
            for( index = 0; index < this.actors.length; index++ ) {
                if( this.actors[index].data.name === name ) {
                    actor = this.actors[index];
                    break;
                } else {
                    log.warn(this.actors[index].data.name );
                }
            }
            if( actor ) {
                this.actors.splice(index, 1);
                this.destroyActor(actor);
            } else {
                // check for a delayed actor that hasn't been triggered yet
                for( index = 0; index < this.delayedActors.length; index++ ) {
                    var delayedActor = this.delayedActors[index][2];
                    if( delayedActor.data.name === name ) {
                        actor = delayedActor;
                        break;
                    } else {
                        log.warn(delayedActor.data.name );
                    }
                }
                if( actor ) {
                    this.delayedActors.splice(index, 1);
                    actor.destroy();
                }
            }
        },
        /**
         * Check for delayed actors. If a delayed actor's start time  in ticks has arrived, add it to the scene and
         * remove it from the delayed actors list.
         *
         * STRONG WARNING: Don't do much here - it's called from the main update loop. Any extensive operations will
         * cause the user interface to lag.
         */
        tickUpdate: function (tick) {
            for (var i = this.delayedActors.length - 1; i >= 0; i--) {
                if (this.delayedActors[i][0] < 0) {
                    // This actor's start time hasn't been set yet. Set its start time to current tick plus its delay.
                    this.delayedActors[i][0] = tick + this.delayedActors[i][1];
                }
                if (tick >= this.delayedActors[i][0] ) {
                    var actor = this.delayedActors[i][2];
                    var delay = this.delayedActors[i][1];
                    this.delayedActors.splice(i, 1); // remove it
                    //log.warn("delayed actor"
                    //    + (((typeof actor.data != "undefined") && (typeof actor.data.name != "undefined")) ? (" named \"" + actor.data.name + "\"") : "")
                    //    + (((typeof actor.data != "undefined") && (typeof actor.data.type != "undefined")) ? (" of type \"" + actor.data.type + "\"") : "")
                    //    + " entering scene after " + delay + " ticks");
                    this.actors.push(actor);
                    actor.enterScene();
                }
            }
            _.each( this.actors, function(actor1) {
                if( actor1.getType() === "drop"  ) {
                    _.each( this.actors, function(actor2) {
                        if( actor2.getType() === "drag" || actor2.getType() === "iucdrag" ) {
                            if( this.game.physics.arcade.overlap( actor1.getPrimarySprite(), actor2.getPrimarySprite()) ) {
                                actor1.onOverlapping(actor2.getName());
                                return false;
                            } else {
                                actor1.onOverlapping(null);
                            }
                        }
                    }, this);
                }
            }, this);
        },
        getActions: function() {
            return this.data.actions;
        },
        /**
         * Retrieve the keys of any additional audio this scene wants.
         * @returns {Array}
         */
        getAdditionalAudio: function() {
            var additionalAudio = [];
            _.each( this.data.actors, function( actor ) {
                if( actor.audioKey ) {
                    additionalAudio.push( actor.audioKey );
                }
            }, this);
            return additionalAudio;
        },
        destroyActor: function( actor ) {
            actor.destroy();
        },
        clearForReuse: function() {
            var actor;
            while( actor = this.actors.pop() ) {
                this.destroyActor(actor);
                actor = null;
            }
            this.actors = [];
            var delayedActorData;
            while( delayedActorData = this.delayedActors.pop() ) {
                actor = delayedActorData[2];
                actor.destroy();
                actor = null;
            }
            this.delayedActors = [];
            this.events.onGameChoice.removeAll();
            this.events.onGameSpeech.removeAll();
            this.events.onGameMusic.removeAll();
        },
        destroy: function() {
            this.clearForReuse();
            this.bgColor.destroy();
            this.background.inputEnabled = false;
            this.background.destroy();
            this.events.onGameChoice.dispose();
            this.events.onGameSpeech.dispose();
            this.events.onGameMusic.dispose();
            this.events = null;
        }
    });

    module.exports = PlayScene;
}());

},{"./actors/actnow/actor-playthrough":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-playthrough.js","./play-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-actor.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scorm.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/10/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This module is an interface to the SCORM API provided via /main/scorm/APIWrapper.js
 * Users of this module are expected to call initialize with a settings object of at least:
 * {
 *     scormEnabled: true|false
 * }
 * You do not have to enable Scorm to use this class, it will hold an internal representation for debugging
 * purposes.
 *
 */
(function () {

    var Base = require('basejs'),
        log = require('loglevel'),
        _ = require('lodash');

    // @TODO, inject scorm interface instead of assuming window.
    var Scorm = Base.extend({
        constructor: function (scormInterface) {
            this.scormInterface = scormInterface || window;
            this.sessionStartTime = new Date();
            this.interval = 0;
            this.scormAvailable = false;
            this.initSuccess = "";
            this.constants = {
                incomplete: "incomplete",
                notAttempted: "not attempted",
                complete: "completed"
            };
            /**
             * @See Scorm Runtime ENV PDF Section 3.4
             */
            this.LMSKeys = {
                lessonStatus: "cmi.core.lesson_status",
                interactionCount: "cmi.interactions._count",
                suspendData: "cmi.suspend_data",
                interactionId: "cmi.interactions.#.id",
                interactionType: "cmi.interactions.#.type", // @SEE LMSInteractionTypes below.
                interactionCorrectPattern: "cmi.interactions.#.correct_responses.0.pattern",
                interactionActualPattern: "cmi.interactions.#.student_response",
                interactionResult: "cmi.interactions.#.result", // @SEE LMSResultTypes below
                rawScore: "cmi.core.score.raw",
                sessionTime: "cmi.core.session_time",
                objectiveId: "cmi.objectives.#.id",
                objectiveStatus: "cmi.objectives.#.status" // @SEE LMSObjectiveStatusValues below
            };
            /**
             * The valid "status" field when working with cmi objectives
             * @type {Array}
             */
            this.LMSObjectiveStatusValues = [
                "passed", "completed", "failed", "incomplete", "browsed", "not attempted"
            ];
            /**
             * The valid "type" field when creating an interaction.
             * @See Scorm Runtime Env PDF Section 3.4.4
             */
            this.LMSInteractionTypes = [
                "true-false", "choice", "fill-in", "matching", "performance", "sequencing", "likert", "numeric"
            ];
            /**
             * The valid "result" field when creating an interaction.
             * @See Scorm Runtime Env PDF Section 3.4.4
             */
            this.LMSResultTypes = [
                "correct", "wrong", "unanticipated", "neutral" // and x.x
            ];
            this.LMSResultTypeNumber = /[0-9]+\.[0-9]+/; // Regular expression for #.#
            this.lessonData = {};
        },
        initialize: function (settings) {
            log.debug("Initializing SCORM CH API");
            if (settings && settings.scormEnabled) {
                log.debug("scormEnabled === true, initializing SCORM");
                if (!doLMSInitialize) {
                    log.error("The LMS Wrapper appears to be missing. Skipping SCORM Initialization.");
                    return;
                }
                this.initSuccess = doLMSInitialize();
                // error in early IE. GJF console.log("initialize success?: " + success);
                if (this.initSuccess === "true") {
                    this.scormAvailable = true;
                    log.debug("SCORM initialized from SCORM CH API successfully.");
                    // Create a "that" closure for the window function. GJF.
                    var that = this;
                    window.onbeforeunload = function () {
                        window.clearInterval(that.interval);
                        doLMSFinish();
                    };

                    this.sessionStartTime = new Date();
                } else {
                    log.error("SCORM initialize from SCORM CH API, FAILED!");
                    alert("Could not initialize SCORM API.");
                }
            } else {
                log.warn("scormEnabled === false, skipping SCORM");
            }
        },
        initializeStatus: function () {
            if (this.scormAvailable) {
                var status = doLMSGetValue(this.LMSKeys.lessonStatus);
                if (!status || status === this.constants.notAttempted) {
                    this.setLessonStatus(this.constants.incomplete);
                }
            } else {
                this.setLessonStatus(this.constants.incomplete);
            }
        },
        setLessonStatus: function (status) {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.lessonStatus, status);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.lessonStatus] = status;
            }
        },
        getLessonStatus: function () {
            var status = "";
            if (this.scormAvailable) {
                status = doLMSGetValue(this.LMSKeys.lessonStatus);
            } else {
                status = this.lessonData[this.LMSKeys.lessonStatus];
            }
            return status;
        },
        isLessonComplete: function () {
            return this.getLessonStatus() === this.constants.complete;
        },
        getObjective: function( index ) {
            var id, status;
            if (this.scormAvailable) {
                id = doLMSGetValue((this.LMSKeys.objectiveId).replace("#", index));
                status = doLMSGetValue((this.LMSKeys.objectiveStatus).replace("#", index));
            } else {
                id = this.lessonData[(this.LMSKeys.objectiveId).replace("#", index)];
                status = this.lessonData[(this.LMSKeys.objectiveStatus).replace("#", index)];
            }
            var temp = {
                index: index,
                id: id,
                status: status
            };
            log.debug(temp);
            return temp;
        },
        setObjective: function( index, id, status) {
            log.debug("Set objective " + index + " " + id + " " + status );
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue((this.LMSKeys.objectiveId).replace("#", index), id);
                doLMSSetValue((this.LMSKeys.objectiveStatus).replace("#", index), status);
                doLMSCommit();
            } else {
                 this.lessonData[(this.LMSKeys.objectiveId).replace("#", index)] = id;
                 this.lessonData[(this.LMSKeys.objectiveStatus).replace("#", index)] = status;
            }
        },
        getInteractionCount: function () {
            var count = 0;
            if (this.scormAvailable) {
                count = doLMSGetValue(this.LMSKeys.interactionCount);
            } else {
                count = this.lessonData[this.LMSKeys.interactionCount] || 0; // default to 0.
            }
            return Number(count);
        },
        createInteraction: function (index, id, type, correctResponse, studentResponse, result) {
            // Allow the user to pass in an object with these values instead of all of the values directly.
            log.debug(index);
            if (typeof index === "object") {
                id = index.id;
                type = index.type;
                correctResponse = index.correctResponse;
                studentResponse = index.studentResponse;
                result = index.result;
                index = index.index;
            }
            if (type && !(_.contains(this.LMSInteractionTypes, type))) {
                throw "Invalid LMSInteractionType: " + type;
            }
            if (result && !( _.contains(this.LMSResultTypes,result)) && !result.match(this.LMSResultTypeNumber)) {
                throw "Invalid LMSResultType: " + result;
            }
            id = this.trimString(id, 255);
            id = this.replaceSpaces(id, "_");
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue((this.LMSKeys.interactionId).replace("#", index), id);
                doLMSSetValue((this.LMSKeys.interactionType).replace("#", index), type);
                doLMSSetValue((this.LMSKeys.interactionCorrectPattern).replace("#", index), correctResponse);
                doLMSSetValue((this.LMSKeys.interactionActualPattern).replace("#", index), studentResponse);
                doLMSSetValue((this.LMSKeys.interactionResult).replace("#", index), result);
                doLMSCommit();
            } else {
                this.lessonData[(this.LMSKeys.interactionId).replace("#", index)] = id;
                this.lessonData[(this.LMSKeys.interactionType).replace("#", index)] = type;
                this.lessonData[(this.LMSKeys.interactionCorrectPattern).replace("#", index)] = correctResponse;
                this.lessonData[(this.LMSKeys.interactionActualPattern).replace("#", index)] = studentResponse;
                this.lessonData[(this.LMSKeys.interactionResult).replace("#", index)] = result;
            }
        },
        setSuspendData: function (data) {
            if (this.scormAvailable) {
                log.debug("Setting suspend data");
                log.debug(data);
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.suspendData, data);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.suspendData] = data;
            }
        },
        getSuspendData: function () {
            var data = "";
            if (this.scormAvailable) {
                data = doLMSGetValue(this.LMSKeys.suspendData);
            } else {
                data = this.lessonData[this.LMSKeys.suspendData];
            }
            return data;
        },
        markComplete: function () {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.lessonStatus, this.constants.complete);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.lessonStatus] = this.constants.complete;
            }
        },
        setRawScore: function (score) {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.rawScore, score);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.rawScore] = score;
            }
        },
        getRawScore: function () {
            var score = 0;
            if (this.scormAvailable) {
                score = doLMSGetValue(this.LMSKeys.rawScore);
            } else {
                score = this.lessonData[this.LMSKeys.rawScore];
            }
            return score;
        },
        computeSessionTime: function () {
            var timeNow = new Date();
            var timeDifference = timeNow.getTime() - this.sessionStartTime.getTime();
            var dateDifference = new Date(timeDifference);
            //console.log("session time set to: " + formattedTime)
            return this.formatDateForSCORM(dateDifference);
        },
        formatDateForSCORM: function (date) {
            var totalTime = "";
            var hr = date.getUTCHours();
            var min = date.getUTCMinutes();
            var sec = date.getUTCSeconds();

            if (hr < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + hr + ":";
            if (min < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + min + ":";
            if (sec < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + sec;

            return totalTime;
        },
        trimString: function (str, toLength) {
            if (str.length > toLength) {
                str = str.substr(0, toLength);
            }
            return str;
        },
        replaceSpaces: function (str, replacement) {
            return str.replace(/\s/g, replacement);
        },
        getLessonData: function () {
            return this.lessonData;
        }
    });

    module.exports = Scorm;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\boot.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/21/15
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The boot state configures the game based on the device loading it. The basic game data is loaded so
 * that the preload state has all prerequisites. The settings
 */
(function () {
	"use strict";
	var Base = require("basejs");

	var BootState = Base.extend({
		constructor: function (settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.loading_image_url ||
				!settings.play_json_key ||
				!settings.play_json_url ||
				!settings.preload_state_name
			) {
				throw "Boot State is missing a required configuration field.";
			}

			this.settings = settings;
			this.ready = false;
		},
		/**
		 * called first before preload.
		 */
		init: function () {
			this.ready = false;
			this.game.input.maxPointers = 1;
			// Don't pause the game when the mouse leaves.
			this.game.stage.disableVisibilityChange = true;
			//this.game.scale.pageAlignHorizontally = true;
			this.game.scale.refresh();

			if (typeof PhaserInput !== "undefined") {
				this.game.plugins.add(PhaserInput.Plugin);
			}
		},
		/**
		 * In order to show the loading image while all of the resources load, it gets loaded during the
		 * boot state, so that it is available during preload of the preload state.
		 */
		preload: function () {
			this.game.load.image(
				this.settings.loading_image_key,
				this.settings.loading_image_url
			);
			this.game.load.text(
				this.settings.play_json_key,
				this.settings.play_json_url
			);
			this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
		},
		loadComplete: function () {
			var playJsonData = this.game.cache.getText(this.settings.play_json_key);
			var config = JSON.parse(playJsonData);
			/*if(config.autoScale){
                window.addEventListener("resize", this.onResize.bind(this));
                this.onResize();
            }*/
			this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
			this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;

			this.game.state.start(this.settings.preload_state_name);
		},
		/**
		 * Scales the gameContainer so that it does not exceed the inner browser width or height
		 */
		/*onResize: function(){
            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;
            var windowRatio = windowWidth / windowHeight;
            var gameContainer = document.querySelector("#gameContainer");
            var boxRatio = this.game.world.width / this.game.world.height;
            if(windowRatio < boxRatio){
                gameContainer.style.width = windowWidth + "px";
                gameContainer.style.height = (windowWidth / boxRatio) + "px";
            }else{
                gameContainer.style.width = (windowHeight * boxRatio) + "px";
                gameContainer.style.height = windowHeight + "px";
            }
        }*/
	});

	module.exports = BootState;
})();

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\main.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/22/15
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the main state. It will be restarted every time an Act changes. The responsibility of this state is to
 * allow the current Act to load media before starting. Everything is done via the Play, no act should be
 * referenced or instantiated here.
 */
(function () {
    'use strict';
    var log = require('loglevel'),
        LoadingScreen = require('../loading-screen'),
        Base = require('basejs');

    var MainState = Base.extend({
        constructor: function (settings) {
            if (!settings
                || !settings.loading_image_key ) {
                throw "Main state is missing a required configuration field.";
            }

            this.settings = settings;
        },
        /**
         * Called before preload, during each restart.
         * @param isRestart true if being called as part of a restart.
         */
        init: function (isRestart) {
            log.info("Main state created");
            if( !this.game.loadingScreen ) {
                this.game.loadingScreen = new LoadingScreen(this.game, this.settings);
            }
            this.ready = false;
            this.isRestart = isRestart; // we are restarting this state due to act change.
        },
        /**
         * Called after init. This is where media can be downloaded.
         */
        preload: function () {
            this.game.loadingScreen.show();
            this.game.play.preloadAct();
            this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
        },
        loadComplete: function() {
            this.game.loadingScreen.showComplete();
        },
        /**
         * Called when preload is complete, all media is downloaded. (But we'll check ourselves anyways)
         */
        create: function () {
        },
        /**
         * Render is called each game tick to allow the application to render anything 'on top' such as a HUD.
         * Used here for debugging.
         */
        render: function () {
            this.game.play.renderDebug();
        },
        /**
         * Called each game tick, used to manually check the media state and then start. Otherwise it passes the
         * update along to the Play.
         */
        update: function () {
            if (this.ready === true) {
                this.game.play.tickUpdate(this.game.time.now);
            } else if (this.game.play.isPreloadActComplete() === true) {
                this.ready = true;
                this.game.play.showNextAct(this.isRestart);
                this.game.play.sendCrossActVariables();
                this.game.loadingScreen.destroy();
            }
        }
    });

    module.exports = MainState;
}());
},{"../loading-screen":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\preload.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/21/15
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The preload state shows the loading screen while it processes all of the themes and scene data for each
 * act entry in the play.
 */
(function () {
	"use strict";
	var log = require("loglevel"),
		Base = require("basejs"),
		Play = require("../play/play"),
		LoadingScreen = require("../loading-screen"),
		_ = require("lodash");

	var PreloadState = Base.extend({
		constructor: function (settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.play_json_key ||
				!settings.main_state_name
			) {
				throw "Preload state is missing a required configuration field.";
			}

			this.settings = settings;
		},
		/**
		 * This is called before preload. Just record that things aren't complete yet.
		 */
		init: function () {
			this.loadingScreen = new LoadingScreen(this.game, this.settings);
			this.ready = false;

			var playJsonData = this.game.cache.getText(this.settings.play_json_key);
			if (!playJsonData) {
				throw "Error in Preload: Did not find play json data in cache.";
			}
			this.game.play = new Play(
				this.game,
				JSON.parse(playJsonData),
				this.settings
			);
		},
		/**
		 * Show the preload image, allow the Play to load data.
		 */
		preload: function () {
			if (this.game.play.isLogging() === true) {
				log.enableAll();
				log.warn("Logging Enabled");
			} else {
				log.disableAll();
			}
			this.loadingScreen.show();
			var preloadSet = this.game.play.getRequiredResourceList();
			_.each(
				preloadSet,
				function (preloadItem) {
					this.game.load.text(preloadItem.key, preloadItem.file);
				},
				this
			);
			this.game.load.audio("audioFix", [
				this.game.config.assetPath + "engine/silence-m4a.m4a",
				this.game.config.assetPath + "engine/silence-ogg.ogg",
			]);
			this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
		},
		/**
		 * Called when preload is complete, all media is downloaded. (But we'll check ourselves anyways)
		 */
		create: function () {
			this.loadingScreen.showClickthrough();
			// this.loadingScreen.showComplete();
			//this.loadingScreen.destroy();
		},
		loadComplete: function () {
			this.game.scorm.initialize({
				scormEnabled: _environmentSettings.scormEnabled,
				//scormEnabled: this.game.play.isScormEnabled(),
			});
			this.game.scorm.initializeStatus();
			this.game.play.loadScormData();
			this.game.play.selectDefaultAct();
			var audioFix = this.game.add.audio("audioFix");
			this.game.input.onTap.add(function () {
				audioFix.play();
				this.state.start(this.settings.main_state_name);
			}, this);
			//this.state.start(this.settings.main_state_name); // The "Play" can also do this.
		},
	});

	module.exports = PreloadState;
})();

},{"../loading-screen":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js","../play/play":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\play.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This file exists so that startup of an engine can be controlled. This file is simply a stub that works to
 * build the engine and then start it. This means that the engine can be loaded without it starting for
 * purposes of testing, debugging, and adding any code that comes up that happens before/after the engine is
 * done.
 */
(function () {
    module.exports = require('./engine/scene-engine');

    if (!String.prototype.startsWith) {
        (function() {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function() {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                } catch(error) {}
                return result;
            }());
            var toString = {}.toString;
            var startsWith = function(search) {
                if (this === null) {
                    throw TypeError();
                }
                var string = String(this);
                if (search && toString.call(search) === '[object RegExp]') {
                    throw TypeError();
                }
                var stringLength = string.length;
                var searchString = String(search);
                var searchLength = searchString.length;
                var position = arguments.length > 1 ? arguments[1] : undefined;
                // `ToInteger`
                var pos = position ? Number(position) : 0;
                if (pos !== pos) { // better `isNaN`
                    pos = 0;
                }
                var start = Math.min(Math.max(pos, 0), stringLength);
                // Avoid the `indexOf` call if no match is possible
                if (searchLength + start > stringLength) {
                    return false;
                }
                var index = -1;
                while (++index < searchLength) {
                    if (string.charCodeAt(start + index) !== searchString.charCodeAt(index)) {
                        return false;
                    }
                }
                return true;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'startsWith', {
                    'value': startsWith,
                    'configurable': true,
                    'writable': true
                });
            } else {
                String.prototype.startsWith = startsWith;
            }
        }());
    }
}());

},{"./engine/scene-engine":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene-engine.js"}]},{},["C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js"])("C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js")
});

//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZWpzL0Jhc2UuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvYXVkaW8tY2hhbm5lbC5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvYXVkaW8tc2VydmljZS5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvcGxheS1hY3QtbWFuYWdlci5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvcGxheS1hY3QuanMiLCJzcmMvbWFpbi9lbmdpbmUvYWN0L3ZhbGlkYXRvci5qcyIsInNyYy9tYWluL2VuZ2luZS9sb2FkaW5nLXNjcmVlbi5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVsLmpzIiwic3JjL21haW4vZW5naW5lL3BsYXkvbW9kZWxzL2FjdG5vdy5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVscy9iYXNpYy5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVscy9tb2RlbC1yZWdpc3RyeS5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L3BsYXkuanMiLCJzcmMvbWFpbi9lbmdpbmUvcGxheS9zY29ybS1zZXJ2aWNlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lLWVuZ2luZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2FkZC1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2NoYW5nZS1vYmplY3RpdmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0aW9ucy9jaGFuZ2Utc2NlbmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0aW9ucy9jaGVjay1vdXRjb21lcy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2dhbWUtY2hvaWNlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdGlvbnMvbWFyay1jb21wbGV0ZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL21oL21oLWNoYW5nZS1zY2VuZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL3JlbW92ZS1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL3ZhcmlhYmxlLWluY3JlbWVudC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWFubm91bmNlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWNob2ljZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWNob29zZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLXBsYXl0aHJvdWdoLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rub3cvYWN0b3Itc3Bpbm5lci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLXppbmstY29tcHV0ZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci16aW5rLXBvc3Rlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYW5pbWF0aW9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1hdWRpby5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYmxvY2tlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYnV0dG9uLWNoYXJhY3Rlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYnV0dG9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1jaGFyYWN0ZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLWNsaWNrLWFuaW1hdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZGVjb3JhdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJhZy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJhdy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJvcC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZmFkZW91dC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItaW5wdXQtZmllbGQuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLWluc3RydWN0aW9uLWJ1YmJsZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItbGluZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3Itbm8taW5wdXQtY2hhcmFjdGVyLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1xdWVzdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItcmVjdGFuZ2xlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1zcGVlY2gtYnViYmxlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci10ZXh0LWJ1YmJsZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItdGV4dC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItdGltZWxpbmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLXRvZ2dsZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLXVybC1idXR0b24taW52aXNpYmxlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci11cmwtYnV0dG9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci13aXN0aWEuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvYWN0b3ItYm9vay5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL2FjdG9yLWNoYXQuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1maWxlLWRyYWcuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1tYXAuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1waG9uZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1waG9uZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL2FjdG9yLXBvcHVwLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvYWN0b3Itd2luZG93LmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvbWFwL2FjdG9yLWJpcmQtbGFyZ2UuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9tYXAvYWN0b3ItYmlyZC1zbWFsbC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL21hcC9hY3Rvci1jYXItYmFzaWMuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9tYXAvYWN0b3ItY2FyLXllbGxvdy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL3JvdW5kZWQtY2hhdC1yZWN0LmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy90d2Vlbi1oZWxwZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvcGxheS1hY3Rpb24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvcGxheS1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9wbGF5LXNjZW5lLmpzIiwic3JjL21haW4vZW5naW5lL3Njb3JtLmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9ib290LmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9tYWluLmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9wcmVsb2FkLmpzIiwic3JjL21haW4vbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzEvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gIEJhc2VkIG9uIEJhc2UuanMgMS4xYSAoYykgMjAwNi0yMDEwLCBEZWFuIEVkd2FyZHNcbiAgVXBkYXRlZCB0byBwYXNzIEpTSGludCBhbmQgY29udmVydGVkIGludG8gYSBtb2R1bGUgYnkgS2VubmV0aCBQb3dlcnNcbiAgTGljZW5zZTogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiovXG4vKmdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSovXG4vKmpzaGludCBlcWVxZXE6dHJ1ZSovXG4oZnVuY3Rpb24gKG5hbWUsIGdsb2JhbCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcpIHtcbiAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsW25hbWVdID0gZGVmaW5pdGlvbigpO1xuICB9XG59KSgnQmFzZScsIHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgLy8gQmFzZSBPYmplY3RcbiAgdmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvLyBJbXBsZW1lbnRhdGlvblxuICBCYXNlLmV4dGVuZCA9IGZ1bmN0aW9uIChfaW5zdGFuY2UsIF9zdGF0aWMpIHsgLy8gc3ViY2xhc3NcbiAgICB2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuICAgIC8vIGJ1aWxkIHRoZSBwcm90b3R5cGVcbiAgICBCYXNlLl9wcm90b3R5cGluZyA9IHRydWU7XG4gICAgdmFyIHByb3RvID0gbmV3IHRoaXMoKTtcbiAgICBleHRlbmQuY2FsbChwcm90bywgX2luc3RhbmNlKTtcbiAgICBwcm90by5iYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2FsbCB0aGlzIG1ldGhvZCBmcm9tIGFueSBvdGhlciBtZXRob2QgdG8gaW52b2tlIHRoYXQgbWV0aG9kJ3MgYW5jZXN0b3JcbiAgICB9O1xuICAgIGRlbGV0ZSBCYXNlLl9wcm90b3R5cGluZztcbiAgICAvLyBjcmVhdGUgdGhlIHdyYXBwZXIgZm9yIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgIC8vdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IudmFsdWVPZigpOyAvLy1kZWFuXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG4gICAgdmFyIGtsYXNzID0gcHJvdG8uY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghQmFzZS5fcHJvdG90eXBpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY29uc3RydWN0aW5nIHx8IHRoaXMuY29uc3RydWN0b3IgPT09IGtsYXNzKSB7IC8vIGluc3RhbnRpYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2NvbnN0cnVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbnN0cnVjdGluZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSAhPT0gbnVsbCkgeyAvLyBjYXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gKGFyZ3VtZW50c1swXS5leHRlbmQgfHwgZXh0ZW5kKS5jYWxsKGFyZ3VtZW50c1swXSwgcHJvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAvLyBidWlsZCB0aGUgY2xhc3MgaW50ZXJmYWNlXG4gICAga2xhc3MuYW5jZXN0b3IgPSB0aGlzO1xuICAgIGtsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xuICAgIGtsYXNzLmZvckVhY2ggPSB0aGlzLmZvckVhY2g7XG4gICAga2xhc3MuaW1wbGVtZW50ID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAga2xhc3MucHJvdG90eXBlID0gcHJvdG87XG4gICAga2xhc3MudG9TdHJpbmcgPSB0aGlzLnRvU3RyaW5nO1xuICAgIGtsYXNzLnZhbHVlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuICh0eXBlID09PSAnb2JqZWN0JykgPyBrbGFzcyA6IGNvbnN0cnVjdG9yLnZhbHVlT2YoKTtcbiAgICB9O1xuICAgIGV4dGVuZC5jYWxsKGtsYXNzLCBfc3RhdGljKTtcbiAgICAvLyBjbGFzcyBpbml0aWFsaXphdGlvblxuICAgIGlmICh0eXBlb2Yga2xhc3MuaW5pdCA9PT0gJ2Z1bmN0aW9uJykga2xhc3MuaW5pdCgpO1xuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICBCYXNlLnByb3RvdHlwZSA9IHtcbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzb3VyY2UsIHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgLy8gZXh0ZW5kaW5nIHdpdGggYSBuYW1lL3ZhbHVlIHBhaXJcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdGhpc1tzb3VyY2VdO1xuICAgICAgICBpZiAoYW5jZXN0b3IgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgLy8gb3ZlcnJpZGluZyBhIG1ldGhvZD9cbiAgICAgICAgLy8gdGhlIHZhbHVlT2YoKSBjb21wYXJpc29uIGlzIHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgKCFhbmNlc3Rvci52YWx1ZU9mIHx8IGFuY2VzdG9yLnZhbHVlT2YoKSAhPT0gdmFsdWUudmFsdWVPZigpKSAmJiAvXFxiYmFzZVxcYi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gICAgICAgICAgdmFyIG1ldGhvZCA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICAgIHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5iYXNlIHx8IEJhc2UucHJvdG90eXBlLmJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gcHJldmlvdXM7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBwb2ludCB0byB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgICAgICAgICB2YWx1ZS52YWx1ZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9PT0gJ29iamVjdCcpID8gdmFsdWUgOiBtZXRob2Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YWx1ZS50b1N0cmluZyA9IEJhc2UudG9TdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tzb3VyY2VdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSkgeyAvLyBleHRlbmRpbmcgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbFxuICAgICAgICB2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuICAgICAgICAvLyBpZiB0aGlzIG9iamVjdCBoYXMgYSBjdXN0b21pemVkIGV4dGVuZCBtZXRob2QgdGhlbiB1c2UgaXRcbiAgICAgICAgaWYgKCFCYXNlLl9wcm90b3R5cGluZyAmJiB0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGV4dGVuZCA9IHRoaXMuZXh0ZW5kIHx8IGV4dGVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgICAgdG9Tb3VyY2U6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZG8gdGhlIFwidG9TdHJpbmdcIiBhbmQgb3RoZXIgbWV0aG9kcyBtYW51YWxseVxuICAgICAgICB2YXIgaGlkZGVuID0gWydjb25zdHJ1Y3RvcicsICd0b1N0cmluZycsICd2YWx1ZU9mJ107XG4gICAgICAgIC8vIGlmIHdlIGFyZSBwcm90b3R5cGluZyB0aGVuIGluY2x1ZGUgdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgIGZvciAodmFyIGkgPSBCYXNlLl9wcm90b3R5cGluZyA/IDAgOiAxOyBpIDwgaGlkZGVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGggPSBoaWRkZW5baV07XG4gICAgICAgICAgaWYgKHNvdXJjZVtoXSAhPT0gcHJvdG9baF0pXG4gICAgICAgICAgICBleHRlbmQuY2FsbCh0aGlzLCBoLCBzb3VyY2VbaF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgZWFjaCBvZiB0aGUgc291cmNlIG9iamVjdCdzIHByb3BlcnRpZXMgdG8gdGhpcyBvYmplY3RcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmICghcHJvdG9ba2V5XSkgZXh0ZW5kLmNhbGwodGhpcywga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvLyBpbml0aWFsaXplXG4gIEJhc2UgPSBCYXNlLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZXh0ZW5kKGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICB9LCB7XG4gICAgYW5jZXN0b3I6IE9iamVjdCxcbiAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAob2JqZWN0LCBibG9jaywgY29udGV4dCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAodGhpcy5wcm90b3R5cGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYmxvY2suY2FsbChjb250ZXh0LCBvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbXBsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0XG4gICAgICAgICAgYXJndW1lbnRzW2ldKHRoaXMucHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgdGhlIGludGVyZmFjZSB1c2luZyB0aGUgZXh0ZW5kIG1ldGhvZFxuICAgICAgICAgIHRoaXMucHJvdG90eXBlLmV4dGVuZChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJldHVybiBCYXNlIGltcGxlbWVudGF0aW9uXG4gIHJldHVybiBCYXNlO1xufSk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjRcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTA0LTI4VDE2OjAxWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXG5cbnZhciBhcnIgPSBbXTtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHR2ZXJzaW9uID0gXCIyLjEuNFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAob2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKyAxKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxuXHRcdC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9IFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggb2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjAtcHJlXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA4LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMTItMTZcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHQvLyBQcm9wZXIgc3ludGF4OiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncjXCIgKSxcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3KlwiICkgKyBcIilcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcblx0XHQvLyBRU0EgdmFyc1xuXHRcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xuXG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0aWYgKCAhc2VlZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgd2hlbiBwb3NzaWJsZSAoZS5nLiwgbm90IHVuZGVyIERvY3VtZW50RnJhZ21lbnQpXG5cdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFFTQSBwYXRoXG5cdFx0aWYgKCBzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0bmlkID0gb2xkID0gZXhwYW5kbztcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdGlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpICkge1xuXHRcdFx0XHRcdG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcblxuXHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gU2V0IG91ciBkb2N1bWVudFxuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIFN1cHBvcnQgdGVzdHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jLnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2MgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMV07XG5cblx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBubyBzZWVkIGFuZCBvbmx5IG9uZSBncm91cFxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0cnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICgvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8pO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID49IDAgKSAhPT0gbm90O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkpO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiYgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWzFdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciBtYXRjaGVkID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBXZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbMF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBjYW4gaGF2ZSBkYXRhXG4gKi9cbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LFxuXHQvLyBPbGQgV2ViS2l0IGRvZXMgbm90IGhhdmUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zL2ZyZWV6ZSBtZXRob2QsXG5cdC8vIHJldHVybiBuZXcgZW1wdHkgb2JqZWN0IGluc3RlYWQgd2l0aCBubyBbW3NldF1dIGFjY2Vzc29yXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5jYWNoZSA9IHt9LCAwLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXHRrZXk6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gdGhlIGtleSBmb3IgYSBmcm96ZW4gb2JqZWN0LlxuXHRcdGlmICggIURhdGEuYWNjZXB0cyggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBkZXNjcmlwdG9yID0ge30sXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XG5cdFx0XHR1bmxvY2sgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF1bmxvY2sgKSB7XG5cdFx0XHR1bmxvY2sgPSBEYXRhLnVpZCsrO1xuXG5cdFx0XHQvLyBTZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHsgdmFsdWU6IHVubG9jayB9O1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggb3duZXIsIGRlc2NyaXB0b3IgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0XG5cdFx0XHQvLyBGYWxsYmFjayB0byBhIGxlc3Mgc2VjdXJlIGRlZmluaXRpb25cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHVubG9jaztcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggb3duZXIsIGRlc2NyaXB0b3IgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxuXHRcdGlmICggIXRoaXMuY2FjaGVbIHVubG9jayBdICkge1xuXHRcdFx0dGhpcy5jYWNoZVsgdW5sb2NrIF0gPSB7fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5sb2NrO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFwib3duZXJcIiwgY3JlYXRlIG9uZSBpbmxpbmVcblx0XHRcdC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZVsgdW5sb2NrIF07XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcblx0XHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIHRoaXMuY2FjaGVbIHVubG9jayBdLCBkYXRhICk7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0Ly8gRWl0aGVyIGEgdmFsaWQgY2FjaGUgaXMgZm91bmQsIG9yIHdpbGwgYmUgY3JlYXRlZC5cblx0XHQvLyBOZXcgY2FjaGVzIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHVubG9jayByZXR1cm5lZCxcblx0XHQvLyBhbGxvd2luZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBuZXdseSBjcmVhdGVkXG5cdFx0Ly8gZW1wdHkgZGF0YSBvYmplY3QuIEEgdmFsaWQgb3duZXIgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQuXG5cdFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZVsgdGhpcy5rZXkoIG93bmVyICkgXTtcblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRjYWNoZSA6IGNhY2hlWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKGtleSkgKTtcblx0XHR9XG5cblx0XHQvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoXG5cdFx0XHR0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXSB8fCB7fVxuXHRcdCk7XG5cdH0sXG5cdGRpc2NhcmQ6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRpZiAoIG93bmVyWyB0aGlzLmV4cGFuZG8gXSApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn07XG52YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFfdXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFfdXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfdXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhX3VzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YV9wcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhX3VzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSlcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0pKCk7XG52YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDtcblxuXG5cbnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxuXHRyZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkkLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gc3RydW5kZWZpbmVkICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YV9wcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0alF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YV9wcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTUrXG5qUXVlcnkuZWFjaCh7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHtcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuXHRcdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSApIHtcblx0XHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vbiggdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblx0XHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggb25lID09PSAxICkge1xuXHRcdFx0b3JpZ0ZuID0gZm47XG5cdFx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID8gaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDogaGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLFxuXG5cdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG5cdHdyYXBNYXAgPSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogMS54IGNvbXBhdGliaWxpdHlcbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YV9wcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YV9wcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YV9wcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhX3VzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhX3VzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YV91c2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdCwgUGhhbnRvbUpTXG5cdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IG5vZGVzWyBpKysgXSkgKSB7XG5cblx0XHRcdC8vICM0MDg3IC0gSWYgb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBlbGVtZW50cyBhcmUgdGhlIHNhbWUsIGFuZCB0aGlzIGlzXG5cdFx0XHQvLyB0aGF0IGVsZW1lbnQsIGRvIG5vdCBkbyBhbnl0aGluZ1xuXHRcdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZnJhZ21lbnQ7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsIGtleSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zWyBpIF0pICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0a2V5ID0gZWxlbVsgZGF0YV9wcml2LmV4cGFuZG8gXTtcblxuXHRcdFx0XHRpZiAoIGtleSAmJiAoZGF0YSA9IGRhdGFfcHJpdi5jYWNoZVsga2V5IF0pICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRhdGFfcHJpdi5jYWNoZVsga2V5IF0gKSB7XG5cdFx0XHRcdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcblx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGB1c2VyYCBkYXRhXG5cdFx0XHRkZWxldGUgZGF0YV91c2VyLmNhY2hlWyBlbGVtWyBkYXRhX3VzZXIuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgdGhpcyApIDogdGhpcyxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmcgPSBhcmd1bWVudHNbIDAgXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRhcmcgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cblx0XHRcdGlmICggYXJnICkge1xuXHRcdFx0XHRhcmcucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpXG5cdFx0cmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHRcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2V0ID0gdGhpcyxcblx0XHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5kb21NYW5pcCggYXJncywgY2FsbGJhY2sgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggbCApIHtcblx0XHRcdGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApO1xuXHRcdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZpcnN0ICkge1xuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0XHRcdFx0XHQvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCB0aGlzWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWRhdGFfcHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiYgalF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIHN0eWxlLFxuXHRcdGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdC8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50XG5cdFx0ZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoIHN0eWxlID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKSApID9cblxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdGltaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZyxcblx0XHRcdC8vIHNpbmNlIGl0IHdhcyByZW1vdmVkIGZyb20gc3BlY2lmaWNhdGlvbiBhbmQgc3VwcG9ydGVkIG9ubHkgaW4gRkZcblx0XHRcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHRpZiAoIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cdH1cblxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPCA2XG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcblx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCxcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1wiICtcblx0XHRcInBvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKSB7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO1wiICtcblx0XHRcdFwiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogbm9kZS5qcyBqc2RvbVxuXHQvLyBEb24ndCBhc3N1bWUgdGhhdCBnZXRDb21wdXRlZFN0eWxlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3Rcblx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHRcdH0sXG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdFx0fSxcblx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHRcdHZhciByZXQsXG5cdFx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KSgpO1xuXG5cbi8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnMuXG5qUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhclxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKC4qKSRcIiwgXCJpXCIgKSxcblx0cnJlbE51bSA9IG5ldyBSZWdFeHAoIFwiXihbKy1dKT0oXCIgKyBwbnVtICsgXCIpXCIsIFwiaVwiICksXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuXHRcdG9yaWdOYW1lID0gbmFtZSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3JpZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgZXh0cmEgP1xuXHRcdFx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9XG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxuXHRhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cdHR3ZWVuZXJzID0ge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICksXG5cdFx0XHRcdHRhcmdldCA9IHR3ZWVuLmN1cigpLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR1bml0ID0gcGFydHMgJiYgcGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdFx0XHRzdGFydCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0ICkgJiZcblx0XHRcdFx0XHRyZnhudW0uZXhlYyggalF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCApICksXG5cdFx0XHRcdHNjYWxlID0gMSxcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDIwO1xuXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XG5cdFx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbIDMgXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHRcdHBhcnRzID0gcGFydHMgfHwgW107XG5cblx0XHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDE7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRcdFx0c3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKCksXG5cdFx0XHRcdC8vIGJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcblx0XHRcdFx0fSB3aGlsZSAoIHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoIHBhcnRzICkge1xuXHRcdFx0XHRzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcblx0XHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sgMSBdID9cblx0XHRcdFx0XHRzdGFydCArICggcGFydHNbIDEgXSArIDEgKSAqIHBhcnRzWyAyIF0gOlxuXHRcdFx0XHRcdCtwYXJ0c1sgMiBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH07XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9KTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3cgYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9KSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9KSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9KVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59KSgpO1xuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59KTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgfHwgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRlbGVtLnRhYkluZGV4IDpcblx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59KTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHQvLyBUaGUgZGlzanVuY3Rpb24gaGVyZSBpcyBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIHJlbW92ZUNsYXNzKVxuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiIFwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0cHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPj0gMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKCBjdXIgKSA6IFwiXCI7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIG9wdGlvbi52YWx1ZSwgdmFsdWVzICkgPj0gMCkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxualF1ZXJ5LmVhY2goIChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH0sXG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0pO1xuXG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24uaHJlZixcblxuXHQvLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcblx0YWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkgKSB7XG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbMF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSk7XG5cdH07XG59KTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogdXJsLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9KTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9KS5nZXQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufTtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cdFx0Ly8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbi8vIFNlZSBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi8yODU2NzQ2IGZvciBtb3JlIGluZm9cbmlmICggd2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRpZCA9ICsreGhySWQ7XG5cblx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaWQgXTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gKCMxMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSBcInN0cmluZ1wiID8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHR9IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0eGhyLm9uZXJyb3IgPSBjYWxsYmFjayhcImVycm9yXCIpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjayhcImFib3J0XCIpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KFwiPHNjcmlwdD5cIikucHJvcCh7XG5cdFx0XHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmICEoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgcmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cblx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9KS5kb25lKGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0fSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFsgXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIiBdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59KTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3KywgQ2hyb21lPDM3K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0pO1xufSk7XG5cblxuLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbmpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSk7XG59XG5cblxuXG5cbnZhclxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gc3RydW5kZWZpbmVkICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG5cbn0pKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIGxvZGFzaCAzLjEwLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzMuMTAuMSc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3Igd3JhcHBlciBtZXRhZGF0YS4gKi9cbiAgdmFyIEJJTkRfRkxBRyA9IDEsXG4gICAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIENVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgQ1VSUllfRkxBRyA9IDgsXG4gICAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBQQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBSRUFSR19GTEFHID0gMjU2O1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgd2hlbiBhIGZ1bmN0aW9uIGJlY29tZXMgaG90LiAqL1xuICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXG5cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wYXR0ZXJucylcbiAgICogYW5kIHRob3NlIG91dGxpbmVkIGJ5IFtgRXNjYXBlUmVnRXhwUGF0dGVybmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVzY2FwZXJlZ2V4cHBhdHRlcm4pLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhcnMgPSAvXls6ISxdfFtcXFxcXiQuKis/KClbXFxde318XFwvXXwoXlswLTlhLWZBLUZucnR1dnhdKXwoW1xcblxcclxcdTIwMjhcXHUyMDI5XSkvZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuICovXG4gIHZhciByZUNvbWJvTWFyayA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTIzXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS4gKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVIYXNIZXhQcmVmaXggPSAvXjBbeFhdLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwcGVyID0gJ1tBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdJyxcbiAgICAgICAgbG93ZXIgPSAnW2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl0rJztcblxuICAgIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG4gIH0oKSk7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdBcnJheUJ1ZmZlcicsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hdGgnLCAnTnVtYmVyJyxcbiAgICAnT2JqZWN0JywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJyxcbiAgICAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICdzZXRUaW1lb3V0JywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW21hcFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNDJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICdgJzogJyYjOTY7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIixcbiAgICAnJiM5NjsnOiAnYCdcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuICovXG4gIHZhciByZWdleHBFc2NhcGVzID0ge1xuICAgICcwJzogJ3gzMCcsICcxJzogJ3gzMScsICcyJzogJ3gzMicsICczJzogJ3gzMycsICc0JzogJ3gzNCcsXG4gICAgJzUnOiAneDM1JywgJzYnOiAneDM2JywgJzcnOiAneDM3JywgJzgnOiAneDM4JywgJzknOiAneDM5JyxcbiAgICAnQSc6ICd4NDEnLCAnQic6ICd4NDInLCAnQyc6ICd4NDMnLCAnRCc6ICd4NDQnLCAnRSc6ICd4NDUnLCAnRic6ICd4NDYnLFxuICAgICdhJzogJ3g2MScsICdiJzogJ3g2MicsICdjJzogJ3g2MycsICdkJzogJ3g2NCcsICdlJzogJ3g2NScsICdmJzogJ3g2NicsXG4gICAgJ24nOiAneDZlJywgJ3InOiAneDcyJywgJ3QnOiAneDc0JywgJ3UnOiAneDc1JywgJ3YnOiAneDc2JywgJ3gnOiAneDc4J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuICB2YXIgZnJlZVdpbmRvdyA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyAmJiB3aW5kb3cuT2JqZWN0ICYmIHdpbmRvdztcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKipcbiAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAgICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gICAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXM7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjb21wYXJlQXNjZW5kaW5nYCB3aGljaCBjb21wYXJlcyB2YWx1ZXMgYW5kXG4gICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgdmFyIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlO1xuXG4gICAgICB2YXIgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgb3RoSXNVbmRlZiA9IG90aGVyID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cbiAgICAgIGlmICgodmFsdWUgPiBvdGhlciAmJiAhb3RoSXNOdWxsKSB8fCAhdmFsSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAodmFsSXNOdWxsICYmICFvdGhJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICh2YWxJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPCBvdGhlciAmJiAhdmFsSXNOdWxsKSB8fCAhb3RoSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAob3RoSXNOdWxsICYmICF2YWxJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgIChvdGhJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNGdW5jdGlvbmAgd2l0aG91dCBzdXBwb3J0IGZvciBlbnZpcm9ubWVudHNcbiAgICogd2l0aCBpbmNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIEF2b2lkIGEgQ2hha3JhIEpJVCBidWcgaW4gY29tcGF0aWJpbGl0eSBtb2RlcyBvZiBJRSAxMS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2lzc3Vlcy8xNjIxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjaGFycy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaW5kZXgpKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAqIG9mIGBzdHJpbmdgIHRoYXQgaXMgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uIGFuZCBzdGFibGVcbiAgICogc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAqXG4gICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgKiBhIHZhbHVlIGlzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kXG4gICAqIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqICgob3JkZXIgPT09ICdhc2MnIHx8IG9yZGVyID09PSB0cnVlKSA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlUmVnRXhwYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYWRpbmdDaGFyIFRoZSBjYXB0dXJlIGdyb3VwIGZvciBhIGxlYWRpbmcgY2hhcmFjdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2hpdGVzcGFjZUNoYXIgVGhlIGNhcHR1cmUgZ3JvdXAgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcihjaHIsIGxlYWRpbmdDaGFyLCB3aGl0ZXNwYWNlQ2hhcikge1xuICAgIGlmIChsZWFkaW5nQ2hhcikge1xuICAgICAgY2hyID0gcmVnZXhwRXNjYXBlc1tjaHJdO1xuICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZUNoYXIpIHtcbiAgICAgIGNociA9IHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICB9XG4gICAgcmV0dXJuICdcXFxcJyArIGNocjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdHJpbW1lZExlZnRJbmRleGAgYW5kIGB0cmltbWVkUmlnaHRJbmRleGAgdG8gZGV0ZXJtaW5lIGlmIGFcbiAgICogY2hhcmFjdGVyIGNvZGUgaXMgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJDb2RlIFRoZSBjaGFyYWN0ZXIgY29kZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGNoYXJDb2RlYCBpcyB3aGl0ZXNwYWNlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgoY2hhckNvZGUgPD0gMTYwICYmIChjaGFyQ29kZSA+PSA5ICYmIGNoYXJDb2RlIDw9IDEzKSB8fCBjaGFyQ29kZSA9PSAzMiB8fCBjaGFyQ29kZSA9PSAxNjApIHx8IGNoYXJDb2RlID09IDU3NjAgfHwgY2hhckNvZGUgPT0gNjE1OCB8fFxuICAgICAgKGNoYXJDb2RlID49IDgxOTIgJiYgKGNoYXJDb2RlIDw9IDgyMDIgfHwgY2hhckNvZGUgPT0gODIzMiB8fCBjaGFyQ29kZSA9PSA4MjMzIHx8IGNoYXJDb2RlID09IDgyMzkgfHwgY2hhckNvZGUgPT0gODI4NyB8fCBjaGFyQ29kZSA9PSAxMjI4OCB8fCBjaGFyQ29kZSA9PSA2NTI3OSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBzZWVuLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKCFpbmRleCB8fCBzZWVuICE9PSBjb21wdXRlZCkge1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZExlZnRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIHVzaW5nIGBjb250ZXh0YCB0byBtb2NrIGBEYXRlI2dldFRpbWVgIHVzZSBpbiBgXy5ub3dgXG4gICAqIHZhciBtb2NrID0gXy5ydW5JbkNvbnRleHQoe1xuICAgKiAgICdEYXRlJzogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4geyAnZ2V0VGltZSc6IGdldFRpbWVNb2NrIH07XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgY3JlYXRpbmcgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanNcbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBzdHJpbmdQcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheUJ1ZmZlciA9IGNvbnRleHQuQXJyYXlCdWZmZXIsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBwYXJzZUZsb2F0ID0gY29udGV4dC5wYXJzZUZsb2F0LFxuICAgICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKSxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUtleXMgPSBnZXROYXRpdmUoT2JqZWN0LCAna2V5cycpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IGdldE5hdGl2ZShEYXRlLCAnbm93JyksXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciBgLUluZmluaXR5YCBhbmQgYEluZmluaXR5YC4gKi9cbiAgICB2YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIFBPU0lUSVZFX0lORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAgICAgKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgY2hhaW5pbmcuXG4gICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuICAgICAqIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZSBvciBtYXkgcmV0dXJuIGFcbiAgICAgKiBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gcmV0dXJuaW5nIHRoZSB1bndyYXBwZWRcbiAgICAgKiB2YWx1ZS4gRXhwbGljaXQgY2hhaW5pbmcgbWF5IGJlIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLiBUaGUgZXhlY3V0aW9uIG9mXG4gICAgICogY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGV4ZWN1dGlvbiBpcyBkZWZlcnJlZCB1bnRpbCBgXyN2YWx1ZWBcbiAgICAgKiBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uIFNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiBzdHJhdGVneSB3aGljaCBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBjYW4gaGVscFxuICAgICAqIHRvIGF2b2lkIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCBncmVhdGx5IHJlZHVjZSB0aGVcbiAgICAgKiBudW1iZXIgb2YgaXRlcmF0ZWUgZXhlY3V0aW9ucy5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsXG4gICAgICogYGZpcnN0YCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcGx1Y2tgLCBgcmVqZWN0YCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcbiAgICAgKiBhbmQgYHdoZXJlYFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25zdGFudGAsXG4gICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsXG4gICAgICogYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLFxuICAgICAqIGBkcm9wV2hpbGVgLCBgZmlsbGAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsXG4gICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLFxuICAgICAqIGBtYXRjaGVzUHJvcGVydHlgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLFxuICAgICAqIGBtb2RBcmdzYCwgYG5lZ2F0ZWAsIGBvbWl0YCwgYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLFxuICAgICAqIGBwYXJ0aXRpb25gLCBgcGlja2AsIGBwbGFudGAsIGBwbHVja2AsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLFxuICAgICAqIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByZWFyZ2AsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmVzdFBhcmFtYCxcbiAgICAgKiBgcmV2ZXJzZWAsIGBzZXRgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzb3J0QnlBbGxgLFxuICAgICAqIGBzb3J0QnlPcmRlcmAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdG9QbGFpbk9iamVjdGAsXG4gICAgICogYHRyYW5zZm9ybWAsIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgemlwYCwgYHppcE9iamVjdGAsIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbG9uZWAsIGBjbG9uZURlZXBgLFxuICAgICAqIGBkZWJ1cnJgLCBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaW5kV2hlcmVgLCBgZmlyc3RgLFxuICAgICAqIGBmbG9vcmAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCxcbiAgICAgKiBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgIGBpc0Z1bmN0aW9uYCwgYGlzTWF0Y2hgLFxuICAgICAqIGBpc05hdGl2ZWAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsXG4gICAgICogYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsXG4gICAgICogYGxhc3RgLCBgbGFzdEluZGV4T2ZgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtaW5gLCBgbm9Db25mbGljdGAsIGBub29wYCxcbiAgICAgKiBgbm93YCwgYHBhZGAsIGBwYWRMZWZ0YCwgYHBhZFJpZ2h0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZExhc3RJbmRleGAsIGBzdGFydENhc2VgLFxuICAgICAqIGBzdGFydHNXaXRoYCwgYHN1bWAsIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1MZWZ0YCwgYHRyaW1SaWdodGAsIGB0cnVuY2AsXG4gICAgICogYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZCBgc2FtcGxlYCB3aWxsIHJldHVybiBhIHdyYXBwZWQgdmFsdWUgd2hlbiBgbmAgaXMgcHJvdmlkZWQsXG4gICAgICogb3RoZXJ3aXNlIGFuIHVud3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgbikge1xuICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX19jaGFpbl9fJykgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGFsbCBjaGFpbmluZyB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIHdyYXBwZXIgbWV0aG9kcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYWN0aW9ucz1bXV0gQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsLCBhY3Rpb25zKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gYWN0aW9ucyB8fCBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZW52aXJvbm1lbnQgZmVhdHVyZSBmbGFncy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBhcnJheUNvcHkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGFycmF5Q29weSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCBhcnJMZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIHx8IChhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKChpc1JpZ2h0ICYmIGlzQXJyKSA/IGFycmF5LnJldmVyc2UoKSA6IGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbmFtZSBDYWNoZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZSgpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB2YWx1ZWAgdG8gYGtleWAgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gICAgICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHB1c2hcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBgYXJyYXlgIHdpdGggYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29uY2F0KGFycmF5LCBvdGhlcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gLTEsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCArIG90aExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytvdGhJbmRleCA8IG90aExlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBvdGhlcltvdGhJbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUV4dHJlbXVtYCBmb3IgYXJyYXlzIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgY29tcHV0ZWQgPSBleFZhbHVlLFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gK2l0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnN1bWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZShhcnJheVtsZW5ndGhdKSB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnbkRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCBpZ25vcmVzXG4gICAgICogaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlcyB3aGVuIGNoZWNraW5nIGlmIGEgcHJvcGVydHkgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBhbmQgc291cmNlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk93bkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiAob2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpXG4gICAgICAgID8gc291cmNlVmFsdWVcbiAgICAgICAgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uYXNzaWduYCBmb3IgY3VzdG9taXppbmcgYXNzaWduZWQgdmFsdWVzIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB8fFxuICAgICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIGNvbGxlY3Rpb25zXG4gICAgICogYW5kIGluZGl2aWR1YWwga2V5IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNOaWwgPSBjb2xsZWN0aW9uID09IG51bGwsXG4gICAgICAgICAgaXNBcnIgPSAhaXNOaWwgJiYgaXNBcnJheUxpa2UoY29sbGVjdGlvbiksXG4gICAgICAgICAgbGVuZ3RoID0gaXNBcnIgPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocHJvcHNMZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzSW5kZXgoa2V5LCBsZW5ndGgpID8gY29sbGVjdGlvbltrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc05pbCA/IHVuZGVmaW5lZCA6IGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2FsbGJhY2tgIHdoaWNoIHN1cHBvcnRzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGZ1bmNcbiAgICAgICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBwcm9wZXJ0eShmdW5jKVxuICAgICAgICA6IGJhc2VNYXRjaGVzUHJvcGVydHkoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnO1xuXG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVhYmxlVGFnc1t0YWddXG4gICAgICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgICAgIDogKG9iamVjdCA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZS5cbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHt9O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBhbiBpbmRleFxuICAgICAqIG9mIHdoZXJlIHRvIHNsaWNlIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgd2hpY2ggYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgY2FjaGUgPSAoaXNDb21tb24gJiYgdmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXh0cmVtdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggdmFsdWVcbiAgICAgKiBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkgfHwgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IChlbmQgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRgLCBgXy5maW5kTGFzdGAsIGBfLmZpbmRLZXlgLCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0S2V5XSBTcGVjaWZ5IHJldHVybmluZyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50XG4gICAgICogIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYywgcmV0S2V5KSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmV0S2V5ID8ga2V5IDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBhZGRlZCBzdXBwb3J0IGZvciByZXN0cmljdGluZ1xuICAgICAqIGZsYXR0ZW5pbmcgYW5kIHNwZWNpZnlpbmcgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzLWxpa2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAoaXNTdHJpY3QgfHwgaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICAgKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSB0aG9zZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgcGF0aHNcbiAgICAgKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoS2V5XSBUaGUga2V5IHJlcHJlc2VudGF0aW9uIG9mIHBhdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGhLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXRoS2V5IGluIHRvT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IFtwYXRoS2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuICAgICAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgICAgIGlmICghb2JqSXNBcnIpIHtcbiAgICAgICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3RoSXNBcnIpIHtcbiAgICAgICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvdGhUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTG9vc2UpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gICAgICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgICAgIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCB0cnVlKSA6IHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hEYXRhWzBdWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaERhdGFbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSxcbiAgICAgICAgICBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gcGF0aEtleTtcbiAgICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgaWYgKChpc0FyciB8fCAhaXNDb21tb24pICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBsYXN0KHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZVxuICAgICAgICAgID8gKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBvYmplY3QpKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9iamVjdFtrZXldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIGlzU3JjQXJyID0gaXNBcnJheUxpa2Uoc291cmNlKSAmJiAoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKSxcbiAgICAgICAgICBwcm9wcyA9IGlzU3JjQXJyID8gdW5kZWZpbmVkIDoga2V5cyhzb3VyY2UpO1xuXG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChyZXN1bHQgIT09IHVuZGVmaW5lZCB8fCAoaXNTcmNBcnIgJiYgIShrZXkgaW4gb2JqZWN0KSkpICYmXG4gICAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShzcmNWYWx1ZSkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG4gICAgICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlXG4gICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gICAgICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4IGFyZ3VtZW50cyBhbmQgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChpbmRleCAhPSBwcmV2aW91cyAmJiBpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICAgKiB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbml0RnJvbUNvbGxlY3Rpb24gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50XG4gICAgICogIG9mIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQ29sbGVjdGlvbiwgZWFjaEZ1bmMpIHtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRGcm9tQ29sbGVjdGlvblxuICAgICAgICAgID8gKGluaXRGcm9tQ29sbGVjdGlvbiA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3AgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZVxuICAgICAqIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeU9yZGVyYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soKSxcbiAgICAgICAgICBpbmRleCA9IC0xO1xuXG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBjYWxsYmFjayhpdGVyYXRlZSk7IH0pO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7IH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHx8IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFLFxuICAgICAgICAgIHNlZW4gPSBpc0xhcmdlID8gY3JlYXRlQ2FjaGUoKSA6IG51bGwsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNDb21tb24gJiYgdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIDApIDwgMCkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZSB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBvZiBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRyb3BSaWdodFdoaWxlYCwgYF8uZHJvcFdoaWxlYCwgYF8udGFrZVJpZ2h0V2hpbGVgLFxuICAgICAqIGFuZCBgXy50YWtlV2hpbGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1tpbmRleF07XG4gICAgICAgIHJlc3VsdCA9IGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmICgocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpICYmIGNvbXB1dGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmluYXJ5SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGludm9rZXMgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgaXNEZWYgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQ7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IGlzUmVmbGV4aXZlIHx8IHJldEhpZ2hlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgaXNEZWYgJiYgKHJldEhpZ2hlc3QgfHwgY29tcHV0ZWQgIT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZikge1xuICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IGlzRGVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wdXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgcmlnaHRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNvdW50QnlgLCBgXy5ncm91cEJ5YCwgYF8uaW5kZXhCeWAsIG9yIGBfLnBhcnRpdGlvbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgb3IgYF8ubWVyZ2VgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAyID8gc291cmNlc1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmRXcmFwcGVyKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBTZXRgIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKHZhbHVlcykge1xuICAgICAgcmV0dXJuIChuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IG5ldyBTZXRDYWNoZSh2YWx1ZXMpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBjb21wb3VuZCB3b3JkcyBvdXQgb2YgdGhlIHdvcmRzIGluIGFcbiAgICAgKiBnaXZlbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBhcnJheSA9IHdvcmRzKGRlYnVycihzdHJpbmcpKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0LCBhcnJheVtpbmRleF0sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yV3JhcHBlcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgY3VycnkgYml0IGZsYWcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZmxhZykge1xuICAgICAgZnVuY3Rpb24gY3VycnlGdW5jKGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgYXJpdHksIGd1YXJkKSkge1xuICAgICAgICAgIGFyaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5RnVuYy5wbGFjZWhvbGRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyeUZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmRlZmF1bHRzYCBvciBgXy5kZWZhdWx0c0RlZXBgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlZmF1bHRzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuICAgICAgICByZXR1cm4gYXNzaWduZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5tYXhgIG9yIGBfLm1pbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGV4dHJlbXVtIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dHJlbXVtKGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgaWYgKGl0ZXJhdGVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJyYXlFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICAgICAgaWYgKCEoY29sbGVjdGlvbi5sZW5ndGggJiYgcmVzdWx0ID09PSBleFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBjb2xsZWN0aW9uW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kSW5kZXhgIG9yIGBfLmZpbmRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRJbmRleChmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRLZXlgIG9yIGBfLmZpbmRMYXN0S2V5YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRLZXkob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIHJldHVybiBiYXNlRmluZChvYmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0RnVuYywgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3cmFwcGVyLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAwLFxuICAgICAgICAgICAgZnVuY3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd3JhcHBlciAmJiBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1ICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gLTEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiYgZGF0YVsxXSA9PSAoQVJZX0ZMQUcgfCBDVVJSWV9GTEFHIHwgUEFSVElBTF9GTEFHIHwgUkVBUkdfRkxBRykgJiYgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMSkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSkgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgICAgICA6IGVhY2hGdW5jKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckluKG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLm1hcEtleXNgIG9yIGBfLm1hcFZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWFwS2V5c10gU3BlY2lmeSBtYXBwaW5nIGtleXMgaW5zdGVhZCBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWFwIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE1hcHBlcihpc01hcEtleXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIHZhciBtYXBwZWQgPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgICAgIGtleSA9IGlzTWFwS2V5cyA/IG1hcHBlZCA6IGtleTtcbiAgICAgICAgICB2YWx1ZSA9IGlzTWFwS2V5cyA/IHZhbHVlIDogbWFwcGVkO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnBhZExlZnRgIG9yIGBfLnBhZFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IHBhZGRpbmcgZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZERpcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHJldHVybiAoZnJvbVJpZ2h0ID8gc3RyaW5nIDogJycpICsgY3JlYXRlUGFkZGluZyhzdHJpbmcsIGxlbmd0aCwgY2hhcnMpICsgKGZyb21SaWdodCA/ICcnIDogc3RyaW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnBhcnRpYWxgIG9yIGBfLnBhcnRpYWxSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgcGFydGlhbCBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZmxhZykge1xuICAgICAgdmFyIHBhcnRpYWxGdW5jID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnJlZHVjZWAgb3IgYF8ucmVkdWNlUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBpbml0RnJvbUFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KVxuICAgICAgICAgIDogYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCksIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5LCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBBUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgQ1VSUllfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgQ1VSUllfQk9VTkRfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5UmlnaHQgPSBiaXRtYXNrICYgQ1VSUllfUklHSFRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyeSB8fCBpc0N1cnJ5UmlnaHQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB3cmFwcGVyLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICBhcmdzSG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGxlbmd0aCAtPSBhcmdzSG9sZGVycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJnUG9zID0gYXJnUG9zID8gYXJyYXlDb3B5KGFyZ1BvcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmV3QXJpdHkgPSBuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApLFxuICAgICAgICAgICAgICAgIG5ld3NIb2xkZXJzID0gaXNDdXJyeSA/IGFyZ3NIb2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzSG9sZGVycyxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBhcmdzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogYXJncztcblxuICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFBBUlRJQUxfUklHSFRfRkxBRyA6IFBBUlRJQUxfRkxBRyk7XG5cbiAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG4gICAgICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHldLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIHRoZSBnaXZlbiBgbGVuZ3RoYC5cbiAgICAgKiBUaGUgYGNoYXJzYCBzdHJpbmcgaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY3JlYXRlIHBhZGRpbmcgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICBpZiAoc3RyTGVuZ3RoID49IGxlbmd0aCB8fCAhbmF0aXZlSXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gc3RyTGVuZ3RoO1xuICAgICAgY2hhcnMgPSBjaGFycyA9PSBudWxsID8gJyAnIDogKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChwYWRMZW5ndGggLyBjaGFycy5sZW5ndGgpKS5zbGljZSgwLCBwYWRMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogdGhlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgYGZ1bmNgLlxuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNlaWxgLCBgXy5mbG9vcmAsIG9yIGBfLnJvdW5kYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gMCA6ICgrcHJlY2lzaW9uIHx8IDApO1xuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgcHJlY2lzaW9uID0gcG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlciAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnNvcnRlZEluZGV4YCBvciBgXy5zb3J0ZWRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW5kZXggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU29ydGVkSW5kZXgocmV0SGlnaGVzdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gKGl0ZXJhdGVlID09IG51bGwgJiYgY2FsbGJhY2sgPT09IGJhc2VDYWxsYmFjaylcbiAgICAgICAgICA/IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdClcbiAgICAgICAgICA6IGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBjYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSksIHJldEhpZ2hlc3QpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogICAyNTYgLSBgXy5hcnlgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oUEFSVElBTF9GTEFHIHwgUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcbiAgICAgIGlmIChiaXRtYXNrICYgUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKSxcbiAgICAgICAgICBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eV07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbOV0gPSBhcml0eSA9PSBudWxsXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiAobmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSB8fCAwKTtcblxuICAgICAgaWYgKGJpdG1hc2sgPT0gQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kV3JhcHBlcihuZXdEYXRhWzBdLCBuZXdEYXRhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKEJJTkRfRkxBRyB8IFBBUlRJQUxfRkxBRykpICYmICFuZXdEYXRhWzRdLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogYXJyVmFsdWUsIGlzTG9vc2UgPyBhcnJWYWx1ZSA6IG90aFZhbHVlLCBpbmRleCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gKG9iamVjdCAhPSArb2JqZWN0KVxuICAgICAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgICAgIDogb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihpc0xvb3NlID8gb3RoVmFsdWUgOiBvYmpWYWx1ZSwgaXNMb29zZT8gb2JqVmFsdWUgOiBvdGhWYWx1ZSwga2V5KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikgOiByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImNhbGxiYWNrXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5jYWxsYmFja2AgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlQ2FsbGJhY2tgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmQgaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5jYWxsYmFjayB8fCBjYWxsYmFjaztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gY2FsbGJhY2sgPyBiYXNlQ2FsbGJhY2sgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJnQ291bnQgPyByZXN1bHQoZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLm5hbWUsXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxudW1iZXJ9IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaW5kZXhPZiB8fCBpbmRleE9mO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbiA/IHJlc3VsdChjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAgICAgKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYWlycyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXVsyXSA9IGlzU3RyaWN0Q29tcGFyYWJsZShyZXN1bHRbbGVuZ3RoXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICBDdG9yID0gT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3BhdGhdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAoKHR5cGUgPT0gJ3N0cmluZycgJiYgcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSkgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQgfHwgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIHRvT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKTtcbiAgICAgIGlmICghKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgcmVxdWlyZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kIGBfLnJlYXJnYFxuICAgICAqIGF1Z21lbnQgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGV4ZWN1dGVkIGltcG9ydGFudCxcbiAgICAgKiBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlXG4gICAgICogY29tbW9uIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgQVJZX0ZMQUc7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IFJFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSAoQVJZX0ZMQUcgfCBSRUFSR19GTEFHKSAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBCSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSAoYml0bWFzayAmIEJJTkRfRkxBRykgPyAwIDogQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs0XSk7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNl0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBBUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogbWVyZ2Uob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBtZXJnZURlZmF1bHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2Agd2hpY2ggcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBzcGVjaWZpZWRcbiAgICAgKiBieSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5QXJyYXkob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWBcbiAgICAgKiByZXR1cm5zIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgYmFzZUZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gYXJyYXlDb3B5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eSBmdW5jdGlvblxuICAgICAqIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZSBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVNldERhdGEoa2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXktbGlrZSBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VUb1N0cmluZyh2YWx1ZSkucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgcmV0dXJuIHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlclxuICAgICAgICA/IHdyYXBwZXIuY2xvbmUoKVxuICAgICAgICA6IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fLCBhcnJheUNvcHkod3JhcHBlci5fX2FjdGlvbnNfXykpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGNvbGxlY3Rpb25gIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBjb250YWluaW5nIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KG5hdGl2ZUZsb29yKHNpemUpIHx8IDEsIDEpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXJcbiAgICAgKiBwcm92aWRlZCBhcnJheXMgdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGlzT2JqZWN0TGlrZShhcnJheSkgJiYgaXNBcnJheUxpa2UoYXJyYXkpKVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIGZhbHNlLCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICBuID0gbGVuZ3RoIC0gKCtuIHx8IDApO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOF0sICcqJywgMSwgMik7XG4gICAgICogLy8gPT4gWzQsICcqJywgOF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ2Jhcm5leSc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgZmluZEluZGV4ID0gY3JlYXRlRmluZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ3BlYmJsZXMnO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gY3JlYXRlRmluZEluZGV4KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWRcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheS4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIHRoZSBhcnJheSBpcyByZWN1cnNpdmVseVxuICAgICAqIGZsYXR0ZW5lZCwgb3RoZXJ3aXNlIGl0IGlzIG9ubHkgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNEZWVwYFxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc0RlZXAsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc0RlZXAsIGd1YXJkKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgc29ydGVkIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgXG4gICAgICogcGVyZm9ybXMgYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogZnJvbUluZGV4O1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBhcnJheVtpbmRleF0pIDogKGFycmF5W2luZGV4XSAhPT0gYXJyYXlbaW5kZXhdKSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcFJpZ2h0KGFycmF5LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZSBwcm92aWRlZFxuICAgICAqIGFycmF5cyB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0gPSBpc0FycmF5TGlrZSh2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0pID8gdmFsdWUgOiBbXTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9IChpc0NvbW1vbiAmJiB2YWx1ZS5sZW5ndGggPj0gMTIwKSA/IGNyZWF0ZUNhY2hlKG90aEluZGV4ICYmIHZhbHVlKSA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcnJheXNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJyYXlzW290aEluZGV4XSwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IG5hdGl2ZU1pbihmcm9tSW5kZXggfHwgMCwgbGVuZ3RoIC0gMSkpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgaW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcnJheSA9IGFyZ3NbMF07XG5cbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhlcyBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBpbmRleGVzIG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbNSwgMTAsIDE1LCAyMF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFs1LCAxNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMTAsIDIwXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlXG4gICAgICogbGlzdHMgaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkXG4gICAgICogYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLiBJZiBhbiBpdGVyYXRlZVxuICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5kYXRhW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRMYXN0SW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyXSwgWzQsIDJdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCA0XVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIGZhbHNlLCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgcGVyZm9ybXMgYSBmYXN0ZXIgc2VhcmNoIGFsZ29yaXRobVxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvclxuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gICAgICogXy51bmlxKFsxLCAxLCAyXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPSBudWxsICYmIHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyB1bmRlZmluZWQgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKCk7XG4gICAgICBpZiAoIShpdGVyYXRlZSA9PSBudWxsICYmIGNhbGxiYWNrID09PSBiYXNlQ2FsbGJhY2spKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gY2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpc1NvcnRlZCAmJiBnZXRJbmRleE9mKCkgPT0gYmFzZUluZGV4T2YpXG4gICAgICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gaXRlcmF0ZWUgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZShncm91cCwgaXRlcmF0ZWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGUgW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDJdLCBbNCwgMl0pO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGFycmF5UHVzaChiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KSwgYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ID8gYmFzZVVuaXEocmVzdWx0KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZCBlbGVtZW50c1xuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IHJlc3RQYXJhbSh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5wYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzXG4gICAgICogb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZSBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYCBvciB0d28gYXJyYXlzLCBvbmUgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFtbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgNDBdXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmIChsZW5ndGggJiYgIXZhbHVlcyAmJiAhaXNBcnJheShwcm9wc1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGl0ZXJhdGVlIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDIgPyBhcnJheXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWUgPSAobGVuZ3RoID4gMSAmJiB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nKSA/ICgtLWxlbmd0aCwgdGhpc0FyZykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlLCB0aGlzQXJnKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNoci51c2VyICsgJyBpcyAnICsgY2hyLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvciBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2ZcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zXG4gICAgICogb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBhIHdyYXBwZWQgYXJyYXkgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG5hbWUgY29uY2F0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5jb25jYXQoMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyh3cmFwcGVkLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJDb25jYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBiYXNlRmxhdHRlbih2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb25jYXQoaXNBcnJheShhcnJheSkgPyBhcnJheSA6IFt0b09iamVjdChhcnJheSldLCB2YWx1ZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluZWQgc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0gWzMsIDRdO1xuICAgICAqIHZhciBvdGhlcldyYXBwZWQgPSB3cmFwcGVkLnBsYW50KG90aGVyKTtcbiAgICAgKlxuICAgICAqIG90aGVyV3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgd3JhcHBlZCBhcnJheSBzbyB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG5cbiAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBlZCAmJiB3cmFwcGVkLl9fZGlyX18gPCAwKSA/IHZhbHVlIDogdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgcmVzdWx0IG9mIGNvZXJjaW5nIHRoZSB1bndyYXBwZWQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29lcmNlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUoKSArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSB0byBleHRyYWN0IHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHJ1biwgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXlzLCBvciBpbmRleGVzLFxuICAgICAqIG9mIGBjb2xsZWN0aW9uYC4gS2V5cyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGtleXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljaywgc3BlY2lmaWVkIGluZGl2aWR1YWxseSBvciBpbiBhcnJheXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnXSwgWzAsIDJdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICB2YXIgYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBiYXNlQXQoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3Iobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gKytyZXN1bHRba2V5XSA6IChyZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFs0LCA1LCA2XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2hSaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuICAgICAqIG93biBvciBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWUgc2VlIGBfLm1hdGNoZXNQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kV2hlcmUoY29sbGVjdGlvbiwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZmluZChjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuICAgICAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlLWtleSBwYWlyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obikge1xuICAgICAqICAgY29uc29sZS5sb2cobik7XG4gICAgICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoUmlnaHQgPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaFJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb250YWlucywgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwodGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSkpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBjb2xsZWN0aW9uID09ICdzdHJpbmcnIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleURhdGEgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IGlzXG4gICAgICogaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzUHJvcCA9IGlzS2V5KHBhdGgpLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gcGF0aCA6ICgoaXNQcm9wICYmIHZhbHVlICE9IG51bGwpID8gdmFsdWVbcGF0aF0gOiB1bmRlZmluZWQpO1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQYXRoKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjYWxsYmFja2AsIGBjaHVua2AsIGBjbG9uZWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsXG4gICAgICogYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCwgYGZpbGxgLCBgZmxhdHRlbmAsIGBpbnZlcnRgLCBgbWF4YCwgYG1pbmAsXG4gICAgICogYHBhcnNlSW50YCwgYHNsaWNlYCwgYHNvcnRCeWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0ZW1wbGF0ZWAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHJhbmRvbWAsIGByYW5nZWAsIGBzYW1wbGVgLCBgc29tZWAsXG4gICAgICogYHN1bWAsIGB1bmlxYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB0aW1lc1RocmVlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMl0sIHRpbWVzVGhyZWUpO1xuICAgICAqIC8vID0+IFszLCA2XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDEsICdiJzogMiB9LCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB3aGlsZSB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbWzEsIDNdLCBbMl1dXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMS4yLCAyLjMsIDMuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pICUgMjtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbWzEuMiwgMy40XSwgWzIuM11dXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVyID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgIHJldHVybiBfLnBsdWNrKGFycmF5LCAndXNlcicpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBmcm9tIGFsbCBlbGVtZW50cyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJJbmRleCA9IF8uaW5kZXhCeSh1c2VycywgJ3VzZXInKTtcbiAgICAgKiBfLnBsdWNrKHVzZXJJbmRleCwgJ2FnZScpO1xuICAgICAqIC8vID0+IFszNiwgNDBdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcGF0aCkge1xuICAgICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBwcm9wZXJ0eShwYXRoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYHNvcnRCeUFsbGAsXG4gICAgICogYW5kIGBzb3J0QnlPcmRlcmBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24odG90YWwsIG4pIHtcbiAgICAgKiAgIHJldHVybiB0b3RhbCArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VSaWdodCA9IGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZVJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA+IDAgPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdG9BcnJheShjb2xsZWN0aW9uKSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIG4gPSBuYXRpdmVNaW4obiA8IDAgPyAwIDogKCtuIHx8IDApLCBsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0W3JhbmRdO1xuXG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2FtcGxlKGNvbGxlY3Rpb24sIFBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmQgZG9lcyBub3QgaXRlcmF0ZVxuICAgICAqIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGlzIG1ldGhvZCBwZXJmb3Jtc1xuICAgICAqIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZiBlcXVhbCBlbGVtZW50cy5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnNpbihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuc2luKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgY29tcGFyZUFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGNhbiBzb3J0IGJ5IG11bHRpcGxlIGl0ZXJhdGVlc1xuICAgICAqIG9yIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW118T2JqZWN0fE9iamVjdFtdfHN0cmluZ3xzdHJpbmdbXSl9IGl0ZXJhdGVlc1xuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnksIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHZhbHVlcyBvciBhcnJheXMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgWyd1c2VyJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQyXSwgWydmcmVkJywgNDhdXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsICd1c2VyJywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihjaHIuYWdlIC8gMTApO1xuICAgICAqIH0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeUFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGd1YXJkID0gaXRlcmF0ZWVzWzJdO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgaXRlcmF0ZWVzLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcyksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBzb3J0IG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGxcbiAgICAgKiB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgYSB2YWx1ZSBpcyBzb3J0ZWQgaW5cbiAgICAgKiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQyIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAqIF8ubWFwKF8uc29ydEJ5T3JkZXIodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSkge1xuICAgICAgICBvcmRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuYXRpdmVJc0Zpbml0ZShuID0gK24pID8gbiA6IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGBuYCBhcmd1bWVudHMgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuICAgICAgICBuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIEFSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0IGlzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoJyNhZGQnKS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gYWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGVcbiAgICAgKiBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZC5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCBlbnVtZXJhYmxlIGZ1bmN0aW9uXG4gICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIHRoZSBlbGVtZW50IGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBtZXRob2ROYW1lcyA9IG1ldGhvZE5hbWVzLmxlbmd0aCA/IGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzKSA6IGZ1bmN0aW9ucyhvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIGFuZCBwcmVwZW5kc1xuICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogY2FsbGVkIGVpdGhlciBpbnZva2VzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IGNyZWF0ZUN1cnJ5KENVUlJZX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeVJpZ2h0ID0gY3JlYXRlQ3VycnkoQ1VSUllfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAgICAgKiBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmVcbiAgICAgKiAgZGVsYXllZCBiZWZvcmUgaXQgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIGRlYm91bmNlZCBjYWxsXG4gICAgICogdmFyIHRvZG9DaGFuZ2VzID0gXy5kZWJvdW5jZShiYXRjaExvZywgMTAwMCk7XG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLnRvZG8sIHRvZG9DaGFuZ2VzKTtcbiAgICAgKlxuICAgICAqIE9iamVjdC5vYnNlcnZlKG1vZGVscywgZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAqICAgaWYgKF8uZmluZChjaGFuZ2VzLCB7ICd1c2VyJzogJ3RvZG8nLCAndHlwZSc6ICdkZWxldGUnfSkpIHtcbiAgICAgKiAgICAgdG9kb0NoYW5nZXMuY2FuY2VsKCk7XG4gICAgICogICB9XG4gICAgICogfSwgWydkZWxldGUnXSk7XG4gICAgICpcbiAgICAgKiAvLyAuLi5hdCBzb21lIHBvaW50IGBtb2RlbHMudG9kb2AgaXMgY2hhbmdlZFxuICAgICAqIG1vZGVscy50b2RvLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyAuLi5iZWZvcmUgMSBzZWNvbmQgaGFzIHBhc3NlZCBgbW9kZWxzLnRvZG9gIGlzIGRlbGV0ZWRcbiAgICAgKiAvLyB3aGljaCBjYW5jZWxzIHRoZSBkZWJvdW5jZWQgYHRvZG9DaGFuZ2VzYCBjYWxsXG4gICAgICogZGVsZXRlIG1vZGVscy50b2RvO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiAoK3dhaXQgfHwgMCk7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGxldGUoaXNDYWxsZWQsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgY29tcGxldGUodHJhaWxpbmdDYWxsLCBtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBjb21wbGV0ZSh0cmFpbGluZywgdGltZW91dElkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gbWF4V2FpdDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KF8uYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBiYWNrZmxvdywgY29tcG9zZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcgYW5kIHVzZWQgYXMgdGhlXG4gICAgICogY2FjaGUga2V5LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGUgW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1cHBlckNhc2UgPSBfLm1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdXBwZXJDYXNlLmNhY2hlLnNldCgnZnJlZCcsICdCQVJORVknKTtcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnQkFSTkVZJ1xuICAgICAqXG4gICAgICogLy8gcmVwbGFjaW5nIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2Jhcm5leScgfTtcbiAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIGlkZW50aXR5KG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyBtZW1vaXplLkNhY2hlO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJ1bnMgZWFjaCBhcmd1bWVudCB0aHJvdWdoIGEgY29ycmVzcG9uZGluZ1xuICAgICAqIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zXSBUaGUgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybVxuICAgICAqIGFyZ3VtZW50cywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgZnVuY3Rpb25zIG9yIGFycmF5cyBvZiBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG1vZGRlZCA9IF8ubW9kQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIHNxdWFyZSwgZG91YmxlZCk7XG4gICAgICpcbiAgICAgKiBtb2RkZWQoMSwgMik7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICpcbiAgICAgKiBtb2RkZWQoNSwgMTApO1xuICAgICAqIC8vID0+IFsyNSwgMjBdXG4gICAgICovXG4gICAgdmFyIG1vZEFyZ3MgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9IGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMpO1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgIWFycmF5RXZlcnkodHJhbnNmb3JtcywgYmFzZUlzRnVuY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XShhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGludm9rZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdFxuICAgICAqIGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgMiwgMCwgMSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcbiAgICAgKiBtYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0sIFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIFJFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2VGbGF0dGVuKGluZGV4ZXMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0UGFyYW0oZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2UgW2BGdW5jdGlvbiNhcHBseWBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC4zKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL1NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgUHJvbWlzZVxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJyYXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGVcbiAgICAgKiB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGVcbiAgICAgKiBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSB0cmFpbGluZyB0aHJvdHRsZWQgY2FsbFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7ICdsZWFkaW5nJzogbGVhZGluZywgJ21heFdhaXQnOiArd2FpdCwgJ3RyYWlsaW5nJzogdHJhaWxpbmcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBbdmFsdWVdLCBbXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyBhcmUgY2xvbmVkLFxuICAgICAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZSh1c2Vycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBlbC5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgaWYgKGlzRGVlcCAmJiB0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBpc0RlZXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzQXJnID0gY3VzdG9taXplcjtcbiAgICAgICAgY3VzdG9taXplciA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZ1xuICAgICAqIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcCh1c2Vycyk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkgdW5sZXNzIGl0IGlzIGFuXG4gICAgICogYGFyZ3VtZW50c2Agb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBvciBqUXVlcnktbGlrZSBjb2xsZWN0aW9uIHdpdGggYSBsZW5ndGhcbiAgICAgKiBncmVhdGVyIHRoYW4gYDBgIG9yIGFuIG9iamVjdCB3aXRoIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFrZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2RcbiAgICAgKiBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIG90aGVyIFssIGluZGV4fGtleV0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgKiBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZCBzdXBwb3J0XG4gICAgICogZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZXFcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwoYXJyYXksIG90aGVyLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIGlmIChfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBlcnJvclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzZmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMTApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gICAgICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkXG4gICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIsIGluZGV4fGtleSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIHByb3BlcnRpZXMgb2YgYXJyYXlzLCBib29sZWFucyxcbiAgICAgKiBgRGF0ZWAgb2JqZWN0cywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcbiAgICAgKiBzdXBwb3J0IGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSB8fCB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIG5vdCB0aGUgc2FtZSBhcyBbYGlzTmFOYF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQpXG4gICAgICogd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICAgICAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCc4LjQnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAgICAgKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvcjtcblxuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZyAmJiAhaXNBcmd1bWVudHModmFsdWUpKSB8fFxuICAgICAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiYgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICogfSgxLCAyLCAzKSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlID8gZ2V0TGVuZ3RoKHZhbHVlKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICAgICAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90J10gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG90aGVyIDogdmFsdWU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gY3VzdG9taXplclxuICAgICAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgICAgIDogYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVEZWZhdWx0cyhhc3NpZ24sIGFzc2lnbkRlZmF1bHRzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAndXNlcic6IHsgJ25hbWUnOiAnYmFybmV5JyB9IH0sIHsgJ3VzZXInOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMzYgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSB9XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gY3JlYXRlRGVmYXVsdHMobWVyZ2UsIG1lcmdlRGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kS2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmdcbiAgICAgKiBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJywgJ2InLCBhbmQgJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duUmlnaHQgPSBjcmVhdGVGb3JPd24oYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FmdGVyJywgJ2FyeScsICdhc3NpZ24nLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IHsgJ2MnOiAzIH0gfSB9O1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIGlmICghcmVzdWx0ICYmICFpc0tleShwYXRoKSkge1xuICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICAgIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgKGlzTGVuZ3RoKG9iamVjdC5sZW5ndGgpICYmIGlzSW5kZXgocGF0aCwgb2JqZWN0Lmxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGUgcHJvcGVydHlcbiAgICAgKiBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMgdW5sZXNzIGBtdWx0aVZhbHVlYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aVZhbHVlXSBBbGxvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIGtleS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG4gICAgICogXy5pbnZlcnQob2JqZWN0LCB0cnVlKTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgdmFyIG1hcEtleXMgPSBjcmVhdGVPYmplY3RNYXBwZXIodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgbWFwVmFsdWVzID0gY3JlYXRlT2JqZWN0TWFwcGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gb21pdCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wc1swXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzKSwgU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZURpZmZlcmVuY2Uoa2V5c0luKG9iamVjdCksIHByb3BzKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJlZGljYXRlID0gYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMyk7XG4gICAgICByZXR1cm4gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiB0aGUga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCxcbiAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuIFByb3BlcnR5XG4gICAgICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuICAgICAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgXy5pc1N0cmluZyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgcHJvcHNbMF0gPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMykpXG4gICAgICAgIDogcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmQgaXRzIHJlc3VsdFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtwYXRoXTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbbGFzdChwYXRoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0LmNhbGwob2JqZWN0KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGBcbiAgICAgKiBkb2VzIG5vdCBleGlzdCBpdCBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBhdWdtZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAneFswXS55LnonLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aEtleSA9IChwYXRoICsgJycpO1xuICAgICAgcGF0aCA9IChvYmplY3RbcGF0aEtleV0gIT0gbnVsbCB8fCBpc0tleShwYXRoLCBvYmplY3QpKSA/IFtwYXRoS2V5XSA6IHRvUGF0aChwYXRoKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG5lc3RlZCkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnNcbiAgICAgKiBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKGlzRnVuY3Rpb24oQ3RvcikgPyBDdG9yLnByb3RvdHlwZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXMgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiB2YWx1ZSA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG4gICAgICogbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgaXNJdGVyYXRlZUNhbGwobWluLCBtYXgsIGZsb2F0aW5nKSkge1xuICAgICAgICBtYXggPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChub01heCAmJiB0eXBlb2YgbWluID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgICBub01heCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYXBpdGFsaXplcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIChzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZyBbbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9ICh0YXJnZXQgKyAnJyk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBsZW5ndGgpO1xuXG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLmluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiLCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgICogdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gICAgICogb2YgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAgICAgKiBbIzEwMl0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwMiksIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kXG4gICAgICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAgICAgKiB0byByZWR1Y2UgWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIC8vIFJlc2V0IGBsYXN0SW5kZXhgIGJlY2F1c2UgaW4gSUUgPCA5IGBTdHJpbmcjcmVwbGFjZWAgZG9lcyBub3QuXG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXFxcIiwgXCIvXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIixcbiAgICAgKiBcIipcIiwgXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6XFwvXFwvbG9kYXNoXFwuY29tXFwvXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgZXNjYXBlUmVnRXhwQ2hhcilcbiAgICAgICAgOiAoc3RyaW5nIHx8ICcoPzopJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDIsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IG5hdGl2ZUZsb29yKG1pZCksXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBuYXRpdmVDZWlsKG1pZCk7XG5cbiAgICAgIGNoYXJzID0gY3JlYXRlUGFkZGluZygnJywgcmlnaHRMZW5ndGgsIGNoYXJzKTtcbiAgICAgIHJldHVybiBjaGFycy5zbGljZSgwLCBsZWZ0TGVuZ3RoKSArIHN0cmluZyArIGNoYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgdmFyIHBhZExlZnQgPSBjcmVhdGVQYWREaXIoKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGUgW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNFKVxuICAgICAqIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHRyaW0gbGVhZGluZyA8Qk9NPiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhhc0hleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgbiA9ICtuO1xuICAgICAgaWYgKG4gPCAxIHx8ICFzdHJpbmcgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbb3RoZXJPcHRpb25zXSBFbmFibGVzIHRoZSBsZWdhY3kgYG9wdGlvbnNgIHBhcmFtIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb24gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IG90aGVyT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3RoZXJPcHRpb25zIHx8IG9wdGlvbnMpLCBzZXR0aW5ncywgYXNzaWduT3duRGVmYXVsdHMpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3B0aW9ucy5pbXBvcnRzKSwgc2V0dGluZ3MuaW1wb3J0cywgYXNzaWduT3duRGVmYXVsdHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKCdzb3VyY2VVUkwnIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgY2hhcnMgPSAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltTGVmdChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltUmlnaHQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIDI0KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmMoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/ICgrb3B0aW9ucy5sZW5ndGggfHwgMCkgOiBsZW5ndGg7XG4gICAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSArb3B0aW9ucyB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChsZW5ndGggPj0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIG9taXNzaW9uLmxlbmd0aDtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIG5ld0VuZCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCAocmVGbGFncy5leGVjKHNlcGFyYXRvcikgfHwgJycpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PSBudWxsID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IsIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYCYjMzk7YCwgYW5kIGAmIzk2O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsIEhUTUxcbiAgICAgKiBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSkge1xuICAgICAgICBwYXR0ZXJuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4gfHwgcmVXb3JkcykgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnNcbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lIHRoZVxuICAgICAqIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgXG4gICAgICogaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW5cbiAgICAgKiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpdGVyYXRlZVxuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNhbGxiYWNrID0gXy53cmFwKF8uY2FsbGJhY2ssIGZ1bmN0aW9uKGNhbGxiYWNrLCBmdW5jLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoZnVuYyk7XG4gICAgICogICBpZiAoIW1hdGNoKSB7XG4gICAgICogICAgIHJldHVybiBjYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCdcbiAgICAgKiAgICAgICA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXVxuICAgICAqICAgICAgIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWdlX19ndDM2Jyk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgdGhpc0FyZywgZ3VhcmQpKSB7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKGZ1bmMpXG4gICAgICAgID8gbWF0Y2hlcyhmdW5jKVxuICAgICAgICA6IGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICogYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5tYXRjaGVzKHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYSBnaXZlblxuICAgICAqIG9iamVjdCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBfLm1hdGNoZXNQcm9wZXJ0eSgndXNlcicsICdmcmVkJykpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IF8uY29uc3RhbnQoMikgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiBfLmNvbnN0YW50KDEpIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmIuYycpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKF8uc29ydEJ5KG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gdGhlbiBtZXRob2RzIGFyZSBhZGRlZCB0b1xuICAgICAqIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWRcbiAgICAgKiAgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiA/IGtleXMoc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gKHByb3BzICYmIHByb3BzLmxlbmd0aCkgPyBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShmdW5jKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB1bmRlZmluZWRgIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvbiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IDIgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAxIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYi5jJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5wbHVjayhfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkocGF0aCkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCB0b1BhdGgocGF0aCksIHBhdGggKyAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzXG4gICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYGVuZGAgaXMgbGVzcyB0aGFuIGBzdGFydGBcbiAgICAgKiBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6ICgrc3RlcCB8fCAwKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG4gICAgICB9XG4gICAgICAvLyBVc2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlcy5cbiAgICAgIC8vIFNlZSBodHRwczovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBpbnZvY2F0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNiwgZmFsc2UpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgbWFnZS5jYXN0U3BlbGwobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzIHdpdGggYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHRoaXMuY2FzdChuKTtcbiAgICAgKiB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBuID0gbmF0aXZlRmxvb3Iobik7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgdG8gYXZvaWQgYSBKU0MgSklUIGJ1ZyBpbiBTYWZhcmkgOFxuICAgICAgLy8gd2hlcmUgYEFycmF5KDApYCBpcyB0cmVhdGVkIGFzIGBBcnJheSgxKWAuXG4gICAgICBpZiAobiA8IDEgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSk7XG5cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpZiAoaW5kZXggPCBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gKCthdWdlbmQgfHwgMCkgKyAoK2FkZGVuZCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oZ3QsIE5FR0FUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG4gICAgICogYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4odXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbih1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgbWluID0gY3JlYXRlRXh0cmVtdW0obHQsIFBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDZdKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogXy5zdW0oeyAnYSc6IDQsICdiJzogNiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICduJzogNCB9LFxuICAgICAqICAgeyAnbic6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnN1bShvYmplY3RzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiBvYmplY3QubjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnN1bShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBpdGVyYXRlZS5sZW5ndGggPT0gMVxuICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgTWFwYCBjYWNoZS5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcEhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwU2V0O1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYFNldGAgY2FjaGUuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5tb2RBcmdzID0gbW9kQXJncztcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJlc3RQYXJhbSA9IHJlc3RQYXJhbTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0QnlBbGwgPSBzb3J0QnlBbGw7XG4gICAgbG9kYXNoLnNvcnRCeU9yZGVyID0gc29ydEJ5T3JkZXI7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmJhY2tmbG93ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5jb21wb3NlID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmRXaGVyZTtcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZExlZnQgPSBwYWRMZWZ0O1xuICAgIGxvZGFzaC5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUxlZnQgPSB0cmltTGVmdDtcbiAgICBsb2Rhc2gudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuICAgIGxvZGFzaC50cnVuYyA9IHRydW5jO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5lcSA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLl9fY2hhaW5fXyAmJiBuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHZhbHVlLCBuKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgaWYgKGZpbHRlcmVkICYmICFpbmRleCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4gPT0gbnVsbCA/IDEgOiBuYXRpdmVNYXgobmF0aXZlRmxvb3IobikgfHwgMCwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4ocmVzdWx0Ll9fdGFrZUNvdW50X18sIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7ICdzaXplJzogbiwgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgIT0gTEFaWV9NQVBfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7ICdpdGVyYXRlZSc6IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSwgJ3R5cGUnOiB0eXBlIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5maXJzdGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2ZpcnN0JywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8ucmVzdGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICdyZXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8ucGx1Y2tgIGFuZCBgXy53aGVyZWAuXG4gICAgYXJyYXlFYWNoKFsncGx1Y2snLCAnd2hlcmUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gaW5kZXggPyAnZmlsdGVyJyA6ICdtYXAnLFxuICAgICAgICAgIGNyZWF0ZUNhbGxiYWNrID0gaW5kZXggPyBiYXNlTWF0Y2hlcyA6IHByb3BlcnR5O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tvcGVyYXRpb25OYW1lXShjcmVhdGVDYWxsYmFjayh2YWx1ZSkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gKCtlbmQgfHwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShQT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmZpcnN0fGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW3JldFVud3JhcHBlZCA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHJldFVud3JhcHBlZCA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXRVbndyYXBwZWQgJiYgY2hhaW5BbGwpXG4gICAgICAgICAgICA/IGxvZGFzaEZ1bmModmFsdWUsIDEpWzBdXG4gICAgICAgICAgICA6IGxvZGFzaEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhY3Rpb24gPSB7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsKSB7XG4gICAgICAgICAgaWYgKG9ubHlMYXp5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvZGFzaEZ1bmMuY2FsbCh1bmRlZmluZWQsIHRoaXMudmFsdWUoKSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gKC9eKD86cmVwbGFjZXxzcGxpdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gc3RyaW5nUHJvdG8gOiBhcnJheVByb3RvKVttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLnZhbHVlKCksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBmdW5jdGlvbiBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUsXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcih1bmRlZmluZWQsIEJJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3sgJ25hbWUnOiAnd3JhcHBlcicsICdmdW5jJzogdW5kZWZpbmVkIH1dO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgbGF6eSB3cmFwcGVyLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbmluZyBmdW5jdGlvbnMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25jYXQgPSB3cmFwcGVyQ29uY2F0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJ1biA9IGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbiBhbGlhc2VzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29sbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUubWFwO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuaGVhZCA9IGxvZGFzaC5wcm90b3R5cGUuZmlyc3Q7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5zZWxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLmZpbHRlcjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRhaWwgPSBsb2Rhc2gucHJvdG90eXBlLnJlc3Q7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIGxvZGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCB0byBhdm9pZFxuICAgIC8vIGVycm9ycyBpbiBjYXNlcyB3aGVyZSBsb2Rhc2ggaXMgbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBhbmQgbm90IGludGVuZGVkXG4gICAgLy8gYXMgYW4gQU1EIG1vZHVsZS4gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yXG4gICAgLy8gbW9yZSBkZXRhaWxzLlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzIG9yIFJpbmdvSlMuXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gRXhwb3J0IGZvciBSaGlubyB3aXRoIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciBhIGJyb3dzZXIgb3IgUmhpbm8uXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8qXHJcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcclxuKlxyXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHt9O1xyXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFdlIGNhbid0IGJ1aWxkIGEgcmVhbCBtZXRob2Qgd2l0aG91dCBhIGNvbnNvbGUgdG8gbG9nIHRvXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHNlbGZbbWV0aG9kTmFtZV0uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXHJcbiAgICAgICAgXCJ0cmFjZVwiLFxyXG4gICAgICAgIFwiZGVidWdcIixcclxuICAgICAgICBcImluZm9cIixcclxuICAgICAgICBcIndhcm5cIixcclxuICAgICAgICBcImVycm9yXCJcclxuICAgIF07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID8gbm9vcCA6IHNlbGYubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcclxuICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbJ2xvZ2xldmVsJ10gPSBsZXZlbE5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBcImxvZ2xldmVsPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRQZXJzaXN0ZWRMZXZlbCgpIHtcclxuICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXTtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL2xvZ2xldmVsPShbXjtdKykvLmV4ZWMod2luZG93LmRvY3VtZW50LmNvb2tpZSlbMV07XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gXCJXQVJOXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKlxyXG4gICAgICogUHVibGljIEFQSVxyXG4gICAgICpcclxuICAgICAqL1xyXG5cclxuICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxyXG4gICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XHJcblxyXG4gICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcclxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcclxuICAgIHNlbGYubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXHJcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IHNlbGYpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH07XHJcblxyXG4gICAgbG9hZFBlcnNpc3RlZExldmVsKCk7XHJcbiAgICByZXR1cm4gc2VsZjtcclxufSkpO1xyXG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTAuNlxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiB1dGlsc19ob29rc19faG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19pc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZDtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2NyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gdXRpbHNfaG9va3NfX2hvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzQU1vbWVudE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9zdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fdHptICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzVVRDICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9vZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fcGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sb2NhbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpIGluIG1vbWVudFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoKSB7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdW5kbyB0aGF0IGZvciBsYXp5IGxvYWRlZCBsb2NhbGVzXG4gICAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWVzLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0gfHwgbmV3IExvY2FsZSgpO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQodmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fc2V0IChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh1bml0IGluIHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFF8WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChzdGgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIzMjVcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGggPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdGgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIGhlcmUhXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcblxuICAgIHZhciBmcm9tX3N0cmluZ19faXNvUmVnZXggPSAvXlxccyooPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86KFxcZFxcZC1cXGRcXGQpfChXXFxkXFxkJCl8KFdcXGRcXGQtXFxkKXwoXFxkXFxkXFxkKSkoKFR8ICkoXFxkXFxkKDpcXGRcXGQoOlxcZFxcZChcXC5cXGQrKT8pPyk/KT8oW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkezJ9LVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGR7Mn0vXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgLyhUfCApXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgLyhUfCApXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBmcm9tX3N0cmluZ19faXNvUmVnZXguZXhlYyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFs2XSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSAobWF0Y2hbNl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKG1hdGNoT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSAnWic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTM0OC9pbnN0YW50aWF0aW5nLWEtamF2YXNjcmlwdC1vYmplY3QtYnktY2FsbGluZy1wcm90b3R5cGUtY29uc3RydWN0b3ItYXBwbHlcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciBkb2Vzbid0IGFjY2VwdCB5ZWFycyA8IDE5NzBcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrICAgICAgIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgc3VuZGF5IG9yIG1vbmRheSlcbiAgICAvLyBmaXJzdERheU9mV2Vla09mWWVhciAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGRheSBvZiB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIChlZy4gSVNPIHdlZWtzIHVzZSB0aHVyc2RheSAoNCkpXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgICAgICB2YXIgZW5kID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBmaXJzdERheU9mV2VlayxcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gbW9tLmRheSgpLFxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XG5cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdGVkTW9tZW50ID0gbG9jYWxfX2NyZWF0ZUxvY2FsKG1vbSkuYWRkKGRheXNUb0RheU9mV2VlaywgJ2QnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5kYXlPZlllYXIoKSAvIDcpLFxuICAgICAgICAgICAgeWVhcjogYWRqdXN0ZWRNb21lbnQueWVhcigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICB2YXIgd2VlazFKYW4gPSA2ICsgZmlyc3REYXlPZldlZWsgLSBmaXJzdERheU9mV2Vla09mWWVhciwgamFuWCA9IGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgMSArIHdlZWsxSmFuKSwgZCA9IGphblguZ2V0VVRDRGF5KCksIGRheU9mWWVhcjtcbiAgICAgICAgaWYgKGQgPCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICAgICAgZCArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IDEgKiB3ZWVrZGF5IDogZmlyc3REYXlPZldlZWs7XG5cbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIHdlZWsxSmFuICsgNyAqICh3ZWVrIC0gMSkgLSBkICsgd2Vla2RheTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogZGF5T2ZZZWFyID4gMCA/IHllYXIgOiB5ZWFyIC0gMSxcbiAgICAgICAgICAgIGRheU9mWWVhcjogZGF5T2ZZZWFyID4gMCA/ICBkYXlPZlllYXIgOiBkYXlzSW5ZZWFyKHllYXIgLSAxKSArIGRheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93LmdldFVUQ0Z1bGxZZWFyKCksIG5vdy5nZXRVVENNb250aCgpLCBub3cuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXA7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICsrd2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3ksIGRvdyk7XG5cbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgfVxuICAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAzNmU1OyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hPZmZzZXQpIHx8IFtdKTtcbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpKSAtICgrcmVzKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKCtyZXMuX2QgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcodGhpcy5faSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faXNEU1RTaGlmdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2lzVVRDO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMDtcbiAgICB9XG5cbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvKFxcLSk/KD86KFxcZCopXFwuKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/KT8vO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgdmFyIGNyZWF0ZV9faXNvUmVnZXggPSAvXigtKT9QKD86KD86KFswLTksLl0qKVkpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopRCk/KD86VCg/OihbMC05LC5dKilIKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKVMpPyk/fChbMC05LC5dKilXKSQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gY3JlYXRlX19pc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgbG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBkdXJhdGlvbi5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZSgrbW9tLl9kICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBhZGRfc3VidHJhY3RfX3N1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhciAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgbG9jYWxfX2NyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgZm9ybWF0ID0gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGZvcm1hdHMgJiYgZm9ybWF0c1tmb3JtYXRdIHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA+ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBpc01vbWVudChpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE1zIDwgK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPCAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5lbmRPZih1bml0cykgPCBpbnB1dE1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgJiYgdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzID09PSAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gKyh0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSArKHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKSxcbiAgICAgICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgICAgIG91dHB1dCA9IHVuaXRzID09PSAnc2Vjb25kJyA/IGRlbHRhIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRlbHRhIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdkYXknID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCk7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmcgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b190eXBlX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuICt0aGlzLl9kIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCt0aGlzIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA/IG5ldyBEYXRlKCt0aGlzKSA6IHRoaXMuX2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKFt5ZWFyLCAxMSwgMzEgKyBkb3cgLSBkb3ldKSwgZG93LCBkb3kpLndlZWs7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS55ZWFyO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAwLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZykge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lKSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSB0aGlzLl93ZWVrZGF5c1BhcnNlIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gbG9jYWxfX2NyZWF0ZUxvY2FsKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHRoaXMuZGF5KCkgfHwgNyA6IHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gaW5wdXQgOiBpbnB1dCAtIDcpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX2FkZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICA9IGRpZmY7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5lbmRPZiAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICA9IGZyb207XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tTm93ICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgPSB0b05vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICA9IGlzQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JlZm9yZSAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICA9IGlzU2FtZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICA9IG1vbWVudF92YWxpZF9faXNWYWxpZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxhbmcgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgPSBsb2NhbGVEYXRhO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWF4ICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzID0gcGFyc2luZ0ZsYWdzO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICA9IGFkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0FycmF5ICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgPSB0b0RhdGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgPSB1bml4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTc3OScsIGdldFNldFpvbmUpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0T3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgdGhpcy5fb3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAodGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSArICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uX2NhbGVuZGFyICAgICAgID0gZGVmYXVsdENhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9sb25nRGF0ZUZvcm1hdCA9IGRlZmF1bHRMb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2ludmFsaWREYXRlICAgID0gZGVmYXVsdEludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbCAgICAgICAgPSBkZWZhdWx0T3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbFBhcnNlICAgPSBkZWZhdWx0T3JkaW5hbFBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3JlbGF0aXZlVGltZSAgID0gZGVmYXVsdFJlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzICAgICAgPSBkZWZhdWx0TG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1Nob3J0ID0gZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuXG4gICAgLy8gV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2VlayA9IGRlZmF1bHRMb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICAvLyBEYXkgb2YgV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXMgICAgICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzTWluICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzU2hvcnQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5fbWVyaWRpZW1QYXJzZSA9IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGxpc3RzX19nZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3QgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBjb3VudCwgc2V0dGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGxpc3RzX19nZXQoZm9ybWF0LCBpLCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHMnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0JywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMgKyAncyddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA9PT0gMSAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPT09IDEgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgID09PSAxICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA9PT0gMSAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPT09IDEgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xMC42JztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5cbiAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgIHJldHVybiBfbW9tZW50O1xuXG59KSk7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogUmVwcmVzZW50IGEgcGxheWFibGUgc2V0IG9mIHNvdW5kcyBpbmNsdWRpbmcgYSBkZXNjcmlwdGl2ZSBrZXksIGFuIGF1ZGlvIHNwcml0ZSwgYW5kIHRoZSBzZXQgb2Ygc291bmQga2V5cy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChrZXksIHNwcml0ZSwgc291bmRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcclxuICAgICAgICAgICAgdGhpcy5zb3VuZHMgPSBzb3VuZHM7IC8vIGpzb24gc2V0IG9mIHNvdW5kcy5cclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChzb3VuZHMsIGZ1bmN0aW9uICh0aW1pbmcsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuYWRkTWFya2VyKGtleSwgdGltaW5nWzBdLCB0aW1pbmdbMV0sIDEsIHRpbWluZ1syXSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvblN0b3A6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUub25TdG9wLmFkZCh0aGlzLm9uU291bmRGaW5pc2hlZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbGxvd011bHRpcGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYWxsb3dNdWx0aXBsZSA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0N1cnJlbnRNYXJrZXI6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGUuY3VycmVudE1hcmtlciA9PT0ga2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNQbGF5aW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlLmlzUGxheWluZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEtleTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldENoYW5uZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNLZXk6IGZ1bmN0aW9uKCBrZXkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhISh0aGlzLnNvdW5kc1trZXldKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCBrZXkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnBsYXkoa2V5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5zdG9wKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTm9FdmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLm9uU3RvcC5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc3RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5vblN0b3AuYWRkKHRoaXMub25Tb3VuZEZpbmlzaGVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uU291bmRGaW5pc2hlZDogZnVuY3Rpb24gKHN0b3BwZWRTb3VuZCwgbWFya2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uU3RvcC5kaXNwYXRjaChzdG9wcGVkU291bmQsIG1hcmtlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUub25TdG9wLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBodHRwczovL3BoYXNlcmdhbWVzLmNvbS9waGFzZXItYXVkaW8tZGVsYXkvXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcbiAgICB2YXIgQXVkaW9DaGFubmVsID0gcmVxdWlyZSgnLi9hdWRpby1jaGFubmVsJyk7XHJcbiAgICB2YXIgQ0hBTk5FTF9QUklNQVJZID0gXCJwcmltYXJ5XCI7XHJcbiAgICB2YXIgQ0hBTk5FTF9NVVNJQyA9IFwic2Vjb25kYXJ5XCI7XHJcbiAgICB2YXIgQ0hBTk5FTF9TRlggPSBcInNmeFwiO1xyXG4gICAgLy92YXIgYnVpbGRBdWRpb0xpcFN5bmNBcnJheSA9IHJlcXVpcmUoJy4uL3Rvb2xzL2F1ZGlvLWxpcC1zeW5jJyk7IC8vY29tbWVudCBvdXQgd2hlbiBkb25lXHJcblxyXG4gICAgdmFyIEF1ZGlvU2VydmljZSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGdhbWUsIHRoZW1lRGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQXVkaW9TZXJ2aWNlIHJlcXVpcmVzIGdhbWUgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGVtZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQXVkaW9TZXJ2aWNlIHJlcXVpcmVzIHRoZW1lRGF0YSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWVEYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVscyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBzb3VuZEZpbmlzaGVkOiBuZXcgUGhhc2VyLlNpZ25hbCgpLFxyXG4gICAgICAgICAgICAgICAgb25TY2VuZUF1ZGlvUmVhZHk6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZXJlIGlzIGEgc2NlbmUgc2hvd2luZywgZW5kIGl0LlxyXG4gICAgICAgICAqIEBUT0RPIGFsbG93IHRoaXMgdG8gcmVtb3ZlIGZyb20gY2FjaGU/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RvcEFuZFVubG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5jaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFN0b3AgdGhlIGN1cnJlbnQgc2NlbmUgYW5kIGNsZWFuIGl0IHVwLlxyXG4gICAgICAgIHN0b3BTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tDSEFOTkVMX1BSSU1BUlldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV0uc3RvcE5vRXZlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tDSEFOTkVMX01VU0lDXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tDSEFOTkVMX01VU0lDXS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9TRlhdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfU0ZYXS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHNvbWV0aGluZyBzdGFydHMgdG8gcGxheSBhdWRpbywgaXQgZG9lcyBpdCB2aWEgYW4gZXZlbnQsIHRoaXMgYWxsb3dzIGZvciB0ZWxsaW5nIHRoZSBvdGhlciBhY3RvcnMsIHRoZVxyXG4gICAgICAgICAqIHNjZW5lLCBhY3QgYW5kIHRoZSBwbGF5LiBJbiB0aGlzIGNhc2UsIHdlIGFsc28gd2FudCB0byBzdG9wIGFueSBwcmV2aW91c2x5IHBsYXlpbmcgc291bmQuXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3BlZWNoIGlzIGFsd2F5cyB0cmFja2VkIHNvIHdlIGNhbiBoYXZlIGV2ZW50aW5nIG9uIHdoZW4gaXQgc3RvcHMuXHJcbiAgICAgICAgICogQHBhcmFtIGRhdGEge1xyXG4gICAgICAgICAqICB0ZXh0OiBcIlwiLFxyXG4gICAgICAgICAqICBcImF1ZGlvXCI6IFwiXCIsXHJcbiAgICAgICAgICogIFwia2V5XCI6IFwiXCIsXHJcbiAgICAgICAgICogIFwiY2hhbm5lbFwiOiBvcHRpb25hbCBjaGFubmVsLCBkZWZhdWx0cyB0byBwcmltYXJ5LCBzd2l0Y2hlZCB0byBzZnggZm9yIHNmeFxyXG4gICAgICAgICAqICBcInByaW9yaXR5XCI6IHN0b3AgfCByZXN0YXJ0IHwgcXVldWUgfCBsb3cgfCB3aXRoIHwgc3RvcGFsbFxyXG4gICAgICAgICAqICBcInN0b3BcIjogID0+IHN0b3AgYXVkaW8gaWYgcGxheWluZyB0aGUgc2FtZSBzb3VuZC5cclxuICAgICAgICAgKiAgXCJyZXN0YXJ0XCI6ICBSZXN0YXJ0IGF1ZGlvIGlmIHBsYXlpbmcgdGhlIHNhbWUgc291bmQuXHJcbiAgICAgICAgICogIFwicXVldWVcIjogUXVldWUgdGhlIGF1ZGlvIHRvIHBsYXkgbmV4dCwgd2lsbCBwbGF5IG5vdyBpZiBubyBxdWV1ZS5cclxuICAgICAgICAgKiAgXCJsb3dcIjogSWdub3JlIHJlcXVlc3QgaWYgc291bmQgaXMgcGxheWluZ1xyXG4gICAgICAgICAqICBcInN0b3BhbGxcIiA6IHN0b3BhbGwgc291bmQsIGlnbm9yZSBhdWRpbyBrZXkuXHJcbiAgICAgICAgICogIGRlZmF1bHQvaW50ZXJydXB0OiBJbnRlcnJ1cHQgdGhlIGN1cnJlbnQgc291bmQgYW5kIHBsYXkgdGhlIG5ldyBvbmUsIGVtcHR5aW5nIHRoZSBxdWV1ZS5cclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGxheUF1ZGlvOiBmdW5jdGlvbiAoYXVkaW8sIGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJkYXRhIGlzIHJlcXVpcmVkIHdoZW4gY2FsbGluZyBwbGF5QXVkaW9cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFkYXRhLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnByaW9yaXR5ID0gXCJpbnRlcnJ1cHRcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFkYXRhLmNoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuY2hhbm5lbCA9IENIQU5ORUxfUFJJTUFSWTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQXR0ZW1wdGluZyB0byBwbGF5IGF1ZGlvIGJlZm9yZSBnYW1lIHNvdW5kcyBhcmUgaW5pdGlhbGl6ZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5maW5kQ2hhbm5lbEZvcktleShhdWRpbywgZGF0YS5jaGFubmVsKTtcclxuICAgICAgICAgICAgaWYgKCFjaGFubmVsICkge1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBhY3Rpdml0aWVzIHBsYXkgXCJzaWxlbmNlXCIsIHJhdGhlciB0aGFuIGFkanVzdGluZyB0aGUgY29udmVydGVkIFhNTCwgd2Ugc3VwcG9ydCBpdC5cclxuICAgICAgICAgICAgICAgIGlmKCBhdWRpbyA9PT0gXCJzaWxlbmNlXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnByaW9yaXR5ID0gXCJzdG9wYWxsXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiUmVxdWVzdCB0byBwbGF5IHVua25vd24ga2V5OiBcIiArIGF1ZGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2FtZVNvdW5kcyA9IHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXTtcclxuICAgICAgICAgICAgc3dpdGNoIChkYXRhLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdG9wYWxsJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9RdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0b3AnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzdG9wIGlzIGFsd2F5cyBhIHN0b3AsIHNvIGVpdGhlciBzdG9wIG9yIGRvIG5vdGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuaXNQbGF5aW5nICYmIGNoYW5uZWwuaXNDdXJyZW50TWFya2VyKGF1ZGlvKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Jlc3RhcnQnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuaXNQbGF5aW5nICYmIGNoYW5uZWwuaXNDdXJyZW50TWFya2VyKGF1ZGlvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdxdWV1ZSc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbC5pc1BsYXlpbmcoKSAmJiAhY2hhbm5lbC5pc0N1cnJlbnRNYXJrZXIoYXVkaW8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9RdWV1ZS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwgZmFsbCB0aHJvdWdoIGFuZCBwbGF5IHRoZSBzb3VuZC5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbC5pc1BsYXlpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2Z4Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmZpbmRDaGFubmVsRm9yS2V5KGF1ZGlvLCAnc2Z4Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFubmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiUmVxdWVzdCB0byBwbGF5IHVua25vd24gc2Z4IGtleTogXCIgKyBhdWRpbztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5wbGF5KGF1ZGlvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW50ZXJydXB0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmlzUGxheWluZygpICYmIGNoYW5uZWwuaXNDdXJyZW50TWFya2VyKGF1ZGlvKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBwbGF5aW5nLCBqdXN0IGtlZXAgcGxheWluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbG9nLndhcm4oXCJQbGF5aW5nIGF1ZGlvIFwiICsgYXVkaW8pO1xyXG4gICAgICAgICAgICBjaGFubmVsLnBsYXkoYXVkaW8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnQgYnkgdHJ5aW5nIHRvIGdldCB0aGUgcHJlZmVycmVkIGNoYW5uZWwsIGJ1dCBvdGhlcndpc2Ugc2VhcmNoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbmRDaGFubmVsRm9yS2V5OiBmdW5jdGlvbiAoa2V5LCBwcmVmZXJyZWRDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVmZXJyZWQgPSB0aGlzLmNoYW5uZWxzW3ByZWZlcnJlZENoYW5uZWxdO1xyXG4gICAgICAgICAgICBpZiAocHJlZmVycmVkICYmIHByZWZlcnJlZC5oYXNLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZlcnJlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXy5maW5kKHRoaXMuY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5oYXNLZXkoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVNdXNpYzogZnVuY3Rpb24gKGF1ZGlvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9NVVNJQ10ucGxheShhdWRpbyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIGF1ZGlvIGZpbmlzaGVzIHBsYXlpbmcsIGFjdG9ycyBuZWVkIHRvIGtub3csIGluIGNhc2UgdGhleSBhcmUgYW5pbWF0aW5nIHNwZWVjaC9ldGMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25Tb3VuZEZpbmlzaGVkOiBmdW5jdGlvbiAoc3RvcHBlZFNvdW5kLCBtYXJrZXIpIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJPbiBzb3VuZCBGaW5pc2hlZCBjYWxsZWQgZm9yOiBcIiArIG1hcmtlcik7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKHN0b3BwZWRTb3VuZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zb3VuZEZpbmlzaGVkLmRpc3BhdGNoKHN0b3BwZWRTb3VuZCwgbWFya2VyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmF1ZGlvUXVldWUucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyhkYXRhLmF1ZGlvLCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdFNvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBVbmNvbW1lbnQgdGhpcyBsaW5lIGFuZCB5b3Ugd2lsbCBwcm9kdWNlIGxpcCBzeW5jIGRhdGEuXHJcbiAgICAgICAgICAgIC8vYnVpbGRBdWRpb0xpcFN5bmNBcnJheSh0aGlzLnRoZW1lLnNvdW5kRmlsZVswXSwgdGhpcy50aGVtZS5zb3VuZHMsIHRoaXMudGhlbWUuc291bmRTeW5jRGF0YSk7IC8vY29tbWVudCBvdXQgd2hlbiBkb25lXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXSA9IG5ldyBBdWRpb0NoYW5uZWwodGhpcy50aGVtZS5zb3VuZEtleSwgdGhpcy5nYW1lLmFkZC5hdWRpbyh0aGlzLnRoZW1lLnNvdW5kS2V5KSwgdGhpcy50aGVtZS5zb3VuZHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfTVVTSUNdID0gbmV3IEF1ZGlvQ2hhbm5lbCh0aGlzLnRoZW1lLnNvdW5kS2V5LCB0aGlzLmdhbWUuYWRkLmF1ZGlvKHRoaXMudGhlbWUuc291bmRLZXkpLCB0aGlzLnRoZW1lLnNvdW5kcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9TRlhdID0gbmV3IEF1ZGlvQ2hhbm5lbCh0aGlzLnRoZW1lLnNvdW5kS2V5LCB0aGlzLmdhbWUuYWRkLmF1ZGlvKHRoaXMudGhlbWUuc291bmRLZXkpLCB0aGlzLnRoZW1lLnNvdW5kcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXS5hbGxvd011bHRpcGxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9NVVNJQ10uYWxsb3dNdWx0aXBsZSgpO1xyXG4gICAgICAgICAgICAvL3RoaXMuZ2FtZVNvdW5kcy5vbk1hcmtlckNvbXBsZXRlLmFkZCh0aGlzLm9uU291bmRGaW5pc2hlZCwgdGhpcyk7IFRoaXMgZXZlbnQgZG9lc24ndCBkbyB3aGF0IHlvdSB0aGluay5cclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tDSEFOTkVMX1BSSU1BUlldLmV2ZW50cy5vblN0b3AuYWRkKHRoaXMub25Tb3VuZEZpbmlzaGVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZXNlIHRocmVlIGZ1bmN0aW9ucyBhcmUgdGhlIG9sZCBsb2FkaW5nIGZ1bmN0aW9ucyB1c2VkIGJ5IHBsYXktYWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbG9hZEF1ZGlvOiBmdW5jdGlvbiAoc291bmRLZXksIHNvdW5kRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5hdWRpbyhzb3VuZEtleSwgc291bmRGaWxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubG9hZEF1ZGlvOiBmdW5jdGlvbiAoc291bmRLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmNhY2hlLnJlbW92ZVNvdW5kKHNvdW5kS2V5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUmVhZHk6IGZ1bmN0aW9uIChzb3VuZEtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nYW1lLmNhY2hlLmlzU291bmREZWNvZGVkKHNvdW5kS2V5KVxyXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nYW1lLmNhY2hlLmlzU291bmRSZWFkeShzb3VuZEtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGVzZSBhcmUgdGhlIG5ld2VyIGZ1bmN0aW9ucyB3aGljaCBzaG93IHRoZSBsb2FkaW5nIHNjcmVlbiBkdXJpbmcgZHluYW1pYyBsb2FkaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWRpbmdTY3JlZW4uc2hvdygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZEFkZGl0aW9uYWxBdWRpbzogZnVuY3Rpb24gKGF1ZGlvTGlzdCkge1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9MaXN0ICYmIGF1ZGlvTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dMb2FkaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGF1ZGlvTGlzdCwgZnVuY3Rpb24gKGF1ZGlvS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yU291bmREYXRhID0gdGhpcy50aGVtZS5hY3RvclNvdW5kc1thdWRpb0tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RvclNvdW5kRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk5vIGF1ZGlvIGVudHJ5IGZvciBhdWRpbyBrZXk6IFwiICsgYXVkaW9LZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPIGp1c3QgZ28gYWhlYWQgYW5kIGxvYWQgdGhlIGpzb24gYXMgd2VsbCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gYmUgY29waWVkIGluIVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkLmF1ZGlvKGF1ZGlvS2V5LCBhY3RvclNvdW5kRGF0YS5zb3VuZEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0xpc3QgPSBhdWRpb0xpc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMud2FpdEZvckF1ZGlvRGVjb2RlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnT3V0cHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vblNjZW5lQXVkaW9SZWFkeS5kaXNwYXRjaCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5sb2FkQWRkaXRpb25hbEF1ZGlvOiBmdW5jdGlvbiAoYXVkaW9MaXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChhdWRpb0xpc3QgJiYgYXVkaW9MaXN0Lmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfLmVhY2goYXVkaW9MaXN0LCBmdW5jdGlvbiAoYXVkaW9LZXkpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmKCB0aGlzLmNoYW5uZWxzW2F1ZGlvS2V5XSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2F1ZGlvS2V5XS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhbm5lbHNbYXVkaW9LZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5jYWNoZS5yZW1vdmVTb3VuZChhdWRpb0tleSk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FpdEZvckF1ZGlvRGVjb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdhbWUubG9hZGluZ1NjcmVlbi5zaG93RGVjb2RpbmcoKTtcclxuICAgICAgICAgICAgXy5lYWNoKHRoaXMuYXVkaW9MaXN0LCBmdW5jdGlvbiAoYXVkaW9LZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdhbWUuY2FjaGUuY2hlY2tTb3VuZEtleShhdWRpb0tleSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NlbmUgd2FzIHNvbWVob3cgZGVzdHJveWVkIGJlZm9yZSBpdCBmaW5pc2hlZCBsb2FkaW5nIGl0J3MgYXVkaW8uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdhbWUuY2FjaGUuaXNTb3VuZERlY29kZWQoYXVkaW9LZXkpIHx8ICF0aGlzLmdhbWUuY2FjaGUuaXNTb3VuZFJlYWR5KGF1ZGlvS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFsbFJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNoYW5uZWxzKHRoaXMuYXVkaW9MaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9MaXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdPdXRwdXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uU2NlbmVBdWRpb1JlYWR5LmRpc3BhdGNoKHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChfLmJpbmQodGhpcy53YWl0Rm9yQXVkaW9EZWNvZGUsIHRoaXMpLCA1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWJ1Z091dHB1dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIHZhciBjaGFubmVsTmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gdmFyIGNhY2hlTmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gXy5lYWNoKCB0aGlzLmNoYW5uZWxzLCBmdW5jdGlvbihjaGFubmVsLCBrZXkpIHtcclxuICAgICAgICAgICAgLy8gICAgIGNoYW5uZWxOYW1lcy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIC8vIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBfLmVhY2goIHRoaXMuZ2FtZS5jYWNoZS5nZXRLZXlzKFBoYXNlci5DYWNoZS5TT1VORCksIGZ1bmN0aW9uKCBrZXkpIHtcclxuICAgICAgICAgICAgLy8gICAgIGNhY2hlTmFtZXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAvLyB9LCB0aGlzKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiQXZhaWxhYmxlIENoYW5uZWxzIGZvciBzY2VuZTogXCIgKyBjaGFubmVsTmFtZXMuam9pbihcIiwgXCIpKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiQXZhaWxhYmxlIENoYW5uZWxzIGluIGNhY2hlOiBcIiArIGNoYW5uZWxOYW1lcy5qb2luKFwiLCBcIikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlQ2hhbm5lbHM6IGZ1bmN0aW9uKCBhdWRpb0xpc3QgKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaChhdWRpb0xpc3QsIGZ1bmN0aW9uIChhdWRpb0tleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdG9yU291bmREYXRhID0gdGhpcy50aGVtZS5hY3RvclNvdW5kc1thdWRpb0tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFjdG9yU291bmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJObyBhdWRpbyBlbnRyeSBmb3IgTE9BREVEIGF1ZGlvIGtleTogXCIgKyBhdWRpb0tleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbYXVkaW9LZXldID0gbmV3IEF1ZGlvQ2hhbm5lbChhdWRpb0tleSwgdGhpcy5nYW1lLmFkZC5hdWRpbyhhdWRpb0tleSksIGFjdG9yU291bmREYXRhLnNvdW5kcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQXVkaW9TZXJ2aWNlO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA5LzIyLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXR1cm4gYW4gYWN0IGluc3RhbmNlIGdpdmVuIGEgdHlwZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgUGxheUFjdCA9IHJlcXVpcmUoJy4vcGxheS1hY3QnKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBnZXRBY3RJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIGdhbWUsIHRoZW1lRGF0YSwgYWN0TmFtZSkge1xyXG4gICAgICAgICAgICBpZiggdHlwZSAmJiB0eXBlICE9PSBcIlBsYXlBY3RcIiApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGF6eiA9IHdpbmRvd1t0eXBlXTtcclxuICAgICAgICAgICAgICAgIGlmKCBjbGF6eiApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0SW5zdGFuY2UgPSBuZXcgY2xhenooZ2FtZSwgIHRoZW1lRGF0YSwgYWN0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0SW5zdGFuY2UuYWN0TmFtZSA9IGFjdE5hbWU7IC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBmdW5ueSBidXNpbmVzcy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0SW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChcIlVuYWJsZSB0byBsb2FkIGFjdGl2aXR5OiBcIiArIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGF5QWN0KGdhbWUsIHRoZW1lRGF0YSwgYWN0TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXByZXNlbnQgYW4gZW50aXJlIEFDVC4gQW4gYWN0IGNvb3JkaW5hdGVzIGEgc2V0IG9mIHNjZW5lcy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0dmFyIF8gPSByZXF1aXJlKFwibG9kYXNoXCIpLFxyXG5cdFx0bG9nID0gcmVxdWlyZShcImxvZ2xldmVsXCIpLFxyXG5cdFx0QmFzZSA9IHJlcXVpcmUoXCJiYXNlanNcIiksXHJcblx0XHRQbGF5U2NlbmUgPSByZXF1aXJlKFwiLi4vc2NlbmUvcGxheS1zY2VuZVwiKSxcclxuXHRcdFBsYXlBY3Rpb24gPSByZXF1aXJlKFwiLi4vc2NlbmUvcGxheS1hY3Rpb25cIiksXHJcblx0XHRQbGF5TW9kZWwgPSByZXF1aXJlKFwiLi4vcGxheS9tb2RlbFwiKSxcclxuXHRcdEFjdFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvclwiKTtcclxuXHR2YXIgQXVkaW9TZXJ2aWNlID0gcmVxdWlyZShcIi4vYXVkaW8tc2VydmljZVwiKTtcclxuXHJcblx0dmFyIFBsYXlBY3QgPSBCYXNlLmV4dGVuZCh7XHJcblx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGdhbWUsIHRoZW1lRGF0YSwgYWN0TmFtZSkge1xyXG5cdFx0XHRpZiAoIWdhbWUpIHtcclxuXHRcdFx0XHR0aHJvdyBcIlBsYXlBY3QgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIXRoZW1lRGF0YSkge1xyXG5cdFx0XHRcdHRocm93IFwiUGxheUFjdCByZXF1aXJlcyB0aGVtZURhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5nYW1lID0gZ2FtZTtcclxuXHRcdFx0dGhpcy50aGVtZSA9IHRoZW1lRGF0YTtcclxuXHRcdFx0dGhpcy5hY3ROYW1lID0gYWN0TmFtZTtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2UgPSBuZXcgQXVkaW9TZXJ2aWNlKHRoaXMuZ2FtZSwgdGhpcy50aGVtZSk7XHJcblxyXG5cdFx0XHR0aGlzLmV2ZW50cyA9IHtcclxuXHRcdFx0XHRvbkdhbWVDaG9pY2U6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcblx0XHRcdFx0b25BY3RTdGF0dXM6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLmlzUHJlbG9hZGVkID0gZmFsc2U7XHJcblx0XHR9LFxyXG5cdFx0c2V0U2Nvcm1TdHJpbmc6IGZ1bmN0aW9uIChzdXNwZW5kRGF0YSkge1xyXG5cdFx0XHR0aGlzLnN1c3BlbmREYXRhID0gc3VzcGVuZERhdGE7XHJcblx0XHR9LFxyXG5cdFx0Z2V0U2Nvcm1TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubW9kZWwuZ2V0U3VzcGVuZERhdGEoKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFNob3cgdGhlIGN1cnJlbnQgc2NlbmUsIGNsZWFyaW5nIG91dCBhbnkgb2xkIHNjZW5lLiBJZiB0aGVyZSBpcyBhIHNvdW5kIHBsYXlpbmcsIHN0b3AgaXQuIFRoaXMgZnJlZXMgdXBcclxuXHRcdCAqIG1lbW9yeSwgYnV0IGluIHRoZSBmdXR1cmUgaXQgY291bGQgcG9zc2libHkgcmVjeWNsZSBhY3RvcnMuXHJcblx0XHQgKi9cclxuXHRcdHN0YXJ0OiBmdW5jdGlvbiAoaXNSZXN0YXJ0KSB7XHJcblx0XHRcdGxvZy53YXJuKFwic2hvd0N1cnJlbnRTY2VuZSBjYWxsZWQuXCIpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuc3VzcGVuZERhdGEpIHtcclxuXHRcdFx0XHR0aGlzLm1vZGVsLnJlc3RvcmVEYXRhKHRoaXMuc3VzcGVuZERhdGEpO1xyXG5cdFx0XHRcdHRoaXMuc3VzcGVuZERhdGEgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMubW9kZWwuZXZlbnRzLm9uR2FtZU91dGNvbWUuYWRkKHRoaXMub25HYW1lT3V0Y29tZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLmluaXRTb3VuZHMoKTtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2UuZXZlbnRzLm9uU2NlbmVBdWRpb1JlYWR5LmFkZChcclxuXHRcdFx0XHR0aGlzLm9uU2NlbmVTdGFydEF1ZGlvUmVhZHksXHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5ldmVudHMuc291bmRGaW5pc2hlZC5hZGQodGhpcy5vblNvdW5kRmluaXNoZWQsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGlzUmVzdGFydCkge1xyXG5cdFx0XHRcdGxvZy53YXJuKFwiVHJ5aW5nIHRvIHJlc3RhcnQuLi5cIiArIHRoaXMubW9kZWwuZ2V0Q3VycmVudFNjZW5lTmFtZSgpKTtcclxuXHRcdFx0XHR0aGlzLm1vZGVsLnRyeVJlc3VtZSgpO1xyXG5cdFx0XHRcdGxvZy53YXJuKFwiLi4uLi5cIiArIHRoaXMubW9kZWwuZ2V0Q3VycmVudFNjZW5lTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnN0YXJ0U2NlbmUoKTtcclxuXHRcdH0sXHJcblx0XHRzdGFydFNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBuZXdTY2VuZURhdGEgPSB0aGlzLm1vZGVsLmdldEN1cnJlbnRTY2VuZSgpO1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U2NlbmUpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zaG93TmV3U2NlbmVEYXRhKG5ld1NjZW5lRGF0YSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUgPSBuZXcgUGxheVNjZW5lKFxyXG5cdFx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdFx0bmV3U2NlbmVEYXRhLFxyXG5cdFx0XHRcdFx0dGhpcy5tb2RlbC5nZXRWYXJJbnRlcmZhY2UoKSxcclxuXHRcdFx0XHRcdHRoaXMudGhlbWVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLmxvYWRBZGRpdGlvbmFsQXVkaW8oXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZ2V0QWRkaXRpb25hbEF1ZGlvKClcclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgaXMgdGhlIG90aGVyIGhhbGYgb2YgXCJzdGFydFNjZW5lXCIsIHdoaWNoIG5vdyB3YWl0cyBmb3IgYXVkaW8uLi5cclxuXHRcdCAqL1xyXG5cdFx0b25TY2VuZVN0YXJ0QXVkaW9SZWFkeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5tb2RlbC5pc1Nob3dQbGF5VGhyb3VnaCgpKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc2hvd1BsYXlUaHJvdWdoKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmV2ZW50cy5vbkdhbWVDaG9pY2UuYWRkKHRoaXMub25HYW1lQ2hvaWNlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZXZlbnRzLm9uR2FtZVNwZWVjaC5hZGQodGhpcy5vbkdhbWVTcGVlY2gsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5ldmVudHMub25HYW1lTXVzaWMuYWRkKHRoaXMub25HYW1lTXVzaWMsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zaG93U2NlbmUoKTtcclxuXHRcdFx0dGhpcy5ydW5TY2VuZVN0YXJ0QWN0aW9ucygpO1xyXG5cdFx0XHR0aGlzLmV2ZW50cy5vbkFjdFN0YXR1cy5kaXNwYXRjaChcInNhdmVcIik7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGVuIGEgc2NlbmUgc3RhcnRzLCBydW4gYW55IHN0YXJ0aW5nIGFjdGlvbnMuXHJcblx0XHQgKi9cclxuXHRcdHJ1blNjZW5lU3RhcnRBY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBhY3Rpb25zID0gdGhpcy5jdXJyZW50U2NlbmUuZ2V0QWN0aW9ucygpO1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0YWN0aW9ucyxcclxuXHRcdFx0XHRmdW5jdGlvbiAoc2luZ2xlQWN0aW9uKSB7XHJcblx0XHRcdFx0XHRsb2cud2FybihcImV4ZWN1dGluZyBzdGFydGluZyBhY3Rpb246XCIpO1xyXG5cdFx0XHRcdFx0bG9nLndhcm4oc2luZ2xlQWN0aW9uKTtcclxuXHRcdFx0XHRcdFBsYXlBY3Rpb24uZ2V0QWN0aW9uKHNpbmdsZUFjdGlvbikuZXhlY3V0ZSh0aGlzKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdFx0YWN0aW9ucyA9IHRoaXMubW9kZWwuZ2V0R2xvYmFsQWN0aW9ucygpO1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0YWN0aW9ucyxcclxuXHRcdFx0XHRmdW5jdGlvbiAoc2luZ2xlQWN0aW9uKSB7XHJcblx0XHRcdFx0XHRsb2cud2FybihcImV4ZWN1dGluZyBzdGFydGluZyBnbG9iYWwgYWN0aW9uOlwiKTtcclxuXHRcdFx0XHRcdGxvZy53YXJuKHNpbmdsZUFjdGlvbik7XHJcblx0XHRcdFx0XHRQbGF5QWN0aW9uLmdldEFjdGlvbihzaW5nbGVBY3Rpb24pLmV4ZWN1dGUodGhpcyk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdCk7XHJcblx0XHRcdC8vIFRoZSBzY2VuZSBpcyBkb25lIHN0YXJ0aW5nIHVwLCBhbGxvdyBpbnB1dC5cclxuXHRcdFx0dGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gZmFsc2U7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiB0aGVyZSBpcyBhIHNjZW5lIHNob3dpbmcsIGVuZCBpdC5cclxuXHRcdCAqL1xyXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5zdG9wQW5kVW5sb2FkKCk7XHJcblxyXG5cdFx0XHQvLyBJZiB3ZSdyZSBub3QgaW4gYSBzY2VuZSwgdGhlbiBubyBpbnB1dCFcclxuXHRcdFx0dGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZGVzdHJveSgpO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnVubG9hZCgpOyAvLyByZW1vdmUgZXZlcnl0aGluZyB0aGF0IHdhcyBwcmVsb2FkZWQuXHJcblx0XHR9LFxyXG5cdFx0Ly8gU3RvcCB0aGUgY3VycmVudCBzY2VuZSBhbmQgY2xlYW4gaXQgdXAuXHJcblx0XHRzdG9wU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2Uuc3RvcFNjZW5lKCk7XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLnVubG9hZEFkZGl0aW9uYWxBdWRpbyhcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5nZXRBZGRpdGlvbmFsQXVkaW8oKVxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U2NlbmUpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5jbGVhckZvclJldXNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIG91dGNvbWUgb3Igc3RhcnRpbmcgYWN0aW9uIGhhcyBzZXQgYSB2YXJpYWJsZSAoZ2FtZSBjaG9pY2UpLiBPdGhlciBhY3RvcnMgaW4gdGhlIHNjZW5lIG5lZWQgdG9cclxuXHRcdCAqIGtub3cgYWJvdXQgaXQuXHJcblx0XHQgKiBAcGFyYW0gZGF0YVxyXG5cdFx0ICovXHJcblx0XHRvbkdhbWVDaG9pY2VBY3Rpb246IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdHRoaXMub25HYW1lQ2hvaWNlKGRhdGEpO1xyXG5cdFx0XHRpZiAoIWRhdGEuY29uc3VtZWQpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zZW5kR2FtZUNob2ljZVRvQWN0b3JzKFwiIUFDVElPTiFcIiwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFNvbWV0aGluZyBpbiB0aGUgZ2FtZSBoYXMgbWFkZSBhIGNob2ljZS4gVGhpcyBjaG9pY2UgaXMgcmVjb3JkZWQgYXMgdGhlIHNldHRpbmcgb2YgYSB2YXJpYWJsZSwgd2UgdGhlblxyXG5cdFx0ICogcnVuIGFuIHVwZGF0ZSBpbiBjYXNlIHRoYXQgY2hvaWNlIGxlZCB0byBhbiBhY3Rpb24sIChldmVudHMgYnViYmxlIHVwLCBhY3Rpb25zIGhhcHBlbiBkb3duKVxyXG5cdFx0ICogQHBhcmFtIGRhdGFcclxuXHRcdCAqL1xyXG5cdFx0b25HYW1lQ2hvaWNlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHRsb2cud2FybihcImdhbWUgY2hvaWNlXCIpO1xyXG5cdFx0XHRsb2cud2FybihkYXRhKTtcclxuXHJcblx0XHRcdHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaChkYXRhKTtcclxuXHRcdFx0aWYgKGRhdGEuY29uc3VtZWQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ZW1wVmFycyA9IF8ucGFpcnMoZGF0YSlbMF07XHJcblx0XHRcdGxvZy53YXJuKHRlbXBWYXJzKTtcclxuXHRcdFx0ZGF0YS5jb25zdW1lZCA9IHRoaXMuYWN0Q29tbWFuZCh0ZW1wVmFyc1swXSwgdGVtcFZhcnNbMV0pO1xyXG5cclxuXHRcdFx0Ly8gT25seSByZWNvcmQgdGhlIHZhcmlhYmxlIGlmIGl0IHdhc24ndCBhIGNvbW1hbmQsIHdoaWNoIGRvZXMgTk9UIGNvbnN1bWUgaXQuIEl0IG1heSByZXN1bHQgaW4gYW4gZXZlbnQsXHJcblx0XHRcdC8vIG90aGVyd2lzZSwgY2hlY2sgZm9yIGNvbXBsZXRlZCBvdXRjb21lcy5cclxuXHRcdFx0aWYgKCFkYXRhLmNvbnN1bWVkKSB7XHJcblx0XHRcdFx0dmFyIGV2ZW50ID0gdGhpcy5tb2RlbC5oYW5kbGVTcGVjaWFsVmFyKHRlbXBWYXJzWzBdLCB0ZW1wVmFyc1sxXSk7XHJcblx0XHRcdFx0Ly8gdmFyIGV2ZW50ID0gdGhpcy5tb2RlbC5zZXRWYXIodGVtcFZhcnNbMF0sIHRlbXBWYXJzWzFdKTtcclxuXHRcdFx0XHRpZiAoZXZlbnQpIHtcclxuXHRcdFx0XHRcdHRoaXMuZXZlbnRzLm9uQWN0U3RhdHVzLmRpc3BhdGNoKGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMubW9kZWwuc2V0VmFyKHRlbXBWYXJzWzBdLCB0ZW1wVmFyc1sxXSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tDdXJyZW50U2NlbmVPdXRjb21lcyh0ZW1wVmFyc1swXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Y2hlY2tDdXJyZW50U2NlbmVPdXRjb21lczogZnVuY3Rpb24gKHZhcmlhYmxlKSB7XHJcblx0XHRcdHRoaXMubW9kZWwuY2hlY2tGb3JDb21wbGV0ZWRPdXRjb21lcyh2YXJpYWJsZSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0aGlzIGZ1bmN0aW9uIGNsZWFycyBhIHZhcmlhYmxlIG91dCBvZiB0aGUgbW9kZWwgbWFudWFsbHkuIEl0IHNob3VsZCBhbG1vc3QgbmV2ZXIgYmUgdXNlZC5cclxuXHRcdCAqIEBwYXJhbSBuYW1lXHJcblx0XHQgKi9cclxuXHRcdGNsZWFyVmFyaWFibGU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRcdHRoaXMubW9kZWwudmFyaWFibGVzW25hbWVdID0gdW5kZWZpbmVkO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogUnVuIGFuIEFjdCBsZXZlbCBjb21tYW5kLiBSZXR1cm4gdHJ1ZSBpZiBhIGNvbW1hbmQgaGFwcGVuZWQsIG90aGVyd2lzZSBmYWxzZS5cclxuXHRcdCAqIEBwYXJhbSBjb21tYW5kXHJcblx0XHQgKiBAcGFyYW0gYXJnXHJcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgY29uc3VtZWQuXHJcblx0XHQgKi9cclxuXHRcdGFjdENvbW1hbmQ6IGZ1bmN0aW9uIChjb21tYW5kLCBhcmcpIHtcclxuXHRcdFx0bG9nLndhcm4oXCJBY3QgY29tbWFuZDogXCIgKyBjb21tYW5kICsgXCIgLyBcIiArIGFyZyk7XHJcblx0XHRcdGlmIChjb21tYW5kID09PSBcInJlbW92ZS1hY3RvclwiICYmIHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlQWN0b3JCeU5hbWUoYXJnKTtcclxuXHRcdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcImFkZC1hY3RvclwiICYmIHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuYWRkQWN0b3IoYXJnKTtcclxuXHRcdFx0fSBlbHNlIGlmIChcclxuXHRcdFx0XHRjb21tYW5kID09PSBcIm9iamVjdGl2ZV9jb21wbGV0ZVwiIHx8XHJcblx0XHRcdFx0Y29tbWFuZCA9PT0gXCJhY3Rpdml0eV9jb21wbGV0ZVwiXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdC8vIG9iamVjdGl2ZV9jb21wbGV0ZSA9PiBcImZpbmlzaGVkIHRoaXMgYWN0XCIsIG5vdCBhIHNjb3JtIG9iamVjdGl2ZS5cclxuXHRcdFx0XHR0aGlzLmV2ZW50cy5vbkFjdFN0YXR1cy5kaXNwYXRjaChcImNvbXBsZXRlXCIpO1xyXG5cdFx0XHRcdC8vIG9iamVjdGl2ZSA9PiBcImZpbmlzaCBhIHNjb3JtIG9iamVjdGl2ZVwiXHJcblx0XHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJvYmplY3RpdmVcIikge1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLm9uQWN0U3RhdHVzLmRpc3BhdGNoKFwib2JqZWN0aXZlXCIsIGFyZyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgc29tZXRoaW5nIHN0YXJ0cyB0byBwbGF5IGF1ZGlvLCBpdCBkb2VzIGl0IHZpYSBhbiBldmVudCwgdGhpcyBhbGxvd3MgZm9yIHRlbGxpbmcgdGhlIG90aGVyIGFjdG9ycywgdGhlXHJcblx0XHQgKiBzY2VuZSwgYWN0IGFuZCB0aGUgcGxheS4gSW4gdGhpcyBjYXNlLCB3ZSBhbHNvIHdhbnQgdG8gc3RvcCBhbnkgcHJldmlvdXNseSBwbGF5aW5nIHNvdW5kLlxyXG5cdFx0ICogVGhlIGN1cnJlbnQgc3BlZWNoIGlzIGFsd2F5cyB0cmFja2VkIHNvIHdlIGNhbiBoYXZlIGV2ZW50aW5nIG9uIHdoZW4gaXQgc3RvcHMuXHJcblx0XHQgKiBAcGFyYW0gZGF0YVxyXG5cdFx0ICovXHJcblx0XHRvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdGxvZy53YXJuKFwib24gZ2FtZSBzcGVlY2hcIik7XHJcblx0XHRcdGxvZy53YXJuKGRhdGEpO1xyXG5cclxuXHRcdFx0dmFyIGF1ZGlvID0gdGhpcy5tb2RlbC5nZXRWYWx1ZShkYXRhLmF1ZGlvKTtcclxuXHRcdFx0aWYgKGRhdGEua2V5KSB7XHJcblx0XHRcdFx0YXVkaW8gPSB0aGlzLm1vZGVsLmdldFZhbHVlKGRhdGEua2V5KSArIFwiX1wiICsgYXVkaW87XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLnBsYXlBdWRpbyhhdWRpbywgZGF0YSk7XHJcblx0XHR9LFxyXG5cdFx0b25HYW1lTXVzaWM6IGZ1bmN0aW9uIChhdWRpbykge1xyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5vbkdhbWVNdXNpYyhhdWRpbyk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGVuIGF1ZGlvIGZpbmlzaGVzIHBsYXlpbmcsIGFjdG9ycyBuZWVkIHRvIGtub3csIGluIGNhc2UgdGhleSBhcmUgYW5pbWF0aW5nIHNwZWVjaC9ldGMuXHJcblx0XHQgKi9cclxuXHRcdG9uU291bmRGaW5pc2hlZDogZnVuY3Rpb24gKHN0b3BwZWRTb3VuZCwgbWFya2VyKSB7XHJcblx0XHRcdC8vIF90ZW1wTWFya2VyIGJlY2F1c2UgY3VycmVudE1hcmtlciBpcyBub3cgYmxhbmsuLi5cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUub25HYW1lU3BlZWNoU3RvcChtYXJrZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbW9kZWwgaGFzIHNpZ25hbGVkIHRoYXQgb3V0Y29tZXMgbmVlZCB0byBleGVjdXRlIGFjdGlvbnMuIEV4ZWN1dGUgdGhvc2UgYWN0aW9ucy5cclxuXHRcdCAqIEBwYXJhbSBwZW5kaW5nQWN0aW9uc1xyXG5cdFx0ICogV2lsbCBsb29rIGxpa2U6XHJcblx0XHQgKiBbXHJcblx0XHQgKiAgWyBcIm91dGNvbWVfMVwiOiBbIHsgQUNUSU9OIH0gLCB7IEFDVElPTiB9IF0sXHJcblx0XHQgKiAgICBcIm91dGNvbWVfMlwiOiBbIHsgQUNUSU9OIH0gLCB7IEFDVElPTiB9IF0sIC4uLiBdXHJcblx0XHQgKi9cclxuXHRcdG9uR2FtZU91dGNvbWU6IGZ1bmN0aW9uIChwZW5kaW5nQWN0aW9ucykge1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0cGVuZGluZ0FjdGlvbnMsXHJcblx0XHRcdFx0ZnVuY3Rpb24gKGFjdGlvbkRhdGEpIHtcclxuXHRcdFx0XHRcdGxvZy53YXJuKFwiZXhlY3V0aW5nIGFjdGlvbnMgZm9yIFwiICsgYWN0aW9uRGF0YS5uYW1lKTtcclxuXHRcdFx0XHRcdF8uZWFjaChcclxuXHRcdFx0XHRcdFx0YWN0aW9uRGF0YS5hY3Rpb25zLFxyXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoc2luZ2xlQWN0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0bG9nLndhcm4oXCJleGVjdXRpbmcgYWN0aW9uOlwiKTtcclxuXHRcdFx0XHRcdFx0XHRsb2cud2FybihhY3Rpb25EYXRhKTtcclxuXHRcdFx0XHRcdFx0XHRQbGF5QWN0aW9uLmdldEFjdGlvbihzaW5nbGVBY3Rpb24pLmV4ZWN1dGUodGhpcyk7XHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0c2hvd05ld1NjZW5lOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuXHRcdFx0aWYgKHRoaXMubW9kZWwuc2V0Q3VycmVudFNjZW5lKHNjZW5lKSkge1xyXG5cdFx0XHRcdHRoaXMuc3RvcFNjZW5lKCk7XHJcblx0XHRcdFx0dGhpcy5zdGFydFNjZW5lKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcmV0dXJucyB0aGUgcGF0aHMgdG8gZXZlcnl0aGluZywgYmFzZWQgb24gdGhlIHRoZW1lL1xyXG5cdFx0ICogQHJldHVybnMge3t0ZXh0dXJlS2V5OiBzdHJpbmcsIHRleHR1cmU6IHN0cmluZywgdGV4dHVyZU1hcDogc3RyaW5nLCBzb3VuZEtleTogc3RyaW5nLCBzb3VuZEZpbGU6IHN0cmluZ319XHJcblx0XHQgKi9cclxuXHRcdGdldE1lZGlhRGF0YTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgc291bmRGaWxlcyA9IG51bGw7XHJcblx0XHRcdGlmICh0aGlzLnRoZW1lLmhhc093blByb3BlcnR5KFwic291bmRGaWxlXCIpKSB7XHJcblx0XHRcdFx0c291bmRGaWxlcyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aGVtZS5zb3VuZEZpbGUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHNvdW5kRmlsZXNbaV0gPSB0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIHRoaXMudGhlbWUuc291bmRGaWxlW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGFuaW1hdGlvbkZpbGVzID0gbnVsbDtcclxuXHRcdFx0aWYgKHRoaXMudGhlbWUuaGFzT3duUHJvcGVydHkoXCJhbmltYXRpb25zXCIpKSB7XHJcblx0XHRcdFx0YW5pbWF0aW9uRmlsZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGhlbWUuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0YW5pbWF0aW9uRmlsZXMucHVzaCh7XHJcblx0XHRcdFx0XHRcdHRleHR1cmU6XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyB0aGlzLnRoZW1lLmFuaW1hdGlvbnNbaV0udGV4dHVyZSxcclxuXHRcdFx0XHRcdFx0dGV4dHVyZU1hcDpcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIHRoaXMudGhlbWUuYW5pbWF0aW9uc1tpXS50ZXh0dXJlTWFwLFxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlS2V5OiB0aGlzLnRoZW1lLmFuaW1hdGlvbnNbaV0udGV4dHVyZUtleSxcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR0ZXh0dXJlS2V5OiB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcblx0XHRcdFx0dGV4dHVyZTogdGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyB0aGlzLnRoZW1lLnRleHR1cmUsXHJcblx0XHRcdFx0dGV4dHVyZU1hcDogdGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyB0aGlzLnRoZW1lLnRleHR1cmVNYXAsXHJcblx0XHRcdFx0c291bmRLZXk6IHRoaXMudGhlbWUuc291bmRLZXksXHJcblx0XHRcdFx0c291bmRGaWxlOiBzb3VuZEZpbGVzLFxyXG5cdFx0XHRcdGRhdGFGaWxlOiB0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIHRoaXMudGhlbWUuZGF0YSxcclxuXHRcdFx0XHRhbmltYXRpb25zOiBhbmltYXRpb25GaWxlcyxcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIEFsbG93IHRoZSBjdXJyZW50IHNjZW5lIHRvIHBlcmZvcm0gdGltZWQgb3BlcmF0aW9ucy4gVGhlIHNpemUgb2YgYSBcInRpY2tcIiBpcyBkZWZpbmVkIGluIG1haW4uanMsIGJ1dCB0aGluayBvZlxyXG5cdFx0ICogaXQgYXMgYSBtaWxsaXNlY29uZC5cclxuXHRcdCAqXHJcblx0XHQgKiBTVFJPTkcgV0FSTklORzogRG9uJ3QgZG8gbXVjaCBoZXJlIC0gaXQncyBjYWxsZWQgZnJvbSB0aGUgbWFpbiB1cGRhdGUgbG9vcC4gQW55IGV4dGVuc2l2ZSBvcGVyYXRpb25zIHdpbGxcclxuXHRcdCAqIGNhdXNlIHRoZSB1c2VyIGludGVyZmFjZSB0byBsYWcuXHJcblx0XHQgKi9cclxuXHRcdHRpY2tVcGRhdGU6IGZ1bmN0aW9uICh0aWNrKSB7XHJcblx0XHRcdGlmICghKHR5cGVvZiB0aGlzLmN1cnJlbnRTY2VuZSA9PT0gXCJ1bmRlZmluZWRcIikpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS50aWNrVXBkYXRlKHRpY2spO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0cmVuZGVyRGVidWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9pZiggdGhpcy5nYW1lU291bmRzICApIHtcclxuXHRcdFx0Ly8gICAgdGhpcy5nYW1lLmRlYnVnLnNvdW5kSW5mbyh0aGlzLmdhbWVTb3VuZHMsIDEwLCAyMCk7XHJcblx0XHRcdC8vfVxyXG5cdFx0fSxcclxuXHRcdHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmlzUHJlbG9hZGVkKSB7XHJcblx0XHRcdFx0bG9nLndhcm4oXCIhISEgQ2FsbGVkIFByZWxvYWQgaW4gQWN0IFwiICsgdGhpcy5hY3ROYW1lKTtcclxuXHRcdFx0XHR0aGlzLm1lZGlhRGF0YSA9IHRoaXMuZ2V0TWVkaWFEYXRhKCk7XHJcblx0XHRcdFx0dGhpcy5nYW1lLmxvYWQudGV4dChcclxuXHRcdFx0XHRcdHRoaXMuYWN0TmFtZSArIFwiX3NjZW5lX2RhdGFcIixcclxuXHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLmRhdGFGaWxlXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLmdhbWUubG9hZC5hdGxhc0pTT05IYXNoKFxyXG5cdFx0XHRcdFx0dGhpcy5tZWRpYURhdGEudGV4dHVyZUtleSxcclxuXHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLnRleHR1cmUsXHJcblx0XHRcdFx0XHR0aGlzLm1lZGlhRGF0YS50ZXh0dXJlTWFwXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRpZiAodGhpcy5tZWRpYURhdGEuc291bmRGaWxlKSB7XHJcblx0XHRcdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5sb2FkQXVkaW8oXHJcblx0XHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLnNvdW5kS2V5LFxyXG5cdFx0XHRcdFx0XHR0aGlzLm1lZGlhRGF0YS5zb3VuZEZpbGVcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLm1lZGlhRGF0YS5hbmltYXRpb25zKSB7XHJcblx0XHRcdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLmFuaW1hdGlvbnMsXHJcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChhbmltYXRpb25TZXQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmdhbWUubG9hZC5hdGxhc0pTT05IYXNoKFxyXG5cdFx0XHRcdFx0XHRcdFx0YW5pbWF0aW9uU2V0LnRleHR1cmVLZXksXHJcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb25TZXQudGV4dHVyZSxcclxuXHRcdFx0XHRcdFx0XHRcdGFuaW1hdGlvblNldC50ZXh0dXJlTWFwXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5pc1ByZWxvYWRlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvblByZWxvYWRGaW5pc2hlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLm1vZGVsID0gbmV3IFBsYXlNb2RlbChcclxuXHRcdFx0XHRKU09OLnBhcnNlKHRoaXMuZ2FtZS5jYWNoZS5nZXRUZXh0KHRoaXMuYWN0TmFtZSArIFwiX3NjZW5lX2RhdGFcIikpXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMudmFsaWRhdG9yID0gbmV3IEFjdFZhbGlkYXRvcih0aGlzLm1vZGVsLmdldFJhd0RhdGEoKSk7XHJcblx0XHRcdHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlKCk7XHJcblx0XHR9LFxyXG5cdFx0dW5sb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzUHJlbG9hZGVkKSB7XHJcblx0XHRcdFx0dGhpcy5tZWRpYURhdGEgPSB0aGlzLmdldE1lZGlhRGF0YSgpO1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5jYWNoZS5yZW1vdmVJbWFnZSh0aGlzLm1lZGlhRGF0YS50ZXh0dXJlS2V5KTtcclxuXHRcdFx0XHRpZiAodGhpcy5tZWRpYURhdGEuYW5pbWF0aW9ucykge1xyXG5cdFx0XHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdFx0XHR0aGlzLm1lZGlhRGF0YS5hbmltYXRpb25zLFxyXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoYW5pbWF0aW9uU2V0KSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5nYW1lLmNhY2hlLnJlbW92ZUltYWdlKGFuaW1hdGlvblNldC50ZXh0dXJlS2V5KTtcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5nYW1lLmNhY2hlLnJlbW92ZVRleHQodGhpcy5tZWRpYURhdGEudGV4dHVyZU1hcCk7XHJcblx0XHRcdFx0dGhpcy5nYW1lLmNhY2hlLnJlbW92ZVRleHQodGhpcy5hY3ROYW1lICsgXCJfc2NlbmVfZGF0YVwiKTtcclxuXHRcdFx0XHRpZiAodGhpcy5tZWRpYURhdGEuc291bmRGaWxlKSB7XHJcblx0XHRcdFx0XHR0aGlzLmF1ZGlvU2VydmljZS51bmxvYWRBdWRpbyh0aGlzLm1lZGlhRGF0YS5zb3VuZEtleSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuaXNQcmVsb2FkZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2hlY2sgdGhhdCBzb3VuZCBoYXMgZGVjb2RlZC5cclxuXHRcdCAqL1xyXG5cdFx0aXNQcmVsb2FkQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNQcmVsb2FkZWQgIT09IHRydWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEBUT0RPIEdKRiB0aGlzIHdhcyBpbmNvcnJlY3QgYmVmb3JlLCAoYWN0ICsgXCJfLi4uXCIpLCBXYXMgaXQgYmVpbmcgcmVhY2hlZCBvciBqdXN0IGZhaWxpbmc/XHJcblx0XHRcdCAqIFNob3VsZCB0aGUgYWJvdmUgbGluZSBiZSByZW1vdmVkL2NoYW5nZWQ/IChwcm9iYWJseSlcclxuXHRcdFx0ICovXHJcblx0XHRcdGlmICghdGhpcy5nYW1lLmNhY2hlLmdldFRleHQodGhpcy5hY3ROYW1lICsgXCJfc2NlbmVfZGF0YVwiKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdCF0aGlzLm1lZGlhRGF0YS5zb3VuZEZpbGUgfHxcclxuXHRcdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5pc1JlYWR5KHRoaXMubWVkaWFEYXRhLnNvdW5kS2V5KVxyXG5cdFx0XHQpO1xyXG5cdFx0fSxcclxuXHRcdHNldFN0YW5kQWxvbmU6IGZ1bmN0aW9uIChpc1N0YW5kQWxvbmUpIHt9LFxyXG5cdH0pO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFBsYXlBY3Q7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgdmFsaWRhdG9yIGZvciB0aGUgc2NlbmVEYXRhLmpzb24gKGFjdCkgZmlsZSB0byBtYWtlIHN1cmUgdGhlIGJhc2ljXHJcbiAqIGZpZWxkcyBhcmUgdGhlcmUgZm9yIGVhY2ggb2JqZWN0LlxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIC8vIEEgc21hbGwgdmFsaWRhdGlvbiBtb2RlbCBmb3IgYSBzZXQgb2Ygc2NlbmVEYXRhLlxyXG4gICAgdmFyIGFjdFZhbGlkYXRpb25Nb2RlbCA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcInBsYXlcIjoge1xyXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvcCBsZXZlbCBjb250YWluZXIgZm9yIGFsbCBzY2VuZSBkYXRhXCIsXHJcbiAgICAgICAgICAgICAgICBcInZhbGlkYXRpb25Nb2RlbFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdGFydFwiOiB7IFwiZGVzY3JpcHRpb25cIjogXCJhY3QucGxheS5zdGFydCBzcGVjaWZpZXMgdGhlIHN0YXJ0aW5nIHNjZW5lLlwifSxcclxuICAgICAgICAgICAgICAgICAgICBcInNjZW5lc1wiOiB7IFwiZGVzY3JpcHRpb25cIjogXCJhY3QucGxheS5zY2VuZXMgc3BlY2lmaWVkIGFsbCBzY2VuZXMuXCIgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB2YXIgc2NlbmVWYWxpZGF0aW9uTW9kZWwgPSB7XHJcbiAgICAgICAgXCJpZFwiOiB7IFwiZGVzY3JpcHRpb25cIjogXCJVbmlxdWUgaWRlbnRpZmllciBmb3IgYSBzY2VuZS5cIiB9LFxyXG4gICAgICAgIFwiYmFja2dyb3VuZFwiOiB7IFwiZGVzY3JpcHRpb25cIjogXCJSZWZlcmVuY2UgYmFja2dyb3VuZCBpbWFnZSBmb3IgYSBzY2VuZS5cIiB9LFxyXG4gICAgICAgIFwiYWN0b3JzXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlNldCBvZiBhY3RvcnMgdG8gYWRkIHRvIGEgc2NlbmUuXCIgfSxcclxuICAgICAgICBcIm91dGNvbWVzXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlNldCBvZiBwb3NzaWJsZSBvdXRjb21lcyBmcm9tIGEgc2NlbmUuXCIgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYWN0b3JWYWxpZGF0aW9uTW9kZWwgPSB7XHJcbiAgICAgICAgXCJuYW1lXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIklkZW50aWZpZXIgZm9yIGFjdG9yLlwiIH0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlR5cGUgb2YgYWN0b3IgdG8gYmUgY3JlYXRlZC5cIiB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBvdXRjb21lVmFsaWRhdGlvbk1vZGVsID0ge1xyXG4gICAgICAgIFwiZXZlbnRzXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlNldCBvZiB2YXJpYWJsZXMvdmFsdWUgcGFpcnMgdGhhdCB0cmlnZ2VyIHRoZSBvdXRjb21lLlwiIH0sXHJcbiAgICAgICAgXCJhY3Rpb25zXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIkFycmF5IG9mIGFjdGlvbnMgdG8gdGFrZSB3aGVuIG91dGNvbWUgaXMgdHJpZ2dlcmVkLlwiIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIEFjdFZhbGlkYXRvciA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBqc29uRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhd0RhdGEgPSBqc29uRGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJ1biBzb21lIGJhc2ljIHZhbGlkYXRpb24gb24gdGhlIGF2YWlsYWJsZSBkYXRhLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoICEgdGhpcy5yYXdEYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJQbGF5TW9kZWwgcmVxdWlyZXMgZ2FtZSBkYXRhIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmF3RGF0YTtcclxuICAgICAgICAgICAgdGhpcy5ydW5BY3RWYWxpZGF0b3IoIGRhdGEsIGFjdFZhbGlkYXRpb25Nb2RlbCk7XHJcbiAgICAgICAgICAgIF8uZWFjaCggZGF0YS5wbGF5LnNjZW5lcywgZnVuY3Rpb24oc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVuU2NlbmVWYWxpZGF0b3Ioc2NlbmUsIHNjZW5lVmFsaWRhdGlvbk1vZGVsKTtcclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJWYWxpZGF0aW9uIGNvbXBsZXRlLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJ1bkFjdFZhbGlkYXRvcjogZnVuY3Rpb24oIGVudHJ5UG9pbnQsIHZhbGlkYXRpb25Nb2RlbCApIHtcclxuICAgICAgICAgICAgXy5lYWNoKCB2YWxpZGF0aW9uTW9kZWwsIGZ1bmN0aW9uKCB0b1ZhbGlkYXRlLCBpbmRleCApIHtcclxuICAgICAgICAgICAgICAgIGlmKCAhZW50cnlQb2ludFtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk1pc3Npbmc6IFwiICsgdG9WYWxpZGF0ZS5kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggdG9WYWxpZGF0ZS52YWxpZGF0aW9uTW9kZWwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5BY3RWYWxpZGF0b3IoIGVudHJ5UG9pbnRbaW5kZXhdLCB0b1ZhbGlkYXRlLnZhbGlkYXRpb25Nb2RlbCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJ1blNjZW5lVmFsaWRhdG9yOiBmdW5jdGlvbiggZW50cnlQb2ludCwgdmFsaWRhdGlvbk1vZGVsICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHZhbGlkYXRpb25Nb2RlbCwgZnVuY3Rpb24oIHRvVmFsaWRhdGUsIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgaWYoICFlbnRyeVBvaW50W2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiTWlzc2luZzogXCIgKyB0b1ZhbGlkYXRlLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgXy5lYWNoKCBlbnRyeVBvaW50LmFjdG9ycywgZnVuY3Rpb24gKGFjdG9yLCBhY3RvckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goIGFjdG9yVmFsaWRhdGlvbk1vZGVsLCBmdW5jdGlvbiggdG9WYWxpZGF0ZSwgaW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoICFhY3RvcltpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJNaXNzaW5nOiBcIiArIHRvVmFsaWRhdGUuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICBfLmVhY2goIGVudHJ5UG9pbnQub3V0Y29tZXMsIGZ1bmN0aW9uIChvdXRjb21lLCBvdXRjb21lSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCggb3V0Y29tZVZhbGlkYXRpb25Nb2RlbCwgZnVuY3Rpb24oIHRvVmFsaWRhdGUsIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCAhb3V0Y29tZVtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJNaXNzaW5nOiBcIiArIHRvVmFsaWRhdGUuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQWN0VmFsaWRhdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA5LzIxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiAgRHJhdyBhIGxvYWRpbmcgc2NyZWVuIGluIFBoYXNlci4gRXhwZWN0cyByZXNvdXJjZXMgdG8gYWxyZWFkeSBiZSBsb2FkZWQuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdHZhciBCYXNlID0gcmVxdWlyZShcImJhc2Vqc1wiKTtcclxuXHJcblx0dmFyIExvYWRpbmdTY3JlZW4gPSBCYXNlLmV4dGVuZCh7XHJcblx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGdhbWUsIHNldHRpbmdzKSB7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHQhc2V0dGluZ3MgfHxcclxuXHRcdFx0XHQhc2V0dGluZ3MubG9hZGluZ19pbWFnZV9rZXkgfHxcclxuXHRcdFx0XHQhc2V0dGluZ3MubG9hZGluZ19iZ19jb2xvciB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX3RleHQgfHxcclxuXHRcdFx0XHQhc2V0dGluZ3MubG9hZGluZ19mb250XHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHRocm93IFwiTG9hZGluZyBzY3JlZW4gaXMgbWlzc2luZyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gZmllbGQuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5nYW1lID0gZ2FtZTtcclxuXHRcdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG5cdFx0XHR0aGlzLnByb2dyZXNzID0gMDtcclxuXHRcdFx0dGhpcy5zcGlubmVyID0gW1wiLlwiLCBcIi4uXCIsIFwiLi4uXCIsIFwiLi4uLlwiXTtcclxuXHRcdH0sXHJcblx0XHRzaG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIDEuIENyZWF0ZSBzb2xpZCBiYWNrZ3JvdW5kLlxyXG5cdFx0XHR0aGlzLmJnQ29sb3IgPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKDAsIDApO1xyXG5cdFx0XHR0aGlzLmJnQ29sb3IuYmVnaW5GaWxsKHRoaXMuc2V0dGluZ3MubG9hZGluZ19iZ19jb2xvcik7XHJcblx0XHRcdHRoaXMuYmdDb2xvci5kcmF3UmVjdChcclxuXHRcdFx0XHQwLFxyXG5cdFx0XHRcdDAsXHJcblx0XHRcdFx0dGhpcy5nYW1lLndvcmxkLndpZHRoLFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS53b3JsZC5oZWlnaHRcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5iZ0NvbG9yLmVuZEZpbGwoKTtcclxuXHRcdFx0dGhpcy5iZ0NvbG9yLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5kaXNhYmxlZCA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyAyLiBDcmVhdGUgYSBsb2FkaW5nIGltYWdlL2ljb24vc3BsYXNoXHJcblx0XHRcdHRoaXMuc3BsYXNoSW1hZ2UgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZShcclxuXHRcdFx0XHR0aGlzLmdhbWUud29ybGQuY2VudGVyWCxcclxuXHRcdFx0XHR0aGlzLmdhbWUud29ybGQuY2VudGVyWSxcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5XHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuc3BsYXNoSW1hZ2UuYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcblx0XHRcdC8vIHRoaXMuc3BsYXNoSW1hZ2UuYWxwaGEgPSAwO1xyXG5cdFx0XHQvLyB0aGlzLnR3ZWVuID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwbGFzaEltYWdlKS50byh7YWxwaGE6IDF9LCAyMDAwLCBcIkxpbmVhclwiLCB0cnVlLCAwLCAtMSk7XHJcblxyXG5cdFx0XHQvLyAgQW5kIHRoaXMgdGVsbHMgaXQgdG8gcmVwZWF0LCBpLmUuIGZhZGUgaW4gYWdhaW4gMTAgdGltZXMuXHJcblx0XHRcdC8vICBUaGUgMTAwMCB0ZWxscyBpdCB0byB3YWl0IGZvciAxIHNlY29uZCBiZWZvcmUgcmVzdGFydGluZyB0aGUgZmFkZS5cclxuXHRcdFx0Ly8gdGhpcy50d2Vlbi55b3lvKHRydWUsIDEwMDApO1xyXG5cclxuXHRcdFx0Ly8gMy4gQWRkIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yXHJcblx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0ID0gdGhpcy5nYW1lLmFkZC50ZXh0KFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZLFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubG9hZGluZ190ZXh0LFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubG9hZGluZ19mb250XHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0LmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG5cclxuXHRcdFx0dmFyIGpvaW50SGVpZ2h0ID0gdGhpcy5zcGxhc2hJbWFnZS5oZWlnaHQgKyB0aGlzLnByb2dyZXNzVGV4dC5oZWlnaHQ7XHJcblx0XHRcdHRoaXMuc3BsYXNoSW1hZ2UueSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZIC0gam9pbnRIZWlnaHQgLyAyO1xyXG5cdFx0XHR0aGlzLnByb2dyZXNzVGV4dC55ID0gdGhpcy5zcGxhc2hJbWFnZS55ICsgdGhpcy5zcGxhc2hJbWFnZS5oZWlnaHQgKyAyNTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQub25GaWxlQ29tcGxldGUuYWRkKHRoaXMuZmlsZUNvbXBsZXRlLCB0aGlzKTtcclxuXHRcdH0sXHJcblx0XHRzaG93Q29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gZmFsc2U7XHJcblx0XHRcdC8vIGh0dHBzOi8vcGhhc2VyLmlvL2RvY3MvMi40LjQvUGhhc2VyLkNhY2hlLmh0bWwjb25Tb3VuZFVubG9ja1xyXG5cdFx0XHQvLyBidXQgY2FuJ3QgdXNlIDotKFxyXG5cdFx0XHRpZiAodGhpcy5nYW1lLmRldmljZS5kZXNrdG9wKSB7XHJcblx0XHRcdFx0dGhpcy5wcm9ncmVzc1RleHQuc2V0VGV4dChcIlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHRoaXMucHJvZ3Jlc3NUZXh0LnNldFRleHQoXCJcIik7XHJcblx0XHR9LFxyXG5cdFx0c2hvd0NsaWNrdGhyb3VnaDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9waGFzZXIuaW8vZG9jcy8yLjQuNC9QaGFzZXIuQ2FjaGUuaHRtbCNvblNvdW5kVW5sb2NrXHJcblx0XHRcdC8vIGJ1dCBjYW4ndCB1c2UgOi0oXHJcblx0XHRcdGlmICh0aGlzLmdhbWUuZGV2aWNlLmRlc2t0b3ApIHtcclxuXHRcdFx0XHR0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiQ2xpY2sgaGVyZSB0byBiZWdpbi5cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5wcm9ncmVzc1RleHQuc2V0VGV4dChcIlRvdWNoIHNjcmVlbiB0byBiZWdpbi5cIik7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gdGhpcy5wcm9ncmVzc1RleHQuc2V0VGV4dChcIlwiKTtcclxuXHRcdH0sXHJcblx0XHRzaG93RGVjb2Rpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly90aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiUHJlcGFyaW5nIEF1ZGlvOiBcIiArIHRoaXMuZ2V0RmFrZVByb2dyZXNzKCkpO1xyXG5cdFx0fSxcclxuXHRcdGdldEZha2VQcm9ncmVzczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvL3JldHVybiB0aGlzLnNwaW5uZXJbdGhpcy5wcm9ncmVzcysrICUgNF07XHJcblx0XHR9LFxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0Ly8gdGhpcy50d2Vlbi5zdG9wKCk7XHJcblx0XHRcdC8vIHRoaXMudHdlZW4udGFyZ2V0ID0gbnVsbDsgLy8gZGlzY29ubmVjdCBmcm9tIHNwbGFzaCBpbWFnZS5cclxuXHRcdFx0Ly8gdGhpcy50d2VlbiA9IG51bGw7XHJcblx0XHRcdHRoaXMuc3BsYXNoSW1hZ2UuY3JvcEVuYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZS5kZXN0cm95KCk7XHJcblx0XHRcdHRoaXMuc3BsYXNoSW1hZ2UgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmJnQ29sb3IuZGVzdHJveSgpO1xyXG5cdFx0XHR0aGlzLmJnQ29sb3IgPSBudWxsO1xyXG5cdFx0XHR0aGlzLnByb2dyZXNzVGV4dC5kZXN0cm95KCk7XHJcblx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQub25GaWxlQ29tcGxldGUucmVtb3ZlQWxsKCk7XHJcblx0XHR9LFxyXG5cdFx0ZmlsZUNvbXBsZXRlOiBmdW5jdGlvbiAoXHJcblx0XHRcdHByb2dyZXNzLFxyXG5cdFx0XHRjYWNoZUtleSxcclxuXHRcdFx0c3VjY2VzcyxcclxuXHRcdFx0dG90YWxMb2FkZWQsXHJcblx0XHRcdHRvdGFsRmlsZXNcclxuXHRcdCkge1xyXG5cdFx0XHQvLyB0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KHRoaXMuc2V0dGluZ3MubG9hZGluZ190ZXh0ICsgcHJvZ3Jlc3MgKyBcIiVcIik7XHJcblx0XHR9LFxyXG5cdH0pO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IExvYWRpbmdTY3JlZW47XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFJlcHJlc2VudCBhIFBsYXkgYXMgYSBtb2RlbCwgdGhpcyBpcyB0aGUgY29sbGVjdGlvbiBvZiBzY2VuZSBkYXRhLCBldGMuXHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKSxcclxuICAgICAgICBNb2RlbFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9tb2RlbHMvbW9kZWwtcmVnaXN0cnknKSxcclxuICAgICAgICBOT19DSEFSID0gXCJub25lXCI7XHJcblxyXG4gICAgdmFyIFBsYXlNb2RlbCA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBqc29uRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhd0RhdGEgPSBqc29uRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGlmKCAhanNvbkRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlBsYXlNb2RlbCByZXF1aXJlcyBnYW1lIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCAhanNvbkRhdGEucGxheSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiUGxheU1vZGVsIGhhcyBubyBwbGF5IGRhdGEuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgb25HYW1lT3V0Y29tZTogbmV3IFBoYXNlci5TaWduYWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxDbGFzcyA9IE1vZGVsUmVnaXN0cnkuZ2V0TW9kZWwodGhpcy5nZXRNb2RlbFR5cGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsID0gbmV3IG1vZGVsQ2xhc3MoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VmFyKFwic3RhcnRfc2NlbmVcIiwgdGhpcy5nZXREZWZhdWx0U2NlbmVOYW1lKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByZXZpb3VzU2NlbmVOYW1lKCBcIiFOT05FIVwiKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50U2NlbmVOYW1lKCB0aGlzLmdldERlZmF1bHRTY2VuZU5hbWUoKSApO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRWYXIoXCJkZWZhdWx0X3NjZW5lX25hbWVcIiwgdGhpcy5nZXREZWZhdWx0U2NlbmVOYW1lKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmF3RGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRNb2RlbFR5cGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIFwiYWN0bm93XCIsIHNpbmNlIHRoYXQgd2FzIHRoZSBvcmlnaW5hbCBhbmQgbWFrZXMgYWxsIHBsYXkgZmlsZXMgYmFja3dhcmRzIGNvbXBhdGlibGUuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5yYXdEYXRhLnBsYXkubW9kZWxUeXBlIHx8IFwiYWN0bm93XCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBzY2VuZSBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDdXJyZW50U2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLmdldFNjZW5lQnlOYW1lKHRoaXMuZ2V0Q3VycmVudFNjZW5lTmFtZSgpKTtcclxuICAgICAgICAgICAgaWYoICFzY2VuZSApIHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcImdldEN1cnJlbnRTY2VuZSBmYWlsZWQgdG8gcmV0dXJuIGEgc2NlbmUuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFNjZW5lQnlOYW1lOiBmdW5jdGlvbiggc2NlbmVOYW1lICkge1xyXG4gICAgICAgICAgICBpZiggIXNjZW5lTmFtZSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YS5wbGF5LnNjZW5lc1tzY2VuZU5hbWVdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0R2xvYmFsQWN0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnJhd0RhdGEucGxheS5nbG9iYWwgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gdGhpcy5yYXdEYXRhLnBsYXkuZ2xvYmFsLmFjdGlvbnMgfHwgW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gYWN0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEdsb2JhbE91dGNvbWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMucmF3RGF0YS5wbGF5ICYmIHRoaXMucmF3RGF0YS5wbGF5Lmdsb2JhbCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGEucGxheS5nbG9iYWwub3V0Y29tZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlIGEgYW4gaW50ZXJmYWNlIHRvIHRoZSBtb2RlbCB0aGF0IGRvZXNuJ3QgYWxsb3cgZm9yIGFueXRoaW5nIGJ1dFxyXG4gICAgICAgICAqIHJlYWQtb25seSBhY2Nlc3MuIFRoaXMgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSByZWZlcmVuY2luZyBvYmplY3RcclxuICAgICAgICAgKiB0byB1c2UgZ2V0VmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7e2dldFZhcjogRnVuY3Rpb259fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFZhckludGVyZmFjZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdldEFjdG9yQnlSZWY6IGZ1bmN0aW9uKCBhY3Rvck5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQucmF3RGF0YS5wbGF5Lmdsb2JhbC5hY3RvcnNbYWN0b3JOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oIHZhck5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0VmFsdWUodmFyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXJWYWx1ZTogZnVuY3Rpb24oIHZhck5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRWYXIodmFyTmFtZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIHRydWUgdmFsdWUgZm9yIGEgZmllbGQgdGhhdCBtYXkgYmUgYSB2YXJpYWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oIHZhck5hbWUgKSB7XHJcbiAgICAgICAgICAgIGlmKCB2YXJOYW1lICYmIHR5cGVvZiB2YXJOYW1lID09PSAnc3RyaW5nJyAmJiB2YXJOYW1lLmluZGV4T2YoJyQnKSA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhcih2YXJOYW1lLnN1YnN0cigxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhck5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgYSBuZXcgc2NlbmUgaW4gdGhlIG1vZGVsLiBUaGlzIG9ubHkgYWZmZWN0cyB0cmFja2luZyB1bnRpbCBnZXRDdXJyZW50U2NlbmUgaXMgY2FsbGVkLlxyXG4gICAgICAgICAqIEF0dGVtcHRpbmcgdG8gc3dpdGNoIHRvIHRoZSBzYW1lIHNjZW5lIGlzIGlnbm9yZWQuXHJcbiAgICAgICAgICogQHBhcmFtIG5ld1NjZW5lSWRcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ5IGlzIHNjZW5lIGNoYW5nZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0Q3VycmVudFNjZW5lOiBmdW5jdGlvbiggbmV3U2NlbmVJZCApIHtcclxuICAgICAgICAgICAgaWYoIG5ld1NjZW5lSWQgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2NlbmVOYW1lID0gdGhpcy5nZXRWYWx1ZShuZXdTY2VuZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmICggbmV3U2NlbmVOYW1lICE9PSB0aGlzLmdldEN1cnJlbnRTY2VuZU5hbWUoKSAmJiB0aGlzLmdldFNjZW5lQnlOYW1lKG5ld1NjZW5lTmFtZSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTY2VuZU5hbWUgPSB0aGlzLmdldEN1cnJlbnRTY2VuZU5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRTY2VuZU5hbWUobmV3U2NlbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByZXZpb3VzU2NlbmVOYW1lKGN1cnJlbnRTY2VuZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwic2V0Q3VycmVudFNjZW5lIGNhbGxlZCB3aXRob3V0IG5ld1NjZW5lSWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFuZGxlU3BlY2lhbFZhcjogZnVuY3Rpb24oIHZhcmlhYmxlLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmhhbmRsZVNwZWNpYWxWYXIodmFyaWFibGUsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbWV0aGluZyBoYXMgY2hhbmdlZCBpbiB0aGUgbW9kZWwuIElmIGEgdmFyaWFibGUgY2hhbmdlcywgdGhlIHN0YXRlXHJcbiAgICAgICAgICogb2YgdGhlIGFjdCBtaWdodCBjaGFuZ2UsIHNvIGlnbm9yZSBhIHZhbHVlIHN0YXlpbmcgdGhlIHNhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0VmFyOiBmdW5jdGlvbiggdmFyaWFibGUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuc2V0VmFyKHZhcmlhYmxlLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhcih2YXJpYWJsZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayBmb3Igb3V0Y29tZXMgdGhhdCB3ZXJlIGNvbXBsZXRlZCBieSBjaGFuZ2luZyBhIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSB2YXJpYWJsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoZWNrRm9yQ29tcGxldGVkT3V0Y29tZXM6IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJjaGVja2luZyBmb3IgY29tcGxldGVkIG91dGNvbWU6IFwiICsgdmFyaWFibGUpO1xyXG4gICAgICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLmdldEN1cnJlbnRTY2VuZSgpLFxyXG4gICAgICAgICAgICAgICAgZ091dGNvbWVzID0gdGhpcy5nZXRHbG9iYWxPdXRjb21lcygpLFxyXG4gICAgICAgICAgICAgICAgcGVuZGluZ0FjdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmKCAhc2NlbmUub3V0Y29tZXMgJiYgIWdPdXRjb21lcykge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU2NlbmUgd2l0aCBubyBvdXRjb21lcyBpbiBjaGVja0ZvckNvbXBsZXRlZE91dGNvbWVzLlwiKTtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihzY2VuZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCBnT3V0Y29tZXMgICkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGdPdXRjb21lcywgZnVuY3Rpb24gKG91dGNvbWUsIG91dGNvbWVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJDaGVja2luZyBnbG9iYWwgb3V0Y29tZTogXCIgKyBvdXRjb21lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tPdXRjb21lKG91dGNvbWUsIHZhcmlhYmxlKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIlBlbmRpbmcgYWN0aW9uIG9uIG91dGNvbWU6IFwiICsgb3V0Y29tZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKHtcIm5hbWVcIjogb3V0Y29tZU5hbWUsIFwiYWN0aW9uc1wiOiBvdXRjb21lLmFjdGlvbnN9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXy5lYWNoKCBzY2VuZS5vdXRjb21lcywgZnVuY3Rpb24ob3V0Y29tZSwgb3V0Y29tZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICBsb2cud2FybihcIkNoZWNraW5nIG91dGNvbWU6IFwiICsgb3V0Y29tZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuY2hlY2tPdXRjb21lKG91dGNvbWUsIHZhcmlhYmxlKSA9PT0gdHJ1ZSAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJQZW5kaW5nIGFjdGlvbiBvbiBvdXRjb21lOiBcIiArIG91dGNvbWVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKCB7IFwibmFtZVwiOiBvdXRjb21lTmFtZSwgXCJhY3Rpb25zXCI6IG91dGNvbWUuYWN0aW9ucyB9ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiggcGVuZGluZ0FjdGlvbnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZU91dGNvbWUuZGlzcGF0Y2goIHBlbmRpbmdBY3Rpb25zICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGFsbCBvZiB0aGUgdmFyaWFibGVzIGluIGFuIG91dGNvbWUgYWdhaW5zdCB0aGUgdmFyaWFibGVzIGluIHRoZSBtb2RlbC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBvdXRjb21lIG9iamVjdCB0aGF0IHNob3VsZCBoYXZlICdldmVudHMnIG9iamVjdCBvbiBpdC5cclxuICAgICAgICAgKiBAdmFyaWFibGUgVGhpcyBpcyB0aGUgdmFyaWFibGUgdGhhdCBjaGFuZ2VkLCBhIHZhcmlhYmxlIGludm9sdmVkIGluIHRoZSBvdXRjb21lIGhhcyB0byBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG91dGNvbWUgaXMgY3VycmVudGx5IG1hdGNoZXMgdGhlIG1vZGVsJ3Mgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hlY2tPdXRjb21lOiBmdW5jdGlvbiggb3V0Y29tZSAsIHZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICBpZiggIW91dGNvbWUuZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJheXMgPSBfLnBhaXJzKCBvdXRjb21lLmV2ZW50cyksXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFuc3dlcixcclxuICAgICAgICAgICAgICAgIGZvdW5kVmFyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF8uZWFjaCggYXJyYXlzLCBmdW5jdGlvbiggc2luZ2xlVmFyICkge1xyXG4gICAgICAgICAgICAgICAgYW5zd2VyID0gdGhpcy5nZXRWYXIoc2luZ2xlVmFyWzBdKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvdXRjb21lIGNhbiBvbmx5IG1hdGNoIGlmIG9uZSBvZiB0aGUgdmFyaWFibGVzIGludm9sdmVkIGlzIHRoZSBvbmUgY2hhdCBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgaWYoIHNpbmdsZVZhclswXSA9PT0gdmFyaWFibGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWYXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoZWQgJiYgdGhpcy5tYXRjaFNpbmdsZU91dGNvbWUoIGFuc3dlciwgc2luZ2xlVmFyWzFdKTtcclxuICAgICAgICAgICAgfSwgdGhpcyApO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZCAmJiBmb3VuZFZhcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hdGNoU2luZ2xlT3V0Y29tZTogZnVuY3Rpb24oIGxlZnRTaWRlLCByaWdodFNpZGUgKSB7XHJcbiAgICAgICAgICAgIC8vIGxvZy53YXJuKFwibWF0Y2hTaW5nbGVPdXRjb21lOiBcIiArIGxlZnRTaWRlICsgXCIgLyBcIiArIHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgICAgIGlmKCBsZWZ0U2lkZSA9PT0gbnVsbCB8fCBsZWZ0U2lkZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgcmlnaHRTaWRlID09PSBcInN0cmluZ1wiICYmIChyaWdodFNpZGVbMF0gPT09ICchJyB8fCByaWdodFNpZGUgPT09ICd1bmRlZmluZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgcmlnaHRTaWRlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggbGVmdFNpZGUgPT09IHJpZ2h0U2lkZSB8fCByaWdodFNpZGUgPT09ICcqJyB8fCAocmlnaHRTaWRlWzBdID09PSAnIScgJiYgbGVmdFNpZGUgIT09IF8udHJpbShyaWdodFNpZGUsXCIhXCIpICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHR5cGVvZiByaWdodFNpZGUgPT09IFwibnVtYmVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggcGFyc2VJbnQobGVmdFNpZGUsMTApID09PSBwYXJzZUludChyaWdodFNpZGUsMTApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYoXy5pc0FycmF5KCByaWdodFNpZGUgKSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbm5lck1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goIHJpZ2h0U2lkZSAsIGZ1bmN0aW9uKCBzaW5nbGVSaWdodFNpZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2ggfHwgdGhpcy5tYXRjaFNpbmdsZU91dGNvbWUobGVmdFNpZGUsIHNpbmdsZVJpZ2h0U2lkZSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lck1hdGNoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgZGF0YSB0aGF0IGFscmVhZHkgZXhpc3RlZCBpbiBTQ09STS5cclxuICAgICAgICAgKiBEYXRhIGxvb2tzIGxpa2U6IFNDRU5FLFsuLi4gZGVwZW5kcyBvbiBkYXRhIG1vZGVsXVxyXG4gICAgICAgICAqIFNDRU5FID0gY3VycmVudCBzY2VuZS4gSGFuZGxlIHRoZSBzY2VuZSBhdCB0aGUgYmFzZSBtb2RlbCBsZXZlbCBiZWNhdXNlIHdlIGFsd2F5cyBzdG9yZSBzY2VuZSwgcmVnYXJkbGVzc1xyXG4gICAgICAgICAqIG9mIGN1cnJlbnQgYWN0aXZpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uIChzdXNwZW5kRGF0YSkge1xyXG4gICAgICAgICAgICBsb2cud2FybihzdXNwZW5kRGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5kRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwucmVzdG9yZURhdGEoIHN1c3BlbmREYXRhICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGNhbGxpbmcgdGhpcyB3aWxsIGF0dGVtcHQgdG8gZGl2ZXJ0IHRoZSBtb2RlbCB0byBzZXR0aW5nIHRoZSBjdXJyZW50IHNjZW5lIHRvIHRoZVxyXG4gICAgICAgICAqIHNwZWNpYWwgcmVzdW1lIHNjZW5lLiBUaGUgY3VycmVudCBzY2VuZSB3aWxsIGJlIHNhdmVkIGFzIHRoZSAncmVzdG9yZScgc2NlbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJ5UmVzdW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmdldEN1cnJlbnRTY2VuZU5hbWUoKSAhPT0gdGhpcy5nZXREZWZhdWx0U2NlbmVOYW1lKCkgJiYgdGhpcy5nZXRSZXN1bWVTY2VuZSgpICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLndhcm4odGhpcy5nZXRDdXJyZW50U2NlbmVOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50U2NlbmVOYW1lKCB0aGlzLmdldFJlc3VtZVNjZW5lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVzdW1lU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdEYXRhLnBsYXkucmVzdW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3VzcGVuZERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFN1c3BlbmREYXRhKHRoaXMuZ2V0UGVyc2lzdExpc3QoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhciBvdXQgYW55IHNhdmVkIGNob2ljZXMgdG8gdW5kZWZpbmVkLiBjdXJyZW50bHkgdGhpcyBpbnZvbHZlcyB3aGljaCBjaGFyYWN0ZXJzIHRoZVxyXG4gICAgICAgICAqIHBsYXllciBzZWxlY3RlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhclNhdmVkQ2hvaWNlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLmNsZWFyU2F2ZWRDaG9pY2VzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1Nob3dQbGF5VGhyb3VnaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGEgJiYgdGhpcy5yYXdEYXRhLnBsYXkgJiYgdGhpcy5yYXdEYXRhLnBsYXkuc2hvd1BsYXlUaHJvdWdoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0RGVmYXVsdFNjZW5lTmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGEucGxheS5zdGFydDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFBlcnNpc3RMaXN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YS5wbGF5LnBlcnNpc3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRDdXJyZW50U2NlbmVOYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhcihcImN1cnJlbnRfc2NlbmVfbmFtZVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEN1cnJlbnRTY2VuZU5hbWU6IGZ1bmN0aW9uKCBzY2VuZU5hbWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFZhcihcImN1cnJlbnRfc2NlbmVfbmFtZVwiLCBzY2VuZU5hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0UHJldmlvdXNTY2VuZU5hbWU6IGZ1bmN0aW9uKCBzY2VuZU5hbWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFZhcihcInByZXZpb3VzX3NjZW5lX25hbWVcIiwgc2NlbmVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBsYXlNb2RlbDtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgUGxheSBNb2RlbCBzdHJhdGVneSBmb3IgYSBzZXQgb2YgY291cnNlcy9hY3Rpdml0aWVzLlxyXG4gKlxyXG4gKiBQQSA9IFBhcnRpY2lwYXRlXHJcbiAqIERJID0gRGlzY291cmFnZVxyXG4gKiBBTCA9IEFsbG93XHJcbiAqIEVOID0gRW5jb3VyYWdlXHJcbiAqIFBSID0gUHJldmVudFxyXG4gKiBYWCA9IFVuYW5zd2VyZWRcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIE5PX0NIQVIgPSBcIm5vbmVcIjtcclxuXHJcbiAgICB2YXIgQWN0Tm93RGF0YSA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBcInNjb3JlXCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcInBsYXlUaHJvdWdoXCI6IDEsXHJcbiAgICAgICAgICAgICAgICBcImRlY2lzaW9uc0N1cnJlbnRcIjogW1wiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCJdLFxyXG4gICAgICAgICAgICAgICAgXCJkZWNpc2lvbnNQcmV2aW91c1wiOiBbXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIl0sXHJcbiAgICAgICAgICAgICAgICBcInBob25lUmluZ2VySW5kZXhcIjogMCxcclxuICAgICAgICAgICAgICAgIFwicGhvbmVCZ0luZGV4XCI6IDBcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NvcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgXCJQQVwiOiAtMixcclxuICAgICAgICAgICAgICAgIFwiRElcIjogMSxcclxuICAgICAgICAgICAgICAgIFwiQUxcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiRU5cIjogLTEsXHJcbiAgICAgICAgICAgICAgICBcIlBSXCI6IDIsXHJcbiAgICAgICAgICAgICAgICBcIlhYXCI6IDBcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBzcGVjaWFsIGJlaGF2aW9yIGZvciBhY3Rub3cgYmFzZWQgYWN0cyB3aGljaCBleHBlY3QgZGVjaXNpb24gcG9pbnRzXHJcbiAgICAgICAgICogYW5kIHNwZWNpYWwgYWN0X2NvbXBsZXRlIC8gY29tcGxldGUgdmFyaWFibGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB2YXJpYWJsZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhhbmRsZVNwZWNpYWxWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmKCB2YXJpYWJsZS5zdWJzdHIoMCwyKSA9PT0gXCJkcFwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmREZWNpc2lvbih2YXJpYWJsZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcInNhdmVcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB2YXJpYWJsZSA9PT0gXCJhY3RfY29tcGxldGVcIiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTYXZlZENob2ljZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmluY3JlbWVudFBsYXl0aHJvdWdoKHZhbHVlKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiY29tcGxldGVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb21ldGhpbmcgaGFzIGNoYW5nZWQgaW4gdGhlIG1vZGVsLiBJZiBhIHZhcmlhYmxlIGNoYW5nZXMsIHRoZSBzdGF0ZVxyXG4gICAgICAgICAqIG9mIHRoZSBhY3QgbWlnaHQgY2hhbmdlLCBzbyBpZ25vcmUgYSB2YWx1ZSBzdGF5aW5nIHRoZSBzYW1lLlxyXG4gICAgICAgICAqIFJldHVybnMgVFJVRSBpZiB0aGUgdmFyaWFibGUgd2FzIGNoYW5nZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0VmFyOiBmdW5jdGlvbiggdmFyaWFibGUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICAvL2xvZy53YXJuKFwiU2V0IFZhcmlhYmxlOiBcIiArIHZhcmlhYmxlICsgXCIgPSBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgaWYoIHZhcmlhYmxlID09PSBcInNjb3JlXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1tcInNjb3JlXCJdICs9IHBhcnNlSW50KHZhbHVlLDEwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHRoaXMudmFyaWFibGVzW3ZhcmlhYmxlXSAhPT0gdmFsdWUgKSAge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFjdCBvbiBhIHZhbHVlIHN0YXlpbmcgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhcjogZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGRhdGEgdGhhdCBhbHJlYWR5IGV4aXN0ZWQgaW4gU0NPUk0uXHJcbiAgICAgICAgICogRGF0YSBsb29rcyBsaWtlOiBbcGxheVRocm91Z2gsY2hhcjEsY2hhcjIsY2hhcjMsMXwyfDN8NHw1fDZ8N3w4fDksMXwyfDN8NHw1fDZ8N3w4fDksMXwyfDN8NHw1fDZ8N3w4fDldXHJcbiAgICAgICAgICogMXwyfDN8NHw1fDZ8N3w4fDkgPSBhbnN3ZXJzIHBlciBwbGF5IHRocm91Z2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICh1bnBhcnNlZFN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKHVucGFyc2VkU3VzcGVuZERhdGEpO1xyXG4gICAgICAgICAgICB2YXIgIHNwbGl0RGF0YSA9IHVucGFyc2VkU3VzcGVuZERhdGEuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY3VycmVudF9zY2VuZV9uYW1lJ10gPSBzcGxpdERhdGFbMF07XHJcbiAgICAgICAgICAgIHZhciBzdXNwZW5kRGF0YSA9IF8uZHJvcChzcGxpdERhdGEsMSk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5kRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMucGxheVRocm91Z2ggPSBwYXJzZUludChzdXNwZW5kRGF0YVswXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8xJ10gPSB0aGlzLnJlc29sdmVDaGFyYWN0ZXIoc3VzcGVuZERhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8yJ10gPSB0aGlzLnJlc29sdmVDaGFyYWN0ZXIoc3VzcGVuZERhdGFbMl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8zJ10gPSB0aGlzLnJlc29sdmVDaGFyYWN0ZXIoc3VzcGVuZERhdGFbM10pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zUHJldmlvdXMgPSBzdXNwZW5kRGF0YVs0XS5zcGxpdChcInxcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNDdXJyZW50ID0gc3VzcGVuZERhdGFbNV0uc3BsaXQoXCJ8XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuc2NvcmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKCB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNDdXJyZW50ICwgZnVuY3Rpb24oc2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5zY29yZSArPSB0aGlzLmNvbnZlcnRUb1BvaW50cyhzY29yZSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5jaG9zZW4gY2hhcmFjdGVycyBhcmUgc2F2ZWQgYXMgTk9fQ0hBUiwgcmVzb2x2ZSB0aGVtIGJhY2sgdG8gJ3VuZGVmaW5lZCcgb3IgdGhlaXJcclxuICAgICAgICAgKiBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzb2x2ZUNoYXJhY3RlcjogZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICBpZiggdmFsdWUgPT09IE5PX0NIQVIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb252ZXJ0VG9Qb2ludHM6IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zY29yZXNbc3RyXSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcmVzW3N0cl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3VzcGVuZERhdGE6IGZ1bmN0aW9uIChwZXJzaXN0TGlzdCkge1xyXG4gICAgICAgICAgICAvLyBwZXJzaXN0TGlzdCBpcyBub3QgdXNlZCBpbiBBY3ROb3chLCB3aGljaCBoYXMgYSBmaXhlZCBzZXQgb2Ygc2F2ZXMuXHJcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIxID0gdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8xJ10gfHwgTk9fQ0hBUixcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlcjIgPSB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzInXSB8fCBOT19DSEFSLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyMyA9IHRoaXMudmFyaWFibGVzWydjaGFyYWN0ZXJfMyddIHx8IE5PX0NIQVI7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3VzcGVuZERhdGEgPSB0aGlzLnZhcmlhYmxlc1snY3VycmVudF9zY2VuZV9uYW1lJ11cclxuICAgICAgICAgICAgICAgICsgXCIsXCIgKyB0aGlzLnZhcmlhYmxlcy5wbGF5VGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgKyBcIixcIiArIGNoYXJhY3RlcjFcclxuICAgICAgICAgICAgICAgICsgXCIsXCIgKyBjaGFyYWN0ZXIyXHJcbiAgICAgICAgICAgICAgICArIFwiLFwiICsgY2hhcmFjdGVyM1xyXG4gICAgICAgICAgICAgICAgKyBcIixcIiArIHRoaXMudmFyaWFibGVzLmRlY2lzaW9uc1ByZXZpb3VzLmpvaW4oXCJ8XCIpXHJcbiAgICAgICAgICAgICAgICArIFwiLFwiICsgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zQ3VycmVudC5qb2luKFwifFwiKTtcclxuICAgICAgICAgICAgbG9nLndhcm4oc3VzcGVuZERhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuZERhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWNvcmREZWNpc2lvbjogZnVuY3Rpb24gKGRwLCBhbnN3ZXIpIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJSZWNvcmRpbmcgZGVjaXNpb24gXCIgKyBkcCArIFwiIC8gXCIgKyBhbnN3ZXIpO1xyXG4gICAgICAgICAgICB2YXIgZEluZGV4ID0gcGFyc2VJbnQoZHAuc3Vic3RyKDIpLCAxMCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLmRlY2lzaW9uc0N1cnJlbnRbZEluZGV4LTFdID0gYW5zd2VyO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5zY29yZSArPSB0aGlzLnNjb3Jlc1thbnN3ZXJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5jcmVhc2UgdGhlIHBsYXl0aHJvdWdoIGNvdW50LCBvcHRpb25hbGx5IG1hcmtpbmcgdGhpcyBhY3QgY29tcGxldGUuXHJcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSBudW1iZXJzIG1heSBiZSBzdHJpbmdzLCBhbmQgZm9yY2VzIHRoZW0gdG8gbnVtYmVycy5cclxuICAgICAgICAgKiBAcGFyYW0gY29tcGxldGVDb3VudCBvcHRpb25hbCB2YWx1ZSBhdCB3aGljaCB0byBtYXJrIHRoZSBhY3QgY29tcGxldGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5jcmVtZW50UGxheXRocm91Z2g6IGZ1bmN0aW9uKCBjb21wbGV0ZUNvdW50ICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcImluY3JlYXNpbmcgcGxheSB0aHJvdWdoXCIpO1xyXG4gICAgICAgICAgICBpZiggIWNvbXBsZXRlQ291bnQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIllvdSBtdXN0IHByb3ZpZGUgYSBjb21wbGV0ZSBjb3VudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnBsYXlUaHJvdWdoID0gcGFyc2VJbnQodGhpcy52YXJpYWJsZXMucGxheVRocm91Z2gsIDEwKTtcclxuXHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ291bnQgPSBwYXJzZUludChjb21wbGV0ZUNvdW50LDEwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGNvbXBsZXRlZCB0aGUgZGVzaXJlZCBudW1iZXIgb2YgcGxheSB0aHJvdWdocywgbWFyayBjb21wbGV0ZS5cclxuICAgICAgICAgICAgaWYoIHRoaXMudmFyaWFibGVzLnBsYXlUaHJvdWdoID09PSBjb21wbGV0ZUNvdW50ICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJUYXJnZXQgcGxheXRocm91Z2hzIHJlYWNoZWRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5wbGF5VGhyb3VnaCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgZ28gdG8gdGhlIG5leHQgcGxheVRocm91Z2guXHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnBsYXlUaHJvdWdoKys7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzWydjdXJyZW50X3NjZW5lX25hbWUnXSA9IHRoaXMudmFyaWFibGVzWydkZWZhdWx0X3NjZW5lX25hbWUnXTtcclxuICAgICAgICAgICAgLy8gQ29weSB0aGUgZGVjaXNpb24gcG9pbnRzIGFuZCBzdGFydCBhIG5ldyBzZXQuXHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLmRlY2lzaW9uc1ByZXZpb3VzID0gdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zQ3VycmVudDtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zQ3VycmVudCA9ICBbXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIl07XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhciBvdXQgYW55IHNhdmVkIGNob2ljZXMgdG8gdW5kZWZpbmVkLiBjdXJyZW50bHkgdGhpcyBpbnZvbHZlcyB3aGljaCBjaGFyYWN0ZXJzIHRoZVxyXG4gICAgICAgICAqIHBsYXllciBzZWxlY3RlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhclNhdmVkQ2hvaWNlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzWydjaGFyYWN0ZXJfMSddID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzInXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8zJ10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBY3ROb3dEYXRhO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEwLzMwLzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTcgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXByZXNlbnQgYSBzcGVjaWZpYyBQbGF5IE1vZGVsIHN0cmF0ZWd5IGZvciBhIHNldCBvZiBjb3Vyc2VzL2FjdGl2aXRpZXMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIEJhc2ljRGF0YSA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHtcclxuICAgICAgICAgICAgICAgIHNjb3JlOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHdoZXJlIHlvdSB3b3VsZCBpbXBsZW1lbnQgc3BlY2lhbCBiZWhhdmlvciBmb3IgYSBjdXN0b21lIG1vZGVsIHN0cmF0ZWd5LlxyXG4gICAgICAgICAqIFlvdSBjYW4gcmV0dXJuIGFuIGV2ZW50IHN0cmluZyBmcm9tIHRoaXMgYW5kIGl0IHdpbGwgYmUgZGlzcGF0Y2hlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBoYW5kbGVTcGVjaWFsVmFyOiBmdW5jdGlvbiggdmFyaWFibGUsIHZhbHVlICkge1xyXG4gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29tZXRoaW5nIGhhcyBjaGFuZ2VkIGluIHRoZSBtb2RlbC4gSWYgYSB2YXJpYWJsZSBjaGFuZ2VzLCB0aGUgc3RhdGVcclxuICAgICAgICAgKiBvZiB0aGUgYWN0IG1pZ2h0IGNoYW5nZSwgc28gaWdub3JlIGEgdmFsdWUgc3RheWluZyB0aGUgc2FtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIC8vbG9nLndhcm4oXCJTZXQgVmFyaWFibGU6IFwiICsgdmFyaWFibGUgKyBcIiA9IFwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICBpZiggdmFyaWFibGUgPT09IFwic2NvcmVcIiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW1wic2NvcmVcIl0gKz0gcGFyc2VJbnQodmFsdWUsMTApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdICE9PSB2YWx1ZSApICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWN0IG9uIGEgdmFsdWUgc3RheWluZyB0aGUgc2FtZS5cclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW3ZhcmlhYmxlXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VmFyOiBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZSBkYXRhIHRoYXQgYWxyZWFkeSBleGlzdGVkIGluIFNDT1JNLlxyXG4gICAgICAgICAqIERhdGEgbG9va3MgbGlrZTogW1ZBUjpWQUxVRXxWQVI6VkFMVUVdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uIChzdXNwZW5kRGF0YSkge1xyXG4gICAgICAgICAgICBpZiggc3VzcGVuZERhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZFNldCA9IHN1c3BlbmREYXRhLnNwbGl0KFwifFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlyO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHN1c3BlbmRTZXQsIGZ1bmN0aW9uICh2YWx1ZVBhaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyID0gdmFsdWVQYWlyLnNwbGl0KFwiOlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT09IDIgJiYgcGFpclsxXSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFpclsxXSAhPT0gXCJudWxsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbcGFpclswXV0gPSBwYWlyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oc3VzcGVuZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuc2NvcmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3IgdGhlIGJhc2ljIG1vZGVsLCBzYXZlIGV2ZXJ5dGhpbmcgdGhhdCBpdCdzIHRvbGQgdG8gc2F2ZS5cclxuICAgICAgICAgKiBAcGFyYW0gcGVyc2lzdExpc3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN1c3BlbmREYXRhOiBmdW5jdGlvbiAocGVyc2lzdExpc3QpIHtcclxuICAgICAgICAgICAgdmFyIHN1c3BlbmREYXRhID0gXCJcIjtcclxuICAgICAgICAgICAgdmFyIHN1c3BlbmRFbnRyaWVzID0gW107XHJcbiAgICAgICAgICAgIF8uZWFjaCggcGVyc2lzdExpc3QsIGZ1bmN0aW9uKCBrZXlWYWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc2F2ZSBkZWZpbmVkIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLnZhcmlhYmxlc1trZXlWYWx1ZV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuZEVudHJpZXMucHVzaChrZXlWYWx1ZSArIFwiOlwiICsgdGhpcy52YXJpYWJsZXNba2V5VmFsdWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIGlmKCBzdXNwZW5kRW50cmllcy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuZERhdGEgPSBzdXNwZW5kRW50cmllcy5qb2luKFwifFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuZERhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNpY0RhdGE7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDkvMTEvMjAxN1xyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSByZWdpc3RyeSBhbmQgY29uc3RydWN0aW9uIGZhY3RvcnkgZm9yIE1vZGVsIFN0cmF0ZWdpZXM7IHdoaWNoIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIG9uIHRoZWlyIG93biwgb25seVxyXG4gKiBmcm9tIHRoaXMgY3JlYXRpb24gcG9pbnQuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgQWN0Tm93ID0gcmVxdWlyZSgnLi9hY3Rub3cnKTtcclxuICAgIHZhciBCYXNpYyA9IHJlcXVpcmUoJy4vYmFzaWMnKTtcclxuXHJcbiAgICB2YXIgTW9kZWxSZWdpc3RyeSA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsVHlwZXMgPSBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyTW9kZWw6IGZ1bmN0aW9uKCB0eXBlLCBtb2RlbCApIHtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLm1vZGVsVHlwZXMsIGZ1bmN0aW9uKGtub3duVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIGtub3duVHlwZSA9PT0gdHlwZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIllvdSBhcmUgcmVnaXN0ZXJpbmcgYSBtb2RlbCB0eXBlIHRoYXQgYWxyZWFkeSBleGlzdHM6IFwiICsgdHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxUeXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsc1t0eXBlXSA9IG1vZGVsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uKCB0eXBlICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIlJldHVybmluZyBtb2RlbCBvZiB0eXBlOiBcIiArIHR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHNbdHlwZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0F2YWlsYWJsZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5tb2RlbFR5cGVzLCBmdW5jdGlvbihrbm93blR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCBrbm93blR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QXZhaWxhYmxlVHlwZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBjbG9uZSwgdG8gbWFrZSBpdCByZWFkIG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMubW9kZWxUeXBlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIE1vZGVsRmFjdG9yeSA9IG5ldyBNb2RlbFJlZ2lzdHJ5KCk7XHJcblxyXG4gICAgLyogR2VuZXJhbCBBY3RvcnMsIG9yIHJldXNhYmxlIGFjcm9zcyBjb3Vyc2VzICovXHJcbiAgICBNb2RlbEZhY3RvcnkucmVnaXN0ZXJNb2RlbChcImFjdG5vd1wiLCBBY3ROb3cgKTtcclxuICAgIE1vZGVsRmFjdG9yeS5yZWdpc3Rlck1vZGVsKFwiYmFzaWNcIiwgQmFzaWMgKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsRmFjdG9yeTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDIuMC4wXHJcbiAqIEBjcmVhdGlvbiAxMC8yNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgdG9wIGxldmVsIGNvbnRyb2xsZXIgZm9yIHRoZSBzY2VuZSBlbmdpbmUsIFBsYXktPkFjdChzKS0+U2NlbmUocyktPkFjdG9yc1xyXG4gKiBUaGUgUGxheSBvYmplY3QgbWFuYWdlcyBhbGwgb2YgdGhlIEFjdHMgaW4gYSBQbGF5LCBzaG93aW5nIG9uZSBhY3QgYXQgYSB0aW1lIGFuZCBhY2NlcHRpbmcgZXZlbnRzIGZyb20gQWN0IG9iamVjdHMuXHJcbiAqXHJcbiAqIFRoZSBnZW5lcmFsIGlkZWEgaXMgdGhhdCBhbiBBY3QgaXMgYWxsb3dlZCB0byB1c2UgdGhlIGdhbWUgb2JqZWN0IGZvciBkcmF3aW5nIHRvIHRoZSBzY3JlZW4sIHNvdW5kLCBhbmQgSS9PLiBUaGVyZVxyXG4gKiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhY3QgaW5zdGFudGlhdGVkLCBhbmQgdGhleSBhcmUgc3RhY2tlZCBvbiB0b3Agb2YgZWFjaCBvdGhlciAoei1pbmRleCkuIEVhY2ggQWN0IGlzIHJlc3BvbnNpYmxlXHJcbiAqIGZvciBjbGVhbmluZyBpdHNlbGYgdXAgYW5kIHJlbW92aW5nIGZyb20gdGhlIGdhbWUgYW55dGhpbmcgaXQgYWRkZWQuIEFuIEFjdCBtdXN0IG9ubHkgY29uZm9ybSB0byB0aGUgYWN0IGludGVyZmFjZSxcclxuICogaXQgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHBsYXktc2NlbmUuXHJcbiAqXHJcbiAqIElmIGFueSBvZiB0aGUgYWN0cyBoYXZlIG9iamVjdGl2ZXMsIHRoZW4gdGhlIGVudGlyZSBwbGF5IChzY29ybSBhY3Rpdml0eSkgd2lsbCBub3QgYmUgbWFya2VkIGNvbXBsZXRlIHVudGlsIGFsbFxyXG4gKiBvYmplY3RpdmUgYWN0cyBoYXZlIHJlcG9ydGVkIGFzIGNvbXBsZXRlZC4gSWYgbm8gYWN0cyBoYXZlIG9iamVjdGl2ZXMsIHRoZW4gdGhlIGVudGlyZSBwbGF5IHdpbGwgYmUgbWFya2VkIGNvbXBsZXRlXHJcbiAqIHdoZW4gdGhlIGRlZmF1bHQgYWN0IHJlcG9ydHMgY29tcGxldGUuXHJcbiAqXHJcbiAqIFRoaXMgd2hhdCB0aGUgY29uZmlndXJhdGlvbiBzaG91bGQgbG9vayBsaWtlLiBJbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGlzIHdpbGwgY29tZSBmcm9tIHBoYXNlci4gQnV0IHlvdSBjb3VsZCBqdXN0XHJcbiAqIHBhc3MgYSBjb25maWd1cmF0aW9uIG9iamVjdCBpbi5cclxuICoge1xyXG4gKiAgIFwibmFtZVwiOiBcIk5hbWUgb2YgdGhlIHBsYXlcIixcclxuICogICBcImRlc2NyaXB0aW9uXCI6IFwiWW91IG1heSB1c2UgdGhpcyBsaW5lIGFzIGluLWRhdGEgZG9jdW1lbnRhdGlvbi5cIixcclxuICogICBcInNjb3JtXCI6IHRydWV8ZmFsc2UsXHJcbiAqICAgXCJsb2dnaW5nXCI6IHRydWV8ZmFsc2UsXHJcbiAqICAgXCJhY3RzXCI6IHtcclxuICogICAgIFwiZGVmYXVsdFwiOiB7IC8vIFlvdSBNVVNUIGhhdmUgYW4gYWN0IGNhbGxlZCAnZGVmYXVsdCcgIVxyXG4gKiAgICAgICBcImlkXCI6IFwiZGVmYXVsdFwiLCAvLyB0aGlzIGlzIGFuIGludGVybmFsIElEIHVzZWQgdG8gc3RvcmUgdGhpbmdzIGluIHRoZSBwaGFzZXIgY2FjaGUuIEl0IHNob3VsZCBiZSB1bmlxdWUgYW1vbmcgYWN0cy5cclxuICogICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkV2ZXJ5IHNldCBvZiBhY3RzIGhhcyBhIGRlZmF1bHQsIHdoaWNoIGlzIHRoZSBhY3QgdGhhdCBpcyBzdGFydGVkIGJ5IGRlZmF1bHQuXCIsXHJcbiAqICAgICAgIFwibmFtZVwiOiBcIkdyYWRlIDYgQWN0IE5vdyFcIixcclxuICogICAgICAgXCJkYXRhXCI6IFwibWVkaWEvc2NlbmVEYXRhLmpzb25cIixcclxuICogICAgICAgXCJ0aGVtZVwiOiBcIm1lZGlhL3RoZW1lLmpzb25cIixcclxuICogICAgICAgXCJvYmplY3RpdmVcIjogXCJ4XCIsIC8vIE9wdGlvbmFsLCBvYmplY3QgdG8gY29tcGxldGUgd2hlbiBhY3QgaXMgY29tcGxldGVcclxuICogICAgICAgXCJvYmplY3RpdmVzXCI6IFsgXCJhXCIsIFwiYlwiLCBjXCJdIC8vIG9wdGlvbmFsLCBtYXkgc3RpbGwgaGF2ZSBcIm9iamVjdGl2ZVwiIGFzIHdlbGwuXHJcbiAqICAgICAgIFwidHlwZVwiOiBcInNjZW5lXCIgLy8gb3B0aW9uYWwsIGRlZmF1bHRzIHRvIFwic2NlbmVcIiwgc3BlY2lmaWVzIHdoYXQgdHlwZSBvZiBBY3QgdG8gaW5zdGFudGlhdGUuXHJcbiAqICAgICB9LFxyXG4gKiAgICAgXCJhY3QyXCI6IHtcclxuICogICAgICAgXCJpZFwiOiBcImFjdDJcIixcclxuICogICAgICAgXCJkZXNjcmlwdGlvblwiOiBcInRoaXMgaXMgdGhlIGV4Y2l0aW5nIHNlY29uZCBhY3QhXCIsXHJcbiAqICAgICAgIFwibmFtZVwiOiBcIkFjdCBUd28hXCIsXHJcbiAqICAgICAgIFwiZGF0YVwiOiBcIm1lZGlhL3NjZW5lRGF0YS5qc29uXCIsXHJcbiAqICAgICAgIFwidGhlbWVcIjogXCJtZWRpYS90aGVtZS5qc29uXCJcclxuICogICAgIH0sXHJcbiAqICAgICAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKSxcclxuXHRcdF8gPSByZXF1aXJlKFwibG9kYXNoXCIpLFxyXG5cdFx0QmFzZSA9IHJlcXVpcmUoXCJiYXNlanNcIiksXHJcblx0XHRBY3RNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2FjdC9wbGF5LWFjdC1tYW5hZ2VyXCIpLFxyXG5cdFx0U2Nvcm1TZXJ2aWNlID0gcmVxdWlyZShcIi4vc2Nvcm0tc2VydmljZVwiKTtcclxuXHJcblx0dmFyIE9CSkVDVElWRV9QUkVGSVggPSBcIm9iamVjdGl2ZV9cIjtcclxuXHJcblx0dmFyIFBsYXkgPSBCYXNlLmV4dGVuZCh7XHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0aW9ucyBvZiB0aGUgUGxheSBvYmplY3QsIHJlcXVpcmluZyBib3RoIGEgUGhhc2VyIGdhbWUgYW5kIGEgY29uZmlndXJhdGlvbiBvYmplY3QgKEpTT04pXHJcblx0XHQgKiB0aGUgY29uZmlndXJhdGlvbiBzaG91bGQgaW5jbHVkZSBhIG5hbWUsIGRlc2NyaXB0aW9uIGFuZCBhIHNldCBvZiBhY3RzLiBUaGUgYWN0cyBNVVNUIGluY2x1ZGVcclxuXHRcdCAqIGFuIGFjdCBsYWJlbGxlZCAnZGVmYXVsdCcuXHJcblx0XHQgKi9cclxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZ2FtZSwgY29uZmlnLCBzZXR0aW5ncykge1xyXG5cdFx0XHRpZiAoIWdhbWUgfHwgIWNvbmZpZyB8fCAhc2V0dGluZ3MpIHtcclxuXHRcdFx0XHR0aHJvdyBcIkNyZWF0aW5nIGEgUGxheSByZXF1aXJlcyBhIFBoYXNlciBnYW1lIGluc3RhbmNlLCBjb25maWd1cmF0aW9uIG9iamVjdCBhbmQgc2V0dGluZ3MuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFjb25maWcuYWN0cykge1xyXG5cdFx0XHRcdHRocm93IFwiVGhlcmUgaXMgbm8gJ2FjdHMnIGZpZWxkIGluIHRoZSBwbGF5Lmpzb25cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmdhbWUgPSBnYW1lO1xyXG5cdFx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdFx0dGhpcy5wbGF5QWN0U2V0ID0gY29uZmlnLmFjdHM7XHJcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHRcdFx0dGhpcy5hY3RJbnN0YW5jZXMgPSB7fTtcclxuXHRcdFx0dGhpcy5wcmV2aW91c0FjdCA9IG51bGw7XHJcblx0XHRcdHRoaXMud2FpdGluZ09uID0gW107XHJcblx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlID0gbmV3IFNjb3JtU2VydmljZShcclxuXHRcdFx0XHR0aGlzLmdhbWUuc2Nvcm0sXHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncyxcclxuXHRcdFx0XHR0aGlzLnBsYXlBY3RTZXRcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRoaXMuY29tbWFuZHMgPSB7XHJcblx0XHRcdFx0Y2hhbmdlX2FjdDogXCJjaGFuZ2VfYWN0XCIsXHJcblx0XHRcdFx0bXV0ZV9nYW1lOiBcIm11dGVfZ2FtZVwiLFxyXG5cdFx0XHRcdG11dGVfZ2FtZV9vbjogXCJtdXRlX29uXCIsXHJcblx0XHRcdFx0c2F2ZTogXCJzYXZlXCIsXHJcblx0XHRcdFx0Y29tcGxldGU6IFwiY29tcGxldGVcIixcclxuXHRcdFx0XHRvYmplY3RpdmU6IFwib2JqZWN0aXZlXCIsXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoIXRoaXMucGxheUFjdFNldFt0aGlzLnNldHRpbmdzLmRlZmF1bHRfYWN0X25hbWVdKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJQbGF5IGNvdWxkIG5vdCBzdGFydC4gWW91IGRvIG5vdCBoYXZlIGEgZGVmYXVsdCBBQ1QuIFNlZSBwbGF5LmpzIGhlYWRlci5cIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5hdXRvU2NhbGUpIHtcclxuXHRcdFx0XHR0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogU2V0IHRoZSBEZWZhdWx0IEFjdCBhcyB0aGUgbmV4dCBBY3QuXHJcblx0XHQgKi9cclxuXHRcdHNlbGVjdERlZmF1bHRBY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5zZWxlY3ROZXh0QWN0KHRoaXMuc2V0dGluZ3MuZGVmYXVsdF9hY3RfbmFtZSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGVzIG9yIGxvb2tzIHVwIGFuIGV4aXN0aW5nIEFjdC4gQW55IGN1cnJlbnRseSBydW5uaW5nIEFjdCB3aWxsXHJcblx0XHQgKiBiZSBzdG9wcGVkLiBXaGVuIGEgbmV3IEFjdCBpcyBjcmVhdGVkLCBpdCBpcyBjYWNoZWQuXHJcblx0XHQgKiBUaGlzIGRvZXMgTk9UIHN0YXJ0IHRoZSBBY3QsIGFmdGVyIHNlbGVjdE5leHRBY3QoKSwgc3RhcnROZXh0QWN0KCkgbXVzdCBiZSBjYWxsZWQuXHJcblx0XHQgKiBAcGFyYW0gYWN0TmFtZSBOYW1lIG9mIEFjdCBmcm9tIFBsYXkuanNvbiB0byBzdGFydC5cclxuXHRcdCAqL1xyXG5cdFx0c2VsZWN0TmV4dEFjdDogZnVuY3Rpb24gKGFjdE5hbWUpIHtcclxuXHRcdFx0Ly8gRXhpdCBhbnkgY3VycmVudCBhY3QuXHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3QpIHtcclxuXHRcdFx0XHQvLyB0aGUgZGVmYXVsdCBhY3Qgc2hvdWxkIG5vdCBiZSBzdG9wcGVkLlxyXG5cdFx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3QuYWN0TmFtZSAhPT0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0X2FjdF9uYW1lKSB7XHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRBY3Quc3RvcCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnByZXZpb3VzQWN0ID0gdGhpcy5jdXJyZW50QWN0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBEb24ndCBjcmVhdGUgYW4gYWN0IHRoYXQgYWxyZWFkeSBleGlzdHMuXHJcblx0XHRcdGlmICh0aGlzLmFjdEluc3RhbmNlc1thY3ROYW1lXSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdCA9IHRoaXMuYWN0SW5zdGFuY2VzW2FjdE5hbWVdO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC5zZXRTY29ybVN0cmluZyh0aGlzLnBsYXlBY3RTZXRbYWN0TmFtZV0uc3VzcGVuZERhdGEpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTG9vayB1cCBhbmQgY3JlYXRlIGFuIEFjdCB0aGF0IGRvZXNuJ3QgZXhpc3QuXHJcblx0XHRcdHZhciBuZXh0QWN0RGF0YSA9IHRoaXMucGxheUFjdFNldFthY3ROYW1lXTtcclxuXHRcdFx0dmFyIG5leHRBY3RUaGVtZSA9IEpTT04ucGFyc2UoXHJcblx0XHRcdFx0dGhpcy5nYW1lLmNhY2hlLmdldFRleHQodGhpcy5zZXR0aW5ncy50aGVtZV9wcmVmaXggKyBuZXh0QWN0RGF0YS5pZClcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKHRoaXMuY29uZmlnLmF1dG9TY2FsZSkge1xyXG5cdFx0XHRcdC8vIElmIGF1dG9TY2FsZSBpcyBzZXQgdG8gdHJ1ZSBpbiB0aGUgcGxheS5qc29uIGZpbGUgYWRkIGEgcHJvcGVydHkgdG8gdGhlIHRoZW1lIHRvIHNtdWdnbGUgaXQgaW50byB0aGUgYWN0IGZvciB1c2UgYnkgYWN0b3JzLCB3aG8gZG8gbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBwbGF5Lmpzb24gc2V0dGluZ3MuIEZvciBleGFtcGxlLCB0aGUgV0lTVElBIGFjdG9yIHNpemVzIHRoZSB2aWRlbyBkaXYgZGlmZmVyZW50bHkgYWNjb3JkaW5nIHRvIHRoZSBhdXRvU2NhbGUgc2V0dGluZy5cclxuXHRcdFx0XHRuZXh0QWN0VGhlbWUuaW50ZXJuYWxfYXV0b1NjYWxlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50QWN0ID0gQWN0TWFuYWdlci5nZXRBY3RJbnN0YW5jZShcclxuXHRcdFx0XHRuZXh0QWN0RGF0YS50eXBlLFxyXG5cdFx0XHRcdHRoaXMuZ2FtZSxcclxuXHRcdFx0XHRuZXh0QWN0VGhlbWUsXHJcblx0XHRcdFx0YWN0TmFtZVxyXG5cdFx0XHQpO1xyXG5cdFx0XHQvLyBPbmx5IHRoZSBkZWZhdWx0IEFjdCBjb3VudHMgYXMgc3RhbmQgYWxvbmUuXHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3Quc2V0U3RhbmRBbG9uZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC5zZXRTdGFuZEFsb25lKFxyXG5cdFx0XHRcdFx0YWN0TmFtZSA9PT0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0X2FjdF9uYW1lXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGV2ZW50cy5cclxuXHRcdFx0dGhpcy5jdXJyZW50QWN0LmV2ZW50cy5vbkdhbWVDaG9pY2UuYWRkKHRoaXMub25HYW1lQ2hvaWNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRBY3QuZXZlbnRzLm9uQWN0U3RhdHVzLmFkZCh0aGlzLm9uQWN0U3RhdHVzRXZlbnQsIHRoaXMpO1xyXG5cdFx0XHQvLyBSZXN0b3JlIHRoZSBBY3QgZnJvbSB0aGUgXCJTYXZlXCIgcG9pbnQuXHJcblx0XHRcdHRoaXMuY3VycmVudEFjdC5zZXRTY29ybVN0cmluZyhuZXh0QWN0RGF0YS5zdXNwZW5kRGF0YSk7XHJcblx0XHRcdHRoaXMuYWN0SW5zdGFuY2VzW2FjdE5hbWVdID0gdGhpcy5jdXJyZW50QWN0O1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogIFRoaXMgaXMgdGhlIGhvb2sgaW50byByZXN0YXJ0aW5nIHRoZSBtYWluIFBoYXNlciBzdGF0ZSBhbmQgbGF1bmNoaW5nIGEgbmV3IEFjdC5cclxuXHRcdCAqICBUaGUgbmV3IEFjdCBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gc2VsZWN0ZWQgdXNpbmcgc2VsZWN0TmV4dEFjdCgpLlxyXG5cdFx0ICogIFRoaXMgd2lsbCBsZWFkIHRvIHNob3dBY3QoKSBiZWluZyBjYWxsZWQgZnJvbSB0aGUgbWFpbiBzdGF0ZS5cclxuXHRcdCAqL1xyXG5cdFx0c3RhcnROZXh0QWN0OiBmdW5jdGlvbiAoaXNSZXN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZ2FtZS5zdGF0ZS5yZXN0YXJ0KGZhbHNlLCBmYWxzZSwgaXNSZXN0YXJ0KTsgLy8gdHJ1ZSwgZmFsc2UgbWVhbnMgXCJjbGVhciB3b3JsZCwga2VlcCBjYWNoZVwiXHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZ1bmN0aW9uYWwgd2lsbCBhY3R1YWxseSBzdGFydCBhbiBhY3QgdXAsIGFuZCB0aGVuIHByb3ZpZGUgaXQgd2l0aCBpbmZvcm1hdGlvbiBvbiB0aGUgb3RoZXIgYWN0cy5cclxuXHRcdCAqIEl0IHdpbGwgdGVsbCBhbiBhY3Qgd2hpY2ggcHJldmlvdXMgYWN0IGV4aXRlZCwgYWxsb3dpbmcgYW4gYWN0IHRvIGtub3cgYm90aCB3aGljaCBhY3QgY2FtZSBiZWZvcmUgYW5kXHJcblx0XHQgKiB0aGF0IGl0IGlzbid0IGZpcnN0LlxyXG5cdFx0ICogU2Vjb25kLCBpdCB3aWxsIGluZm9ybSBhIG5vbi1maXJzdCBhY3QgaWYgdGhlIHByZXZpb3VzIGFjdHMgb2JqZWN0aXZlIHN0YXR1cyAoYWN0X2V4aXRlZCArIG9iamVjdGl2ZSBzdGF0dXMpXHJcblx0XHQgKiBGb3IgYSBmaXJzdCAoRGVmYXVsdCkgYWN0LCB0aGUgc3RhdHVzIG9mIGV2ZXJ5IG90aGVyIGFjdCBvYmplY3RpdmUgd2lsbCBiZSBwYXNzZWQgaW4sIGJ1dCBvbmx5IGlmIHRoYXRcclxuXHRcdCAqIGFjdCBpcyB0cmFja2luZyBieSBvYmplY3RpdmUuXHJcblx0XHQgKiBAcGFyYW0gaXNSZXN0YXJ0XHJcblx0XHQgKi9cclxuXHRcdHNob3dOZXh0QWN0OiBmdW5jdGlvbiAoaXNSZXN0YXJ0KSB7XHJcblx0XHRcdGlmICghdGhpcy5jdXJyZW50QWN0KSB7XHJcblx0XHRcdFx0dGhyb3cgXCJObyBjdXJyZW50IEFjdCB0byBzdGFydCFcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHNpbmdsZUFjdERhdGEgPSB0aGlzLnBsYXlBY3RTZXRbdGhpcy5jdXJyZW50QWN0LmFjdE5hbWVdO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhbiBvYmplY3RpdmUsIGl0IG1heSBuZWVkIHRvIGJlIG1hcmtlZCBhcyBzdGFydGVkLlxyXG5cdFx0XHR0aGlzLnNjb3JtU2VydmljZS5tYXJrQWN0U3RhcnRlZChzaW5nbGVBY3REYXRhLmlkKTtcclxuXHJcblx0XHRcdC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gc3RhcnQgdGhlIGRlZmF1bHQgYWN0LCBpdCdzIG5vdCBzdG9wcGVkLiBCdXQgdGhpcyBtYXkgYmUgdGhlIGZpcnN0IGNhbGwuXHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHQhdGhpcy5wcmV2aW91c0FjdCB8fFxyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC5hY3ROYW1lICE9PSB0aGlzLnNldHRpbmdzLmRlZmF1bHRfYWN0X25hbWVcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuY3VycmVudEFjdC5vblByZWxvYWRGaW5pc2hlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50QWN0Lm9uUHJlbG9hZEZpbmlzaGVkKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC5zdGFydChpc1Jlc3RhcnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHdpbGwgc2VuZCB2YXJpYWJsZXMgdG8gdGhlIGN1cnJlbnQgYWN0IGZyb20gdGhlIHByZXZpb3VzIG9yIGFsbCBhY3RzLCBzbyB3aGVuIHRoZSBkZWZhdWx0XHJcblx0XHQgKiBhY3Qgc3RhcnRzLCBpdCB3aWxsIGtub3cgYWJvdXQgYWxsIHRyYWNrZWQgb2JqZWN0aXZlIHZhcmlhYmxlcyBpbiBvdGhlciBhY3RzLlxyXG5cdFx0ICovXHJcblx0XHRzZW5kQ3Jvc3NBY3RWYXJpYWJsZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIG9iamVjdGl2ZVNldCA9IFtdO1xyXG5cdFx0XHR2YXIgdGVtcDtcclxuXHJcblx0XHRcdGlmICh0aGlzLnByZXZpb3VzQWN0KSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0Lm9uR2FtZUNob2ljZSh7IGFjdF9leGl0ZWQ6IHRoaXMucHJldmlvdXNBY3QuYWN0TmFtZSB9KTtcclxuXHRcdFx0XHR2YXIgcHJldmlvdXNBY3REYXRhID0gdGhpcy5wbGF5QWN0U2V0W3RoaXMucHJldmlvdXNBY3QuYWN0TmFtZV07XHJcblx0XHRcdFx0b2JqZWN0aXZlU2V0ID0gdGhpcy5zY29ybVNlcnZpY2UuZ2V0QWN0T2JqZWN0aXZlU3RhdHVzU2V0KFxyXG5cdFx0XHRcdFx0cHJldmlvdXNBY3REYXRhLmlkXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSAvKiBkZWZhdWx0IGFjdCAqLyBlbHNlIHtcclxuXHRcdFx0XHRvYmplY3RpdmVTZXQgPSB0aGlzLnNjb3JtU2VydmljZS5nZXRQbGF5T2JqZWN0aXZlU3RhdHVzU2V0KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdG9iamVjdGl2ZVNldCxcclxuXHRcdFx0XHRmdW5jdGlvbiAoZWFjaE9iamVjdGl2ZSkge1xyXG5cdFx0XHRcdFx0dGVtcCA9IHt9O1xyXG5cdFx0XHRcdFx0dGVtcFtPQkpFQ1RJVkVfUFJFRklYICsgZWFjaE9iamVjdGl2ZS5nZXRJZCgpXSA9XHJcblx0XHRcdFx0XHRcdGVhY2hPYmplY3RpdmUuZ2V0U3RhdHVzKCk7XHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRBY3Qub25HYW1lQ2hvaWNlKHRlbXApO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHQpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHBsYXllciBtYWRlIGEgZ2FtZSBjaG9pY2UuIFRoaXMgbWF5IGJlIGEgc3BlY2lhbCBjb21tYW5kIGZvciB0aGUgUGxheS5cclxuXHRcdCAqIEF0dGVtcHQgdG8gZXhlY3V0ZSBpdCwgYW5kIGFsbG93IHRoZSBleGVjdXRpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCB3YXNcclxuXHRcdCAqIGNvbnN1bWVkLlxyXG5cdFx0ICogQHBhcmFtIGV2ZW50UGFpclxyXG5cdFx0ICovXHJcblx0XHRvbkdhbWVDaG9pY2VFdmVudDogZnVuY3Rpb24gKGV2ZW50UGFpcikge1xyXG5cdFx0XHR2YXIgdGVtcFZhcnMgPSBfLnBhaXJzKGV2ZW50UGFpcilbMF07XHJcblx0XHRcdGV2ZW50UGFpci5jb25zdW1lZCA9IHRoaXMucGxheUNvbW1hbmQodGVtcFZhcnNbMF0sIHRlbXBWYXJzWzFdKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBwbGF5ZXIgY2F1c2VkIGEgc3RhdHVzIGV2ZW50OyB1c3VhbGx5IGVpdGhlciBhIHNhdmUgb3IgYSBjb21wbGV0aW9uIG9mIGFuIGFjdGl2aXR5LiBUaGVzZSBhcmVuJ3RcclxuXHRcdCAqIGNhdWVkIGJ5IHBsYXllcidzIGRpcmVjdGx5LCBidXQgYnkgdGhlIFNjZW5lcy9BY3RzLlxyXG5cdFx0ICogXCJhY3RfY29tcGxldGVcIiAtPiBpbmNyZW1lbnQgcGxheXRocm91Z2ggLT4gXCJjb21wbGV0ZVwiIHN0YXR1cyBldmVudC5cclxuXHRcdCAqIEBwYXJhbSBldmVudENvbW1hbmRcclxuXHRcdCAqL1xyXG5cdFx0b25BY3RTdGF0dXNFdmVudDogZnVuY3Rpb24gKGV2ZW50Q29tbWFuZCwgZXZlbnRBcmcpIHtcclxuXHRcdFx0aWYgKGV2ZW50Q29tbWFuZCA9PT0gdGhpcy5jb21tYW5kcy5zYXZlKSB7XHJcblx0XHRcdFx0dGhpcy5zYXZlU2Nvcm1EYXRhKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRDb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0dGhpcy5zY29ybVNlcnZpY2UuaGFuZGxlQWN0Q29tcGxldGUodGhpcy5jdXJyZW50QWN0LmFjdE5hbWUpOyAvLyBhY3ROYW1lID09PSBhY3RJZFxyXG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50Q29tbWFuZCA9PT0gdGhpcy5jb21tYW5kcy5vYmplY3RpdmUpIHtcclxuXHRcdFx0XHR0aGlzLnNjb3JtU2VydmljZS5tYXJrT2JqZWN0aXZlQ29tcGxldGUoZXZlbnRBcmcpO1xyXG5cdFx0XHRcdHRoaXMuc2F2ZVNjb3JtRGF0YSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBFeGVjdXRlIGEgUGxheSBsZXZlbCBjb21tYW5kLCBzdWNoIGFzIHNhdmluZyBvciBjaGFuZ2luZyBhY3RzLlxyXG5cdFx0ICogUmV0dXJucyB0cnVlIGlmIGl0IGNvbnN1bWVzIHRoZSBjb21tYW5kL2Nob2ljZS5cclxuXHRcdCAqL1xyXG5cdFx0cGxheUNvbW1hbmQ6IGZ1bmN0aW9uIChjb21tYW5kLCBhcmcpIHtcclxuXHRcdFx0bG9nLndhcm4oXCJwbGF5IGNvbW1hbmQ6IFwiICsgY29tbWFuZCArIFwiIC8gXCIgKyBhcmcpO1xyXG5cdFx0XHRpZiAoY29tbWFuZCA9PT0gdGhpcy5jb21tYW5kcy5jaGFuZ2VfYWN0KSB7XHJcblx0XHRcdFx0bG9nLndhcm4oXCJDaGFuZ2luZyBhY3QgdG8gXCIgKyBhcmcpO1xyXG5cdFx0XHRcdGlmICh0aGlzLnBsYXlBY3RTZXRbYXJnXSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zZWxlY3ROZXh0QWN0KGFyZyk7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXJ0TmV4dEFjdCh0cnVlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bG9nLmVycm9yKFwiUmVxdWVzdCB0byBjaGFuZ2UgdG8gbm9uLWV4aXN0YW50IGFjdDogXCIgKyBhcmcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLnNhdmUpIHtcclxuXHRcdFx0XHR0aGlzLnNhdmVTY29ybURhdGEoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLm11dGVfZ2FtZSkge1xyXG5cdFx0XHRcdC8vIEdKRiAtIDA5LzIwLzE3IC0gSSBtYXkgaGF2ZSBqdXN0IGJyb2tlIG11dGUgZm9yIGFsbCBwYXN0IGFjdGl2aXRpZXMgYnkgZml4aW5nIHRoaXMgbGluZS5cclxuXHRcdFx0XHR0aGlzLmdhbWUuc291bmQubXV0ZSA9XHJcblx0XHRcdFx0XHRhcmcgPT09IHRoaXMuY29tbWFuZHMubXV0ZV9nYW1lX29uID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gUmV0dXJuIGZhbHNlIGJlY2F1c2UgdGhpcyBpc24ndCAnY29uc3VtaW5nJywgaXQncyBhIHNpZGUgZWZmZWN0IHNwZWNpYWwgY2FzZS5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBMb2FkIHRoZSB0aGVtZSBhbmQgZGF0YSBmaWxlcyBmb3IgZWFjaCBhY3QgaW4gcGxheS5qc29uXHJcblx0XHQgKiBUaGlzIHVzZWQgdG8gXCJwcmVsb2FkXCIsIGJ1dCBub3cgaXQgcmV0dXJucyBhIHNldCwgdGhlIHBsYXkgaXMgbm8gbG9uZ2VyIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nXHJcblx0XHQgKiByZXNvdXJjZXMuXHJcblx0XHQgKiBUaGlzIGNhbid0IGJlIGRvbmUgZm9yIHRoZSBhY3QgYmVjYXVzZSBpdCB3b3VsZCBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSA6LShcclxuXHRcdCAqL1xyXG5cdFx0Z2V0UmVxdWlyZWRSZXNvdXJjZUxpc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIHByZWxvYWRTZXQgPSBbXTtcclxuXHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdHRoaXMuZ2V0QWN0c0xpc3QoKSxcclxuXHRcdFx0XHRmdW5jdGlvbiAoYWN0KSB7XHJcblx0XHRcdFx0XHRsb2cud2FybihcclxuXHRcdFx0XHRcdFx0XCJsb2FkaW5nIHRleHQgXCIgK1xyXG5cdFx0XHRcdFx0XHRcdGFjdC50aGVtZSArXHJcblx0XHRcdFx0XHRcdFx0XCIgYXMgXCIgK1xyXG5cdFx0XHRcdFx0XHRcdCh0aGlzLnNldHRpbmdzLnRoZW1lX3ByZWZpeCArIGFjdC5pZClcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRwcmVsb2FkU2V0LnB1c2goe1xyXG5cdFx0XHRcdFx0XHRrZXk6IHRoaXMuc2V0dGluZ3MudGhlbWVfcHJlZml4ICsgYWN0LmlkLFxyXG5cdFx0XHRcdFx0XHRmaWxlOiB0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIGFjdC50aGVtZSxcclxuXHRcdFx0XHRcdFx0dHlwZTogXCJqc29uXCIsXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdFx0cmV0dXJuIHByZWxvYWRTZXQ7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGVuIHRoZSBtYWluIFBoYXNlciBzdGF0ZSBpcyByZXN0YXJ0ZWQsIGR1cmluZyB0aGUgUGhhc2VyIHByZWxvYWQgZnVuY3Rpb24sIHRoaXMgcHJlbG9hZCB3aWxsIGJlIGNhbGxlZFxyXG5cdFx0ICogc28gdGhhdCB0aGUgbmV3IEFjdCBoYXMgYSB2YWxpZCBlbnRyeSBwb2ludCB0byBsb2FkaW5nIGFzc2V0cy4gVGhlIEFjdCBjYW4gbG9hZCBhbnkgcmVzb3VyY2VzIG5lY2Vzc2FyeS5cclxuXHRcdCAqL1xyXG5cdFx0cHJlbG9hZEFjdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50QWN0KSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LnByZWxvYWQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGFjdCBkZXRlcm1pbmVzIHdoZW4gaXQgaXMgZG9uZSBsb2FkaW5nLCBzbyB3aGVuIGFza2VkLCBkZWxlZ2F0ZSB0byB0aGUgQWN0LlxyXG5cdFx0ICovXHJcblx0XHRpc1ByZWxvYWRBY3RDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50QWN0ICYmIHRoaXMuY3VycmVudEFjdC5pc1ByZWxvYWRDb21wbGV0ZSgpO1xyXG5cdFx0fSxcclxuXHRcdGlzTG9nZ2luZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcubG9nZ2luZyA9PT0gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRnZXRBY3RzTGlzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5QWN0U2V0O1xyXG5cdFx0fSxcclxuXHRcdGlzU2Nvcm1FbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5zY29ybSA9PT0gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRyZW5kZXJEZWJ1ZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50QWN0ICYmIHRoaXMuc2V0dGluZ3MuZGVidWcgPT09IHRydWUpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRBY3QucmVuZGVyRGVidWcoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogdGhpcyBpcyB0aGUgZ2FtZSBsb29wLiBJZiB0aGUgYWN0IGlzIGEgZ2FtZSwgb3IgaGFzIGEgZGVsYXksIG9yIG5lZWRzIHRvIGRvIHRpbWluZywgaXQgU0hPVUxEIE5PVFxyXG5cdFx0ICogdXNlIGl0cyBvd24gdXBkYXRlIGZ1bmN0aW9uLCBidXQgc2hvdWxkIGluc3RlYWQgcHJvdmlkZSBhIHRpY2tVcGRhdGUuIFRoaXMgd2lsbCBiZSBjYWxsZWQgaGVyZSBzb1xyXG5cdFx0ICogdGhhdCB0aGUgdXBkYXRlKCkgY2FsbHMgYXJlIGNvbnRyb2xsZWQgZnJvbSB0aGUgcGxheS5cclxuXHRcdCAqIEBwYXJhbSB0aW1lXHJcblx0XHQgKi9cclxuXHRcdHRpY2tVcGRhdGU6IGZ1bmN0aW9uICh0aW1lKSB7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3QpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRBY3QudGlja1VwZGF0ZSh0aGlzLmdhbWUudGltZS5ub3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0bG9hZFNjb3JtRGF0YTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLnNjb3JtU2VydmljZS5sb2FkU2Nvcm1PYmplY3RpdmVEYXRhKCk7XHJcblx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLmxvYWRTY29ybVN1c3BlbmREYXRhKCk7XHJcblx0XHR9LFxyXG5cdFx0c2F2ZVNjb3JtRGF0YTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLnNjb3JtU2VydmljZS5zYXZlU2Nvcm1PYmplY3RpdmVEYXRhKCk7XHJcblx0XHRcdHZhciBzY29ybVN0cmluZyA9IHRoaXMuY3VycmVudEFjdC5nZXRTY29ybVN0cmluZygpO1xyXG5cdFx0XHRpZiAoc2Nvcm1TdHJpbmcgJiYgc2Nvcm1TdHJpbmcubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLnNhdmVTY29ybVN1c3BlbmREYXRhKFxyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LmFjdE5hbWUsXHJcblx0XHRcdFx0XHRzY29ybVN0cmluZ1xyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gUGxheTtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIFJlcHJlc2VudCB0aGUgc2V0IG9mIHNjb3JtIG9wZXJhdGlvbnMgdGhhdCBhcmUgcmVxdWlyZWQgYnkgYSBQbGF5LiBUaGlzIGludm9sdmVzIHRoZSBzYXZpbmcsIGxvYWRpbmcgYW5kIHVwZGF0aW5nXHJcbiAqIG9mIGFsbCBvYmplY3RpdmVzIGFuZCBzdXNwZW5kIGRhdGEuXHJcbiAqXHJcbiAqIFRoaXMgc2VydmljZSBkb2VzIG5vdCBoYW5kbGUgZ2FtZSBldmVudHMgb3Igc2VuZCBnYW1lIG5vdGlmaWNhdGlvbnMgdG8gYWN0cy9zY2VuZXMvZXRjLiBJdCBvbmx5IG1hbmFnZXMgc2Nvcm1cclxuICogcmVsYXRlZCBkYXRhIGFzIHJlcXVpcmVkLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcImJhc2Vqc1wiKTtcclxuXHJcbiAgICB2YXIgU1RBVFVTX05PVF9BVFRFTVBURUQgPSBcIm5vdCBhdHRlbXB0ZWRcIjtcclxuICAgIHZhciBTVEFUVVNfQVRURU1QVEVEID0gXCJpbmNvbXBsZXRlXCI7XHJcbiAgICB2YXIgU1RBVFVTX0NPTVBMRVRFRCA9IFwiY29tcGxldGVkXCI7XHJcblxyXG4gICAgdmFyIFNjb3JtT2JqZWN0aXZlID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggYWN0SWQsIGluZGV4LCBpZCwgc3RhdHVzICkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdElkID0gYWN0SWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFN0YXR1czogZnVuY3Rpb24oIG5ld1ZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3RhdHVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRBY3RJZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdElkO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBTY29ybVNlcnZpY2UgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChzY29ybSwgc2V0dGluZ3MsIHBsYXlBY3RTZXQpIHtcclxuICAgICAgICAgICAgaWYgKCFzY29ybSB8fCAhc2V0dGluZ3MgfHwgIXBsYXlBY3RTZXQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiWW91IG11c3QgcHJvdmlkZSBhbiBpbnRlcmZhY2UgdG8gc2Nvcm0gYW5kIHNldHRpbmdzLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2Nvcm0gPSBzY29ybTtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBY3RTZXQgPSBwbGF5QWN0U2V0O1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZVNldCA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFya0FjdFN0YXJ0ZWQ6IGZ1bmN0aW9uIChhY3RJZCkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuZ2V0QWN0T2JqZWN0aXZlU3RhdHVzU2V0KGFjdElkKSwgZnVuY3Rpb24ob2JqZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0aXZlLmdldFN0YXR1cygpICE9PSBTVEFUVVNfQ09NUExFVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0aXZlLnNldFN0YXR1cyhTVEFUVVNfQVRURU1QVEVEKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVPYmplY3RpdmUob2JqZWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXJrT2JqZWN0aXZlQ29tcGxldGU6IGZ1bmN0aW9uKCBvYmplY3RpdmVJZCApIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdGl2ZSA9IF8uZmluZFdoZXJlKCB0aGlzLm9iamVjdGl2ZVNldCwgeyBpZDogb2JqZWN0aXZlSWR9KTtcclxuICAgICAgICAgICAgaWYoIG9iamVjdGl2ZSApIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdGl2ZS5zZXRTdGF0dXMoU1RBVFVTX0NPTVBMRVRFRCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVPYmplY3RpdmUob2JqZWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQbGF5Q29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QWN0T2JqZWN0aXZlU3RhdHVzU2V0OiBmdW5jdGlvbiAoYWN0SWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ud2hlcmUodGhpcy5vYmplY3RpdmVTZXQsIHthY3RJZDogYWN0SWR9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFBsYXlPYmplY3RpdmVTdGF0dXNTZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RpdmVTZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5SGFzT2JqZWN0aXZlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgcmV0dXJuICh0aGlzLm9iamVjdGl2ZVNldC5sZW5ndGggPiAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIGJlIHByaXZhdGUsIGl0J3MgcGFydCBvZiB0aGUgc3RhcnR1cCBvZiB0aGlzIHNlcnZpY2UgYW5kIG91dHNpZGUgc291cmNlcyBzaG91bGQgbm90IGFjY2Vzc1xyXG4gICAgICAgICAqIHRoZSByYXcgZGF0YSBsaWtlIHRoaXM7IHdoaWNoIGlzIGluIGpzb24gdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCByZWFkIG9ubHkuXHJcbiAgICAgICAgICogVGhpcyBidWlsZHMgYSByYXcgbGlzdCBvZiBvYmplY3RpdmUgbmFtZXMgYmFzZWQgb24gZXZlcnkgYWN0IGluIHRoZSBwbGF5IGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmF3T2JqZWN0aXZlTGlzdDogZnVuY3Rpb24oIGFjdERhdGEgKSB7XHJcbiAgICAgICAgICB2YXIgb2JqZWN0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgaWYoIGFjdERhdGEub2JqZWN0aXZlICkge1xyXG4gICAgICAgICAgICAgIG9iamVjdExpc3QucHVzaChhY3REYXRhLm9iamVjdGl2ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiggYWN0RGF0YS5vYmplY3RpdmVzICkge1xyXG4gICAgICAgICAgICAgIG9iamVjdExpc3QgPSBvYmplY3RMaXN0LmNvbmNhdChhY3REYXRhLm9iamVjdGl2ZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG9iamVjdExpc3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHdpbGwgbG9hZCBvciBpbml0aWFsaXplIGFuIG9iamVjdGl2ZSBvYmplY3QgZm9yIGV2ZXJ5IG9iamVjdGl2ZSBpbiB0aGUgcGxheS4gSXQgd2lsbCBpbml0aWFsaXplXHJcbiAgICAgICAgICogdGhlIG9iamVjdCB3aXRoIFNDT1JNIGlmIGl0IGhhc24ndCBiZWVuIHByZXZpb3VzbHkgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbG9hZFNjb3JtT2JqZWN0aXZlRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RpdmVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ09iamVjdGl2ZTtcclxuICAgICAgICAgICAgdmFyIGFjdE9iamVjdGl2ZUxpc3Q7XHJcbiAgICAgICAgICAgIHZhciBuZXdPYmplY3RpdmU7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMucGxheUFjdFNldCwgZnVuY3Rpb24oIHNpbmdsZUFjdCApIHtcclxuICAgICAgICAgICAgICAgIGFjdE9iamVjdGl2ZUxpc3QgPSB0aGlzLmdldFJhd09iamVjdGl2ZUxpc3Qoc2luZ2xlQWN0KTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCggYWN0T2JqZWN0aXZlTGlzdCwgZnVuY3Rpb24oIGVhY2hPYmplY3RpdmUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0aXZlID0gbmV3IFNjb3JtT2JqZWN0aXZlKHNpbmdsZUFjdC5pZCwgb2JqZWN0aXZlSW5kZXgsIGVhY2hPYmplY3RpdmUsIFNUQVRVU19OT1RfQVRURU1QVEVEKTtcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ09iamVjdGl2ZSA9IHRoaXMubG9hZE9iamVjdGl2ZShvYmplY3RpdmVJbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgZXhpc3RlZCwgb3RoZXJ3aXNlIHdlIHdvdWxkbid0IGhhdmUgYSBtYXRjaGluZyBpZCFcclxuICAgICAgICAgICAgICAgICAgICBpZiggZXhpc3RpbmdPYmplY3RpdmUuc3RhdHVzICYmIGV4aXN0aW5nT2JqZWN0aXZlLmlkID09PSBuZXdPYmplY3RpdmUuZ2V0SWQoKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0aXZlLnNldFN0YXR1cyhleGlzdGluZ09iamVjdGl2ZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZU9iamVjdGl2ZShuZXdPYmplY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3RpdmVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlU2V0LnB1c2gobmV3T2JqZWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYXZlU2Nvcm1PYmplY3RpdmVEYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gU2Nvcm0gb2JqZWN0aXZlcyBhcmUgbm90IHJlZ3VsYXJseSBzYXZlZC5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWRTY29ybVN1c3BlbmREYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgIHZhciBzY29ybURhdGEgPSB0aGlzLnNjb3JtLmdldFN1c3BlbmREYXRhKCkgfHwgXCJcIjtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgbG9nLndhcm4oc2Nvcm1EYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3JtRGF0YSA9IHNjb3JtRGF0YS5zcGxpdCh0aGlzLnNldHRpbmdzLnNjb3JtX3NlcGFyYXRvcl9jaGFyKTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5wbGF5QWN0U2V0LCBmdW5jdGlvbiggc2luZ2xlQWN0ICkge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlQWN0LnN1c3BlbmREYXRhID0gc2Nvcm1EYXRhW2luZGV4XSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYXZlU2Nvcm1TdXNwZW5kRGF0YTogZnVuY3Rpb24oIGFjdElkLCBzY29ybVN0cmluZyApIHtcclxuICAgICAgICAgICAgdmFyIHNjb3JtRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc2F2ZVN0cmluZztcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGxheUFjdFNldFthY3RJZF0uc3VzcGVuZERhdGEgPSBzY29ybVN0cmluZztcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5wbGF5QWN0U2V0LCBmdW5jdGlvbihzaW5nbGVBY3QpIHtcclxuICAgICAgICAgICAgICAgIHNjb3JtRGF0YS5wdXNoKHNpbmdsZUFjdC5zdXNwZW5kRGF0YSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgc2F2ZVN0cmluZyA9IHNjb3JtRGF0YS5qb2luKHRoaXMuc2V0dGluZ3Muc2Nvcm1fc2VwYXJhdG9yX2NoYXIpO1xyXG4gICAgICAgICAgICBsb2cud2FybihzYXZlU3RyaW5nKTtcclxuICAgICAgICAgICAgdGhpcy5zY29ybS5zZXRTdXNwZW5kRGF0YShzYXZlU3RyaW5nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFjdCBjb21wbGV0ZSBldmVudCBoYXMgYmVlbiBzZW50LCBnZW5lcmFsbHkgbWVhbmluZyBcImNvbXBsZXRlIHRoZSBvbmx5IG9iamVjdGl2ZSBmb3IgdGhpcyBhY3RcIi5cclxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb24gb2JqZWN0aXZlIGluIHRoZSBhY3QsIHRoaXMgZnVuY3Rpb24gb25seSBjaGVja3MgZm9yICdhbGwgY29tcGxldGUnLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW4gXCJBY3QgTm93XCIsIGJvdGggXCJvYmplY3RpdmVfY29tcGxldGVcIiBhbmQgXCJhY3RfY29tcGxldGVcIiB3b3VsZCBsZWFkIHRvIHRoaXMuIEZvciBub24tYWN0bm93LCBjdXJyZW50bHlcclxuICAgICAgICAgKiBvbmx5IFwib2JqZWN0aXZlX2NvbXBsZXRlXCIgd2lsbCBsZWFkIHRvIHRoaXMsIGJ1dCBvdGhlciBtb2RlbHMgbWF5IGFjdCBkaWZmZXJlbnRseS4gVGhpcyBkZXBlbmRzIG9uIGFcclxuICAgICAgICAgKiAgXCJjb21wbGV0ZVwiIGFjdC1zdGF0dXMgZXZlbnQuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdElkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaGFuZGxlQWN0Q29tcGxldGU6IGZ1bmN0aW9uKGFjdElkKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RPYmplY3RpdmVzID0gW107XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnBsYXlIYXNPYmplY3RpdmVzKCkgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RPYmplY3RpdmVzID0gIHRoaXMuZ2V0QWN0T2JqZWN0aXZlU3RhdHVzU2V0KGFjdElkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBvYmplY3RpdmUsIHNvIG1hcmsgaXQgY29tcGxldGUuXHJcbiAgICAgICAgICAgICAgICBpZiggYWN0T2JqZWN0aXZlcy5sZW5ndGggPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0T2JqZWN0aXZlc1swXS5zZXRTdGF0dXMoU1RBVFVTX0NPTVBMRVRFRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlT2JqZWN0aXZlKGFjdE9iamVjdGl2ZXNbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BsYXlDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gb2JqZWN0aXZlcyAtIHlvdSdyZSBkb25lIVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY29ybS5tYXJrQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hlY2tQbGF5Q29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYWxsQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMub2JqZWN0aXZlU2V0LCBmdW5jdGlvbihvYmplY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCBvYmplY3RpdmUuZ2V0U3RhdHVzKCkgIT09IFNUQVRVU19DT01QTEVURUQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIGlmKCBhbGxDb21wbGV0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nvcm0ubWFya0NvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWRPYmplY3RpdmU6IGZ1bmN0aW9uKCBvYmplY3RpdmVJbmRleCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nvcm0uZ2V0T2JqZWN0aXZlKG9iamVjdGl2ZUluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdmVPYmplY3RpdmU6IGZ1bmN0aW9uKCBvYmplY3RpdmUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nvcm0uc2V0T2JqZWN0aXZlKG9iamVjdGl2ZS5nZXRJbmRleCgpLCBvYmplY3RpdmUuZ2V0SWQoKSwgb2JqZWN0aXZlLmdldFN0YXR1cygpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjb3JtU2VydmljZTtcclxufSgpKTsiLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzA0LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgQm9vdFN0YXRlID0gcmVxdWlyZShcIi4vc3RhdGVzL2Jvb3QuanNcIiksXHJcblx0XHRQcmVsb2FkU3RhdGUgPSByZXF1aXJlKFwiLi9zdGF0ZXMvcHJlbG9hZC5qc1wiKSxcclxuXHRcdE1haW5TdGF0ZSA9IHJlcXVpcmUoXCIuL3N0YXRlcy9tYWluLmpzXCIpLFxyXG5cdFx0U2Nvcm0gPSByZXF1aXJlKFwiLi9zY29ybVwiKTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tRWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0dmFyIGNvbmZpZyA9IHtcclxuXHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0cmVuZGVyZXI6IFBoYXNlci5DQU5WQVMsIC8vIFNldCB0byBDYW52YXMgdG8gaGVscCBJRS5cclxuXHRcdFx0cGFyZW50OiBkb21FbGVtZW50LFxyXG5cdFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblx0XHRcdGFudGlhbGlhczogdHJ1ZSxcclxuXHRcdFx0Zm9yY2VTZXRUaW1lT3V0OiBmYWxzZSxcclxuXHRcdFx0YXNzZXRQYXRoOiBfZW52aXJvbm1lbnRTZXR0aW5ncy5hc3NldFBhdGgsIC8vIG5vdCBhIHN0YW5kYXJkIFBoYXNlciBwcm9wZXJ0eSAtIHVzZWQgdG8gcGFzcyBpbiByZWxhdGl2ZSBsb2FkaW5nIHBhdGhzIGZvciBkaWZmZXJlbnQgaG9zdCBlbnZpcm9ubWVudHMgKExNUywgQ01TLCBldGMuKS4gX2Vudmlyb25tZW50U2V0dGluZ3MuYXNzZXRQYXRoIGlzIGRlY2xhcmVkIGluIEhUTUwgZmlsZS5cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIHNldHRpbmdzID0ge1xyXG5cdFx0XHRwbGF5X2pzb25fa2V5OiBcInBsYXlEYXRhXCIsXHJcblx0XHRcdGxvYWRpbmdfaW1hZ2Vfa2V5OiBcInByZWxvYWRlckJhclwiLFxyXG5cdFx0XHRsb2FkaW5nX2ltYWdlX3VybDogY29uZmlnLmFzc2V0UGF0aCArIFwibWVkaWEvY3dsb2dvLnBuZ1wiLFxyXG5cdFx0XHRsb2FkaW5nX2JnX2NvbG9yOiBcIjB4MDA3NGM4XCIsXHJcblx0XHRcdGxvYWRpbmdfZm9udDoge1xyXG5cdFx0XHRcdGZvbnQ6IFwiQXJpYWwsIEhlbHZldGljYSwgU2Fuc1wiLFxyXG5cdFx0XHRcdGZvbnRTaXplOiAyNixcclxuXHRcdFx0XHRmaWxsOiBcIiNmZmZmZmZcIixcclxuXHRcdFx0fSxcclxuXHRcdFx0bG9hZGluZ190ZXh0OiBcIkxvYWRpbmcuLi5cIixcclxuXHRcdFx0cGxheV9qc29uX3VybDogY29uZmlnLmFzc2V0UGF0aCArIFwibWVkaWEvcGxheS5qc29uXCIsXHJcblx0XHRcdHRoZW1lX3ByZWZpeDogXCJ0aGVtZV9cIixcclxuXHRcdFx0ZGF0YV9wcmVmaXg6IFwiZGF0YV9cIixcclxuXHRcdFx0cHJlbG9hZF9zdGF0ZV9uYW1lOiBcInByZWxvYWRcIixcclxuXHRcdFx0bWFpbl9zdGF0ZV9uYW1lOiBcIm1haW5cIixcclxuXHRcdFx0Ym9vdF9zdGF0ZV9uYW1lOiBcImJvb3RcIixcclxuXHRcdFx0ZGVmYXVsdF9hY3RfbmFtZTogXCJkZWZhdWx0XCIsXHJcblx0XHRcdHNjb3JtX3NlcGFyYXRvcl9jaGFyOiBcIiRcIixcclxuXHRcdFx0bG9nZ2luZzogdHJ1ZSxcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGdhbWUgPSBuZXcgUGhhc2VyLkdhbWUoY29uZmlnKTtcclxuXHRcdGdhbWUuc2Nvcm0gPSBuZXcgU2Nvcm0oKTtcclxuXHRcdGdhbWUuc3RhdGUuYWRkKHNldHRpbmdzLmJvb3Rfc3RhdGVfbmFtZSwgbmV3IEJvb3RTdGF0ZShzZXR0aW5ncykpO1xyXG5cdFx0Z2FtZS5zdGF0ZS5hZGQoc2V0dGluZ3MucHJlbG9hZF9zdGF0ZV9uYW1lLCBuZXcgUHJlbG9hZFN0YXRlKHNldHRpbmdzKSk7XHJcblx0XHRnYW1lLnN0YXRlLmFkZChzZXR0aW5ncy5tYWluX3N0YXRlX25hbWUsIG5ldyBNYWluU3RhdGUoc2V0dGluZ3MpKTtcclxuXHRcdGdhbWUuc3RhdGUuc3RhcnQoc2V0dGluZ3MuYm9vdF9zdGF0ZV9uYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gZ2FtZTtcclxuXHR9O1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBhZGRzIGFuIGFjdG9yIHRvIGEgc2NlbmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIEFkZEFjdG9yQWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihhY3QpIHtcclxuICAgICAgICAgICAgaWYoICFhY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyBhbiBhY3QgdG8gd29yayBvbi5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYXJncywgZnVuY3Rpb24oIGVhY2hBcmcgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3QuYWN0Q29tbWFuZChcImFkZC1hY3RvclwiLCBlYWNoQXJnKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBZGRBY3RvckFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYWN0aW9uIHRoYXQgYWRkcyBhbiBhY3RvciB0byBhIHNjZW5lLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBDaGFuZ2VPYmplY3RpdmVBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hcmdzLCBmdW5jdGlvbiggZWFjaEFyZyApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5hY3RDb21tYW5kKFwib2JqZWN0aXZlXCIsIGVhY2hBcmcpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYW5nZU9iamVjdGl2ZUFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYWN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgc2NlbmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFNjZW5lQWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihhY3QpIHtcclxuICAgICAgICAgICAgaWYoICFhY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyBhbiBhY3QgdG8gd29yayBvbi5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Quc2hvd05ld1NjZW5lKHRoaXMuYXJnc1swXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTY2VuZUFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYWN0aW9uIHRoYXQgZG9lcyBhbiBhZGRpdGlvbmFsIG91dGNvbWUgY2hlY2sgYmFzZWQgb24gZ2l2ZW4gdmFyaWFibGUocyksIGNhbiBiZSB1c2VkIHRvIGZvcmNlIHRoZSBjaGVja1xyXG4gKiBvZiBvdXRjb21lcyBldmVuIHdoZW4gdGhlIHBsYXllciBoYXNuJ3QgZGlyZWN0bHkgYWN0ZWQgb24gaXQuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIENoZWNrT3V0Y29tZXNBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hcmdzLCBmdW5jdGlvbiggZWFjaEFyZyApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5jaGVja0N1cnJlbnRTY2VuZU91dGNvbWVzKGVhY2hBcmcpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoZWNrT3V0Y29tZXNBY3Rpb247XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDcvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBtb3N0IGJhc2ljIG9mIGFjdGlvbnMsIHJlY29yZCBhIHZhcmlhYmxlLlxyXG4gKiBUaGlzIGFjdGlvbiB0YWtlcyB0aHJlZSBhcmd1bWVudHMuXHJcbiAqIDEgLSBuYW1lIG9mIHZhcmlhYmxlfGNob2ljZXxjb21tYW5kXHJcbiAqIDIgLSB2YWx1ZSBvZiB2YXJpYWJsZXxjaG9pY2V8Y29tbWFuZFxyXG4gKiAzIC0gYm9vbGVhbiBmb3JjZSB2YWx1ZSwgb3B0aW9uYWwuXHJcbiAqXHJcbiAqIElmIHlvdSBzZXQgdGhlICdmb3JjZSB2YWx1ZScsIHRoZSB2YWx1ZSB3aWxsIGZpcnN0IGJlIHJlbW92ZWQgZnJvbSB0aGUgbW9kZWwgbWFudWFsbHkuIFRoaXMgd291bGQgYWxsb3cgeW91IHRvXHJcbiAqIHNldCBhIHZhbHVlIChhbmQgY2F1c2UgYW4gb3V0Y29tZSkgbXVsdGlwbGUgdGltZXMgaW4gYSByb3cuIFRoaXMgd291bGQgbm9ybWFsbHkgYmUgYmxvY2tlZCBiZWNhdXNlIHRoZSBtb2RlbFxyXG4gKiBpZ25vcmVzIHZhbHVlcyBiZWluZyBzZXQgcmVwZWF0ZWRseS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgVmFyaWFibGVBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbYWN0Lm1vZGVsLmdldFZhbHVlKHRoaXMuYXJnc1swXSldID0gYWN0Lm1vZGVsLmdldFZhbHVlKHRoaXMuYXJnc1sxXSk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmFyZ3NbM10gPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3QuY2xlYXJWYXJpYWJsZSh0aGlzLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdC5vbkdhbWVDaG9pY2VBY3Rpb24odGVtcCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZUFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYWN0aW9uIHRoYXQgYWRkcyBhbiBhY3RvciB0byBhIHNjZW5lLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBNYXJrQ29tcGxldGVBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hcmdzLCBmdW5jdGlvbiggZWFjaEFyZyApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5hY3RDb21tYW5kKFwiYWN0aXZpdHlfY29tcGxldGVcIiwgZWFjaEFyZyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTWFya0NvbXBsZXRlQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBQYXVsIEtuZWxsXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAxMi8yMC8yMDE4XHJcbiAqIENvcHlyaWdodCAyMDE4IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBhY3Rpb24gaXMgY3VzdG9taXplZCBmb3IgTWlzc2lvbi1IZWFsdGggYW5kIHVzZWRcclxuICogdG8gdXBkYXRlIFNDT1JNIGRhdGEgcHJpb3IgdG8gc3dpdGNoaW5nIHNjZW5lcy4gVGhpcyB3YXMgbmVlZGVkXHJcbiAqIGJlY2F1c2Ugc2V0dGluZyB0aGUgU0NPUk0gXCJjb21wbGV0ZWRcIiBmbGFnIChhdCB0aGUgZW5kIG9mIHRoZSBsZXNzb24pXHJcbiAqIG1heSB0YWtlIDEtMiBzZWNvbmRzLiAgQ29uc2VxdWVudGx5LCB3ZSBuZWVkIHRvIHNldCB0aGlzIGltbWVkaWF0ZWx5XHJcbiAqIHByaW9yIHRvIHN3aXRjaGluZyB0byB0aGUgbWlzc2lvbi1jb21wbGV0ZWQgc2NlbmUgQU5EIHdlIG5lZWQgdG8gc3RvcFxyXG4gKiBhdWRpbyBmaXJzdCB0byBhdm9pZCBpdCBiZWluZyBpbnRlcmZlcmVkIHdpdGggYnkgdGhlIHN5bmNocm9ub3VzIEhUVFAgcmVxdWVzdFxyXG4gKiB0aGF0IFNDT1JNIHVzZXMuIFJlZmVyIHRvIEdpdExhYiBJc3N1ZSAjNDI3LlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgVmFyaWFibGVBY3Rpb24gPSByZXF1aXJlKCcuLi9nYW1lLWNob2ljZS5qcycpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgTWhTY2VuZUFjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdTY2VuZU5hbWUgPSB0aGlzLmFyZ3NbMF07XHJcbiAgICAgICAgICAgIHZhciB2YXJzTWFwID0gdGhpcy5hcmdzWzFdIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgXy5mb3JPd24odmFyc01hcCwgZnVuY3Rpb24odmFsdWUsIHZhck5hbWUpIHtcclxuICAgICAgICAgICAgICAgIChuZXcgVmFyaWFibGVBY3Rpb24oW3Zhck5hbWUsIHZhbHVlXSkpLmV4ZWN1dGUoYWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBhY3QuYXVkaW9TZXJ2aWNlLnN0b3BTY2VuZSgpOyAvLyBTdG9wIGF1ZGlvIGJlZm9yZSBzZW5kaW5nIFNDT1JNIHVwZGF0ZXMgdG8gYXZvaWQgaW50ZXJydXB0ZWQgYXVkaW9cclxuXHJcbiAgICAgICAgICAgIGFjdC5ldmVudHMub25BY3RTdGF0dXMuZGlzcGF0Y2goXCJzYXZlXCIpO1xyXG5cclxuICAgICAgICAgICAgYWN0LnNob3dOZXdTY2VuZShuZXdTY2VuZU5hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTWhTY2VuZUFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYWN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgc2NlbmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFJlbW92ZUFjdG9yQWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihhY3QpIHtcclxuICAgICAgICAgICAgaWYoICFhY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyBhbiBhY3QgdG8gd29yayBvbi5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYXJncywgZnVuY3Rpb24oIGVhY2hBcmcgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3QuYWN0Q29tbWFuZChcInJlbW92ZS1hY3RvclwiLGFjdC5tb2RlbC5nZXRWYWx1ZShlYWNoQXJnKSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVtb3ZlQWN0b3JBY3Rpb247XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFBhdWwgS25lbGxcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEwLzE1LzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGFjdGlvbiBhZGRzIGEgdmFsdWUgdG8gYSBudW1lcmljIHZhcmlhYmxlLlxyXG4gKiBTaW5jZSBhbGwgdmFyaWFibGVzIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgaXQgd2lsbCBmaXJzdCBiZSBwYXJzZWQgaW50byBhIG51bWJlci5cclxuICogXHJcbiAqIFRoaXMgYWN0aW9uIHRha2VzIHRocmVlIGFyZ3VtZW50cy5cclxuICogMSAtIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGluY3JlbWVudFxyXG4gKiAyIC0gbnVtZXJpYyBhbW91bnQgb2YgdGhlIGluY3JlbWVudCAob3IgZGVjcmVtZW50LCBpZiBuZWdhdGl2ZSlcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgVmFyaWFibGVJbmNyZW1lbnRBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKGFjdC5tb2RlbC5nZXRWYWx1ZSgnJCcrdGhpcy5hcmdzWzBdKSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihudW1lcmljVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyB0aGUgdmFyaWFibGUgdG8gYmUgbnVtYmVyLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50ID0gTnVtYmVyKHRoaXMuYXJnc1sxXSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihpbmNyZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyB0aGUgaW5jcmVtZW50IHRvIGJlIG51bWJlci5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbnVtZXJpY1ZhbHVlICs9IGluY3JlbWVudDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbYWN0Lm1vZGVsLmdldFZhbHVlKHRoaXMuYXJnc1swXSldID0gbnVtZXJpY1ZhbHVlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBhY3Qub25HYW1lQ2hvaWNlQWN0aW9uKHRlbXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVmFyaWFibGVJbmNyZW1lbnRBY3Rpb247XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEFuIGFubm91bmNlciBidWJibGUuIFRoZSBhbm5vdW5jZXIgYm94IGlzIG9wdGlvbmFsLlxyXG4gKiBJdCB3aWxsIGRpc3BsYXkgdGV4dCBhbmQgb3B0aW9uYWxseSBwbGF5IGF1ZGlvLlxyXG4gKiBUaGlzIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgc3BlZWNoIGJ1YmJsZSwgb25seSBpdCBpc24ndCBsaXN0ZW5pbmcgZm9yIGV2ZW50cyB0byBjaGFuZ2UgaXRzIHRleHQuXHJcbiAqXHJcbiAqIHtcclxuICogICAgXCJuYW1lXCI6IFwiYW5ub3VuY2VyQm94XCIsXHJcbiAqICAgICBcInR5cGVcIjogXCJhbm5vdW5jZXJcIixcclxuICogICAgIFwibG9jYXRpb25cIjogWyAyLCA1IF0sIC8vIGxvY2F0aW9uIG9uIHNjcmVlbi5cclxuICogICAgIFwidGV4dFwiOiBcIldlbGNvbWUgdG8gTmV3YnJpZGdlIE1pZGRsZSBTY2hvb2wuXCIsIC8vIHRleHQgdG8gZGlzcGxheS5cclxuICogICAgIFwiYXVkaW9cIjogXCJuYXJfNnRoX2ludF8wMVwiLCAvLyBBdWRpbyB0byBwbGF5XHJcbiAqICAgICBcImFubm91bmNlckJveFwiOiB0cnVlIC8vIHNob3cgdGhlIGFubm91bmNlciBib3hcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfSxcclxuICpcclxuICogQFRPRE8gdXBkYXRlIHRoaXMgY2xhc3MgdG8gc2hvdyBhbnkgaWNvbiBhcyB0aGUgJ2Fubm91bmNlcicuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgQW5ub3VuY2VyQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIENvbnN0cnVjdG9yIGlzIGluIHBhcmVudC5cclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuZGF0YS50ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvID0gdGhpcy5kYXRhLmF1ZGlvO1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IHRoaXMuZGF0YS5rZXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRYID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRZID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmFubm91bmNlckJveCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbm5vdW5jZXJCb3goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRhdGEuaW52ZXJzZVNvdW5kRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3coKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcGVlY2goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRBbm5vdW5jZXJCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hbm5vdW5jZXJCb3ggPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbWFnZSggJ2Fubm91bmNlci1ib3gnLCAnYWN0b3JJbWFnZXMnKSApO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRYICs9IHRoaXMuYW5ub3VuY2VyQm94LndpZHRoIC0gMTA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgNSB0aGluZ3MgdG8gYSBncm91cDpcclxuICAgICAgICAgKiAxLiBBIHRvcCBcInNwcml0ZVwiIHdoaWNoIGlzIHRoZSB0b3Agb2YgdGhlIHRleHQgYnViYmxlLlxyXG4gICAgICAgICAqIDIuIFRleHQsIHJlcHJlc2VudGluZyB0aGUgdGV4dCBmb3IgdGhpcyBzcHJpdGUgYW5kIHdyYXBwaW5nIGl0cyBmb250LlxyXG4gICAgICAgICAqIDMuIEEgbWlkZGxlIFwidGlsZXNwcml0ZVwiIHdoaWNoIGlzIGEgcmVwZWF0aW5nIG1pZGRsZSBzcHJpdGUgbWFkZSB0byBtYXRjaCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxyXG4gICAgICAgICAqIDQuIEEgYm90dG9tIFwic3ByaXRlXCIgd2hpY2ggaXMgdGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBidWJibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkV2luZG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy50aGVtZS50ZXh0V2luZG93cyB8fCAhdGhpcy50aGVtZS50ZXh0V2luZG93cy5hbm5vdW5jZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQW5ub3VuY2VyIGFjdG9yIHJlcXVpcmVzIHRleHRXaW5kb3dzIHRoZW1lIGVudHJ5LCBhbmQgYW5ub3VuY2Ugc2VjdGlvbiBpbnNpZGUgaXQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC54ID0gdGhpcy5jdXJyZW50WDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueSA9IHRoaXMuY3VycmVudFk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWFyZ2luWCA9IDgsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5ZID0gMjA7XHJcbiAgICAgICAgICAgIHZhciB0b3BXaW5kb3cgPSB3aW5kb3dHcm91cC5jcmVhdGUoMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRXaW5kb3dzLmFubm91bmNlLnRvcCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IHRoaXMuZ2V0Rm9udCgnYnViYmxlVGV4dCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJTdHlsZSA9IHRoaXMuZ2V0Rm9udCgncmVwbGF5QXVkaW8nKTtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcFdpZHRoID0gdG9wV2luZG93LndpZHRoICogLjg1O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblggKyA1MCwgbWFyZ2luWSwgdGhpcy50ZXh0LCB0aGlzLmZTdHlsZSk7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLmFkZCh0aGlzLmN1cnJlbnRUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVIZWlnaHQgPSB0aGlzLmN1cnJlbnRUZXh0LmhlaWdodCAtICh0b3BXaW5kb3cuaGVpZ2h0IC0gbWFyZ2luWSk7XHJcbiAgICAgICAgICAgIGlmKCBtaWRkbGVIZWlnaHQgPCA1ICkge1xyXG4gICAgICAgICAgICAgICAgbWlkZGxlSGVpZ2h0ID0gNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlV2luZG93ID0gbmV3IFBoYXNlci5UaWxlU3ByaXRlKHRoaXMuZ2FtZSwgMCwgdG9wV2luZG93LmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHRvcFdpbmRvdy53aWR0aCwgbWlkZGxlSGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3MuYW5ub3VuY2UubWlkZGxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKG1pZGRsZVdpbmRvdyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IHRoaXMuY3VycmVudFRleHQueSArIHRoaXMuY3VycmVudFRleHQuaGVpZ2h0ICsgbWFyZ2luWTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbVdpbmRvdyA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCB0b3BXaW5kb3cuaGVpZ2h0ICsgbWlkZGxlV2luZG93LmhlaWdodCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRXaW5kb3dzLmFubm91bmNlLmJvdHRvbSk7XHJcblxyXG4gICAgICAgICAgICAvLyA1LiBBZGQgZXZlbnRpbmcuXHJcbiAgICAgICAgICAgIHRoaXMud2luZG93cyA9IHtcclxuICAgICAgICAgICAgICAgIHRvcDogdG9wV2luZG93LFxyXG4gICAgICAgICAgICAgICAgbWlkZGxlOiBtaWRkbGVXaW5kb3csXHJcbiAgICAgICAgICAgICAgICBib3R0b206IGJvdHRvbVdpbmRvd1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKHRoaXMud2luZG93cywgZnVuY3Rpb24gKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBidWJibGUuZXZlbnRzLm9uSW5wdXRPdmVyLmFkZCh0aGlzLm9uTW91c2VJbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBidWJibGUuZXZlbnRzLm9uSW5wdXRPdXQuYWRkKHRoaXMub25Nb3VzZU91dCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBidWJibGUuZXZlbnRzLm9uSW5wdXRVcC5hZGQodGhpcy5vblBvaW50ZXJVcCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgKGJvdHRvbVdpbmRvdy54ICsgYm90dG9tV2luZG93LndpZHRoIC0gNDApIC8gMixcclxuICAgICAgICAgICAgICAgICh0b3BXaW5kb3cuaGVpZ2h0ICsgYm90dG9tV2luZG93LmhlaWdodCArIG1pZGRsZVdpbmRvdy5oZWlnaHQpIC8gMiwgXCJSZXBsYXkgQXVkaW9cIiwgdGhpcy5yU3R5bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKHRoaXMucmVwbGF5VGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0LmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cCA9IHdpbmRvd0dyb3VwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Nb3VzZUluOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLnRoZW1lLnRpbnRzLmJ1YmJsZVRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuc2V0U3R5bGUodGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLmdldEZvbnQoJ2J1YmJsZVRleHQnKS5maWxsO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFN0eWxlKHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lU3BlZWNoKCB7dGV4dDogdGhpcy50ZXh0LCBhdWRpbzogdGhpcy5hdWRpbywga2V5OiB0aGlzLmtleX0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0U3BlZWNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuc2V0VGV4dCh0aGlzLnRleHQpO1xyXG4gICAgICAgICAgICAvLyBtYXkgbmVlZCB0byBhZGp1c3QgaGVpZ2h0cy9ldGMuXHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lU3BlZWNoKCB7dGV4dDogdGhpcy50ZXh0LCBhdWRpbzogdGhpcy5hdWRpbywga2V5OiB0aGlzLmtleX0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLndpbmRvd3MgKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy53aW5kb3dzLCBmdW5jdGlvbiAoYnViYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53aW5kb3dzID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLndpbmRvd0dyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmFubm91bmNlckJveCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VyQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VyQm94ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFubm91bmNlckFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBjaG9pY2UgYWN0b3IsIHdoaWNoIHdpbGwgc2hvdyB0aGUgcGxheWVyIGEgbXVsdGlwbGUgY2hvaWNlIHF1ZXN0aW9uLiBJdCB3aWxsIGFsc29cclxuICogcGxheSBhbnkgYXVkaW8vdGV4dCBhc3NvY2lhdGVkIHdpdGggYXNraW5nIHF1ZXN0aW9uLlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJjaG9pY2VzX21hbmR5XzFcIiwgLy8gdW5pcXVlIG5hbWUgZm9yIHRoaXMgYWN0b3IuXHJcbiAqICAgICBcInR5cGVcIjogXCJjaG9pY2VcIiwgLy8gcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwic3RhcnRDaG9pY2VcIjogXCJkcDFcIiwgLy8gd2hpY2ggY2hvaWNlIHRvIHN0YXJ0IHdpdGggZnJvbSB0aGUgY2hvaWNlTWFwIHNldC5cclxuICogICAgIFwiY2hvaWNlTWFwXCI6IHtcclxuICogICAgICAgICBcImRwMVwiOiB7IC8vIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhpcyBjaG9pY2UsIHVzZWQgd2hlbiBsaW5raW5nIGNob2ljZXNcclxuICogICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSeKAmW0gTWFuZHkuIENsaWNrIG9uZSBvZiB0aGUgcmVzcG9uc2UgYnViYmxlcyBiZWxvdyB0byByZXNwb25kIHRvIG1lLlwiLCAvLyBxdWVzdGlvbi4gSXQgY2FuIGJlIGJsYW5rLlxyXG4gKiAgICAgICAgICAgICBcImF1ZGlvXCI6IFwiNnRoX2ludF8wMVwiLCAvLyBhdWRpbywgaXQgaXMgb3B0aW9uYWwuXHJcbiAqICAgICAgICAgICAgIFwia2V5XCI6IFwibWFuZHlcIiwgLy8gYSBrZXkgaW50byBhIHNldCBvZiBhdWRpby4gb3B0aW9uYWwuXHJcbiAqICAgICAgICAgICAgIFwiZGVjaXNpb25Qb2ludFwiOiB0cnVlLCAvLyBtYXJrIHRoaXMgb3B0aW9uIGZvciBzYXZpbmcuXHJcbiAqICAgICAgICAgICAgIFwiY2hvaWNlc1wiOiBbXHJcbiAqICAgICAgICAgICAgICAgICB7XHJcbiAqICAgICAgICAgICAgICAgICAgICBcImxpbmtcIjogXCJkcDJcIiwgIC8vIHdoaWNoIHF1ZXN0aW9uL2Nob2ljZXMgdG8gc2hvdyBuZXh0LlxyXG4gKiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiT25lIG9mIHRoZXNlP1wiIC8vIGRpc3BsYXllZCB0ZXh0IG9mIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgXCJkZWNpc2lvblwiOiBcIlBSXCJldmVudCB8IFwiQUxcImxvdyB8IFwiRU5cImNvdXJhZ2UgfCBcIlBBXCJydGljcGF0ZSB8IFwiRElcInNjb3VyYWdlICAoUmVxdWlyZWQgaWYgZGVjaXNpb25Qb2ludCA9PT0gdHJ1ZSApXHJcbiAqICAgICAgICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgXCJsaW5rXCI6IFwiZHAyXCIsXHJcbiAqICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJTbywgdGhpcyBpcyBob3cgd2UgdGFsaz9cIipcclxuICogICAgICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICAgICB7XHJcbiAqICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJZb3UgbWVhbiB0aGVzZSBidWJibGVzP1wiLCAvLyB0ZXh0IHRvIHNob3cgZm9yIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgXCJ2YXJpYWJsZVwiOiBcImNob2ljZV8yXCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIHRoaXMgY2hvaWNlIGlzIHNlbGVjdGVkLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcInppbmtfbWFuZHlcIiAgIC8vIHZhbHVlIHRvIHNldCB2YXJpYWJsZSB0by5cclxuICogICAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICAgICAgXVxyXG4gKiAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgLi4uIC8vIGFzIG1hbnkgY2hvaWNlcyBhcyB5b3Ugd2FudC5cclxuICogICAgICAgICAgfVxyXG4gKiAgICAgICAgIH0sXHJcbiAqICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICpcclxuICogIEZvciBhIGRlY2lzaW9uIHBvaW50LCB5b3UgY2FuIHN0bGwgZG8gYSB2YXJpYWJsZS92YWx1ZSBhbmQgbGluay5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgTUFYX0NIT0lDRVMgPSA1LFxyXG4gICAgICAgIGNob2ljZU1hcCA9IHsgXCJQUlwiIDogMCwgXCJESVwiIDogMSwgXCJBTFwiOiAyLCBcIkVOXCI6IDMsIFwiUEFcIjogNH0sXHJcbiAgICAgICAgbWFyZ2luWSA9IDYsXHJcbiAgICAgICAgbWFyZ2luRm9udCA9IDI1O1xyXG5cclxuICAgIHZhciBDaG9pY2VBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJjaG9pY2VNYXBcIiwgXCJzdGFydENob2ljZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5jaG9pY2VNYXAgPSB0aGlzLmRhdGEuY2hvaWNlTWFwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaG9pY2UgPSB0aGlzLmNob2ljZU1hcFt0aGlzLmRhdGEuc3RhcnRDaG9pY2VdO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZSB0aGUgbnVtYmVyIG9mIHF1ZXN0aW9ucyBhbmQgYnVpbGQgdGhlIGNvcnJlY3QgY2hvaWNlIGxpc3QuXHJcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBkZWNpc2lvbiBwb2ludCBjaG9pY2UsIHVzZSB0aGUgcHJldmlvdXMgY2hvaWNlcyBwZXIgdGhlIGZvcm11bGEuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDaG9pY2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb25ZID0gNTAsXHJcbiAgICAgICAgICAgICAgICBidXR0b25DbnQsXHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uLFxyXG4gICAgICAgICAgICAgICAgY3VyclRleHQsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvblggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IHRoaXMuZ2V0Rm9udCgnYnViYmxlVGV4dCcpO1xyXG5cclxuICAgICAgICAgICAgZm9yKCBidXR0b25DbnQgPSBNQVhfQ0hPSUNFUzsgYnV0dG9uQ250ID4gMDsgYnV0dG9uQ250LS0gKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLm9uQ2hvaWNlLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZXNwb25zZS1iZy1vdmVyLnBuZycsICdyZXNwb25zZS1iZy11cC5wbmcnLCAncmVzcG9uc2UtYmctZG93bi5wbmcnLCAncmVzcG9uc2UtYmctdXAucG5nJyk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnRoZW1lLmJ1dHRvbnMucmVzcG9uc2VzLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9ucy5yZXNwb25zZXMub3V0LCB0aGlzLnRoZW1lLmJ1dHRvbnMucmVzcG9uc2VzLmRvd24sIHRoaXMudGhlbWUuYnV0dG9ucy5yZXNwb25zZXMudXBcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uWCA9ICh0aGlzLmdhbWUud29ybGQud2lkdGggLSBjdXJyQnV0dG9uLndpZHRoICkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb25ZID0gdGhpcy5nYW1lLndvcmxkLmhlaWdodCAtICggKGN1cnJCdXR0b24uaGVpZ2h0ICsgbWFyZ2luWSkgKiBidXR0b25DbnQpO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi54ID0gbG9jYXRpb25YO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi55ID0gbG9jYXRpb25ZO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgbWFyZ2luRm9udCwgY3VyckJ1dHRvbi5oZWlnaHQgLyAyLCBcIlwiLCB0aGlzLmZTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uLmFkZENoaWxkKGN1cnJUZXh0KTtcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LmFuY2hvci5zZXRUbygwLCAwLjUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5wdXNoKGN1cnJCdXR0b24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0LnB1c2goY3VyclRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3B1bGF0ZUNob2ljZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5jdXJyZW50Q2hvaWNlLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uSGlkZUNvdW50ID0gTUFYX0NIT0lDRVMgLSBvcHRpb25zLmNob2ljZXMubGVuZ3RoLC8vIGhvdyBtYW55IGNob2ljZXMgdG8gaGlkZS5cclxuICAgICAgICAgICAgICAgIGJ1dHRvbkNudCxcclxuICAgICAgICAgICAgICAgIGFuc3dlcixcclxuICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnMgPSBbIHRydWUsIHRydWUsIHRydWUsIHRydWUsIHRydWVdLFxyXG4gICAgICAgICAgICAgICAgZHBDaG9pY2VzID0gW10sXHJcbiAgICAgICAgICAgICAgICBjaG9zZW5JbmRleCxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzUGxheUhpZGRlbiA9IC0xO1xyXG5cclxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZGVjaXNpb25Qb2ludCA9PT0gdHJ1ZSB8fCBvcHRpb25zLmRlY2lzaW9uUG9pbnQgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRwSW5kZXggPSB0aGlzLmdldERlY2lzaW9uSW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiU2hvd2luZyBkZWNpc2lvbiBwb2ludDogXCIgKyB0aGlzLmRwSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCB0d28gcXVlc3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZSwgYW5kIHdlJ2xsIG9ubHkgaGlkZSBvbmUuLi5cclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmRwSW5kZXggPT09IDAgfHwgdGhpcy5kcEluZGV4ID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuc3dlciA9IHRoaXMuZ2V0UHJldmlvdXNQbGF5QW5zd2VyKCB0aGlzLmRwSW5kZXggKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiggYW5zd2VyICYmIGFuc3dlciAhPT0gXCJYWFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkhpZGluZyBhbnN3ZXIgXCIgKyBhbnN3ZXIgKyBcIiBmcm9tIHByZXZpb3VzIHBsYXl0aHJvdWdoLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNQbGF5SGlkZGVuID0gY2hvaWNlTWFwW2Fuc3dlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHF1ZXN0aW9ucyBhZnRlciB0aGF0LCBqdXN0IHVzZSB0aGUgcHJldmlvdXMgYW5zd2VyLlxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuZHBJbmRleCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyID0gdGhpcy5nZXRQcmV2aW91c0Fuc3dlciggdGhpcy5kcEluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJnb3QgcHJldmlvdXMgYW5zd2VyIG9mIFwiICsgYW5zd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBjaG9zZW5JbmRleCA9IGNob2ljZU1hcFthbnN3ZXJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbmRleCBpcyB0aGUgYmVnaW5uaW5nIG9yIGVuZCwgZ28gdXAvZG93biAyLCBvdGhlcndpc2UsIGdvIGJvdGggc2lkZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGNob3NlbkluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnNbM10gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1s0XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggY2hvc2VuSW5kZXggPT09IDQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnNbMF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1sxXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnMgPSBbIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnNbY2hvc2VuSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1tjaG9zZW5JbmRleCsxXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnNbY2hvc2VuSW5kZXgtMV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNpbmNlIHdlIG1heSBoYXZlIG92ZXJyaWRlbiB0aGUgaGlkZSB3aXRoIGEgdHJ1ZSwgaGlkZSBBRlRFUiBwYXJzaW5nIHByZXZpb3VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiggcHJldmlvdXNQbGF5SGlkZGVuICE9PSAtMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG93UXVlc3Rpb25zW3ByZXZpb3VzUGxheUhpZGRlbl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmNob2ljZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIHNob3dRdWVzdGlvbnNbaW5kZXhdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcENob2ljZXMucHVzaCggb3B0aW9ucy5jaG9pY2VzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVkbyB0aGUgb2Zmc2V0LCBub3cgdGhhdCBjaG9pY2VzIGFyZSBiZWluZyBoaWRkZW4uXHJcbiAgICAgICAgICAgICAgICBidXR0b25IaWRlQ291bnQgPSBNQVhfQ0hPSUNFUyAtIGRwQ2hvaWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcImRldGVybWluZWQgYnV0dG9uIG9mZnNldCBvZiBcIiArIGJ1dHRvbkhpZGVDb3VudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmNob2ljZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHBDaG9pY2VzLnB1c2goIG9wdGlvbnMuY2hvaWNlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYWQgYnV0dG9uIHVwIHRvIHRoZSBjb3VudC5cclxuICAgICAgICAgICAgZm9yKCBidXR0b25DbnQgPSAwOyBidXR0b25DbnQgPCBidXR0b25IaWRlQ291bnQ7IGJ1dHRvbkNudCsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYnV0dG9uc1tidXR0b25DbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2J1dHRvbkNudF0udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tidXR0b25DbnRdLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJCYWQgYnV0dG9uIGNvdW50OiBcIiArIGJ1dHRvbkNudCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFrZSBhIGxpc3Qgb2YgdGhlIGluZGV4ZXMsIGFuZCB0aGVuIHJhbmRvbWl6ZSB0aGF0IGxpc3QuXHJcbiAgICAgICAgICAgICAqIFRoaXMgaXMgcmFuZG9taXplIHRoZSBvcmRlciB0aGUgYW5zd2VycyBhcmUgcHJlc2VudGVkIHRvIHRoZSB1c2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIHJhbmRvbWl6ZWRJbmRleCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBkcENob2ljZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICByYW5kb21pemVkSW5kZXgucHVzaCggaW5kZXggKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQaGFzZXIuQXJyYXlVdGlscy5zaHVmZmxlKHJhbmRvbWl6ZWRJbmRleCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmFuZG9tS2V5O1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBkcENob2ljZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICByYW5kb21LZXkgPSByYW5kb21pemVkSW5kZXhbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0W2luZGV4ICsgYnV0dG9uSGlkZUNvdW50XS5zZXRUZXh0KGRwQ2hvaWNlc1tyYW5kb21LZXldLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2luZGV4ICsgYnV0dG9uSGlkZUNvdW50XS5jdXJyZW50T3B0aW9uID0gZHBDaG9pY2VzW3JhbmRvbUtleV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbaW5kZXggKyBidXR0b25IaWRlQ291bnRdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2luZGV4ICsgYnV0dG9uSGlkZUNvdW50XS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggb3B0aW9ucy50ZXh0IHx8IG9wdGlvbnMuYXVkaW8gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBvcHRpb25zLnRleHQsIFwiYXVkaW9cIjogb3B0aW9ucy5hdWRpbywgXCJrZXlcIjogb3B0aW9ucy5rZXl9O1xyXG4gICAgICAgICAgICAgICAgLy9sb2cud2FybihcIkNob2ljZSBhY3RvciBzZW5kaW5nIGdhbWUgc3BlZWNoXCIpO1xyXG4gICAgICAgICAgICAgICAgLy9sb2cud2FybihldmVudERhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIGV2ZW50RGF0YSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wO1xyXG4gICAgICAgICAgICB3aGlsZSggdGhpcy50ZXh0Lmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gdGhpcy50ZXh0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKCB0aGlzLmJ1dHRvbnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSB0aGlzLmJ1dHRvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHRlbXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNob2ljZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy9sb2cud2FybihcIkNob2ljZSBtYWRlLCBwb3B1cGxhdGluZyBuZXcgY2hvaWNlXCIpO1xyXG4gICAgICAgICAgICAvL2xvZy53YXJuKF8uY2xvbmVEZWVwKGRhdGEuY3VycmVudE9wdGlvbikpO1xyXG4gICAgICAgICAgICB2YXIgY2hvaWNlID0gZGF0YS5jdXJyZW50T3B0aW9uO1xyXG4gICAgICAgICAgICBpZiggY2hvaWNlLnZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyU2V0W2Nob2ljZS52YXJpYWJsZV0gPSBjaG9pY2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggY2hvaWNlLmxpbmsgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDaG9pY2UgPSB0aGlzLmNob2ljZU1hcFtjaG9pY2UubGlua107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlQ2hvaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpZ3VyZSBvdXQgd2hpY2ggZGVjaXNpb24gdGhlIHBsYXllciBpcyBtYWtpbmcsIGJ5IGFzc3VtaW5nIHRoZXkgbWFrZSB0aGVtIGluIG9yZGVyLlxyXG4gICAgICAgICAqIFNvIGZpbmQgdGhlIGZpcnN0IGluZGV4IHRoYXQgaXMgWFguXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggb2YgbmV4dCBkZWNpc2lvbiBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXREZWNpc2lvbkluZGV4OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGRlY2lzaW9uU2V0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRkZWNpc2lvbnNDdXJyZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgZHBJbmRleDtcclxuXHJcbiAgICAgICAgICAgIGZvciggZHBJbmRleCA9IDA7IGRwSW5kZXggPCBkZWNpc2lvblNldC5sZW5ndGg7IGRwSW5kZXgrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmKCBkZWNpc2lvblNldFtkcEluZGV4XSA9PT0gXCJYWFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvciBhIGdpdmVuIGRlY2lzaW9uIGluZGV4LCBmaW5kIHRoZSBhbnN3ZXIgZnJvbSB0aGUgcHJldmlvdXMgcGxheSB0aHJvdWdoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFByZXZpb3VzUGxheUFuc3dlcjogZnVuY3Rpb24oZGVjaXNpb25JbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRkZWNpc2lvbnNQcmV2aW91c1wiKVtkZWNpc2lvbkluZGV4XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYW5zd2VyIHRvIHRoZSBwcmV2aW91cyBkZWNpc2lvbiBmcm9tIHRoaXMgcGxheSB0aHJvdWdoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFByZXZpb3VzQW5zd2VyOiBmdW5jdGlvbiggZGVjaXNpb25JbmRleCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkZGVjaXNpb25zQ3VycmVudFwiKVtkZWNpc2lvbkluZGV4LTFdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hvaWNlQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFphY2sgQmllcm5hdFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMjMvMjAxOFxyXG4gKiBDb3B5cmlnaHQgMjAxOCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogXHJcbiAqICBBIGNob29zZXIgYWN0b3Igd2hpY2ggcmFuZG9tbHkgdG9nZ2xlcyBhIGhpLWxpdGVkIHNlbGVjdGlvbiB0aHJvdWdoIGEgc3BlY2lmaWVkIG51bWJlciBvZiBjaGFuZ2VzIGJlZm9yZVxyXG4gKiAgdWx0aW1hdGVseSBlbmRpbmcgb24gYSBzZWxlY3Rpb24gd2hpY2ggd2lsbCBlaXRoZXIgYmUgKG5vdCByaWdnZWQpIGFsd2F5cyByYW5kb20gb3IgKHJpZ2dlZCkgdW5pcXVlIGZpcnN0IGFuZCB0aGVuIHJhbmRvbS5cclxuICogIFRoZSBcInRvZ2dsaW5nXCIgYWN0aW9uIHdpbGwgaW5jcmVhc2UgaW4gaW50ZXJ2YWwgdW50aWwgc3RvcHBpbmcsIHRoYXQgaXMsIHRoZSBjaG9vc2VyIGRlY2VsZXJhdGVzIHVudGlsIGl0IHN0b3BzLCBzb21ld2hhdCBcclxuICogIGxpa2UgYSByb3VsZXR0ZSB3aGVlbC5cclxuICogXHJcbiAqIENyZWF0aW5nIGEgQ2hvb3NlciBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgIFwibmFtZVwiOiBcImNob29zZXIxXCIsICAgICAgICAgICAgIC8vIEEgdW5pcXVlIG5hbWUgZm9yIHRoZSBhY3RvclxyXG4gKiAgICAgIFwidHlwZVwiOiBcImNob29zZXJcIiwgICAgICAgICAgICAgIC8vIFJlcXVpcmVkIHR5cGVcclxuICogICAgICBcInN0YXJ0QnV0dG9uXCI6IHsgICAgICAgICAgICAgICAgLy8gVGhlIGltYWdlIHdoaWNoIHNob3VsZCB0cmlnZ2VyIHRoZSBjaG9vc2luZyBzZXF1ZW5jZSwgYW5kIHdoZXJlIHRvIHB1dCBpdFxyXG4gKiAgICAgICAgICBcImltYWdlXCI6IFwiY2hvb3NlX2J1dHRvblwiLFxyXG4gKiAgICAgICAgICBcImxvY2F0aW9uXCI6IFsgMzAwLCAyMDAgXVxyXG4gKiAgICAgIH0sXHJcbiAqICAgICAgXCJpbWFnZXNcIjogXCJjaG9vc2VyXzFcIiwgICAgICAgICAgLy8gUmVmZXJzIHRvIHRoZW1lLmltYWdlcy5jaG9vc2VySW1hZ2VzLmNob29zZXJfMSB3aGljaCBpcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyBcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiYmFzZVwiOiBcImltYWdlMS5wbmdcIiwgXCJoaVwiOiBcImltYWdlMV9oaS5wbmdcIiAgfVxyXG4gKiAgICAgIFwibG9jYXRpb25cIjogWyAxMDAsIDEwMCBdLCAgICAgICAvLyBXaGVyZSB0aGUgZmlyc3QgaW1hZ2UgaXMgcG9zaXRpb25lZFxyXG4gKiAgICAgIFwiYXVkaW9cIjogXCJ0aWNrX3NvdW5kXCIsICAgICAgICAgIC8vIEFuIG9wdGlvbmFsIHNvdW5kIHRvIHBsYXkgZm9yIGVhY2ggY2hhbmdlXHJcbiAqICAgICAgXCJudW1DaGFuZ2VzXCI6IDI0LCAgICAgICAgICAgICAgIC8vIEhvdyBtYW55IGRpZmZlcmVudCBldmVudHMgYXJlIGVtaXRlZCBiZWZvcmUgcmVhY2hpbmcgdGhlIHVsdGltYXRlIHNlbGVjdGlvbi4gSWYgdGhpcyBpcyB0b28gbXVjaCBpdCBjb3VsZCBjYXVzZSBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICogICAgICBcInJpZ2dlZFwiOiB0cnVlLCAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwsIGlmIHRoaXMgaXMgdHJ1ZSB0aGUgY2hvb3NlciB3aWxsIHNlbGVjdCBlYWNoIG9wdGlvbiBvbmNlIHVudGlsIGVhY2ggaXMgdXNlZCwgdGhlbiBiZWdpbiByYW5kb21seSBzZWxlY3RpbmcgdGhpbmdzLlxyXG4gKiAgICAgIFwidmFyaWFibGVcIjogXCJjaG9vc2VyX3ZhbHVlXCIsICAgIC8vIFdoZW4gYWN0b3IgaXMgYWRkZWQsIHRoZSB2YXJpYWJsZSAnY2hvb3Nlcl92YWx1ZScgd2lsbCBiZSBzZXQgdG8gYSBudW1iZXIgYmV0d2VlbiAwIGFuZCBudW1PcHRpb25zIC0gMSAuXHJcbiAqICAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZDsgaXQgaXMgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBDaG9vc2VyQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwidmFyaWFibGVcIiwgXCJudW1DaGFuZ2VzXCIsIFwiaW1hZ2VzXCIsIFwibG9jYXRpb25cIiwgXCJzdGFydEJ1dHRvblwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByYW5kb21JbnRGcm9tSW50ZXJ2YWw6IGZ1bmN0aW9uKG1pbixtYXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKCBtYXggLSBtaW4pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMgPSB0aGlzLmRhdGEucmlnZ2VkID8gXy5zaHVmZmxlKF8ucmFuZ2UoMCwgdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXS5sZW5ndGgpKSA6IFtdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmNob2ljZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmhpX2Nob2ljZSA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXNbdGhpcy5kYXRhLmltYWdlc10ubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHhfcG9zID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgKGkgJSAyKSAqIHRoaXMuZ2FtZS5jYWNoZS5nZXRGcmFtZUJ5TmFtZSh0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXNbdGhpcy5kYXRhLmltYWdlc11baV0uYmFzZSkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeV9wb3MgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB5X3BvcyArPSB0aGlzLmdhbWUuY2FjaGUuZ2V0RnJhbWVCeU5hbWUodGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLmltYWdlcy5jaG9vc2VySW1hZ2VzW3RoaXMuZGF0YS5pbWFnZXNdW2ldLmJhc2UpLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hvaWNlLnB1c2godGhpcy5nYW1lLmFkZC5zcHJpdGUoIHhfcG9zLCB5X3BvcyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMuZ2V0SW1hZ2UoIHRoaXMudGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXNbdGhpcy5kYXRhLmltYWdlc11baV0uYmFzZSwgbnVsbCkpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlfY2hvaWNlLnB1c2godGhpcy5nYW1lLmFkZC5zcHJpdGUoIHhfcG9zLCB5X3BvcyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMuZ2V0SW1hZ2UoIHRoaXMudGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXNbdGhpcy5kYXRhLmltYWdlc11baV0uaGksIG51bGwpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpX2Nob2ljZVtpXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLnN0YXJ0QnV0dG9uLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEuc3RhcnRCdXR0b24ubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25DbGljaywgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3RhcnRCdXR0b24uaW1hZ2VdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3RhcnRCdXR0b24uaW1hZ2VdLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3RhcnRCdXR0b24uaW1hZ2VdLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3RhcnRCdXR0b24uaW1hZ2VdLnVwKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaG9pY2VJdGVyYXRvcjogZnVuY3Rpb24gKGNob2ljZXMsIGNiKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDEwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNob2ljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSBjaG9pY2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWUudGltZS5ldmVudHMuYWRkKHN0YXJ0LCB0aGlzLnRvZ2dsZVNlbGVjdGlvbiwgdGhpcywgY2hvaWNlc1tpIC0gMV0sIGNob2ljZXNbaV0sIGNiLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWUudGltZS5ldmVudHMuYWRkKHN0YXJ0LCB0aGlzLnRvZ2dsZVNlbGVjdGlvbiwgdGhpcywgY2hvaWNlc1tpIC0gMV0sIGNob2ljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IDEyICogaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9nZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiAobGFzdCwgbmV4dCwgZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLmRhdGEuYXVkaW8sIFwicHJpb3JpdHlcIjogXCJzdG9wQWxsXCIgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGlfY2hvaWNlW2xhc3RdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oaV9jaG9pY2VbbmV4dF0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1PcHRpb25zID0gdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXS5sZW5ndGhcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaG9vc2luZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gMTAwO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmlzQ2hvb3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9wdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaV9jaG9pY2VbaV0udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByYW5kb21JbnQgPSB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMubGVuZ3RoID8gdGhpcy5yaWdnZWRTcGluVmFsdWVzLnBvcCgpIDogdGhpcy5yYW5kb21JbnRGcm9tSW50ZXJ2YWwoMSwgbnVtT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBjaG9pY2VzID0gW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51bU9wdGlvbnMpXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5kYXRhLm51bUNoYW5nZXMgLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaG9pY2UgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBudW1PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjaG9pY2UgPT09IGNob2ljZXNbaSAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaG9pY2VzLnB1c2goY2hvaWNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAocmFuZG9tSW50ID09PSBjaG9pY2VzW2Nob2ljZXMubGVuZ3RoIC0xXSkge1xyXG4gICAgICAgICAgICAgICAgY2hvaWNlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51bU9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hvaWNlcy5wdXNoKHJhbmRvbUludCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNob2ljZUl0ZXJhdG9yKGNob2ljZXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0Nob29zaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gcmFuZG9tSW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyb3cpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3cuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hvb3NlckFjdG9yO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBwaG9uZSBidXR0b24gYWN0b3IuIFRoaXMgYWN0b3IgaXMgdXNlZCBmb3Igb3BlbmluZyB0aGUgcGhvbmUgYW5kIHNob3dpbmcgcGhvbmUgYWxlcnRzLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHBob25lIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicGhvbmUxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInBob25lLWJ1dHRvblwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VzXCI6IFwicGhvbmVcIiwgLy8gd2hlcmUgaW4gdGhlIHRoZW1lIHRvIGZpbmQgdGhlIGltYWdlcy5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICogIEhhbmRsZXMgc3BlY2lhbCB2YXJpYWJsZXM6XHJcbiAqICBwaG9uZV9hbGVydCA6IHR5cGUgLy8gc2hvdyBhbiBhbGVydCwgb2YgdGhlIHR5cGUgZ2l2ZW4uXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFBob25lQnV0dG9uQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBbGVydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFsZXJ0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkdhbWVDaG9pY2UoIHsgJ3Bob25lX2FsZXJ0JzogdGhpcy5kYXRhLmFsZXJ0IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25BbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgdExvYyA9IHRoaXMuZGF0YS5pbWFnZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdICsgMzYsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lW3RMb2NdLmJ1dHRvbi5vdmVyLCB0aGlzLnRoZW1lW3RMb2NdLmJ1dHRvbi5vdXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lW3RMb2NdLmJ1dHRvbi5kb3duLCB0aGlzLnRoZW1lW3RMb2NdLmJ1dHRvbi51cCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yQWxlcnRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAueCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLnkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciB0TG9jID0gdGhpcy5kYXRhLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hbGVydHMgPSB7XHJcbiAgICAgICAgICAgICAgICBnYW1lOiBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZVt0TG9jXS5hbGVydHMuZ2FtZSksXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZVt0TG9jXS5hbGVydHMubWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICBwZGY6IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lW3RMb2NdLmFsZXJ0cy5wZGYpLFxyXG4gICAgICAgICAgICAgICAgdmlkZW86IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lW3RMb2NdLmFsZXJ0cy52aWRlbyksXHJcbiAgICAgICAgICAgICAgICBndGZzOiBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZVt0TG9jXS5hbGVydHMuZ3RmcylcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRHcm91cC5hZGQodGhpcy5hbGVydHMuZ2FtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRHcm91cC5hZGQodGhpcy5hbGVydHMubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRHcm91cC5hZGQodGhpcy5hbGVydHMucGRmKTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmFkZCh0aGlzLmFsZXJ0cy52aWRlbyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRHcm91cC5hZGQodGhpcy5hbGVydHMuZ3Rmcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0FsZXJ0KGZhbHNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFueSBnYW1lIGNob2ljZSBkdXJpbmcgYW4gYWxlcnQgd2lsbCBjYXVzZSB0aGUgcGhvbmUgdG8gJ3ZpYnJhdGUnIG9uIHNjcmVlbi5cclxuICAgICAgICAgKiBAcGFyYW0gY2hvaWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggY2hvaWNlICkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc0FsZXJ0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBbGVydCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIGNob2ljZVsncGhvbmVfYWxlcnQnXSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbGVydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0FsZXJ0KGNob2ljZVsncGhvbmVfYWxlcnQnXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBbGVydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IG9uZSBvZiB0aGUgYWxlcnRzLCBvciBoaWRlIHRoZW0gYWxsIGlmIG5vIHR5cGUgKG9yIGZhbHNlKSBpcyBwYXNzZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUgZ2FtZXxtZXNzYWdlfHBkZnx2aWRlb3xmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dBbGVydDogZnVuY3Rpb24oIHR5cGUgKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmFsZXJ0R3JvdXAgPT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3JBbGVydHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0cy5nYW1lLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydHMubWVzc2FnZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRzLnBkZi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRzLnZpZGVvLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydHMuZ3Rmcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKCB0eXBlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGVydHNbdHlwZV0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXkgdGhlIHJpbmcgYW5pbWF0aW9uIGFuZCBjdXJyZW50IHJpbmcgdG9uZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwbGF5QWxlcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmluZ1RvbmVJbmRleCA9IHBhcnNlSW50KHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkcGhvbmVSaW5nZXJJbmRleFwiKSwgMTApO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5idXR0b25BbmltYXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQW5pbWF0aW9uID0gdGhpcy5idXR0b24uYW5pbWF0aW9ucy5hZGQoJ3JpbmcnLCB0aGlzLnRoZW1lW3RoaXMuZGF0YS5pbWFnZV0ucmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5idXR0b24uYW5pbWF0aW9ucy5wbGF5KCdyaW5nJywgNCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMudGhlbWUucGhvbmUucmluZ3RvbmVzW3JpbmdUb25lSW5kZXhdIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgcGxheWVyIGNsaWNrcyB0aGUgcGhvbmUgYnV0dG9uLCBzdG9wIGFueSBhbGVydCBhbmQgdGhlbiBzZW5kIG91dCB0aGUgZ2FtZSBjaG9pY2UuXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FsZXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaG93QWxlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0WydzaG93X2NlbGxfcGhvbmUnXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0cyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5hbGVydEdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGhvbmVCdXR0b25BY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8yMC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBpcyBhIHZlcnkgc3BlY2lhbGl6ZWQgYWN0b3IgZm9yIHVzZSB3aXRoIFdlbGNvbWUgVG8gTmV3YnJpZGdlIGFuZCBBY3QgTm93ISBpdCBzaG93cyBhIGNlbGwgcGhvbmUgdGhhdCBzZW5kcyBvdXRcclxuICogc3BlY2lhbCBldmVudHMsIHJlc3BvbmRzIHRvIGV2ZW50cywgYW5kIGNhbiBpbnRlcmFjdCB3aXRoIHRoZSB1c2VyIGJ5IGRyYXdpbmcgb3ZlciB0aGUgc2NlbmUuIFRoZSB1c2VyIGNhbiBpbnRlcmFjdFxyXG4gKiB3aXRoIHRoZSBwaG9uZSBhbmQgcG9zc2libHkgbGF1bmNoIHN1Yi1hY3Rpdml0aWVzIGZyb20gaXQuIEJlY2F1c2Ugb2YgdGhpcywgdGhlIHBob25lIG11c3QgYmxvY2sgdXNlciBpbnB1dCwgd2hpY2hcclxuICogaXMgdGhlIHB1cnBvc2Ugb2YgdGhlIGJsb2NraW5nU3ByaXRlKHMpLlxyXG4gKlxyXG4gKiByaW5ndG9uZSBhbmQgYmFja2dyb3VuZCBhcmUgbm93IHN0b3JlZCBvbiB0aGUgcGxheS1tb2RlbCBvZiB0aGUgY3VycmVudCBzY2VuZS5cclxuICpcclxuICogIHtcclxuICogICAgIFwibmFtZVwiOiBcInBob25lXzFcIixcclxuICogICAgIFwidHlwZVwiOiBcInBob25lXCIsXHJcbiAqICAgICBcImhlbHBcIjoge1xyXG4gKiAgICAgICBcInZhcmlhYmxlXCI6IFwicGhvbmVfMVwiLCAvLyB0aGVzZSB2YXJpYWJsZXMgd2lsbCBiZSBzZXQgdG8gJ29wZW4nIG9yICdjbG9zZWQnIGF1dG9tYXRpY2FsbHkuIEl0J3Mgb3B0aW9uYWwuXHJcbiAqICAgICAgIFwidGV4dFwiIDogXCJZb3UnbGwgZmluZCBnb29kIGFkdmljZSBoZXJlLlwiIC8vIHRleHQgdG8gZGlzcGxheSBmb3IgdGhpcyAnaWNvbidcclxuICogICAgIH0sXHJcbiAqICAgICBcImd0ZnNcIjoge1xyXG4gKiAgICAgICBcInZhcmlhYmxlXCI6IFwicGhvbmVfMlwiLFxyXG4gKiAgICAgICBcInRleHRcIjogXCJZb3UnbGwgYmUgbm90aWZpZWQgd2hlbiBpdCdzIHRpbWUgdG8gbGVhcm4gc29tZSBmYWN0cyBhYm91dCBidWxseWluZy5cIlxyXG4gKiAgICAgfSxcclxuICogICAgIFwiZ2FtZXNcIjoge1xyXG4gKiAgICAgICBcInRleHRcIjogXCJTb21ldGltZXMgeW91IGNhbiBjaG9vc2UgdGhpcyBpY29uIHRvIHBsYXkgYW5vdGhlciBnYW1lIHdpdGhpbiB0aGUgc2Nob29sIGRheS5cIlxyXG4gKiAgICB9LFxyXG4gKiAgICAgXCJtZXNzYWdlc1wiOiB7XHJcbiAqICAgICAgIFwidmFyaWFibGVcIjogXCJwaG9uZV8zXCIsXHJcbiAqICAgICAgIFwiZnJvbVwiOiBcImFub255bW91c1wiLCAvLyBtZXNzYWdlcyBoYXMgYSAnZnJvbSc7IHNpbmNlIHRoZXkgYXJlIGRpc3BsYXllZCBhcyB0ZXh0IG1lc3NhZ2VzLlxyXG4gKiAgICAgICBcInRleHRcIjogXCJ0aGlzIGlzIGEgdGV4dCBtZXNzYWdlLlwiXHJcbiAqICAgICB9LFxyXG4gKiAgICAgXCJ2aWRlb3NcIjoge1xyXG4gKiAgICAgICBcImxpbmtcIjogXCJcIixcclxuICogICAgICAgXCJ0ZXh0XCI6IFwiWW91J2xsIGJlIGRpcmVjdGVkIHdoZW4gdG8gd2F0Y2ggdmlkZW9zIGFib3V0IGJ1bGx5aW5nLiBDbGljayB0aGlzIGljb24gd2hlbiB0b2xkIHRvIHNlZSBhIHZpZGVvIG9uIHlvdXIgcGhvbmUuXCJcclxuICogICAgIH0sXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICB9XHJcbiAqXHJcbiAqICBTcGVjaWFsIGRhdGEgc3RvcmVkIG9uIG1vZGVsLiBUaGVzZSBkYXRhIGFyZSBzdG9yZWQgb24gdGhlIG1vZGVsIHRvIG1ha2UgdGhlbSBzdGF0ZWZ1bCBiZXR3ZWVuIGluc3RhbmNlczpcclxuICogICAgIFwicGhvbmVSaW5nZXJJbmRleFwiOiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgcmluZyB0b25lLlxyXG4gKiAgICAgXCJwaG9uZUJnSW5kZXhcIjogdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGJhY2tncm91bmQgaW1hZ2UuXHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKSxcclxuICAgICAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbiAgICB2YXIgUGhvbmUgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIF07IC8vIG5vIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRIZWFkZXIgPSB0aGlzLmdldEZvbnQoJ3Bob25lSGVhZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHkgPSB0aGlzLmdldEZvbnQoJ3Bob25lQm9keScpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5TGluayA9IHRoaXMuZ2V0Rm9udCgncGhvbmVCb2R5TGluaycpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEub3BlbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuICAgICAgICAgICAgaWYoIGNob2ljZVsnc2hvd19jZWxsX3Bob25lJ10gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMucGhvbmVHcm91cC52aXNpYmxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbGlja0Nsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZGF0YSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbZGF0YS52YXJpYWJsZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0hlbHA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWNvbiA9IHRoaXMuZGF0YS5oZWxwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SWNvbi52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLmN1cnJlbnRJY29uLCBcIm9wZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaG93VGV4dChcIkhlbHBcIiwgdGhpcy5jdXJyZW50SWNvbi50ZXh0LCBmYWxzZSwgdGhpcy5jdXJyZW50SWNvbi5saW5rLCAgdGhpcy5jdXJyZW50SWNvbi52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNsaWNrR3RmczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJY29uID0gdGhpcy5kYXRhLmd0ZnM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJY29uLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwib3BlblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNob3dUZXh0KFwiR2V0IFRoZSBGYWN0c1wiLCB0aGlzLmN1cnJlbnRJY29uLnRleHQsIGZhbHNlLCB0aGlzLmN1cnJlbnRJY29uLmxpbmssICB0aGlzLmN1cnJlbnRJY29uLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tNZXNzYWdlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJY29uID0gdGhpcy5kYXRhLm1lc3NhZ2VzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SWNvbi52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLmN1cnJlbnRJY29uLCBcIm9wZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaG93VGV4dCh0aGlzLmN1cnJlbnRJY29uLmZyb20sIHRoaXMuY3VycmVudEljb24udGV4dCwgdHJ1ZSwgdGhpcy5jdXJyZW50SWNvbi5saW5rLCAgdGhpcy5jdXJyZW50SWNvbi52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNsaWNrVmlkZW9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEljb24gPSB0aGlzLmRhdGEudmlkZW9zO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SWNvbi52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLmN1cnJlbnRJY29uLCBcIm9wZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaG93VGV4dChcIlZpZGVvc1wiLCB0aGlzLmN1cnJlbnRJY29uLnRleHQsIGZhbHNlLCB0aGlzLmN1cnJlbnRJY29uLmxpbmssICB0aGlzLmN1cnJlbnRJY29uLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tSaW5ndG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmluZ1RvbmVJbmRleCA9IHBhcnNlSW50KHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkcGhvbmVSaW5nZXJJbmRleFwiKSwgMTApO1xyXG4gICAgICAgICAgICByaW5nVG9uZUluZGV4Kys7XHJcbiAgICAgICAgICAgIHJpbmdUb25lSW5kZXggJT0gdGhpcy50aGVtZS5waG9uZS5yaW5ndG9uZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIHsgXCJhdWRpb1wiOiB0aGlzLnRoZW1lLnBob25lLnJpbmd0b25lc1tyaW5nVG9uZUluZGV4XX0pO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lUmluZ2VySW5kZXhcIjogcmluZ1RvbmVJbmRleCB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tCYWNrZ3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwaG9uZUJnSW5kZXggPSBwYXJzZUludCh0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJHBob25lQmdJbmRleFwiKSwgMTApO1xyXG4gICAgICAgICAgICBwaG9uZUJnSW5kZXgrKztcclxuICAgICAgICAgICAgcGhvbmVCZ0luZGV4ICU9IHRoaXMudGhlbWUucGhvbmUuYmFja2dyb3VuZHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lQmcuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5waG9uZS5iYWNrZ3JvdW5kc1twaG9uZUJnSW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lQmdJbmRleFwiOiBwaG9uZUJnSW5kZXh9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tDbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwge1wicGhvbmVcIjogXCJjbG9zZWRcIn0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlUGhvbmVCdXR0b246IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSBuZXcgUGhhc2VyLkJ1dHRvbih0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5waG9uZS5pY29uc1trZXldWzFdLCB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMV0sIHRoaXMudGhlbWUucGhvbmUuaWNvbnNba2V5XVswXSk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3dpbmcgdGhlIHBob25lIGlzIGEgYml0IGNvbXBsaWNhdGVkLiBFdmVyeXRoaW5nIGhhcyB0byBiZSBicm91Z2h0IHRvIHRoZSB0b3AgaW5cclxuICAgICAgICAgKiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dQaG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEhvbWVTY3JlZW5Hcm91cCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QmxvY2tpbmdHcm91cCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0TWVzc2FnZVdpbmRvd0dyb3VwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUud29ybGQuYnJpbmdUb1RvcCh0aGlzLnBob25lR3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMudGV4dEdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB7XCJwaG9uZVwiOiBcIm9wZW5cIn0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIHRoZSBtYWluIHNjcmVlbiwgaW5jbHVkaW5nIGFsbCBvZiB0aGUgYnV0dG9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0SG9tZVNjcmVlbkdyb3VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBob25lQmdJbmRleCA9IHBhcnNlSW50KHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkcGhvbmVCZ0luZGV4XCIpLCAxMCk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLnggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVCZyA9IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnBob25lLmJhY2tncm91bmRzW3Bob25lQmdJbmRleF0pO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lQmcuYW5jaG9yLnNldFRvKDAuNSwgMC4wKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLnBob25lQmcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbignaGVscCcsIHRoaXMub25DbGlja0hlbHAsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMuaGVscEJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEJ1dHRvbi54ID0gLXRoaXMuaGVscEJ1dHRvbi53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnkgPSA1MDtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ndGZzQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbignZ3RmcycsIHRoaXMub25DbGlja0d0ZnMsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMuZ3Rmc0J1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZ3Rmc0J1dHRvbi54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5ndGZzQnV0dG9uLnkgPSA1MDtcclxuICAgICAgICAgICAgdGhpcy5ndGZzQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmd0ZnNCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc0J1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ21lc3NhZ2VzJywgdGhpcy5vbkNsaWNrTWVzc2FnZXMsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMubWVzc2FnZXNCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQnV0dG9uLnggPSB0aGlzLm1lc3NhZ2VzQnV0dG9uLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQnV0dG9uLnkgPSA1MDtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc0J1dHRvbi5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc0J1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZpZGVvc0J1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ3ZpZGVvcycsIHRoaXMub25DbGlja1ZpZGVvcywgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy52aWRlb3NCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLnZpZGVvc0J1dHRvbi54ID0gLXRoaXMudmlkZW9zQnV0dG9uLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnZpZGVvc0J1dHRvbi55ID0gNTAgKyB0aGlzLnZpZGVvc0J1dHRvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9zQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnZpZGVvc0J1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJpbmd0b25lQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbigncmluZ3RvbmVzJywgdGhpcy5vbkNsaWNrUmluZ3RvbmUsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMucmluZ3RvbmVCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmd0b25lQnV0dG9uLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmd0b25lQnV0dG9uLnkgPSA1MCArIHRoaXMudmlkZW9zQnV0dG9uLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5yaW5ndG9uZUJ1dHRvbi5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5yaW5ndG9uZUJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdiYWNrZ3JvdW5kJywgdGhpcy5vbkNsaWNrQmFja2dyb3VuZCwgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5iYWNrZ3JvdW5kQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQnV0dG9uLnggPSB0aGlzLm1lc3NhZ2VzQnV0dG9uLndpZHRoOyAvLyB0aGlzIGlzIG9uIHB1cnBvc2UuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEJ1dHRvbi55ID0gNTAgKyB0aGlzLnZpZGVvc0J1dHRvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEJ1dHRvbi5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQnV0dG9uLmJyaW5nVG9Ub3AoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdjbG9zZScsIHRoaXMub25DbGlja0Nsb3NlLCB0aGlzLCAyKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLmNsb3NlQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbi54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbi55ID0gNTAgKyAodGhpcy5ndGZzQnV0dG9uLmhlaWdodCAqIDMpO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdEJsb2NraW5nR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMiA9IHRoaXMuY3JlYXRlQmxvY2tpbmdTcHJpdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmJsb2NraW5nU3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmJsb2NraW5nU3ByaXRlMik7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbml0TWVzc2FnZVdpbmRvd0dyb3VwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMucGhvbmVCZy53aWR0aCAtIDMyO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYIC0gKHdpZHRoIC8gMiksXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5waG9uZUJnLnkgKyAzMixcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucGhvbmVCZy5oZWlnaHQgLSA3NCxcclxuICAgICAgICAgICAgICAgIGhlaWdodEhlYWRpbmcgPSBoZWlnaHQgLyA3LFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luID0gMTA7XHJcblxyXG4gICAgICAgICAgICBoZWlnaHQgLT0gKGhlaWdodEhlYWRpbmcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC55ID0geTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZ1RleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB3aWR0aCAvIDIsIGhlaWdodEhlYWRpbmcgLyAyLCBcIkhFQURJTkcgVEVTVFwiLCB0aGlzLmZvbnRIZWFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmdUZXh0LmFuY2hvci5zZXRUbygwLjUsIDAuNSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5LndvcmRXcmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keS53b3JkV3JhcFdpZHRoID0gd2lkdGggKiAwLjk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHlMaW5rLndvcmRXcmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keUxpbmsud29yZFdyYXBXaWR0aCA9IHdpZHRoICogMC45O1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgbWFyZ2luLCBoZWlnaHRIZWFkaW5nICsgbWFyZ2luLCBcIlRISVMgSVMgQSBURVhUIE1FU1NBR0UgRk9SIFlPVSBUTyBTRUUgVEVTVFwiLCB0aGlzLmZvbnRCb2R5KTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5hbmNob3Iuc2V0VG8oMC4wLCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlUZXh0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keVRleHQuZXZlbnRzLm9uSW5wdXREb3duLmFkZCh0aGlzLmNsaWNrZWRCb2R5VGV4dCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLmFkZChncmFwaGljcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgYSBmaWxsIGFuZCBsaW5lIHN0eWxlXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweDM1MzUzNSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgxLCAweDAwMDAwMCwgMSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHRIZWFkaW5nKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkZGRkZGLCAwLjkpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5kcmF3UmVjdCgwLCBoZWlnaHRIZWFkaW5nLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1dHRvblNwcml0ZSA9IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnBob25lLm1lc3NhZ2VzLmJ1dHRvbik7XHJcbiAgICAgICAgICAgIGJ1dHRvblNwcml0ZS54ID0gd2lkdGggLSBidXR0b25TcHJpdGUud2lkdGggLSBtYXJnaW47XHJcbiAgICAgICAgICAgIGJ1dHRvblNwcml0ZS55ID0gaGVpZ2h0SGVhZGluZyArIGhlaWdodCAtIG1hcmdpbiAtIGJ1dHRvblNwcml0ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGJ1dHRvblNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBidXR0b25TcHJpdGUuZXZlbnRzLm9uSW5wdXREb3duLmFkZCh0aGlzLmNob29zZU9rLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbiA9IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgbWFyZ2luLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUucGhvbmUucGxheUJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uZXZlbnRzLm9uSW5wdXREb3duLmFkZCh0aGlzLmNsaWNrZWRCb2R5VGV4dCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC5hZGQodGhpcy5oZWFkaW5nVGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLmFkZCh0aGlzLmJvZHlUZXh0KTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAuYWRkKGJ1dHRvblNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLmFkZCh0aGlzLnBsYXlCdXR0b24pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5oaWRlVGV4dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd1RleHQ6IGZ1bmN0aW9uIChoZWFkaW5nMSwgYm9keSwgaXNUZXh0TWVzc2FnZSwgbGluaywgdmFsdWVJbikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiggdmFsdWVJbiApIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSggdmFsdWVJbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5oZWFkaW5nVGV4dC5zZXRUZXh0KGhlYWRpbmcxKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRCb2R5VGV4dCggYm9keSwgbGluaywgdmFsdWVJbiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiggaXNUZXh0TWVzc2FnZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkdCA9IFwiUmVjZWl2ZWQ6IFwiICsgbW9tZW50KCkuZm9ybWF0KFwiTU1NIERvIFlZWVksIGg6bW0gYSBcIik7IC8vIEp1bCAyMXN0IDIwMTUsIDExOjEyIGFtXHJcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoaGVhZGluZzEpO1xyXG4gICAgICAgICAgICAgICAgZnJvbSA9IGZyb20uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmcm9tLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkaW5nVGV4dC5zZXRUZXh0KCBcIkZyb206IFwiICsgZnJvbSArIFwiXFxuXCIgKyBkdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEJvZHlUZXh0OiBmdW5jdGlvbiggdGV4dCwgaXNMaW5rLCB1c2VWYWx1ZSkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkluIHNldCBib2R5IHRleHQuXCIpO1xyXG4gICAgICAgICAgICBpZiggaXNMaW5rID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIlNldHRpbmcgYXMgc2ltcGxlIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0U3R5bGUoIHRoaXMuZm9udEJvZHkgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0VGV4dCggdGhpcy5zdWJzdGl0dXRlVGV4dCh0ZXh0KSApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJub3QgYSBzdHJpbmcsIHBhcnNpbmcgZXZlcnl0aGluZy4uXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5zZXRTdHlsZSggdGhpcy5mb250Qm9keUxpbmsgKTtcclxuICAgICAgICAgICAgICAgIGlmKCB1c2VWYWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcInVzZVZhbHVlIGRlZmluZWQsIGFzOiBcIiArIHVzZVZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludCh0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHVzZVZhbHVlKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwidmFsdWUgaXMgXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kU2NvcmVSYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaCggdGV4dCwgZnVuY3Rpb24oc2luZ2xlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHZhbHVlID49IHNpbmdsZUVudHJ5WzBdICYmIHZhbHVlIDw9IHNpbmdsZUVudHJ5WzFdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5zZXRUZXh0KCB0aGlzLnN1YnN0aXR1dGVUZXh0KHNpbmdsZUVudHJ5WzJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNjb3JlUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU2NvcmVSYW5nZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2cud2FybihcIiQkJCQkJCQkJCQkIG5vdGVkIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNjb3JlIHdhc24ndCB3aXRoaW4gYW55IHJhbmdlLiBJdCBjb3VsZCBiZSBoaWdoZXIgdGhhbiBhbnkgb3IgbG93ZXIgdGhhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnksIG9yIHRoZXJlIGNvdWxkIGJlIGEgaG9sZSBpbiB0aGUgcmFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGVzdFNjb3JlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VzdFNjb3JlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2hlc3RUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VzdFRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHRleHQsIGZ1bmN0aW9uKHNpbmdsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggc2luZ2xlRW50cnlbMF0gPiBoaWdoZXN0U2NvcmUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFNjb3JlID0gc2luZ2xlRW50cnlbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFRleHQgPSBzaW5nbGVFbnRyeVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBzaW5nbGVFbnRyeVsxXSA+IGhpZ2hlc3RTY29yZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0U2NvcmUgPSBzaW5nbGVFbnRyeVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0VGV4dCA9IHNpbmdsZUVudHJ5WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzaW5nbGVFbnRyeVswXSA8IGxvd2VzdFNjb3JlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNjb3JlID0gc2luZ2xlRW50cnlbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VGV4dCA9IHNpbmdsZUVudHJ5WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzaW5nbGVFbnRyeVsxXSA8IGxvd2VzdFNjb3JlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNjb3JlID0gc2luZ2xlRW50cnlbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VGV4dCA9IHNpbmdsZUVudHJ5WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gaGlnaGVzdFNjb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY29yZSBpcyBoaWdoZXIgdGhhbiBoaWdoZXN0IHJhbmdlOyB1c2UgaGlnaGVzdCByYW5nZSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LnNldFRleHQoIHRoaXMuc3Vic3RpdHV0ZVRleHQoaGlnaGVzdFRleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGxvd2VzdFNjb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY29yZSBpcyBsb3dlciB0aGFuIGxvd2VzdCByYW5nZTsgdXNlIGxvd2VzdCByYW5nZSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LnNldFRleHQoIHRoaXMuc3Vic3RpdHV0ZVRleHQobG93ZXN0VGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgbXVzdCBiZSBhIGhvbGUgaW4gdGhlIHJhbmdlczsganVzdCB1c2UgdGhlIGZpcnN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LnNldFRleHQodGhpcy5zdWJzdGl0dXRlVGV4dCh0ZXh0WzBdWzJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0VGV4dCggdGhpcy5zdWJzdGl0dXRlVGV4dCh0ZXh0WzBdWzJdKSk7IC8vIGp1c3QgdXNlIGZpcnN0IGVudHJ5LlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi55ID0gdGhpcy5ib2R5VGV4dC55ICsgdGhpcy5ib2R5VGV4dC5oZWlnaHQgKyA1O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3Vic3RpdHV0ZVRleHQ6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkRvaW5nIHN1YnN0aXR1dGlvbiBvbjogXCIgKyB0ZXh0KTtcclxuICAgICAgICAgICAgdmFyIGxlZnRJbmRleCwgcmlnaHRJbmRleDtcclxuICAgICAgICAgICAgbGVmdEluZGV4ID0gdGV4dC5pbmRleE9mKFwiJFwiKTtcclxuICAgICAgICAgICAgaWYoIGxlZnRJbmRleCA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByaWdodEluZGV4ID0gdGV4dC5pbmRleE9mKFwiJFwiLCBsZWZ0SW5kZXggKyAxKTtcclxuICAgICAgICAgICAgaWYoIHJpZ2h0SW5kZXggPT09IC0xICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGtleSA9IHRleHQuc3Vic3RyaW5nKCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXggKzEpO1xyXG4gICAgICAgICAgICB2YXIga2V5MiA9IGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIDEpOyAvLyByZW1vdmUgdHJhaWxpbmcgZG9sbGFyc2lnbi5cclxuICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoa2V5Mik7XHJcbiAgICAgICAgICAgIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGZpbmFsVGV4dC5zbGljZSgxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShrZXksIGZpbmFsVGV4dCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZVRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaG9vc2VPazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SWNvbiAmJiB0aGlzLmN1cnJlbnRJY29uLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwiY2xvc2VkXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SWNvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5oaWRlVGV4dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xpY2tlZEJvZHlUZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLmN1cnJlbnRJY29uLCBcImNsaWNrZWRcIik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQaG9uZSBsaW5rcyBtdXN0IGJlaGF2ZSBkaWZmZXJlbnRseSB0aGFuIG90aGVyIGJ1dHRvbnMgaW4gdGhlIHNjZW5lIGVuZ2luZS5cclxuICAgICAgICAgICAgICogVGhleSBjYW4gYmUgY2xpY2tlZCBvdmVyIGFuZCBvdmVyLiBTbywgYWZ0ZXIgc2VuZGluZyB0aGUgY2xpY2tlZCBldmVudCwgd2Ugc2VuZCBhblxyXG4gICAgICAgICAgICAgKiBhZnRlckNsaWNrZWQgZXZlbnQsIHdoaWNoIGZvcmNlcyB0aGUgdmFyaWFibGUgdG8gY2hhbmdlLCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgdGhlXHJcbiAgICAgICAgICAgICAqIGxpbmsgaXMgY2xpY2tlZCwgdGhlICdjbGlja2VkJyBldmVudCBpcyBzZWVuIGFzIGEgY2hhbmdlIGFnYWluLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLmN1cnJlbnRJY29uLCBcImFmdGVyQ2xpY2tlZFwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250SGVhZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5waG9uZUdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMudGV4dEdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5ibG9ja2luZ1Nwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYmxvY2tpbmdTcHJpdGUyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZTIuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMucGxheUJ1dHRvbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQaG9uZTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGRlY29yYXRpb24gYWN0b3IuIEp1c3QgYW4gaW1hZ2Ugb24gdGhlIHNjcmVlbi5cclxuICpcclxuICogQ3JlYXRpbmcgYSBidXR0b24gYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkZWNvcmF0aW9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZVwiOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGJ1dHRvbiBzZWN0aW9uIG9mIHRoZSB0aGVtZS5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJzY2FsZVwiOiBbIHgsIHldLCAvLyBvcHRpb25hbCB4L3kgc2NhbGUuXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgUGxheVRocm91Z2hBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCB0aGVtZSkge1xyXG4gICAgICAgICAgICBpZiggIWdhbWUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdG9yIHJlcXVpcmVzIGdhbWUgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicGxheXRocm91Z2hkaXNwbGF5XCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy50aGVtZS5wbGF5dGhyb3VnaERpc3BsYXlDb250YWluZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIllvdSBjYW5ub3QgZGlzcGxheSBwbGF5dGhyb3VnaCB3aXRob3V0IHByb3ZpZGluZyBhbiBpbWFnZSBpbiB0aGUgdGhlbWUuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5wbGF5dGhyb3VnaERpc3BsYXlDb250YWluZXIgKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuZ2FtZS53b3JsZC53aWR0aCAtIHRoaXMuc3ByaXRlLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS55ID0gMDtcclxuICAgICAgICAgICAgdmFyIGZTdHlsZSA9IHRoaXMuZ2V0Rm9udCgncGxheVRocm91Z2gnKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgdGhpcy5zcHJpdGUud2lkdGgvMiwgdGhpcy5zcHJpdGUuaGVpZ2h0LzIsIFwiUGxheXRocm91Z2g6IFwiICsgdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRwbGF5VGhyb3VnaFwiKSwgZlN0eWxlKTtcclxuICAgICAgICAgICAgY3VycmVudFRleHQuYW5jaG9yLnNldFRvKDAuNSwwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hZGRDaGlsZChjdXJyZW50VGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGxheVRocm91Z2hBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgRGF2aWQgTGVlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNC8wMy8yMDE4XHJcbiAqIENvcHlyaWdodCAyMDE4IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBcclxuICogQSBzcGlubmVyIGFjdG9yIHdpdGggYSBjZW50cmFsIGJ1dHRvbiBhbmQgYSBwb2ludGVyIHRoYXQgZXh0ZW5kcyBvZmYgaXQuXHJcbiAqIFxyXG4gKiBDcmVhdGluZyBhIFNwaW5uZXIgYWN0b3I6XHJcbiAqIHtcclxuICogICAgICBcIm5hbWVcIjogXCJzcGlubmVyMVwiLCAgICAgICAgICAgICAvLyBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYWN0b3JcclxuICogICAgICBcInR5cGVcIjogXCJzcGlubmVyXCIsICAgICAgICAgICAgICAvLyBSZXF1aXJlZCB0eXBlXHJcbiAqICAgICAgXCJpbWFnZXNcIjogXCJzcGlubmVyXCIsICAgICAgICAgICAgLy8gVGhlIGtleSB0byB1c2UgZnJvbSB0aGUgc3Bpbm5lcnMgc2VjdGlvbiBvZiB0aGUgdGhlbWVcclxuICogICAgICBcImNlbnRlckltYWdlXCI6IFwiY2VudGVyXCIgICAgICAgICAvLyBUaGUga2V5IHRvIHVzZSB3aXRoaW4gdGhlIHRoZW1lIGZpbGUgZm9yIHRoZSBjZW50ZXIgaW1hZ2VcclxuICogICAgICBcImFycm93SW1hZ2VcIjogXCJhcnJvd1wiICAgICAgICAgICAvLyBUaGUga2V5IHRvIHVzZSB3aXRoaW4gdGhlIHRoZW1lIGZpbGUgZm9yIHRoZSBhcnJvdyBpbWFnZVxyXG4gKiAgICAgIFwib2Zmc2V0XCI6IDAuMjUgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgaW4gcmFkaWFucyB1c2VkIGJ5IHRoZSBzdGFydGluZyBwb3NpdGlvbiAvIHdoZW4gc3Bpbm5pbmdcclxuICogICAgICBcIm51bU9wdGlvbnNcIjogNCAgICAgICAgICAgICAgICAgLy8gSG93IG1hbnkgZGlmZmVyZW50IG9wdGlvbnMgdGhlIHNwaW5uZXIgdXNlcy4gRGVmYXVsdHMgdG8gNFxyXG4gKiAgICAgIFwiYXVkaW9cIjogXCJzcGluXCIsICAgICAgICAgICAgICAgIC8vIEFuIG9wdGlvbmFsIHNvdW5kIHRvIHBsYXkgd2hlbiB0aGUgc3Bpbm5lciBpcyBjbGlja2VkLiBEb24ndCBwbGF5IGxvbmcgYXVkaW8hXHJcbiAqICAgICAgXCJhdWRpb1ByaW9yaXR5XCI6IFwic2Z4XCIsICAgICAgICAgLy8gQW4gb3B0aW9uYWwgcHJpb3JpdHkgdG8gdXNlIGZvciB0aGUgc3Bpbm5lciBhdWRpbyBwcm9wZXJ0eS4gSWYgdGhpcyBpcyBub3Qgc2V0LCBpdCBkZWZhdWx0cyB0byBcInNmeFwiXHJcbiAqICAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSwgICAgICAgICAgIC8vIFdoZXJlIHRvIHB1dCB0aGUgY2VudGVyIG9mIHRoZSBzcGlubmVyXHJcbiAqICAgICAgXCJzcGluRHVyYXRpb25cIjogMzYwMCwgICAgICAgICAgIC8vIEhvdyBsb25nIHRoZSBzcGluIGFuaW1hdGlvbiBzaG91bGQgdGFrZS4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCBhIGR1cmF0aW9uIGJhc2VkIG9uIHRoZSBudW1iZXIgb2Ygc3BpbnMgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHRcclxuICogICAgICBcImZha2VTcGluc1JhbmdlXCI6IFsyLCA1XSwgICAgICAgLy8gUmFuZ2UgW21pbiwgbWF4XSBvZiBmYWtlIHNwaW5zIHRvIHNob3cgYmVmb3JlIHRoZSBhcnJvdyBpcyBzZXQgdG8gdGhlIHJhbmRvbWx5IHNlbGVjdGVkIHNlY3Rpb24uIFRoaXMgZGVmYXVsdHMgdG8gWzIsIDVdIGlmIG5vdCBzcGVjaWZpZWRcclxuICogICAgICBcInJpZ2dlZFwiOiB0cnVlLCAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwsIGlmIHRoaXMgaXMgdHJ1ZSB0aGUgc3Bpbm5lciB3aWxsIHNlbGVjdCBlYWNoIG9wdGlvbiBvbmNlIHVudGlsIGVhY2ggaXMgdXNlZCwgdGhlbiBiZWdpbiByYW5kb21seSBzZWxlY3RpbmcgdGhpbmdzLlxyXG4gKiAgICAgIFwiY2xpY2tWYWx1ZVwiOiBcInJlc2V0XCIsICAgICAgICAgIC8vIE9wdGlvbmFsLCBpZiB0aGlzIGlzIHNldCwgd2hlbiB0aGUgY2VudGVyIGlzIGNsaWNrZWQgdGhlIHZhcmlhYmxlIHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIHRvIHRyaWdnZXIgZXZlbnRzIG9uIGNsaWNrIHRoYXQgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBzcGluIGlzIGNvbXBsZXRlZCBhbmQgdGhlIHZhcmlhYmxlIGlzIHVwZGF0ZWQgdG8gdGhlIGZpbmFsIHZhbHVlXHJcbiAqICAgICAgXCJ2YXJpYWJsZVwiOiBcInNwaW5uZXJfdmFsdWVcIiAgICAgLy8gaWYgeW91IGNsaWNrIHRoZSBzcGlubmVyLCB0aGUgdmFyaWFibGUgJ3NwaW5uZXJfdmFsdWUnIHdpbGwgYmUgc2V0IHRvIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgNC5cclxuICogICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kOyBpdCBpcyBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICAgXCJhcnJvd09mZnNldFhcIjogMC4wNSAgICAgICAgICAgIC8vIG9wdGlvbmFsIG9mZnNldCBmb3Igc3Bpbm5lciBhcnJvd1hcclxuICogfVxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgREVGQVVMVF9OVU1fT1BUSU9OUyA9IDQ7XHJcblxyXG4gICAgdmFyIFNwaW5uZXJBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZXNcIiwgXCJjZW50ZXJJbWFnZVwiLCBcImFycm93SW1hZ2VcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByYW5kb21JbnRGcm9tSW50ZXJ2YWw6IGZ1bmN0aW9uKG1pbixtYXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKCBtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnNwaW5uZXJzIHx8ICF0aGlzLnRoZW1lLnNwaW5uZXJzW3RoaXMuZGF0YS5pbWFnZXNdICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTcGlubmVyIEFjdG9yIHJlcXVpcmVzIHNwaW5uZXJzIGVudHJ5IGluIHRoZW1lLCB3aXRoIHNwZWNpZmljIGVudHJ5IG1hdGNoaW5nIFwiICsgdGhpcy5kYXRhLmltYWdlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGhlbWUuc3Bpbm5lcnNbdGhpcy5kYXRhLmltYWdlc11bdGhpcy5kYXRhLmNlbnRlckltYWdlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTcGlubmVyIEFjdG9yIHJlcXVpcmVzIHNwaW5uZXIgZW50cnkgdG8gaGF2ZSBhIGNlbnRlciBpbWFnZSwgd2l0aCBhIHNwZWNpZmljIGVudHJ5IG1hdGNoaW5nIFwiICsgdGhpcy5kYXRhLmltYWdlcyArIFwiLlwiICsgdGhpcy5kYXRhLmNlbnRlckltYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aGVtZS5zcGlubmVyc1t0aGlzLmRhdGEuaW1hZ2VzXVt0aGlzLmRhdGEuYXJyb3dJbWFnZV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiU3Bpbm5lciBBY3RvciByZXF1aXJlcyBzcGlubmVyIGVudHJ5IHRvIGhhdmUgYW4gYXJyb3cgaW1hZ2UsIHdpdGggYSBzcGVjaWZpYyBlbnRyeSBtYXRjaGluZyBcIiArIHRoaXMuZGF0YS5pbWFnZXMgKyBcIi5cIiArIHRoaXMuZGF0YS5hcnJvd0ltYWdlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighdGhpcy5kYXRhLm51bU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5udW1PcHRpb25zID0gREVGQVVMVF9OVU1fT1BUSU9OUztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIXRoaXMuZGF0YS5mYWtlU3BpbnNSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmZha2VTcGluc1JhbmdlID0gWzIsIDVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighdGhpcy5kYXRhLmF1ZGlvUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hdWRpb1ByaW9yaXR5ID0gXCJzZnhcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yaWdnZWRTcGluVmFsdWVzID0gdGhpcy5kYXRhLnJpZ2dlZCA/IF8uc2h1ZmZsZShfLnJhbmdlKDEsIHRoaXMuZGF0YS5udW1PcHRpb25zICsgMSkpIDogW107XHJcblxyXG4gICAgICAgICAgICB2YXIgYW5jaG9yWCA9IDAuNSxcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSAwLjU7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFycm93ID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoeCwgeSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnNwaW5uZXJzW3RoaXMuZGF0YS5pbWFnZXNdW3RoaXMuZGF0YS5hcnJvd0ltYWdlXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoeCwgeSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnNwaW5uZXJzW3RoaXMuZGF0YS5pbWFnZXNdW3RoaXMuZGF0YS5jZW50ZXJJbWFnZV0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuYW5jaG9yLnNldFRvKGFuY2hvclgsIGFuY2hvclkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hcnJvd09mZnNldFgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3cuYW5jaG9yLnNldFRvKGFuY2hvclggLSB0aGlzLmRhdGEuYXJyb3dPZmZzZXRYLCBhbmNob3JZKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3cuYW5jaG9yLnNldFRvKGFuY2hvclgsIGFuY2hvclkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFycm93LnJvdGF0aW9uID0gTWF0aC5QSSAqIHRoaXMuZGF0YS5vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hcnJvdy5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFycm93LmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuZXZlbnRzLm9uSW5wdXREb3duLmFkZCh0aGlzLm9uQ2xpY2ssIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmFycm93LmV2ZW50cy5vbklucHV0RG93bi5hZGQodGhpcy5vbkNsaWNrLCB0aGlzKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zcGlubmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmNsaWNrVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLmNsaWNrVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNwaW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMuZGF0YS5hdWRpbywgXCJwcmlvcml0eVwiOiB0aGlzLmRhdGEuYXVkaW9Qcmlvcml0eSB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByYW5kb21JbnQgPSB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMubGVuZ3RoID8gdGhpcy5yaWdnZWRTcGluVmFsdWVzLnNoaWZ0KCkgOiB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgxLCB0aGlzLmRhdGEubnVtT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmFuZG9tRnVsbFNwaW5zID0gdGhpcy5yYW5kb21JbnRGcm9tSW50ZXJ2YWwodGhpcy5kYXRhLmZha2VTcGluc1JhbmdlWzBdLCB0aGlzLmRhdGEuZmFrZVNwaW5zUmFuZ2VbMV0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJhbmRvbVJvdGF0aW9uID0gKChNYXRoLlBJICogMikgLyB0aGlzLmRhdGEubnVtT3B0aW9ucykgKiByYW5kb21JbnQ7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9ICgyICogcmFuZG9tRnVsbFNwaW5zICogTWF0aC5QSSkgKyByYW5kb21Sb3RhdGlvbiArIChNYXRoLlBJICogdGhpcy5kYXRhLm9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoISB0aGlzLmRhdGEuc3BpbkR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3BpbkR1cmF0aW9uIGlzbid0IHBhc3NlZCBpbiwgb3ZlcnJpZGUgaXQgd2l0aCB0aGUgb2xkIGNvZGUgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwaW5EdXJhdGlvbiA9IChyb3RhdGlvbiAvICgyICogTWF0aC5QSSkpICogMTAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLmFycm93KS50byggeyByb3RhdGlvbjogcm90YXRpb24gfSwgdGhpcy5kYXRhLnNwaW5EdXJhdGlvbiwgUGhhc2VyLkVhc2luZy5RdWFkcmF0aWMuT3V0LCB0cnVlLCAwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25Db21wbGV0ZS5hZGQoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyb3cucm90YXRpb24gPSB0aGlzLmFycm93LnJvdGF0aW9uICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwaW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gcmFuZG9tSW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyb3cpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3cuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWVuLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNwaW5uZXJBY3RvcjtcclxufSgpKTsiLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBIHNwZWVjaCBidWJibGUuIEl0IGRpc3BsYXlzIHRleHQgYW5kIHJlcXVlc3RzIHRoYXQgYXVkaW8gYmUgcGxheWVkLiBBIHNwZWVjaCBidWJibGUgY2FuIGhhdmUgaXRzIG93biB0ZXh0L2F1ZGlvXHJcbiAqIGFuZCBjYW4gYWxzbyBsaXN0ZW4gZm9yIHRleHQvYXVkaW8gZXZlbnRzIHRvIHNob3cuXHJcbiAqIFRoZSBzcGVlY2ggYnViYmxlIHdpbGwgYWRqdXN0IGl0cyBzaXplIHRvIGZpdCB0aGUgcHJvdmlkZWQvc2V0IHRleHQuXHJcbiAqXHJcbiAqe1xyXG4gKiAgICBcIm5hbWVcIjogXCJjaG9pY2VCdWJibGVcIiwgLy8gbmFtZS5cclxuICogICAgXCJ0eXBlXCI6IFwic3BlZWNoLWJ1YmJsZVwiLFxyXG4gKiAgICBcInRleHRcIjogXCJcIiwgLy8gdGV4dCB0byBzaG93LlxyXG4gKiAgICBcImF1ZGlvXCI6IFwiXCIsIC8vIGF1ZGlvIGtleSB0byBwbGF5LlxyXG4gKiAgICBcImhpZGRlblwiOiB0cnVlLCAvLyBzZXQgdG8gdHJ1ZSB0byBvcHRpb25hbGx5IGhpZGUgdGhlIGJ1YmJsZSBpbml0aWFsbHksIHVzZWQgd2hlbiBjaGFyYWN0ZXIgaXNuJ3QgdGhlIGZpcnN0IHRvIHRhbGsuXHJcbiAqICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICp9LFxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIG1hcmdpblggPSAxNSwgbWFyZ2luWSA9IDIwO1xyXG5cclxuICAgIHZhciBaaW5rQ29tcHV0ZXJBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuZGF0YS50ZXh0IHx8IFwiIFwiO1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IHRoaXMuZGF0YS5rZXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvdyh0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3BlZWNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRXaW5kb3c6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy50aGVtZS50ZXh0V2luZG93cyB8fCAhdGhpcy50aGVtZS50ZXh0V2luZG93cy56aW5rICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnN0cnVjdGlvbiBhY3RvciByZXF1aXJlcyB0ZXh0V2luZG93cyB0aGVtZSBlbnRyeSwgYW5kIHppbmsgZGVmaW5pdGlvbiBpbnNpZGUgaXQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueCA9IHg7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLnkgPSB5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRvcFdpbmRvdyA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muemluayk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IHRoaXMuZ2V0Rm9udCgnYnViYmxlVGV4dCcpO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLndvcmRXcmFwV2lkdGggPSB0b3BXaW5kb3cud2lkdGggKiAwLjU1O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblgsIG1hcmdpblksIFwiIFwiLCB0aGlzLmZTdHlsZSk7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLmFkZCh0aGlzLmN1cnJlbnRUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gd2luZG93R3JvdXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTcGVlY2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRUZXh0KCB0aGlzLmdldFRleHQodGhpcy50ZXh0LCB0aGlzLmtleSkgKTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIHt0ZXh0OiB0aGlzLnRleHQsIGF1ZGlvOiB0aGlzLmF1ZGlvLCBrZXk6IHRoaXMua2V5fSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uIChzcGVlY2gpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gc3BlZWNoLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0gc3BlZWNoLmtleTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRUZXh0KCB0aGlzLmdldFRleHQodGhpcy50ZXh0LCB0aGlzLmtleSkgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFppbmtDb21wdXRlckFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgemluayBwb3N0ZXIgYWN0b3IuIFRoaXMgaXMgYSBzcGVjaWFsIGFjdG9yIHRoYXQgcmVxdWlyZXMgb25seSB0ZXh0IGFuZCBmb250IGNvbmZpZ3VyYXRpb24uIEl0IHdpbGwgc2hvdyBhXHJcbiAqIHppbmsgcG9zdGVyIHdpdGggdGV4dCBvbiBpdC5cclxuICpcclxuICogQ3JlYXRpbmcgYSB6aW5rIHBvc3RlciBhY3RvcjpcclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwibWFuZHlcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiemluay1wb3N0ZXJcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcInRleHRcIjogXCJZbywgSSdtIHppbmtcIiwgLy8gd2hhdCB0byBwdXQgb24gdGhlIHBvc3Rlci5cclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBaaW5rUG9zdGVyQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBdOyAvLyBubyByZXF1aXJlZCBmaWVsZHMuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGV4dEJveCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXJrT3V0ID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGFya091dC5iZWdpbkZpbGwoIDB4MDAwMDAwLCAwLjQgKTtcclxuICAgICAgICAgICAgdGhpcy5kYXJrT3V0LmRyYXdSZWN0KCAwLCAgMCwgdGhpcy5nYW1lLndvcmxkLndpZHRoLCB0aGlzLmdhbWUud29ybGQuaGVpZ2h0ICk7XHJcbiAgICAgICAgICAgIHRoaXMuZGFya091dC5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kYXJrT3V0KTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggKHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYKSwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbWFnZSgnemluay1wb3N0ZXInLCAnYWN0b3JJbWFnZXMnKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWCAtICh0aGlzLnNwcml0ZS53aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmdsZSAtPSAzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVGV4dEJveDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udCA9IHRoaXMuZ2V0Rm9udCgnemlua1Bvc3RlcicpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib3hZID0gdGhpcy5zcHJpdGUueSArICh0aGlzLnNwcml0ZS5oZWlnaHQgKiAwLjc1KTtcclxuICAgICAgICAgICAgdGhpcy5ib3hXaWR0aCA9IHRoaXMuc3ByaXRlLndpZHRoIC0gMjtcclxuICAgICAgICAgICAgdGhpcy5ib3hIZWlnaHQgPSAxMTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvbnQud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnQud29yZFdyYXBXaWR0aCA9IHRoaXMuYm94V2lkdGggKiAwLjk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCAxMCAsIDUsIHRoaXMuZGF0YS50ZXh0ICwgdGhpcy5mb250KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMSwgdGhpcy5ib3hZKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoIDB4RUZFRkVGLCAxLjAgKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3UmVjdCggMCwgIDAsIHRoaXMuYm94V2lkdGgsIHRoaXMuYm94SGVpZ2h0ICk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5hZGRDaGlsZCh0aGlzLnRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hZGRDaGlsZCh0aGlzLmdyYXBoaWNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhcmtPdXQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhcmtPdXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gWmlua1Bvc3RlckFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEwLzAyMy8yMDE3XHJcbiAqIENvcHlyaWdodCAyMDE3IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGFuaW1hdGlvbiBhY3Rvci4gV2lsbCBydW4gaXQncyBhbmltYXRpb24sIGFuZCBjYW4gb3B0aW9uYWxseSBiZSBjbGlja2VkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGNsaWNrLWFuaW1hdGlvbiBhY3RvciwgYSBzdGFydGluZywgYW5pbWF0aW9uIHNldCwgYW5kIGVuZGluZyBpbWFnZTpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9ydHJhaXQxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImFuaW1hdGlvblwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VzXCI6IFwicGhvbmVcIiwgLy8gdGhlIGltYWdlcyB0byB1c2VcclxuICogICAgIFwia2V5XCI6IFwid2hhdGV2c1wiLCAvLyBvcHRpb25hbCBpbWFnZSBrZXlcclxuICogICAgIFwidGV4dHVyZUtleVwiOiBcImtleVwiLCAvLyBvcHRpb25hbCB0ZXh0IGtleSB0byBnZXQgYW5pbWF0aW9uIGZyb21cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInNjYWxlXCI6IFsgeCwgeV0sIC8vIG9wdGlvbmFsIHgveSBzY2FsZS5cclxuICogICAgIFwiZnBzXCI6IDEwLCAvLyBmcmFtZXMgd2VyZSBzZWNvbmQsIHdpbGwgZGVmYXVsdCB0byAzMFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAsIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogICAgIFwidmFyaWFibGVcIjogXCJ4XCIsIC8vIHZhcmlhYmxlIHRvIHNlbmQgb3V0IDJuZCBjbGljayBldmVudHMsIHdpbGwgYmUgbmFtZSArIFwiX3BsYXlpbmdcIiBhbmQgbmFtZSArIFwiX2ZpbmlzaGVkXCJcclxuICogICAgIFwibG9vcFwiOiB0cnVlIC8vIHRydWU9bG9vcCBpbmRlZmluaXRseSwgZmFsc2U9bm8gbG9vcCwgb3IgbnVtYmVyIG9mIHRpbWVzIHRvIHBsYXkgdGhlIGFuaW1hdGlvbjsgZGVmYXVsdHMgdG8gdHJ1ZS5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpLFxyXG5cdFx0VHdlZW5IZWxwZXIgPSByZXF1aXJlKFwiLi90d2Vlbi1oZWxwZXJcIik7XHJcblxyXG5cdHZhciBBbmltYXRpb25BY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcblx0XHQvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuXHRcdGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBbXCJsb2NhdGlvblwiLCBcImltYWdlc1wiXTtcclxuXHRcdH0sXHJcblx0XHRnZXRWYXJpYWJsZUxpc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS52YXJpYWJsZVxyXG5cdFx0XHRcdD8gW3RoaXMuZGF0YS52YXJpYWJsZSArIFwiX3BsYXlpbmdcIiwgdGhpcy5kYXRhLnZhcmlhYmxlICsgXCJfZmluaXNoZWRcIl1cclxuXHRcdFx0XHQ6IFtdO1xyXG5cdFx0fSxcclxuXHRcdGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5idWlsZEFjdG9yKCk7XHJcblx0XHRcdHZhciBsb29wSW5kZWZpbml0ZWx5ID1cclxuXHRcdFx0XHR0aGlzLmRhdGEubG9vcCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZGF0YS5sb29wID09IHRydWU7XHJcblx0XHRcdHRoaXMuc3ByaXRlLmFuaW1hdGlvbnMucGxheShcImFuaW1hdGlvblwiLCB0aGlzLmZwcywgbG9vcEluZGVmaW5pdGVseSk7XHJcblx0XHR9LFxyXG5cdFx0YnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmZwcyA9IDMwO1xyXG5cclxuXHRcdFx0dGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZShcclxuXHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG5cdFx0XHRcdHRoaXMuZ2V0VGV4dHVyZUtleSh0aGlzLmRhdGEpLFxyXG5cdFx0XHRcdHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmltYWdlcywgdGhpcy5kYXRhLmtleSlbMF1cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuc3ByaXRlLmlucHV0LnBpeGVsUGVyZmVjdE92ZXIgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5zcHJpdGUuZXZlbnRzLm9uSW5wdXRVcC5hZGQodGhpcy5vblBvaW50ZXJVcCwgdGhpcyk7XHJcblx0XHRcdGlmICh0aGlzLmRhdGEudmFyaWFibGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hbmltYXRpb24gPSB0aGlzLnNwcml0ZS5hbmltYXRpb25zLmFkZChcclxuXHRcdFx0XHRcImFuaW1hdGlvblwiLFxyXG5cdFx0XHRcdHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmltYWdlcywgdGhpcy5kYXRhLmtleSlcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5hbmltYXRpb24ub25TdGFydC5hZGQodGhpcy5hbmltYXRpb25TdGFydGVkLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5hbmltYXRpb24ub25Db21wbGV0ZS5hZGQodGhpcy5hbmltYXRpb25TdG9wcGVkLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmRhdGEuZnBzKSB7XHJcblx0XHRcdFx0dGhpcy5mcHMgPSB0aGlzLmRhdGEuZnBzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYW5jaG9yWCA9IDAsXHJcblx0XHRcdFx0YW5jaG9yWSA9IDA7XHJcblx0XHRcdHZhciB4ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdLFxyXG5cdFx0XHRcdHkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcblx0XHRcdHRoaXMuc2NhbGVYID0gMS4wO1xyXG5cdFx0XHR0aGlzLnNjYWxlWSA9IDEuMDtcclxuXHJcblx0XHRcdGlmICh0aGlzLmRhdGEuc2NhbGUpIHtcclxuXHRcdFx0XHR0aGlzLnNjYWxlWCA9IHRoaXMuZGF0YS5zY2FsZVswXTtcclxuXHRcdFx0XHR0aGlzLnNjYWxlWSA9IHRoaXMuZGF0YS5zY2FsZVsxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyh0aGlzLnNjYWxlWCwgdGhpcy5zY2FsZVkpO1xyXG5cclxuXHRcdFx0aWYgKHggPT09IFwiY2VudGVyXCIpIHtcclxuXHRcdFx0XHR4ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclg7XHJcblx0XHRcdFx0YW5jaG9yWCA9IDAuNTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHkgPT09IFwiY2VudGVyXCIpIHtcclxuXHRcdFx0XHR5ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclk7XHJcblx0XHRcdFx0YW5jaG9yWSA9IDAuNTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5hbmNob3IpIHtcclxuXHRcdFx0XHRhbmNob3JYID0gdGhpcy5kYXRhLmFuY2hvclswXTtcclxuXHRcdFx0XHRhbmNob3JZID0gdGhpcy5kYXRhLmFuY2hvclsxXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zcHJpdGUuYW5jaG9yLnNldFRvKGFuY2hvclgsIGFuY2hvclkpO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS54ID0geDtcclxuXHRcdFx0dGhpcy5zcHJpdGUueSA9IHk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLmxvb3ApIHtcclxuXHRcdFx0XHR2YXIgcmVwZWF0Q291bnQgPSBOdW1iZXIodGhpcy5kYXRhLmxvb3ApO1xyXG5cdFx0XHRcdGlmIChyZXBlYXRDb3VudCA+IDEpIHtcclxuXHRcdFx0XHRcdHRoaXMucmVwZWF0Q291bnQgPSByZXBlYXRDb3VudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLmRhdGEudHdlZW4pIHtcclxuXHRcdFx0XHRpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnR3ZWVuSGVscGVyKSkge1xyXG5cdFx0XHRcdFx0dGhpcy50d2VlbkhlbHBlciA9IG5ldyBUd2VlbkhlbHBlcih0aGlzLmdhbWUsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnR3ZWVuSGVscGVyLmFkZFR3ZWVucyh0aGlzLmRhdGEudHdlZW4sIHRoaXMuc3ByaXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGFuaW1hdGlvblN0YXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG5cdFx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0XHR2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlICsgXCJfcGxheWluZ1wiXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGFuaW1hdGlvblN0b3BwZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMucmVwZWF0Q291bnQgJiYgLS10aGlzLnJlcGVhdENvdW50KSB7XHJcblx0XHRcdFx0dGhpcy5hbmltYXRpb24ucmVzdGFydCgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG5cdFx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0XHR2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlICsgXCJfZmluaXNoZWRcIl0gPSB0aGlzLmRhdGEubmFtZTtcclxuXHRcdFx0XHR0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvblBvaW50ZXJVcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcblx0XHRcdFx0dmFyIHZhclNldCA9IHt9O1xyXG5cdFx0XHRcdHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcblx0XHRcdFx0dGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQodGhpcy50d2VlbkhlbHBlcikpIHtcclxuXHRcdFx0XHR0aGlzLnR3ZWVuSGVscGVyLnJlbW92ZVR3ZWVucyh0aGlzLnNwcml0ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuc3ByaXRlKSB7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEFuIGF1ZGlvIGFjdG9yLiBJdCB3aWxsIHBsYXkgYSBzb3VuZChzKSBhbmQgdGhlbiBzZXQgdGhlIHZhcmlhYmxlLlxyXG4gKiBJdCBpcyB1cCB0byB0aGUgdXNlci9zY3JpcHQgd3JpdGVyIHRvIG1ha2Ugc3VyZSB0aGlzIGF1ZGlvIGlzbid0IGJlaW5nIGludGVycnVwdGVkIGJ5IG90aGVyIGF1ZGlvLlxyXG4gKlxyXG4gKntcclxuICogICAgXCJuYW1lXCI6IFwiYXVkaW9fYWN0b3JfMVwiLCAvLyBuYW1lLlxyXG4gKiAgICBcInR5cGVcIjogXCJhdWRpb1wiLFxyXG4gKiAgICBcImF1ZGlvXCI6IFtcInNvdW5kMSwgc291bmQyXCJdLCAvLyBhdWRpbyBrZXkocykgdG8gcGxheS5cclxuICogICAgXCJ2YXJpYWJsZVwiOiBcInhcIiwgLy8gdmFyaWFibGUgdG8gc2V0IHdoZW4gc291bmRzIGhhdmUgY29tcGxldGVkIHBsYXlpbmcuXHJcbiAqICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogICAgXCJwcmlvcml0eVwiOiBzZnggfCBpbnRlcnJ1cHQgfCBxdWV1ZSB8IHN0b3AgfCBzdG9wYWxsIHwgbG93XHJcbiAqfSxcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIEF1ZGlvQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwiYXVkaW9cIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSB0aGlzLmRhdGEuYXVkaW87XHJcbiAgICAgICAgICAgIC8vIEFsbG93IGEgc2luZ2xlIHN0cmluZyB0aHJvdWdoLlxyXG4gICAgICAgICAgICBpZiggdHlwZW9mIHRoaXMuYXVkaW8gPT09ICdzdHJpbmcnICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpbyA9IFsgdGhpcy5hdWRpbyBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9JbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUN1cnJlbnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXlDdXJyZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYXVkaW9JbmRleCA+ICh0aGlzLmF1ZGlvLmxlbmd0aC0xKSApIHtcclxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiU2V0dGluZyBhdWRpbyBzcHJpdGUgdmFyaWFibGVcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IFwicGxheWVkXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXVkaW9LZXkgPSB0aGlzLmF1ZGlvW3RoaXMuYXVkaW9JbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKHsgYXVkaW86IGF1ZGlvS2V5LCBrZXk6IG51bGwsIHByaW9yaXR5OiB0aGlzLmRhdGEucHJpb3JpdHl9ICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2hTdG9wOiBmdW5jdGlvbiggc3BlZWNoICkge1xyXG4gICAgICAgICAgICAvLyBsb2cud2FybihcIk9uIGdhbWUgc3BlZWNoIHJlYWNoZWQgYXVkaW8gYWN0b3I6IFwiICsgc3BlZWNoKTtcclxuICAgICAgICAgICAgaWYoIHNwZWVjaCA9PT0gdGhpcy5hdWRpb1t0aGlzLmF1ZGlvSW5kZXhdICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlDdXJyZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQXVkaW9BY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgU3lkIEdyb3NjbGF1ZGVcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA5LzIzLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgYmxvY2tlciBhY3Rvci4gVGhpcyBhY3RvciBjYW4gYmUgdXNlZCB0byBibG9jayBpbnB1dCBldmVudHMgZnJvbSB0aGUgYWN0b3JzIGJlaGluZCBpdC5cclxuICpcclxuICogQ3JlYXRpbmcgYSBibG9ja2VyIGFjdG9yOlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJhbGVydEJsb2NrZXJcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiYmxvY2tlclwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyAwLCAwIF0sIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIFswLDBdOyB3aGVyZSBvbiB0aGUgc2NyZWVuIHRvIHBsYXkgdGhpcyBhY3RvclxyXG4gKiAgICAgXCJzaXplXCI6IFsgODAwLCA2MDAgXSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgW2dhbWUud29ybGQud2lkdGgsZ2FtZS53b3JsZC5oZWlnaHRdIGhvdyBsYXJnZVxyXG4gKiAgICAgXCJibG9ja2VyVGludFwiIDogXCIweDAwMDAwMFwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBibGFjayAoMHgwMDAwMDApXHJcbiAqICAgICBcImJsb2NrZXJBbHBoYVwiIDogMC41LCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAwLjVcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICAgdmFyIEJsb2NrZXJBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGlzIG5vdyBpbiBiYXNlIGNsYXNzIVxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyWCA9ICh0eXBlb2YgdGhpcy5kYXRhLmxvY2F0aW9uID09PSAndW5kZWZpbmVkJykgPyAwIDogdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlclkgPSAodHlwZW9mIHRoaXMuZGF0YS5sb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJXaWR0aCA9ICh0eXBlb2YgdGhpcy5kYXRhLnNpemUgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZ2FtZS53b3JsZC53aWR0aCA6IHRoaXMuZGF0YS5zaXplWzBdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlckhlaWdodCA9ICh0eXBlb2YgdGhpcy5kYXRhLnNpemUgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgOiB0aGlzLmRhdGEuc2l6ZVsxXTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJUaW50ID0gKHR5cGVvZiB0aGlzLmRhdGEuYmxvY2tlclRpbnQgPT09ICd1bmRlZmluZWQnKSA/IDB4MDAwMDAwIDogdGhpcy5kYXRhLmJsb2NrZXJUaW50O1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlckFscGhhID0gKHR5cGVvZiB0aGlzLmRhdGEuYmxvY2tlckFscGhhID09PSAndW5kZWZpbmVkJykgPyAwLjUgOiB0aGlzLmRhdGEuYmxvY2tlckFscGhhO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwKTtcclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuYWRkQ2hpbGQoZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoIGJsb2NrZXJUaW50LCBibG9ja2VyQWxwaGEgKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoIGJsb2NrZXJYLCBibG9ja2VyWSwgYmxvY2tlcldpZHRoLCBibG9ja2VySGVpZ2h0ICk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmJsb2NrZXJTcHJpdGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGREZWJ1Z0JveCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRGVidWdCb3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggd2luZG93LmlzRGVidWdnaW5nICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveCA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lLCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmJlZ2luRmlsbCgweDAwMDAwMCwgMS4wKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZHJhd1JlY3QoMCwgMCwgdGhpcy5kYXRhLnNpemVbMF0sIHRoaXMuZGF0YS5zaXplWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmRlYnVnQm94KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5ibG9ja2VyU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGVidWdCb3ggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJsb2NrZXJBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgWmFjayBiaWVybmF0XHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNC8xOC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJ1dHRvbi1jaGFyYWN0ZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdGluZyBhIGNoYXJhY3RlciwgYW5kIGNhbiBiZVxyXG4gKiB1c2VkIGZvciBhbmltYXRpbmcgYSBjaGFyYWN0ZXIgdGhhdCBpcyB0YWxraW5nIChwcm92aWRlIG1vdXRoIGFuaW1hdGlvbikuIEl0IGlzIGRpZmZlcmVudGlhdGVkIGZyb20gdGhlXHJcbiAqIE5vSW5wdXRDaGFyYWN0ZXIgQWN0b3IgYnkgYWxsb3dpbmcgdGhlIGltYWdlIGZpZWxkIHRvIGFjY2VzcyBcImJ1dHRvbnNcIiBmcm9tIHRoZSB0aGVtZSBpbnN0ZWFkIG9mIFwiYWN0b3JJbWFnZXNcIi5cclxuICogVGhpcyBhbGxvd3MgYnV0dG9uLWxpa2UgYmVoYXZpb3IgZm9yIHRoZSBncmFwaGljLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGJ1dHRvbi1jaGFyYWN0ZXIgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm1hbmR5XCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImJ1dHRvbi1jaGFyYWN0ZXJcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwibWFuZHlcIiwgLy8gdGhlIGJ1dHRvbiBpbWFnZSB0byB1c2UgZnJvbSB0aGUgdGhlbWUgKHNob3VsZCBpbmNsdWRlIFwidXBcIiwgXCJkb3duXCIsIFwib3ZlclwiLCBcIm91dFwiKS5cclxuICogICAgIFwic3BlZWNoQW5pbWF0aW9uXCI6IHRydWV8ZmFsc2UsIC8vIGlmIHRoZXJlIGlzIGEgc3BlZWNoIGFuaW1hdGlvbi5cclxuICogICAgIFwiZnJhbWVSYXRlXCI6IDI0IC8vIG9wdGlvbmFsIGZyYW1lIHJhdGUgZm9yIHRoZSBzcGVlY2ggYW5pbWF0aW9uLCBkZWZhdWx0cyB0byAxMC5cclxuICogICAgIFwibG9jYXRpb25cIjogWyAyMDAsIDIwMCBdLCAvLyB3aGVyZSBvbiB0aGUgc2NyZWVuIHRvIHBsYXkgdGhpcyBhY3RvclxyXG4gKiAgICAgXCJzaXplXCI6IFsgdywgaCBdLCAvLyBwcm92aWRlIHRoaXMgaWYgeW91IGRvIG5vdCBwcm92aWRlIGFuIGltYWdlLlxyXG4gKiAgICAgXCJzcGVlY2hBdWRpb1wiOiBcIjZ0aF8wMVwiLCAvLyBUaGUgYWN0b3Igc2hvdWxkIGFuaW1hdGUgdGhpcyBwaWVjZSBvZiBhdWRpby5cclxuICogICAgIFwia2V5XCI6IFwibWFuZHlcIiwgLy8gb3B0aW9uYWwgYXVkaW8ga2V5LCBpZiBub3QgcHJlc2VudCwgbmFtZSB3aWxsIGJlIHVzZWQuXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwiY2hhcmFjdGVyXzJcIiwgLy8gaWYgeW91IGNsaWNrIHRoaXMgY2hhcmFjdGVyLCB0aGUgdmFyaWFibGUgJ2NoYXJhY3Rlcl8yJyB3aWxsIGJlIHNldCB0byAnbWFuZHknLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqICBJZiB5b3Ugc2V0IHNwZWVjaEFuaW1hdGlvbiB0byB0cnVlLCAtdGFsayBtdXN0IGJlIGFwcGVuZGVkIHRvIHRoZSBidXR0b24tY2hhcmFjdGVyJ3MgaW1hZ2UgbmFtZSB0byBkaWZmZXJlbnRpYXRlXHJcbiAqICBmcm9tIHRoZSBub24tc3BlYWtpbmcgdmVyc2lvbiAod2hpY2ggbWF5IGhhdmUgYSBkaWZmZXJlbnQgbW91dGggZ3JhcGhpYyEpXHJcbiAqXHJcbiAqICBGb3IgdGhlIHNwZWVjaCBhbmltYXRpb25zIHRvIHdvcmssIHlvdSdsbCBuZWVkIGEgc3BlZWNoQW5pbWF0aW9ucyBzZWN0aW9uIGluIHRoZSB0aGVtZS5qc29uLCB3aGljaCBzcGVjaWZpZXNcclxuICogIHNwZWFraW5nLWFuaW1hdGlvbiBpbWFnZXMgYW5kIGxvY2F0aW9uIG9mZnNldHMgZm9yIHRoZSBtb3V0aDpcclxuICpcclxuICogICBcInNwZWVjaEFuaW1hdGlvbnNcIjoge1xyXG4gKiAgICBcImphbmVsbGVcIjoge1xyXG4gKiAgICAgIFwiaW1hZ2VzXCI6IFtcInRhbGtpbmctamFuZWxsZS1tb3V0aDEucG5nXCIsIFwidGFsa2luZy1qYW5lbGxlLW1vdXRoMS5wbmdcIiwgXCJ0YWxraW5nLWphbmVsbGUtbW91dGgyLnBuZ1wiXSxcclxuICogICAgICBcIm1vdXRoT2Zmc2V0XCI6IFs2NSwgMTY1XSAgIC8vIHdoZXJlIHdpdGhpbiB0aGUgYWN0b3IgXCItdGFsa1wiIGltYWdlIHRvIHBsYWNlIHRoZSBhbmltYXRpb25cclxuICogICAgfVxyXG4gKlxyXG4gKiAgVGhlcmUgbXVzdCBhZGRpdGlvbmFsbHkgYmUgXCJTb3VuZCBTeW5jIERhdGFcIiwgZGVmaW5pbmcgd2hpY2ggaW1hZ2UgdG8gc2hvdy4uLlxyXG4gKlxyXG4gKiBcInNvdW5kU3luY0RhdGFcIjoge1xyXG4gKiAgIFwiNnRoXzAxXCI6IFtcclxuICogICAgIDAsMSwxLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwxLDAsMSwxLDAsMCwwLDAsMSwxXHJcbiAqICAgXSwgLi4uXHJcbiAqIH1cclxuICpcclxuICogIFRoZSAwcyBhbmQgMXMgcmVwcmVzZW50IHdoaWNoIGltYWdlLCBhbmQgY291bGQgYmUgMCwxLDIsMyBldGMgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAyLiBUaGV5IGtleSBzaG91bGQgbWF0Y2hcclxuICogIHRoZSBcInNwZWVjaEF1ZGlvXCIgb2YgdGhpcyBhY3RvciBhcyB3ZWxsIGFzIHRoZSBhdWRpbyBiZWluZyBwbGF5ZWQuXHJcbiAqICBOT1RFOiBNb3N0IG9mIHRoZSBzcGVlY2hTeW5jRGF0YSBkb2VzIG5vdCBjb250YWluICcxJ3MgYW5kIGxvb2tzIGxpa2UgWzAsMCwyLDMsMywzLDIsMCwyLDMsMiwwLDAsMCwyLDMsNCw0LDMsNCwyLDBdLlxyXG4gKiAgSW4gdGhpcyBjYXNlIGl0IGlzIGFkdmlzZWQgdG8gdXNlIHRoZSBbQSwgQiwgQiwgQywgRF0gcGF0dGVybiBmb3IgdGhlIGRpZmZlcmVudCBmcmFtZXMgaW4geW91ciB0aGVtZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0dmFyIF8gPSByZXF1aXJlKFwibG9kYXNoXCIpLFxyXG5cdFx0bG9nID0gcmVxdWlyZShcImxvZ2xldmVsXCIpLFxyXG5cdFx0QWN0b3IgPSByZXF1aXJlKFwiLi9hY3RvclwiKTtcclxuXHJcblx0dmFyIEJ1dHRvbkNoYXJhY3RlckFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuXHRcdC8vIGNvbnN0cnVjdG9yIGlzIG5vdyBpbiBiYXNlIGNsYXNzIVxyXG5cdFx0ZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmJ1aWxkQWN0b3IoKTtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5zcGVlY2hBbmltYXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZFNwZWVjaEFuaW1hdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Z2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIFtcImxvY2F0aW9uXCIsIFwidmFyaWFibGVcIl07XHJcblx0XHR9LFxyXG5cdFx0YnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgaW1hZ2VJZCA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKTtcclxuXHRcdFx0aWYgKGltYWdlSWQpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLnNwZWVjaEFuaW1hdGlvbikge1xyXG5cdFx0XHRcdFx0aW1hZ2VJZCArPSBcIi10YWxrXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5idXR0b24oXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMV0sXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcblx0XHRcdFx0XHR0aGlzLm9uQ2xpY2ssXHJcblx0XHRcdFx0XHR0aGlzLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZV0ub3ZlcixcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLm91dCxcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLmRvd24sXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS51cFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmRhdGEuc2NhbGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuc3ByaXRlLnNjYWxlLnNldFRvKHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbihcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSxcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuXHRcdFx0XHRcdHRoaXMub25DbGljayxcclxuXHRcdFx0XHRcdHRoaXMsXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5vdmVyLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZV0ub3V0LFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZV0uZG93bixcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLnVwXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS53aWR0aCA9IHRoaXMuZGF0YS5zaXplWzBdO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmhlaWdodCA9IHRoaXMuZGF0YS5zaXplWzFdO1xyXG5cdFx0XHRcdHRoaXMuYWRkRGVidWdCb3goKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IENQVS9leHBlbnNpdmUgdGhpbmdzIHlvdSBjYW4gZG8gaW4gcGhhc2VyLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy5zcHJpdGUuaW5wdXQucGl4ZWxQZXJmZWN0T3ZlciA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdGFkZERlYnVnQm94OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh3aW5kb3cuaXNEZWJ1Z2dpbmcpIHtcclxuXHRcdFx0XHR0aGlzLmRlYnVnQm94ID0gbmV3IFBoYXNlci5HcmFwaGljcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2FtZSxcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSxcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblsxXVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcblx0XHRcdFx0dGhpcy5kZWJ1Z0JveC5kcmF3UmVjdCgwLCAwLCB0aGlzLmRhdGEuc2l6ZVswXSwgdGhpcy5kYXRhLnNpemVbMV0pO1xyXG5cdFx0XHRcdHRoaXMuZGVidWdCb3guZW5kRmlsbCgpO1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRhZGRTcGVlY2hBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGFTcGVlY2hBbmltYXRpb24gPVxyXG5cdFx0XHRcdHRoaXMudGhlbWUuc3BlZWNoQW5pbWF0aW9uc1tcclxuXHRcdFx0XHRcdHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKVxyXG5cdFx0XHRcdF07XHJcblx0XHRcdGlmICghYVNwZWVjaEFuaW1hdGlvbikge1xyXG5cdFx0XHRcdGxvZy5lcnJvcihcclxuXHRcdFx0XHRcdFwiQ291bGQgbm90IGFkZCBzcGVlY2ggYW5pbWF0aW9uIGZvciBjaGFyYWN0ZXI6IFwiICsgdGhpcy5kYXRhLm5hbWVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGxvZy5lcnJvcihcIlNwZWVjaCBhbmltYXRpb24gbm90IGZvdW5kIGZvciBcIiArIHRoaXMuZGF0YS5pbWFnZSk7XHJcblx0XHRcdFx0bG9nLmVycm9yKFxyXG5cdFx0XHRcdFx0XCJDaGVjayB0aGF0IHlvdSBoYXZlIGEgc3BlZWNoQW5pbWF0aW9ucyBzZWN0aW9uIGluIHlvdXIgdGhlbWUuXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNwZWVjaEFuaW1hdGlvbiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKFxyXG5cdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSArIGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0sXHJcblx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzFdICsgYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSxcclxuXHRcdFx0XHR0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcblx0XHRcdFx0YVNwZWVjaEFuaW1hdGlvbi5pbWFnZXNbMF1cclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24uYW5pbWF0aW9ucy5hZGQoXCJ0YWxrXCIsIGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzKTtcclxuXHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb25TZXQgPSBhU3BlZWNoQW5pbWF0aW9uLmltYWdlcztcclxuXHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb25EZWZhdWx0ID0gYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXNbMF07XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnNjYWxlKSB7XHJcblx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24uc2NhbGUuc2V0VG8oXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEuc2NhbGVbMF0sXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEuc2NhbGVbMV1cclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uLnggPVxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzBdICtcclxuXHRcdFx0XHRcdGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0gKiB0aGlzLmRhdGEuc2NhbGVbMF07XHJcblx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24ueSA9XHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMV0gK1xyXG5cdFx0XHRcdFx0YVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSAqIHRoaXMuZGF0YS5zY2FsZVsxXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG5cdFx0XHR2YXIgYXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5hdWRpbyk7XHJcblx0XHRcdGlmIChzcGVlY2gua2V5KSB7XHJcblx0XHRcdFx0YXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5rZXkpICsgXCJfXCIgKyBhdWRpbztcclxuXHRcdFx0fVxyXG5cdFx0XHRsb2cud2FybihcIk9uIGdhbWUgc3BlZWNoOiBcIiArIGF1ZGlvKTtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uICYmXHJcblx0XHRcdFx0dGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhICYmXHJcblx0XHRcdFx0dGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhW2F1ZGlvXSAmJlxyXG5cdFx0XHRcdHRoaXMuZGF0YS5zcGVlY2hBdWRpbyA9PT0gYXVkaW9cclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhpcy5zb3VuZFN5bmNEYXRhID0gdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhW2F1ZGlvXTtcclxuXHRcdFx0XHRpZiAoIXRoaXMudGltZXIpIHtcclxuXHRcdFx0XHRcdHZhciBGUkFNRV9SQVRFID0gdGhpcy5kYXRhLmZyYW1lUmF0ZSA/IHRoaXMuZGF0YS5mcmFtZVJhdGUgOiAxMDtcclxuXHRcdFx0XHRcdHRoaXMudGltZXIgPSB0aGlzLmdhbWUudGltZS5jcmVhdGUoZmFsc2UpO1xyXG5cdFx0XHRcdFx0dGhpcy5zcGVlY2hJbmRleCA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWVyLmxvb3AoMTAwMCAvIEZSQU1FX1JBVEUsIHRoaXMuaW5jcmVtZW50U3BlZWNoLCB0aGlzKTtcclxuXHRcdFx0XHRcdHRoaXMudGltZXIuc3RhcnQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRpbmNyZW1lbnRTcGVlY2g6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuc291bmRTeW5jRGF0YSkge1xyXG5cdFx0XHRcdHRoaXMuc3BlZWNoSW5kZXgrKztcclxuXHRcdFx0XHR0aGlzLnNwZWVjaEFuaW1hdGlvbi5mcmFtZU5hbWUgPVxyXG5cdFx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb25TZXRbdGhpcy5zb3VuZFN5bmNEYXRhW3RoaXMuc3BlZWNoSW5kZXhdXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uR2FtZVNwZWVjaFN0b3A6IGZ1bmN0aW9uIChzcGVlY2gpIHtcclxuXHRcdFx0aWYgKHRoaXMuc3BlZWNoQW5pbWF0aW9uICYmIHRoaXMuc291bmRTeW5jRGF0YSkge1xyXG5cdFx0XHRcdHRoaXMudGltZXIuc3RvcCgpO1xyXG5cdFx0XHRcdHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG5cdFx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xyXG5cdFx0XHRcdHRoaXMuc291bmRTeW5jRGF0YSA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25EZWZhdWx0O1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0b25DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSB0aGlzLmRhdGEubmFtZTtcclxuXHRcdFx0dGhpcy5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuXHRcdH0sXHJcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5zcGVlY2hBbmltYXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVjaEFuaW1hdGlvbi5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuZGVidWdCb3gpIHtcclxuXHRcdFx0XHR0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy50aW1lcikge1xyXG5cdFx0XHRcdHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBCdXR0b25DaGFyYWN0ZXJBY3RvcjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJ1dHRvbiBhY3Rvci4gVGhpcyBhY3RvciBjYW4gYmUgdXNlZCBmb3Igc2ltcGxlIGFjdGlvbnMsIHN1Y2ggYXMgb3BlbmluZyB0aGUgY2VsbCBwaG9uZS4gSW4gbWFueSAncGxheXMnLCB0aGlzIGFjdG9yc1xyXG4gKiBpc24ndCBuZWVkZWQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgYnV0dG9uIGFjdG9yOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwaG9uZTFcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiYnV0dG9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZVwiOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGJ1dHRvbiBzZWN0aW9uIG9mIHRoZSB0aGVtZS5cclxuICogICAgIFwiYXVkaW9cIjogXCJyaW5nXCIsIC8vIGFuIG9wdGlvbmFsIHNvdW5kIHRvIHBsYXkgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuIERvbid0IHBsYXkgbG9uZyBhdWRpbyEqKipcclxuICogICAgIFwic2Z4XCI6IHtcclxuICogICAgICAgIFwib3ZlclwiOiBcImRpbmdcIiAvLyBvcHRpb25hbCBzb3VuZHMgdG8gcGxheSBvbiB1cC9vdmVyL2Rvd24vb3V0LiBBZGQgc3VwcG9ydCBhcyBuZWVkZWQuIE92ZXIgYWRkZWQuXHJcbiAqICAgICB9LFxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSxcclxuICogICAgIFwidmFyaWFibGVcIjogXCJzaG93X2NlbGxfcGhvbmVcIiAvLyBpZiB5b3Ugb3BlbiB0aGUgcGhvbmUsIHRoZSB2YXJpYWJsZSAnc2hvd19jZWxsX3Bob25lJyB3aWxsIGJlIHNldCB0byAncGhvbmUxJy5cclxuICogICAgIFwiYW5pbWF0ZWRcIjogXCJ0cnVlXCIsIC8vIG9wdGlvbmFsOyB0aGVtZS5idXR0b25BbmltYXRpb25zLjxpbWFnZT4gaXRlbSBuYW1lIGNvbnRhaW5pbmcgYSBsaXN0IG9mIGltYWdlc1xyXG4gKiAgICAgXCJhbmltYXRpb25GcmFtZVJhdGVcIjogMzAsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIDMwIGZwczsgaWdub3JlZCBpZiBhbmltYXRlZCBpcyBub3QgdHJ1ZVxyXG4gKiAgICAgXCJhbmltYXRpb25Mb29wXCI6IFwidHJ1ZVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZTsgaWdub3JlZCBpZiBhbmltYXRlZCBpcyBub3QgdHJ1ZVxyXG4gKiAgICAgXCJhbmltYXRpb25SZXBlYXRcIjogNDAwMCwgLy8gb3B0aW9uYWwsIHRpbWUgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyBubyByZXBlYXQ7IG92ZXJyaWRlcyBhbmltYXRpb25Mb29wIGlmIGJvdGggYXJlIHNwZWNpZmllZDsgaWdub3JlZCBpZiBhbmltYXRlZCBpcyBub3QgdHJ1ZVxyXG4gKiAgICAgXCJhbHBoYVwiOiAwLjQgLy8gb3B0aW9uYWwsIG9wYWNpdHkgY29lZmZpY2llbnRcclxuICogICAgIC8vIG9wdGlvbmFsIFwic2NhbGVcIjogWyAxLjEsIDEuMSBdLCAvLyBVc2UgbmVnYXRpdmUgc2NhbGVzIHRvICdmbGlwJyB0aGUgaW1hZ2VzLlxyXG4gKiAgICAgLy8gb3B0aW9uYWwgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kOyBpdCBpcyBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICogICoqKiBJZiB5b3Ugd2FudCB0byBwbGF5IGxvbmcgYXVkaW8gb24gYSBidXR0b24sIHVzZSBhbiBldmVudCBhbmQgYWRkIHRoZSBhdWRpbyBhY3Rvci4gVGhpcyBpcyBtZWFudCBmb3IgdGhpbmdzIGxpa2VcclxuICogICAgICBjbGlja3MgYW5kIGJlZXBzIHRoYXQgcGxheSBmb3IgYWJvdXQgYSBzZWNvbmQuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKSxcclxuICAgICAgICBUd2VlbkhlbHBlciA9IHJlcXVpcmUoXCIuL3R3ZWVuLWhlbHBlclwiKTtcclxuXHJcbiAgICB2YXIgQlVUVE9OX1RJTUVPVVQgPSAyMDA7IC8vIFVzZSB0aGlzIHNvIHRoZSBhdWRpbyBoYXMgYSBjaGFuY2UgdG8gcGxheS5cclxuXHJcbiAgICB2YXIgQnV0dG9uQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBpbiBwYXJlbnQuXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLmJ1dHRvbnMgfHwgIXRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJCdXR0b24gQWN0b3IgcmVxdWlyZXMgYnV0dG9ucyBlbnRyeSBpbiB0aGVtZSwgd2l0aCBzcGVjaWZpYyBlbnRyeSBtYXRjaGluZyBcIiArIHRoaXMuZGF0YS5pbWFnZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IDAsXHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmKCB4ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHkgPT09IFwiY2VudGVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclk7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gMC41O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmFuY2hvciA9PT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmFuY2hvciA9PT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hbmNob3IgKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gdGhpcy5kYXRhLmFuY2hvclswXTtcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSB0aGlzLmRhdGEuYW5jaG9yWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB4LHksIHRoaXMuZ2V0VGV4dHVyZUtleSh0aGlzLmRhdGEpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25Jc0FuaW1hdGVkID0gKCB0eXBlb2YgdGhpcy5kYXRhLmFuaW1hdGVkICE9PSBcInVuZGVmaW5lZFwiICkgJiYgKCB0aGlzLmRhdGEuYW5pbWF0ZWQgPT09IHRydWUgKTtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJ1dHRvbklzQW5pbWF0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLmFkZCh0aGlzLmRhdGEuaW1hZ2UsIHRoaXMudGhlbWUuYnV0dG9uQW5pbWF0aW9uc1t0aGlzLmRhdGEuaW1hZ2VdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVSYXRlID0gKCB0eXBlb2YgdGhpcy5kYXRhLmFuaW1hdGlvbkZyYW1lUmF0ZSAhPT0gXCJ1bmRlZmluZWRcIiApID8gdGhpcy5kYXRhLmFuaW1hdGlvbkZyYW1lUmF0ZSA6IDMwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb29wQW5pbWF0aW9uID0gKCB0eXBlb2YgdGhpcy5kYXRhLmFuaW1hdGlvbkxvb3AgIT09IFwidW5kZWZpbmVkXCIgKSA/IHRoaXMuZGF0YS5hbmltYXRpb25Mb29wIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblJlcGVhdCA9ICggdHlwZW9mIHRoaXMuZGF0YS5hbmltYXRpb25SZXBlYXQgIT09IFwidW5kZWZpbmVkXCIgKSA/IHRoaXMuZGF0YS5hbmltYXRpb25SZXBlYXQgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmFuaW1hdGlvblJlcGVhdCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb29wQW5pbWF0aW9uID0gZmFsc2U7IC8vIHRpbWVkIHJlcGVhdCBvdmVycmlkZXMgbG9vcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZXJFdmVudCA9IHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5sb29wKCB0aGlzLmFuaW1hdGlvblJlcGVhdCwgdGhpcy5hbmltYXRlQnV0dG9uLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVCdXR0b24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24uYW5jaG9yLnNldFRvKCBhbmNob3JYLCBhbmNob3JZICk7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uYWxwaGEgPSB0aGlzLmRhdGEuYWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZTtcclxuICAgICAgICAgICAgdmFyIHRleHRYID0gdGhpcy5idXR0b24ud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgdGV4dFkgPSB0aGlzLmJ1dHRvbi5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gWzAuNSwgMC40NV07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR0pGIC0gdGhpcyB3YXMgYWxyZWFkeSBoZXJlIGFuZCBJIGRvbid0IHdhbnQgdG8gYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIHNvIEknbSBhZGRpbmcgYVxyXG4gICAgICAgICAgICAgKiBcInRleHREYXRhXCIgc2VjdGlvbiBiZWxvdy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIGZvbnROYW1lID0gdGhpcy5kYXRhLmZvbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5nZXRGb250KCh0eXBlb2YgZm9udE5hbWUgIT09ICd1bmRlZmluZWQnKSA/IGZvbnROYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnRleHQodGV4dFgsIHRleHRZLCB0aGlzLmRhdGEudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dERhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dERhdGEgPSB0aGlzLmRhdGEudGV4dERhdGE7XHJcbiAgICAgICAgICAgICAgICBmb250TmFtZSA9IHRleHREYXRhLmZvbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5nZXRGb250KCh0eXBlb2YgZm9udE5hbWUgIT09ICd1bmRlZmluZWQnKSA/IGZvbnROYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIHRleHREYXRhLnRleHRYICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRYID0gdGV4dERhdGEudGV4dFg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdGV4dERhdGEudGV4dFkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFkgPSB0ZXh0RGF0YS50ZXh0WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCB0ZXh0RGF0YS5hbmNob3IgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gdGV4dERhdGEuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRleHRYLCB0ZXh0WSwgdGV4dERhdGEudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnRleHRTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUuYW5jaG9yLnNldFRvKCBhbmNob3JbMF0sIGFuY2hvclsxXSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkQ2hpbGQodGhpcy50ZXh0U3ByaXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b24ub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZU92ZXIsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS50d2VlbiApIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMudHdlZW5IZWxwZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2VlbkhlbHBlciA9IG5ldyBUd2VlbkhlbHBlcih0aGlzLmdhbWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50d2VlbkhlbHBlci5hZGRUd2VlbnModGhpcy5kYXRhLnR3ZWVuLCB0aGlzLmJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXh0U3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2VlbkhlbHBlci5hZGRUd2VlbnModGhpcy5kYXRhLnR3ZWVuLCB0aGlzLnRleHRTcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zZnggJiYgdGhpcy5kYXRhLnNmeC5vdmVyICkge1xyXG4gICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLmRhdGEuc2Z4Lm92ZXIsIFwicHJpb3JpdHlcIjogXCJzZnhcIiB9O1xyXG4gICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmltYXRlQnV0dG9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJ1dHRvbklzQW5pbWF0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnBsYXkodGhpcy5kYXRhLmltYWdlLCB0aGlzLmFuaW1hdGlvbkZyYW1lUmF0ZSwgdGhpcy5sb29wQW5pbWF0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy5kYXRhLmF1ZGlvLCBcInByaW9yaXR5XCI6IFwic2Z4XCIgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXJTZXRbdGhhdC5kYXRhLnZhcmlhYmxlXSA9IHRoYXQuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKCB0aGF0LmRhdGEubmFtZSwgdmFyU2V0ICk7XHJcblxyXG4gICAgICAgICAgICB9LCBCVVRUT05fVElNRU9VVCk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy50d2VlbkhlbHBlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWVuSGVscGVyLnJlbW92ZVR3ZWVucyh0aGlzLmJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB0aGlzLmFuaW1hdGlvblRpbWVyRXZlbnQgIT0gJ3VuZGVmaW5lZCcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLnRpbWUuZXZlbnRzLnJlbW92ZSggdGhpcy5hbmltYXRpb25UaW1lckV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMudGV4dFNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aGlzLnR3ZWVuSGVscGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIucmVtb3ZlVHdlZW5zKHRoaXMudGV4dFNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQnV0dG9uQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBjaGFyYWN0ZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdGluZyBhIGNoYXJhY3RlciAoY2xpY2thYmxlIHdpdGggdGV4dCBidWJibGUpLCBvciBjYW4gYmVcclxuICogdXNlZCBmb3IgYW5pbWF0aW5nIGEgY2hhcmFjdGVyIHRoYXQgaXMgdGFsa2luZyAocHJvdmlkZSBtb3V0aCBhbmltYXRpb24pXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgY2hhcmFjdGVyIGFjdG9yOlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJtYW5keVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJjaGFyYWN0ZXJcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwibWFuZHlcIiwgLy8gdGhlIGltYWdlIHRvIHVzZSBmcm9tIHRoZSB0aGVtZS5cclxuICogICAgIFwic3BlZWNoQW5pbWF0aW9uXCI6IHRydWV8ZmFsc2UsIC8vIGlmIHRoZXJlIGlzIGEgc3BlZWNoIGFuaW1hdGlvbi5cclxuICogICAgIFwibG9jYXRpb25cIjogWyAyMDAsIDIwMCBdLCAvLyB3aGVyZSBvbiB0aGUgc2NyZWVuIHRvIHBsYXkgdGhpcyBhY3RvclxyXG4gKiAgICAgXCJzaXplXCI6IFsgdywgaCBdLCAvLyBwcm92aWRlIHRoaXMgaWYgeW91IGRvIG5vdCBwcm92aWRlIGFuIGltYWdlLlxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiTWFuZHlcIiwgLy8gd2hhdCB0byBwdXQgaW4gYSB0ZXh0IGJ1YmJsZSBkdXJpbmcgbW91c2Ugb3Zlci5cclxuICogICAgIFwiYXVkaW9cIjogXCI2dGhfMDFcIiwgLy8gb3B0aW9uYWwgYXVkaW8gdG8gc3BlYWsgb24gbW91c2Ugb3Zlci5cclxuICogICAgIFwia2V5XCI6IFwibWFuZHlcIiwgLy8gb3B0aW9uYWwgYXVkaW8ga2V5LCBpZiBub3QgcHJlc2VudCwgbmFtZSB3aWxsIGJlIHVzZWQuXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwiY2hhcmFjdGVyXzJcIiwgLy8gaWYgeW91IGNsaWNrIHRoaXMgY2hhcmFjdGVyLCB0aGUgdmFyaWFibGUgJ2NoYXJhY3Rlcl8yJyB3aWxsIGJlIHNldCB0byAnbWFuZHknLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKlxyXG4gKiB9XHJcbiAqXHJcbiAqICBJZiB5b3Ugc2V0IHNwZWVjaEFuaW1hdGlvbiB0byB0cnVlLCAtdGFsayB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjaGFyYWN0ZXJzIGltYWdlIG5hbWUuXHJcbiAqIHNwZWVjaEFuaW1hdGlvbi9zcGVlY2hMb2NhdGlvbiBhcmUgb3B0aW9uYWwuXHJcbiAqXHJcbiAqIFNlZSBhbHNvIHRoZW1lLmpzb24ncyBzcGVlY2hBbmltYXRpb25zLCB3aGljaCBzcGVjaWZ5IHNwZWFraW5nLWFuaW1hdGlvbiBpbWFnZXMgYW5kIGxvY2F0aW9uIG9mZnNldHM6XHJcbiAqXHJcbiAqICAgXCJzcGVlY2hBbmltYXRpb25zXCI6IHtcclxuICogICAgXCJqYW5lbGxlXCI6IHtcclxuICogICAgICBcImltYWdlc1wiOiBbXCJ0YWxraW5nLWphbmVsbGUtbW91dGgxLnBuZ1wiLCBcInRhbGtpbmctamFuZWxsZS1tb3V0aDEucG5nXCIsIFwidGFsa2luZy1qYW5lbGxlLW1vdXRoMi5wbmdcIl0sXHJcbiAqICAgICAgXCJtb3V0aE9mZnNldFwiOiBbNjUsIDE2NV0gICAvLyB3aGVyZSB3aXRoaW4gdGhlIGFjdG9yIFwiLXRhbGtcIiBpbWFnZSB0byBwbGFjZSB0aGUgYW5pbWF0aW9uXHJcbiAqICAgIH1cclxuICpcclxuICogIFlvdXIgdGhlbWUgc2hvdWxkIGhhdmUgYSAnYnViYmxlVGV4dFdpZHRoJyBlbnRyeSB0byBzcGVjaWZ5IGhvdyB3aWRlIHRvIG1ha2UgdGhlIHRleHQgYnViYmxlLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpO1xyXG5cclxuXHR2YXIgQ2hhcmFjdGVyQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG5cdFx0Ly8gY29uc3RydWN0b3IgaXMgbm93IGluIGJhc2UgY2xhc3MhXHJcblx0XHRlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuYnVpbGRBY3RvcigpO1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnRleHQpIHtcclxuXHRcdFx0XHR0aGlzLmFkZFRleHRCb3goKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnNwZWVjaEFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkU3BlZWNoQW5pbWF0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gW1wibG9jYXRpb25cIl07XHJcblx0XHR9LFxyXG5cdFx0YnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgaW1hZ2VJZCA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKTtcclxuXHRcdFx0aWYgKGltYWdlSWQpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLnNwZWVjaEFuaW1hdGlvbikge1xyXG5cdFx0XHRcdFx0aW1hZ2VJZCArPSBcIi10YWxrXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMV0sXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcblx0XHRcdFx0XHR0aGlzLmdldEltYWdlKGltYWdlSWQsIFwiYWN0b3JJbWFnZXNcIilcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLnNjYWxlKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyh0aGlzLmRhdGEuc2NhbGVbMF0sIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMV1cclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLndpZHRoID0gdGhpcy5kYXRhLnNpemVbMF07XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcblx0XHRcdFx0dGhpcy5hZGREZWJ1Z0JveCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnRleHQpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZUluLCB0aGlzKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ldmVudHMub25JbnB1dE91dC5hZGQodGhpcy5vbk1vdXNlT3V0LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuZXZlbnRzLm9uSW5wdXRVcC5hZGQodGhpcy5vblBvaW50ZXJVcCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLmRhdGEudGV4dCB8fCB0aGlzLmRhdGEudmFyaWFibGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IENQVS9leHBlbnNpdmUgdGhpbmdzIHlvdSBjYW4gZG8gaW4gcGhhc2VyLlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmlucHV0LnBpeGVsUGVyZmVjdE92ZXIgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGFkZERlYnVnQm94OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh3aW5kb3cuaXNEZWJ1Z2dpbmcpIHtcclxuXHRcdFx0XHR0aGlzLmRlYnVnQm94ID0gbmV3IFBoYXNlci5HcmFwaGljcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2FtZSxcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSxcclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblsxXVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcblx0XHRcdFx0dGhpcy5kZWJ1Z0JveC5kcmF3UmVjdCgwLCAwLCB0aGlzLmRhdGEuc2l6ZVswXSwgdGhpcy5kYXRhLnNpemVbMV0pO1xyXG5cdFx0XHRcdHRoaXMuZGVidWdCb3guZW5kRmlsbCgpO1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRhZGRUZXh0Qm94OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICghdGhpcy50aGVtZS5idWJibGVUZXh0V2lkdGgpIHtcclxuXHRcdFx0XHRsb2cuZXJyb3IoXHJcblx0XHRcdFx0XHRcIllvdSBtdXN0IHNwZWNpZnkgYSBidWJibGVUZXh0V2lkdGggaW4geW91ciB0aGVtZSB3aGVuIHVzaW5nIGNoYXJhY3RlciBsYWJlbHMuXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBib3hZID0gdGhpcy5zcHJpdGUuaGVpZ2h0IC8gNCxcclxuXHRcdFx0XHRib3hYID0gdGhpcy5zcHJpdGUud2lkdGggLyAyLFxyXG5cdFx0XHRcdGJveFdpZHRoID0gdGhpcy50aGVtZS5idWJibGVUZXh0V2lkdGgsXHJcblx0XHRcdFx0Zm9udCA9IHRoaXMuZ2V0Rm9udChcImJ1YmJsZUljb25cIiksXHJcblx0XHRcdFx0bGFiZWxYID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgYm94WCxcclxuXHRcdFx0XHRsYWJlbFkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV0gKyBib3hZO1xyXG5cclxuXHRcdFx0Zm9udC53b3JkV3JhcCA9IHRydWU7XHJcblx0XHRcdGZvbnQud29yZFdyYXBXaWR0aCA9IGJveFdpZHRoICogMC45O1xyXG5cclxuXHRcdFx0dmFyIHRleHQgPSBuZXcgUGhhc2VyLlRleHQoXHJcblx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdGJveFdpZHRoIC8gMixcclxuXHRcdFx0XHQxMCxcclxuXHRcdFx0XHR0aGlzLmRhdGEudGV4dCxcclxuXHRcdFx0XHRmb250XHJcblx0XHRcdCk7XHJcblx0XHRcdHRleHQuYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgYm94SGVpZ2h0ID0gdGV4dC5oZWlnaHQgKyAxMDtcclxuXHJcblx0XHRcdC8vIEFDVC0zNTMgSWYgaXQgaXMgb3ZlcmxhcHBpbmcgdGhlIGVkZ2Ugb2YgdGhlIHNjcmVlbiwgYWRqdXN0IHRoZSBsb2NhdGlvbi5cclxuXHRcdFx0aWYgKGxhYmVsWCArIGJveFdpZHRoICsgMyA+IHRoaXMuZ2FtZS53b3JsZC53aWR0aCkge1xyXG5cdFx0XHRcdGxhYmVsWCA9IHRoaXMuZ2FtZS53b3JsZC53aWR0aCAtIGJveFdpZHRoIC0gMztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGxhYmVsWSArIGJveEhlaWdodCArIDMgPiB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KSB7XHJcblx0XHRcdFx0bGFiZWxZID0gdGhpcy5nYW1lLndvcmxkLmhlaWdodCAtIGJveEhlaWdodCAtIDM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgbGFiZWxYLCBsYWJlbFkpO1xyXG5cdFx0XHR0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCgweDAwMDAwMCwgMS4wKTtcclxuXHRcdFx0dGhpcy5ncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoMywgMywgYm94V2lkdGgsIGJveEhlaWdodCwgOSk7XHJcblx0XHRcdHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cdFx0XHR0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCgweGZmZmZmZik7XHJcblx0XHRcdHRoaXMuZ3JhcGhpY3MuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJveFdpZHRoLCBib3hIZWlnaHQsIDkpO1xyXG5cdFx0XHR0aGlzLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuXHRcdFx0dGhpcy5ncmFwaGljcy52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ3JhcGhpY3MuYWRkQ2hpbGQodGV4dCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5ncmFwaGljcyk7XHJcblx0XHR9LFxyXG5cdFx0YWRkU3BlZWNoQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBhU3BlZWNoQW5pbWF0aW9uID1cclxuXHRcdFx0XHR0aGlzLnRoZW1lLnNwZWVjaEFuaW1hdGlvbnNbXHJcblx0XHRcdFx0XHR0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHRoaXMuZGF0YS5pbWFnZSlcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHRpZiAoIWFTcGVlY2hBbmltYXRpb24pIHtcclxuXHRcdFx0XHRsb2cuZXJyb3IoXHJcblx0XHRcdFx0XHRcIkNvdWxkIG5vdCBhZGQgc3BlZWNoIGFuaW1hdGlvbiBmb3IgY2hhcmFjdGVyOiBcIiArIHRoaXMuZGF0YS5uYW1lXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRsb2cuZXJyb3IoXCJTcGVlY2ggYW5pbWF0aW9uIG5vdCBmb3VuZCBmb3IgXCIgKyB0aGlzLmRhdGEuaW1hZ2UpO1xyXG5cdFx0XHRcdGxvZy5lcnJvcihcclxuXHRcdFx0XHRcdFwiQ2hlY2sgdGhhdCB5b3UgaGF2ZSBhIHNwZWVjaEFuaW1hdGlvbnMgc2VjdGlvbiBpbiB5b3VyIHRoZW1lLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24gPSB0aGlzLmdhbWUuYWRkLnNwcml0ZShcclxuXHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0gKyBhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdLFxyXG5cdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMV0sXHJcblx0XHRcdFx0dGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uLmFuaW1hdGlvbnMuYWRkKFwidGFsa1wiLCBhU3BlZWNoQW5pbWF0aW9uLmltYWdlcyk7XHJcblx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uU2V0ID0gYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXM7XHJcblx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uRGVmYXVsdCA9IGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5zY2FsZSkge1xyXG5cdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uLnNjYWxlLnNldFRvKFxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhLnNjYWxlWzBdLFxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhLnNjYWxlWzFdXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLnNwZWVjaEFuaW1hdGlvbi54ID1cclxuXHRcdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSArXHJcblx0XHRcdFx0XHRhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdICogdGhpcy5kYXRhLnNjYWxlWzBdO1xyXG5cdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uLnkgPVxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzFdICtcclxuXHRcdFx0XHRcdGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMV0gKiB0aGlzLmRhdGEuc2NhbGVbMV07XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uIChzcGVlY2gpIHtcclxuXHRcdFx0dmFyIGF1ZGlvID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShzcGVlY2guYXVkaW8pO1xyXG5cdFx0XHRpZiAoc3BlZWNoLmtleSkge1xyXG5cdFx0XHRcdGF1ZGlvID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShzcGVlY2gua2V5KSArIFwiX1wiICsgYXVkaW87XHJcblx0XHRcdH1cclxuXHRcdFx0bG9nLndhcm4oXCJPbiBnYW1lIHNwZWVjaDogXCIgKyBhdWRpbyk7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHR0aGlzLnNwZWVjaEFuaW1hdGlvbiAmJlxyXG5cdFx0XHRcdHRoaXMudGhlbWUuc291bmRTeW5jRGF0YSAmJlxyXG5cdFx0XHRcdHRoaXMudGhlbWUuc291bmRTeW5jRGF0YVthdWRpb11cclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhpcy5zb3VuZFN5bmNEYXRhID0gdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhW2F1ZGlvXTtcclxuXHRcdFx0XHRpZiAoIXRoaXMudGltZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMudGltZXIgPSB0aGlzLmdhbWUudGltZS5jcmVhdGUoZmFsc2UpO1xyXG5cdFx0XHRcdFx0dGhpcy5zcGVlY2hJbmRleCA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWVyLmxvb3AoMTAwLCB0aGlzLmluY3JlbWVudFNwZWVjaCwgdGhpcyk7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWVyLnN0YXJ0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0aW5jcmVtZW50U3BlZWNoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNvdW5kU3luY0RhdGEpIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVjaEluZGV4Kys7XHJcblx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID1cclxuXHRcdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uU2V0W3RoaXMuc291bmRTeW5jRGF0YVt0aGlzLnNwZWVjaEluZGV4XV07XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbkdhbWVTcGVlY2hTdG9wOiBmdW5jdGlvbiAoc3BlZWNoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNwZWVjaEFuaW1hdGlvbiAmJiB0aGlzLnNvdW5kU3luY0RhdGEpIHtcclxuXHRcdFx0XHR0aGlzLnRpbWVyLnN0b3AoKTtcclxuXHRcdFx0XHR0aGlzLnRpbWVyLmRlc3Ryb3koKTtcclxuXHRcdFx0XHR0aGlzLnRpbWVyID0gbnVsbDtcclxuXHRcdFx0XHR0aGlzLnNvdW5kU3luY0RhdGEgPSBudWxsO1xyXG5cdFx0XHRcdHRoaXMuc3BlZWNoQW5pbWF0aW9uLmZyYW1lTmFtZSA9IHRoaXMuc3BlZWNoQW5pbWF0aW9uRGVmYXVsdDtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uTW91c2VJbjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdGlmICh0aGlzLmdyYXBoaWNzKSB7XHJcblx0XHRcdFx0dGhpcy5ncmFwaGljcy52aXNpYmxlID0gdHJ1ZTtcclxuXHRcdFx0XHR0aGlzLmdhbWUud29ybGQuYnJpbmdUb1RvcCh0aGlzLmdyYXBoaWNzKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLmF1ZGlvKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoR2FtZVNwZWVjaCh7XHJcblx0XHRcdFx0XHRcdHRleHQ6IHRoaXMuZGF0YS50ZXh0LFxyXG5cdFx0XHRcdFx0XHRhdWRpbzogdGhpcy5kYXRhLmF1ZGlvLFxyXG5cdFx0XHRcdFx0XHRrZXk6IHRoaXMuZGF0YS5rZXkgfHwgdGhpcy5kYXRhLm5hbWUsXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbk1vdXNlT3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0aWYgKHRoaXMuZ3JhcGhpY3MgJiYgdGhpcy5ncmFwaGljcy52aXNpYmxlID09PSB0cnVlKSB7XHJcblx0XHRcdFx0dGhpcy5ncmFwaGljcy52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvblBvaW50ZXJVcDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSB0aGlzLmRhdGEubmFtZTtcclxuXHRcdFx0dGhpcy5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuXHRcdH0sXHJcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnRleHQpIHtcclxuXHRcdFx0XHR0aGlzLmdyYXBoaWNzLmRlc3Ryb3kodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuc3BlZWNoQW5pbWF0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5zcGVlY2hBbmltYXRpb24uZGVzdHJveSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmRlYnVnQm94KSB7XHJcblx0XHRcdFx0dGhpcy5kZWJ1Z0JveC5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMudGltZXIpIHtcclxuXHRcdFx0XHR0aGlzLnRpbWVyLmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gQ2hhcmFjdGVyQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBjbGljay1hbmltYXRpb24gYWN0b3IuIFdpbGwgc3RhcnQgd2l0aCBhbiBpbWFnZSwgYW5kIHdoZW4gY2xpY2tlZDsgd2lsbCBhbmltYXRlIGFuZCB0aGVuIHNldCB0byBmaW5hbCBpbWFnZS5cclxuICogV2lsbCBnZW5lcmF0ZSBldmVudHMgZm9yIGVhY2hcclxuICpcclxuICogQ3JlYXRpbmcgYSBjbGljay1hbmltYXRpb24gYWN0b3IsIGEgc3RhcnRpbmcsIGFuaW1hdGlvbiBzZXQsIGFuZCBlbmRpbmcgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJjbGljay1hbmltYXRpb25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGJ1dHRvbiBzZWN0aW9uIG9mIHRoZSB0aGVtZS5cclxuICogICAgIFwia2V5XCI6IFwid2hhdGV2c1wiLCAvLyBvcHRpb25hbCBpbWFnZSBrZXlcclxuICogICAgIFwidGV4dHVyZUtleVwiOiBcImtleVwiLCAvLyBvcHRpb25hbCB0ZXh0IGtleSB0byBnZXQgYW5pbWF0aW9uIGZyb21cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcImF1ZGlvXCI6IFwiYXVkaW9cIiwgLy8gb3B0aW9uYWwgYXVkaW8gdG8gcGxheSBkdXJpbmcgYW5pbWF0aW9uLlxyXG4gKiAgICAgXCJzY2FsZVwiOiBbIHgsIHldLCAvLyBvcHRpb25hbCB4L3kgc2NhbGUuXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwieFwiIC8vIHZhcmlhYmxlIHRvIHNlbmQgb3V0IDJuZCBjbGljayBldmVudHMsIHdpbGwgYmUgbmFtZSArIFwiX3BsYXlpbmdcIiBhbmQgbmFtZSArIFwiX2ZpbmlzaGVkXCJcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpO1xyXG5cclxuXHR2YXIgQ2xpY2tBbmltYXRpb25BY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcblx0XHQvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuXHRcdGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBbXCJsb2NhdGlvblwiLCBcImltYWdlc1wiXTtcclxuXHRcdH0sXHJcblx0XHRlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuYnVpbGRBY3RvcigpO1xyXG5cdFx0fSxcclxuXHRcdGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZShcclxuXHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG5cdFx0XHRcdHRoaXMuZ2V0VGV4dHVyZUtleSh0aGlzLmRhdGEpLFxyXG5cdFx0XHRcdHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmltYWdlcywgdGhpcy5kYXRhLmtleSlbMF1cclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5zcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IENQVS9leHBlbnNpdmUgdGhpbmdzIHlvdSBjYW4gZG8gaW4gcGhhc2VyLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy5zcHJpdGUuaW5wdXQucGl4ZWxQZXJmZWN0T3ZlciA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRoaXMuc3ByaXRlLmV2ZW50cy5vbklucHV0VXAuYWRkKHRoaXMub25Qb2ludGVyVXAsIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5hbmltYXRpb24gPSB0aGlzLnNwcml0ZS5hbmltYXRpb25zLmFkZChcclxuXHRcdFx0XHRcImFuaW1hdGlvblwiLFxyXG5cdFx0XHRcdHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmltYWdlcywgdGhpcy5kYXRhLmtleSlcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5hbmltYXRpb24ub25Db21wbGV0ZS5hZGQodGhpcy5vbkFuaW1hdGlvbkNvbXBsZXRlLCB0aGlzKTtcclxuXHJcblx0XHRcdHZhciBhbmNob3JYID0gMCxcclxuXHRcdFx0XHRhbmNob3JZID0gMDtcclxuXHRcdFx0dmFyIHggPSB0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0eSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuXHRcdFx0dGhpcy5zY2FsZVggPSAxLjA7XHJcblx0XHRcdHRoaXMuc2NhbGVZID0gMS4wO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5zY2FsZSkge1xyXG5cdFx0XHRcdHRoaXMuc2NhbGVYID0gdGhpcy5kYXRhLnNjYWxlWzBdO1xyXG5cdFx0XHRcdHRoaXMuc2NhbGVZID0gdGhpcy5kYXRhLnNjYWxlWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuc3ByaXRlLnNjYWxlLnNldFRvKHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSk7XHJcblxyXG5cdFx0XHRpZiAoeCA9PT0gXCJjZW50ZXJcIikge1xyXG5cdFx0XHRcdHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuXHRcdFx0XHRhbmNob3JYID0gMC41O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoeSA9PT0gXCJjZW50ZXJcIikge1xyXG5cdFx0XHRcdHkgPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWTtcclxuXHRcdFx0XHRhbmNob3JZID0gMC41O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLmFuY2hvcikge1xyXG5cdFx0XHRcdGFuY2hvclggPSB0aGlzLmRhdGEuYW5jaG9yWzBdO1xyXG5cdFx0XHRcdGFuY2hvclkgPSB0aGlzLmRhdGEuYW5jaG9yWzFdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNwcml0ZS5hbmNob3Iuc2V0VG8oYW5jaG9yWCwgYW5jaG9yWSk7XHJcblx0XHRcdHRoaXMuc3ByaXRlLnggPSB4O1xyXG5cdFx0XHR0aGlzLnNwcml0ZS55ID0geTtcclxuXHRcdFx0dGhpcy5hbmltYXRlZCA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdG9uUG9pbnRlclVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0dmFyIHN1ZmZpeDtcclxuXHRcdFx0aWYgKHRoaXMuaXNBbmltYXRlZCA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHN1ZmZpeCA9IFwiX2ZpbmlzaGVkXCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3VmZml4ID0gXCJfcGxheWluZ1wiO1xyXG5cdFx0XHRcdHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWUgKyBcIl9wbGF5aW5nXCI7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5wbGF5KFwiYW5pbWF0aW9uXCIsIDEwLCBmYWxzZSk7XHJcblx0XHRcdFx0dGhpcy5pc0FuaW1hdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLmF1ZGlvKSB7XHJcblx0XHRcdFx0XHR0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiB0aGlzLmRhdGEuYXVkaW8sIGtleTogbnVsbCB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSB0aGlzLmRhdGEubmFtZSArIHN1ZmZpeDtcclxuXHRcdFx0dGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQsIHRoaXMpO1xyXG5cdFx0fSxcclxuXHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5pc0FuaW1hdGVkID0gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gQ2xpY2tBbmltYXRpb25BY3RvcjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGRlY29yYXRpb24gYWN0b3IuIEp1c3QgYW4gaW1hZ2Ugb24gdGhlIHNjcmVlbi5cclxuICpcclxuICogQ3JlYXRpbmcgYSBkZWNvcmF0aW9uIGFjdG9yLCBhIHNpbXBsZSBpbWFnZTpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9ydHJhaXQxXCIsICAgICAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkZWNvcmF0aW9uXCIsICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZVwiOiBcInBob25lXCIsICAgICAgICAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b24gc2VjdGlvbiBvZiB0aGUgdGhlbWUuXHJcbiAqICAgICBcImtleVwiOiBcInNvbWV0aGluZ1wiLCAgICAgIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJzY2FsZVwiOiBbIHgsIHldLCAgICAgICAgLy8gb3B0aW9uYWwgeC95IHNjYWxlLlxyXG4gKiAgICAgXCJhbmdsZVwiOiAtMzAsICAgICAgICAgICAgLy8gb3B0aW9uYWwsIGRlZ3JlZXMgZnJvbSBub3J0aCAoLTE4MCB0byAxODApXHJcbiAqICAgICBcInJvdGF0aW9uXCI6IDAuNSwgICAgICAgICAvLyBvcHRpb25hbCwgcmFkaWFucyBpbiB1bml0cyBvZiBQSS4gVGhpcyBvdmVycmlkZXMgYW5nbGUgaWYgYm90aCBhcmUgc2V0LlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgICAgXCJhbHBoYVwiOiAwLjUgLy8gb3B0aW9uYWwgYWxwaGEgdHJhbnNwYXJlbmN5XHJcbiAqICAgICBcInR3ZWVuXCI6IFtPYmplY3RdIC8vIG9wdGlvbmFsIHRyYW5zaXRpb24gb2JqZWN0XHJcbiAqIH1cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgRGVjb3JhdGlvbkFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUZXh0dXJlS2V5KHRoaXMuZGF0YSksIHRoaXMuZ2V0SW1hZ2UoIHRoaXMuZGF0YS5pbWFnZSwgdGhpcy5kYXRhLmtleSkpO1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yWCA9IDAsIGFuY2hvclkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXSxcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHggPT09IFwiY2VudGVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclg7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gMC41O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggeSA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWTtcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IHRoaXMuZGF0YS5hbmNob3JbMF07XHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gdGhpcy5kYXRhLmFuY2hvclsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYW5jaG9yLnNldFRvKCBhbmNob3JYLCBhbmNob3JZKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRhdGEuYWxwaGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5hbHBoYSA9IHRoaXMuZGF0YS5hbHBoYTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRhdGEuYW5nbGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRhdGEucm90YXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5yb3RhdGlvbiA9IE1hdGguUEkgKiB0aGlzLmRhdGEucm90YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudHdlZW4gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW5EYXRhID0gdGhpcy5kYXRhLnR3ZWVuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IHR3ZWVuRGF0YS5kZWxheSA/IHR3ZWVuRGF0YS5kZWxheSA6IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWFzaW5nID0gKCB0eXBlb2YgdHdlZW5EYXRhLmVhc2luZyAhPSBcInVuZGVmaW5lZFwiICkgPyB0d2VlbkRhdGEuZWFzaW5nIDogXCJMaW5lYXJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiggdHdlZW5EYXRhLmxvY2F0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5zcHJpdGUpLnRvKCB7IHg6IHR3ZWVuRGF0YS5sb2NhdGlvblswXSwgeTogdHdlZW5EYXRhLmxvY2F0aW9uWzFdICB9LCB0d2VlbkRhdGEudGltZSwgZWFzaW5nLCB0cnVlLCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdHdlZW5EYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5zcHJpdGUuc2NhbGUpLnRvKCB7IHg6IHR3ZWVuRGF0YS5zY2FsZVswXSwgeTogdHdlZW5EYXRhLnNjYWxlWzFdICB9LCB0d2VlbkRhdGEudGltZSwgZWFzaW5nLCB0cnVlLCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLmFscGhhKSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3ByaXRlKS50bygge2FscGhhOiB0d2VlbkRhdGEuYWxwaGF9LCB0d2VlbkRhdGEudGltZSwgZWFzaW5nLCB0cnVlLCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRGVjb3JhdGlvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgZHJhZyBhY3Rvci4gQW4gaW1hZ2Ugb24gdGhlIHNjcmVlbiB3aXRoIG9wdGlvbmFsIHRleHQgdGhhdCBjYW4gYmUgZHJhZ2dlZCBhcm91bmQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgZGVjb3JhdGlvbiBhY3RvciwgYSBzaW1wbGUgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkcmFnXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogeyBcIm5vcm1hbFwiIDogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBpbWFnZXMgc2VjdGlvbiB0aGUgdGhlbWUuXHJcbiAqICAgICAgICAgICAgICAgICBcImRyYWdnaW5nXCIgOiBcInBob25lXCIsIC8vIG9wdGlvbmFsIGltYWdlIHdoaWxlIGRyYWdnaW5nXHJcbiAqICAgICAgICAgICAgICAgICBcIm92ZXJsYXBcIiA6IFwicGhvbmVcIiwgLy8gb3B0aW9uYWwgaW1hZ2Ugd2hlbiBvdmVybGFwcGluZy5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UocykuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInN0cmluZ1wiIC8vIG5hbWUgb2YgdmFyaWFibGUgdG8gYmUgc2V0IHdoZW4gdGhpcyBpcyBkcmFnZ2luZy9kcm9wcGVkL2V0Yy5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpO1xyXG5cclxuXHR2YXIgRHJhZ0FjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuXHRcdC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudFxyXG5cdFx0Z2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIFtcImxvY2F0aW9uXCIsIFwiaW1hZ2VzXCIsIFwidmFyaWFibGVcIl07XHJcblx0XHR9LFxyXG5cdFx0ZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmJ1aWxkQWN0b3IoKTtcclxuXHRcdH0sXHJcblx0XHRidWlsZEFjdG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBzcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZShcclxuXHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcblx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG5cdFx0XHRcdHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuXHRcdFx0XHR0aGlzLmdldEltYWdlKHRoaXMuZ2V0RnJhbWUoKSwgdGhpcy5kYXRhLmtleSlcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLnBoeXNpY3MuZW5hYmxlKHNwcml0ZSwgUGhhc2VyLlBoeXNpY3MuQVJDQURFKTtcclxuXHRcdFx0c3ByaXRlLmJvZHkuc2V0U2l6ZSgxLCAxLCBzcHJpdGUud2lkdGggLyAyLCBzcHJpdGUuaGVpZ2h0IC8gMik7XHJcblx0XHRcdHNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHRzcHJpdGUuaW5wdXQucGl4ZWxQZXJmZWN0T3ZlciA9IGZhbHNlO1xyXG5cdFx0XHRzcHJpdGUuaW5wdXQuZW5hYmxlRHJhZyh0cnVlLCB0cnVlKTtcclxuXHRcdFx0c3ByaXRlLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG5cdFx0XHRzcHJpdGUuZXZlbnRzLm9uRHJhZ1N0b3AuYWRkKHRoaXMuaXRlbURyYWdTdG9wLCB0aGlzKTtcclxuXHRcdFx0c3ByaXRlLmV2ZW50cy5vbkRyYWdTdGFydC5hZGQodGhpcy5pdGVtRHJhZ1N0YXJ0LCB0aGlzKTtcclxuXHRcdFx0c3ByaXRlLm9yaWdMb2MgPSBbc3ByaXRlLngsIHNwcml0ZS55XTtcclxuXHRcdFx0dGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcblxyXG5cdFx0XHR2YXIgZm9udE5hbWU7XHJcblx0XHRcdHZhciB0ZXh0WCA9IHRoaXMuc3ByaXRlLndpZHRoIC8gMjtcclxuXHRcdFx0dmFyIHRleHRZID0gdGhpcy5zcHJpdGUuaGVpZ2h0IC8gMjtcclxuXHRcdFx0dmFyIGFuY2hvciA9IFswLjUsIDAuNV07XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnRleHREYXRhKSB7XHJcblx0XHRcdFx0dmFyIHRleHREYXRhID0gdGhpcy5kYXRhLnRleHREYXRhO1xyXG5cdFx0XHRcdGZvbnROYW1lID0gdGV4dERhdGEuZm9udDtcclxuXHRcdFx0XHR0aGlzLnN0eWxlID0gdGhpcy5nZXRGb250KFxyXG5cdFx0XHRcdFx0dHlwZW9mIGZvbnROYW1lICE9PSBcInVuZGVmaW5lZFwiID8gZm9udE5hbWUgOiBcInF1ZXN0aW9uVGV4dFwiXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKHRleHREYXRhLnRleHRYKSB7XHJcblx0XHRcdFx0XHR0ZXh0WCA9IHRleHREYXRhLnRleHRYO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGV4dERhdGEudGV4dFkpIHtcclxuXHRcdFx0XHRcdHRleHRZID0gdGV4dERhdGEudGV4dFk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0ZXh0RGF0YS5hbmNob3IpIHtcclxuXHRcdFx0XHRcdGFuY2hvciA9IHRleHREYXRhLmFuY2hvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy50ZXh0U3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KFxyXG5cdFx0XHRcdFx0dGV4dFgsXHJcblx0XHRcdFx0XHR0ZXh0WSxcclxuXHRcdFx0XHRcdHRleHREYXRhLnRleHQsXHJcblx0XHRcdFx0XHR0aGlzLnN0eWxlXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMudGV4dFNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMudGV4dFNwcml0ZS5hbmNob3Iuc2V0VG8oYW5jaG9yWzBdLCBhbmNob3JbMV0pO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmFkZENoaWxkKHRoaXMudGV4dFNwcml0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRyZXR1cm5Ub0hvbWU6IGZ1bmN0aW9uICgpIHt9LFxyXG5cdFx0aXRlbURyYWdTdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUltYWdlKCk7XHJcblx0XHRcdHZhciB0ZW1wID0ge307XHJcblx0XHRcdHRlbXBbXCJkcm9wcGVkXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcblx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG5cdFx0XHQvLyBJdCB3aWxsIGhhdmUgYmVlbiBkcm9wcGVkLCBhbmQgcG9zc2libHkgcmVtb3ZlZCBmcm9tIHNjZW5lLlxyXG5cdFx0XHRpZiAodGhpcy5zcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS54ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1swXTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS55ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGl0ZW1EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy51cGRhdGVJbWFnZSgpO1xyXG5cdFx0XHR2YXIgdGVtcCA9IHt9O1xyXG5cdFx0XHR0ZW1wW1wiZHJhZ2dpbmdcIl0gPSB0aGlzLmRhdGEubmFtZTtcclxuXHRcdFx0dGhpcy5kaXNwYXRjaEdhbWVDaG9pY2UodGVtcCk7XHJcblx0XHR9LFxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ib2R5LmRlc3Ryb3koKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ldmVudHMub25EcmFnU3RvcC5yZW1vdmVBbGwoKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ldmVudHMub25EcmFnU3RhcnQucmVtb3ZlQWxsKCk7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMudGV4dFNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMudGV4dFNwcml0ZS5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zdHlsZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG5cdFx0fSxcclxuXHRcdGdldEZyYW1lOiBmdW5jdGlvbiAodHlwZSkge1xyXG5cdFx0XHR2YXIgZnJhbWVOYW1lID0gdGhpcy5kYXRhLmltYWdlcy5ub3JtYWw7XHJcblx0XHRcdGlmICh0eXBlID09PSBcIm92ZXJsYXBcIiAmJiB0aGlzLmRhdGEuaW1hZ2VzLm92ZXJsYXApIHtcclxuXHRcdFx0XHRmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLm92ZXJsYXA7XHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0KHR5cGUgPT09IFwiZHJhZ2dpbmdcIiB8fCAhZnJhbWVOYW1lKSAmJlxyXG5cdFx0XHRcdHRoaXMuZGF0YS5pbWFnZXMuZHJhZ2dpbmdcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0ZnJhbWVOYW1lID0gdGhpcy5kYXRhLmltYWdlcy5kcmFnZ2luZztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZnJhbWVOYW1lO1xyXG5cdFx0fSxcclxuXHRcdHVwZGF0ZUltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBmcmFtZTtcclxuXHRcdFx0aWYgKHRoaXMuaXNPdmVybGFwcGluZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGZyYW1lID0gdGhpcy5nZXRGcmFtZShcIm92ZXJsYXBcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc0RyYWdnaW5nID09PSB0cnVlKSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwiZHJhZ2dpbmdcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwibm9ybWFsXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuc3ByaXRlLmZyYW1lTmFtZSA9IHRoaXMuZ2V0SW1hZ2UoZnJhbWUsIHRoaXMuZGF0YS5rZXkpO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS5ib2R5LnNldFNpemUoXHJcblx0XHRcdFx0MSxcclxuXHRcdFx0XHQxLFxyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLndpZHRoIC8gMixcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5oZWlnaHQgLyAyXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0Z2V0Qm9keTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zcHJpdGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zcHJpdGUuYm9keTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH0sXHJcblx0XHRvbk92ZXJsYXBwaW5nOiBmdW5jdGlvbiAob3RoZXJBY3Rvcikge1xyXG5cdFx0XHRpZiAodGhpcy5pc092ZXJsYXBwaW5nID09PSBvdGhlckFjdG9yKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuaXNPdmVybGFwcGluZyA9IG90aGVyQWN0b3I7XHJcblx0XHRcdC8vIGNoYW5nZSB0byBvdmVybGFwcGluZyBpbWFnZS5cclxuXHRcdFx0dGhpcy51cGRhdGVJbWFnZSgpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBEcmFnQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFphY2sgQmllcm5hdFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gNi8yNi8yMDE4XHJcbiAqIENvcHlyaWdodCAyMDE4IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJsb2NrZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgdG8gYmxvY2sgaW5wdXQgZXZlbnRzIGZyb20gdGhlIGFjdG9ycyBiZWhpbmQgaXQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgZHJhdyBhY3RvcjpcclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwiZHJhdy1kZW1vXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImRyYXdcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImZpZWxkTG9jYXRpb25zXCI6IFtbNDAwLCAzMDBdLCBbNTAwLCAzMDBdXSwgLy8gVGhlIHRhcmdldCBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWxlY3RhYmxlIGZpZWxkXHJcbiAqICAgICBcImZpZWxkU2l6ZVwiOiA1MCwgLy8gdGhlIHJhZGl1cyBvZiBlYWNoIGFyZWFcclxuICogICAgIFwidmFyaWFibGVcIjogXCJkcmF3Q2hvb3NlclwiIC8vIFRoZSB2YXJpYWJsZSBuYW1lIGZvciBkaXNwYXRjaGVkIGV2ZW50c1xyXG4gKiB9XHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgICB2YXIgRHJhd0FjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaXMgbm93IGluIGJhc2UgY2xhc3MhXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEuZmllbGRTaXplIHx8ICF0aGlzLmRhdGEuZmllbGRMb2NhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiUmVxdWlyZWQgZmllbGQgc2l6ZSBvciBmaWVsZCBsb2NhdGlvbnMgbm90IGZvdW5kXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ibWQgPSB0aGlzLmdhbWUubWFrZS5iaXRtYXBEYXRhKHRoaXMuZ2FtZS53aWR0aCwgdGhpcy5nYW1lLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm1kLmFkZFRvV29ybGQoKTtcclxuICAgICAgICAgICAgdGhpcy5hZGREZWJ1Z0JveCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQub25Eb3duLmFkZCh0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0Lm9uVXAuYWRkKHRoaXMub25Nb3VzZVVwLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ibWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm1kLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm1kLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LnN0cm9rZVN0eWxlID0gXCIjMDA1OTk2XCJcclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LmxpbmVXaWR0aCA9IDg7XHJcbiAgICAgICAgICAgIHRoaXMuYm1kLmN0eC5tb3ZlVG8ocG9pbnRlci54LCBwb2ludGVyLnkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0LmFkZE1vdmVDYWxsYmFjayh0aGlzLm9uRHJhdywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkRyYXc6IGZ1bmN0aW9uKHBvaW50ZXIsIHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA8IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChbeCwgeV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBdmVyYWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm1kLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0LmRlbGV0ZU1vdmVDYWxsYmFjayh0aGlzLm9uRHJhdywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWxjdWxhdGVBdmVyYWdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF2ZVggPSAwO1xyXG4gICAgICAgICAgICB2YXIgYXZlWSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGF2ZVggKz0gdGhpcy5wb3NpdGlvbnNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBhdmVZICs9IHRoaXMucG9zaXRpb25zW2ldWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF2ZVggLz0gdGhpcy5wb3NpdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBhdmVZIC89IHRoaXMucG9zaXRpb25zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoZWNrVGFyZ2V0cyhhdmVYLCBhdmVZKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja1RhcmdldHM6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSB0aGlzLmRhdGEuZmllbGRMb2NhdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZGF0YS5maWVsZFNpemU7XHJcbiAgICAgICAgICAgIHZhciBjaG9pY2UgPSB0YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCByYW5nZSArIHRhcmdldHNbaV1bMV0gJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1tpXVsxXSA8IHkgJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgeCA8IDEwMCArIHRhcmdldHNbaV1bMF0gJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1tpXVswXSA8IHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gY2hvaWNlOyAvL1RoaXMgbmVlZHMgdG8gZGV0ZXJtaW5lIHdoaWNoIHRoaW5nIHdhcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUudGltZS5ldmVudHMuYWRkKDEwLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEJtZCA9IHRoaXMuYm1kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Qm1kLmFkZFRvV29ybGQoKTsgXHJcbiAgICAgICAgICAgIH0sIHRoaXMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGREZWJ1Z0JveDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB3aW5kb3cuaXNEZWJ1Z2dpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94ID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guYmVnaW5GaWxsKDB4MDAwMDAwLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5kcmF3UmVjdCgwLCAwLCB0aGlzLmRhdGEuc2l6ZVswXSwgdGhpcy5kYXRhLnNpemVbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuZGVidWdCb3gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJtZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm1kLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGVidWdCb3ggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQuZGVsZXRlTW92ZUNhbGxiYWNrKHRoaXMub25EcmF3LCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0Lm9uRG93bi5yZW1vdmUodGhpcy5vbk1vdXNlRG93biwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5pbnB1dC5vblVwLnJlbW92ZSh0aGlzLm9uTW91c2VVcCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRHJhd0FjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgZHJvcCBhY3Rvci4gWW91IGNhbiBkcm9wIGRyYWcgYWN0b3JzIG9udG8gdGhpcyBvbmUsIHRyaWdnZXJpbmcgaXQncyB2YXJpYWJsZSBhbmQgb3B0aW9uYWwgaW1hZ2Ugc3RhZ2UuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgZGVjb3JhdGlvbiBhY3RvciwgYSBzaW1wbGUgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkcm9wXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogeyBcIm5vcm1hbFwiIDogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBpbWFnZXMgc2VjdGlvbiB0aGUgdGhlbWUuXHJcbiAqICAgICAgICAgICAgICAgICBcIm92ZXJsYXBcIiA6IFwicGhvbmVcIiwgLy8gb3B0aW9uYWwgaW1hZ2Ugd2hlbiBvdmVybGFwcGluZy5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UocykuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJib2R5XCI6IFsgd2lkdGglLCBoZWlnaHQlLCBvZmZzZXR4LCBvZmZzZXR5IF0sIC8vIG9wdGlvbmFsIGJvZHkuXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwic3RyaW5nXCIgLy8gbmFtZSBvZiB2YXJpYWJsZSB0byBiZSBzZXQgd2hlbiB0aGlzIGlzIGRyb3BwZWQvZXRjLlxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdHZhciBfID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuXHRcdGxvZyA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKSxcclxuXHRcdEFjdG9yID0gcmVxdWlyZShcIi4vYWN0b3JcIik7XHJcblxyXG5cdHZhciBEcm9wQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG5cdFx0Ly8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcblx0XHRnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gW1wibG9jYXRpb25cIiwgXCJpbWFnZXNcIiwgXCJ2YXJpYWJsZVwiXTtcclxuXHRcdH0sXHJcblx0XHRlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuYnVpbGRBY3RvcigpO1xyXG5cdFx0fSxcclxuXHRcdGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIHNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKFxyXG5cdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblswXSxcclxuXHRcdFx0XHR0aGlzLmRhdGEubG9jYXRpb25bMV0sXHJcblx0XHRcdFx0dGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmltYWdlcy5vdmVybGFwLCB0aGlzLmRhdGEua2V5KVxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLmdhbWUucGh5c2ljcy5lbmFibGUoc3ByaXRlLCBQaGFzZXIuUGh5c2ljcy5BUkNBREUpO1xyXG5cdFx0XHR2YXIgYm9keSA9IFtcclxuXHRcdFx0XHRzcHJpdGUud2lkdGggKiAwLjYsXHJcblx0XHRcdFx0c3ByaXRlLmhlaWdodCAqIDAuNixcclxuXHRcdFx0XHRzcHJpdGUud2lkdGggKiAwLjIsXHJcblx0XHRcdFx0c3ByaXRlLmhlaWdodCAqIDAuMixcclxuXHRcdFx0XTtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5ib2R5KSB7XHJcblx0XHRcdFx0Ym9keVswXSA9IHNwcml0ZS53aWR0aCAqIHRoaXMuZGF0YS5ib2R5WzBdO1xyXG5cdFx0XHRcdGJvZHlbMV0gPSBzcHJpdGUuaGVpZ2h0ICogdGhpcy5kYXRhLmJvZHlbMV07XHJcblx0XHRcdFx0Ym9keVsyXSA9IHRoaXMuZGF0YS5ib2R5WzJdIHx8IGJvZHlbMl07XHJcblx0XHRcdFx0Ym9keVszXSA9IHRoaXMuZGF0YS5ib2R5WzNdIHx8IGJvZHlbM107XHJcblx0XHRcdH1cclxuXHRcdFx0c3ByaXRlLmJvZHkuc2V0U2l6ZShib2R5WzBdLCBib2R5WzFdLCBib2R5WzJdLCBib2R5WzNdKTtcclxuXHRcdFx0c3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblx0XHRcdHNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cdFx0XHRzcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIGZvbnROYW1lO1xyXG5cdFx0XHR2YXIgdGV4dFggPSB0aGlzLnNwcml0ZS53aWR0aCAvIDI7XHJcblx0XHRcdHZhciB0ZXh0WSA9IHRoaXMuc3ByaXRlLmhlaWdodCAvIDI7XHJcblx0XHRcdHZhciBhbmNob3IgPSBbMC41LCAwLjVdO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGF0YS50ZXh0RGF0YSkge1xyXG5cdFx0XHRcdHZhciB0ZXh0RGF0YSA9IHRoaXMuZGF0YS50ZXh0RGF0YTtcclxuXHRcdFx0XHRmb250TmFtZSA9IHRleHREYXRhLmZvbnQ7XHJcblx0XHRcdFx0dGhpcy5zdHlsZSA9IHRoaXMuZ2V0Rm9udChcclxuXHRcdFx0XHRcdHR5cGVvZiBmb250TmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGZvbnROYW1lIDogXCJxdWVzdGlvblRleHRcIlxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGlmICh0ZXh0RGF0YS50ZXh0WCkge1xyXG5cdFx0XHRcdFx0dGV4dFggPSB0ZXh0RGF0YS50ZXh0WDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRleHREYXRhLnRleHRZKSB7XHJcblx0XHRcdFx0XHR0ZXh0WSA9IHRleHREYXRhLnRleHRZO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGV4dERhdGEuYW5jaG9yKSB7XHJcblx0XHRcdFx0XHRhbmNob3IgPSB0ZXh0RGF0YS5hbmNob3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dChcclxuXHRcdFx0XHRcdHRleHRYLFxyXG5cdFx0XHRcdFx0dGV4dFksXHJcblx0XHRcdFx0XHR0ZXh0RGF0YS50ZXh0LFxyXG5cdFx0XHRcdFx0dGhpcy5zdHlsZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLnN0eWxlW1wibGluZVNwYWNpbmdcIl0gIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRcdHRoaXMudGV4dFNwcml0ZS5saW5lU3BhY2luZyA9IHRoaXMuc3R5bGVbXCJsaW5lU3BhY2luZ1wiXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLnRleHRTcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLnRleHRTcHJpdGUuYW5jaG9yLnNldFRvKGFuY2hvclswXSwgYW5jaG9yWzFdKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5hZGRDaGlsZCh0aGlzLnRleHRTcHJpdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Z2V0RnJhbWU6IGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0XHRcdHZhciBmcmFtZU5hbWUgPSBudWxsO1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJub3JtYWxcIiAmJiB0aGlzLmRhdGEuaW1hZ2VzLm5vcm1hbCkge1xyXG5cdFx0XHRcdGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMubm9ybWFsO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwib3ZlcmxhcFwiICYmIHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcCkge1xyXG5cdFx0XHRcdGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcDtcclxuXHRcdFx0fSBlbHNlIGlmIChcclxuXHRcdFx0XHQodHlwZSA9PT0gXCJkcmFnZ2luZ1wiIHx8ICFmcmFtZU5hbWUpICYmXHJcblx0XHRcdFx0dGhpcy5kYXRhLmltYWdlcy5kcmFnZ2luZ1xyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLmRyYWdnaW5nO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmcmFtZU5hbWU7XHJcblx0XHR9LFxyXG5cdFx0dXBkYXRlSW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGZyYW1lID0gbnVsbDtcclxuXHRcdFx0aWYgKHRoaXMuaXNPdmVybGFwcGluZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGZyYW1lID0gdGhpcy5nZXRGcmFtZShcIm92ZXJsYXBcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc0RyYWdnaW5nID09PSB0cnVlKSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwiZHJhZ2dpbmdcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwibm9ybWFsXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChmcmFtZSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmZyYW1lTmFtZSA9IHRoaXMuZ2V0SW1hZ2UoZnJhbWUsIHRoaXMuZGF0YS5rZXkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGdldEJvZHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuc3ByaXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ByaXRlLmJvZHk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9LFxyXG5cdFx0b25PdmVybGFwcGluZzogZnVuY3Rpb24gKG90aGVyQWN0b3IpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNPdmVybGFwcGluZyA9PT0gb3RoZXJBY3Rvcikge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmlzT3ZlcmxhcHBpbmcgPSBvdGhlckFjdG9yO1xyXG5cdFx0XHQvLyBjaGFuZ2UgdG8gb3ZlcmxhcHBpbmcgaW1hZ2UuXHJcblx0XHRcdHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuXHRcdH0sXHJcblx0XHRvblJlY2VpdmVEcm9wOiBmdW5jdGlvbiAob3RoZXJBY3Rvck5hbWUpIHtcclxuXHRcdFx0bG9nLndhcm4oXCJSZWNlaXZlZCBkcm9wPyBcIiArIG90aGVyQWN0b3JOYW1lKTtcclxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcclxuXHRcdFx0dGVtcFt0aGlzLmRhdGEudmFyaWFibGVdID0gb3RoZXJBY3Rvck5hbWU7XHJcblx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG5cdFx0fSxcclxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5pc092ZXJsYXBwaW5nID0gbnVsbDtcclxuXHRcdFx0aWYgKHRoaXMuc3ByaXRlKSB7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuYm9keS5kZXN0cm95KCk7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMudGV4dFNwcml0ZSkge1xyXG5cdFx0XHRcdHRoaXMudGV4dFNwcml0ZS5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zdHlsZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBEcm9wQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFN5ZCBHcm9zY2xhdWRlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8yMy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGZhZGVvdXQgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgdG8gZmFkZSBvdXQgdGhlIHNjcmVlblxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGJsb2NrZXIgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImFsZXJ0QmxvY2tlclwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJmYWRlb3V0XCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDAsIDAgXSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgWzAsMF07IHdoZXJlIG9uIHRoZSBzY3JlZW4gdG8gcGxheSB0aGlzIGFjdG9yXHJcbiAqICAgICBcInNpemVcIjogWyA4MDAsIDYwMCBdLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBbZ2FtZS53b3JsZC53aWR0aCxnYW1lLndvcmxkLmhlaWdodF0gaG93IGxhcmdlXHJcbiAqICAgICBcImNvbG9yXCIgOiBcIjB4MDAwMDAwXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrICgweDAwMDAwMClcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcImZhZGVQZXJpb2RcIjogMzAwMCwgLy8gIGhvdyBsb25nIHRvIGZhZGUgb3Zlci5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJ4XCIgLy8gdmFyaWFibGUgdG8gc2V0IHVwb24gY29tcGxldGlvbi5cclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgRmFkZW91dEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcImZhZGVQZXJpb2RcIiwgXCJ2YXJpYWJsZVwiXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJYID0gKHR5cGVvZiB0aGlzLmRhdGEubG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDAgOiB0aGlzLmRhdGEubG9jYXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyWSA9ICh0eXBlb2YgdGhpcy5kYXRhLmxvY2F0aW9uID09PSAndW5kZWZpbmVkJykgPyAwIDogdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlcldpZHRoID0gKHR5cGVvZiB0aGlzLmRhdGEuc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5nYW1lLndvcmxkLndpZHRoIDogdGhpcy5kYXRhLnNpemVbMF07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VySGVpZ2h0ID0gKHR5cGVvZiB0aGlzLmRhdGEuc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5nYW1lLndvcmxkLmhlaWdodCA6IHRoaXMuZGF0YS5zaXplWzFdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlclRpbnQgPSAodHlwZW9mIHRoaXMuZGF0YS5ibG9ja2VyVGludCA9PT0gJ3VuZGVmaW5lZCcpID8gMHgwMDAwMDAgOiB0aGlzLmRhdGEuYmxvY2tlclRpbnQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoYmxvY2tlclRpbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KGJsb2NrZXJYLCBibG9ja2VyWSwgYmxvY2tlcldpZHRoLCBibG9ja2VySGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuZmFkZVBlcmlvZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5hbHBoYSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhZGVUd2VlbiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5ncmFwaGljcykudG8oe2FscGhhOiAxfSwgdGhpcy5kYXRhLmZhZGVQZXJpb2QsICdMaW5lYXInLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhZGVUd2Vlbi5vbkNvbXBsZXRlLmFkZCh0aGlzLm9uQ29tcGxldGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4uc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZmFkZVR3ZWVuICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRmFkZW91dEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBQYXVsIEtuZWxsXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAxMS8wMi8yMDE4XHJcbiAqIENvcHlyaWdodCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgYWN0b3IgdXNlcyB0aGUgcGhhc2VyLWlucHV0LmpzIGV4dGVuc2lvbiB0byBhZGQgYSB0ZXh0IGlucHV0IGZpZWxkIHRvIHRoZSBzY2VuZS5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwidGV4dElucHV0MVwiLCAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcImlucHV0LWZpZWxkXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJvcHRpb25zXCI6IHtwYWRkaW5nOiA4LCBib3JkZXJXaWR0aDogMSwgYm9yZGVyQ29sb3I6ICcjMDAwJ30gLy8gb3B0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIElucHV0RmllbGQsIHJlZmVyIHRvIHBoYXNlci1pbnB1dC5qcyBkb2NzIGZvciBmdWxsIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmFuZ2UtZ2FtZXMvcGhhc2VyLWlucHV0XHJcbiAqICB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgSW5wdXRGaWVsZEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuZGF0YS5sb2NhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5kYXRhLm9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gdGhpcy5nYW1lLmFkZC5pbnB1dEZpZWxkKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblswXSwgdGhpcy5sb2NhdGlvblsxXSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IElucHV0RmllbGRBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gaW5zdHJ1Y3Rpb24gYnViYmxlLiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgYWN0b3IgZm9yIHNob3dpbmcgbGFyZ2UgZm9udCB0ZXh0IHdpdGggbm8gc3BlZWNoIGluIGEgZml4ZWQgc2l6ZVxyXG4gKiBidWJibGUuIE5vcm1hbGx5IHVzZWQgZm9yIHRoZSBlbmQgb2YgYW4gYWN0aXZpdHkuXHJcbiAqXHJcbiAqICBDcmVhdGluZyBhbiBpbnN0cnVjdGlvbiBidWJibGUgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImVuZG9mYWN0aXZpdHlcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaW5zdHJ1Y3Rpb25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcInRleHRcIjogXCJQbGVhc2UgbW92ZSBvbiB0byBuZXh0IGFjdGl2aXR5XCIsIC8vIHRleHQgdG8gc2hvdy5cclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgbWFyZ2luWCA9IDgsXHJcbiAgICAgICAgbWFyZ2luWSA9IDEyO1xyXG5cclxuICAgIHZhciBJbnN0cnVjdGlvbkJ1YmJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwidGV4dFwiLCBcImxvY2F0aW9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93KHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFdpbmRvdzogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzIHx8ICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzLmluc3RydWN0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnN0cnVjdGlvbiBhY3RvciByZXF1aXJlcyB0ZXh0V2luZG93cyB0aGVtZSBlbnRyeSwgYW5kIGluc3RydWN0aW9uIGFyZWEgaW5zaWRlIGl0LlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLndpbmRvdyA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHgsIHksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0V2luZG93cy5pbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdtb3ZlT24nKTtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcFdpZHRoID0gdGhpcy53aW5kb3cud2lkdGggKiAwLjk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB0aGlzLndpbmRvdy53aWR0aCAvIDIsIHRoaXMud2luZG93LmhlaWdodC8yLCB0aGlzLnRleHQsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5hbmNob3Iuc2V0VG8oMC41LDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93LmFkZENoaWxkKHRoaXMuY3VycmVudFRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3cuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSW5zdHJ1Y3Rpb25CdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8xNy8yMDE3XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbGluZSBhY3Rvciwgd2hpY2ggd2lsbDpcclxuICogICAtIERyYXcgYSBsaW5lIG9uIHRoZSBzY3JlZW5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwic25pdGNoaW5nT3JUZWxsaW5nX2ZlZWRiYWNrXzAxXCIsIC8vIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGFjdG9yLlxyXG4gKiAgICAgXCJ0eXBlXCI6IFwibGluZVwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJzdGFydFwiOiBbIHgsIHkgXSwgLy8gb3IgXCJjZW50ZXJcIiBmb3IgZWl0aGVyIGZpZWxkLlxyXG4gKiAgICAgXCJlbmRcIjogWyB4LCB5IF0sIC8vIG9yIFwiY2VudGVyXCIgZm9yIGVpdGhlciBmaWVsZC5cclxuICogICAgIFwiY29sb3JcIjogXCJyZ2JhKDAsMCwwLDEpXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrXHJcbiAqICAgICBcIndpZHRoXCI6IFwiNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxXHJcbiAqICAgICBcImFscGhhXCI6IFwiMC41XCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIDEuMFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIExpbmVBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcInN0YXJ0XCIsIFwiZW5kXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZGF0YS5zdGFydDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSB0aGlzLmRhdGEuZW5kO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MgPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKCAwLDApO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSAweEZGMzMwMDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gMjA7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmNvbG9yICkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmRhdGEuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53aWR0aCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFscGhhICkge1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KHRoaXMuZGF0YS5hbHBoYSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKHdpZHRoLCBjb2xvciwgYWxwaGEpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyh0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8odGhpcy5lbmRMb2NbMF0sIHRoaXMuZW5kTG9jWzFdKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uKCBjaG9pY2UgKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFphY2sgQmllcm5hdFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMjMvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBuby1pbnB1dC1jaGFyYWN0ZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2Fubm90IGJlIGludGVyYWN0ZWQgd2l0aC4gSXQgc3BlYWtzIHdoZW4gaXQncyBhdWRpbyBiaXQgaXMgcGxheWVkLCBidXQgaXMgb3RoZXJ3aXNlIGEgZGVjb3JhdGlvbi5cclxuICogQ3JlYXRpbmcgYSBuby1pbnB1dC1jaGFyYWN0ZXIgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm1hbmR5XCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImNoYXJhY3RlclwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VcIjogXCJtYW5keVwiLCAvLyB0aGUgaW1hZ2UgdG8gdXNlIGZyb20gdGhlIHRoZW1lLlxyXG4gKiAgICAgXCJzcGVlY2hBbmltYXRpb25cIjogdHJ1ZXxmYWxzZSwgLy8gaWYgdGhlcmUgaXMgYSBzcGVlY2ggYW5pbWF0aW9uLlxyXG4gKiAgICAgXCJmcmFtZVJhdGVcIjogMjQgLy8gb3B0aW9uYWwgZnJhbWUgcmF0ZSBmb3IgdGhlIHNwZWVjaCBhbmltYXRpb24sIGRlZmF1bHRzIHRvIDEwLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDIwMCwgMjAwIF0sIC8vIHdoZXJlIG9uIHRoZSBzY3JlZW4gdG8gcGxheSB0aGlzIGFjdG9yXHJcbiAqICAgICBcInNpemVcIjogWyB3LCBoIF0sIC8vIHByb3ZpZGUgdGhpcyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgYW4gaW1hZ2UuXHJcbiAqICAgICBcImF1ZGlvXCI6IFwiNnRoXzAxXCIsIC8vIG9wdGlvbmFsIGF1ZGlvIHRvIHNwZWFrIG9uIG1vdXNlIG92ZXIuXHJcbiAqICAgICBcImtleVwiOiBcIm1hbmR5XCIsIC8vIG9wdGlvbmFsIGF1ZGlvIGtleSwgaWYgbm90IHByZXNlbnQsIG5hbWUgd2lsbCBiZSB1c2VkLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqICBJZiB5b3Ugc2V0IHNwZWVjaEFuaW1hdGlvbiB0byB0cnVlLCAtdGFsayB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjaGFyYWN0ZXJzIGltYWdlIG5hbWUuXHJcbiAqIHNwZWVjaEFuaW1hdGlvbi9zcGVlY2hMb2NhdGlvbiBhcmUgb3B0aW9uYWwuXHJcbiAqXHJcbiAqIFNlZSBhbHNvIHRoZW1lLmpzb24ncyBzcGVlY2hBbmltYXRpb25zLCB3aGljaCBzcGVjaWZ5IHNwZWFraW5nLWFuaW1hdGlvbiBpbWFnZXMgYW5kIGxvY2F0aW9uIG9mZnNldHM6XHJcbiAqXHJcbiAqICAgXCJzcGVlY2hBbmltYXRpb25zXCI6IHtcclxuICogICAgXCJqYW5lbGxlXCI6IHtcclxuICogICAgICBcImltYWdlc1wiOiBbXCJ0YWxraW5nLWphbmVsbGUtbW91dGgxLnBuZ1wiLCBcInRhbGtpbmctamFuZWxsZS1tb3V0aDEucG5nXCIsIFwidGFsa2luZy1qYW5lbGxlLW1vdXRoMi5wbmdcIl0sXHJcbiAqICAgICAgXCJtb3V0aE9mZnNldFwiOiBbNjUsIDE2NV0gICAvLyB3aGVyZSB3aXRoaW4gdGhlIGFjdG9yIFwiLXRhbGtcIiBpbWFnZSB0byBwbGFjZSB0aGUgYW5pbWF0aW9uXHJcbiAqICAgIH1cclxuICogXHJcbiAqIFRoZXJlIG11c3QgYWRkaXRpb25hbGx5IGJlIFwiU291bmQgU3luYyBEYXRhXCIsIGRlZmluaW5nIHdoaWNoIGltYWdlIHRvIHNob3cuLi5cclxuICpcclxuICogXCJzb3VuZFN5bmNEYXRhXCI6IHtcclxuICogICBcIjZ0aF8wMVwiOiBbXHJcbiAqICAgICAwLDEsMSwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMSwwLDEsMSwwLDAsMCwwLDEsMVxyXG4gKiAgIF0sIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqICBUaGUgMHMgYW5kIDFzIHJlcHJlc2VudCB3aGljaCBpbWFnZSwgYW5kIGNvdWxkIGJlIDAsMSwyLDMgZXRjIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gMi4gVGhlIGtleSBzaG91bGQgbWF0Y2hcclxuICogIHRoZSBcInNwZWVjaEF1ZGlvXCIgb2YgdGhpcyBhY3RvciBhcyB3ZWxsIGFzIHRoZSBhdWRpbyBiZWluZyBwbGF5ZWQuIFxyXG4gKiAgTk9URTogTW9zdCBvZiB0aGUgc3BlZWNoU3luY0RhdGEgZG9lcyBub3QgY29udGFpbiAnMSdzIGFuZCBsb29rcyBsaWtlIFswLDAsMiwzLDMsMywyLDAsMiwzLDIsMCwwLDAsMiwzLDQsNCwzLDQsMiwwXS5cclxuICogIEluIHRoaXMgY2FzZSBpdCBpcyBhZHZpc2VkIHRvIHVzZSB0aGUgW0EsIEIsIEIsIEMsIERdIHBhdHRlcm4gZm9yIHRoZSBkaWZmZXJlbnQgZnJhbWVzIGluIHlvdXIgdGhlbWUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICAgdmFyIE5vSW5wdXRDaGFyYWN0ZXJBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGlzIG5vdyBpbiBiYXNlIGNsYXNzIVxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zcGVlY2hBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNwZWVjaEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUlkID0gdGhpcy5kYXRhLmltYWdlO1xyXG4gICAgICAgICAgICBpZiggaW1hZ2VJZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUodGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKGltYWdlSWQsICdhY3RvckltYWdlcycpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS53aWR0aCA9IHRoaXMuZGF0YS5zaXplWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERlYnVnQm94KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlYnVnQm94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHdpbmRvdy5pc0RlYnVnZ2luZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3ggPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRyYXdSZWN0KDAsIDAsIHRoaXMuZGF0YS5zaXplWzBdLCB0aGlzLmRhdGEuc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFNwZWVjaEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhU3BlZWNoQW5pbWF0aW9uID0gdGhpcy50aGVtZS5zcGVlY2hBbmltYXRpb25zW3RoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKV07XHJcbiAgICAgICAgICAgIGlmKCAhYVNwZWVjaEFuaW1hdGlvbiApIHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkNvdWxkIG5vdCBhZGQgc3BlZWNoIGFuaW1hdGlvbiBmb3IgY2hhcmFjdGVyOiBcIiArIHRoaXMuZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIlNwZWVjaCBhbmltYXRpb24gbm90IGZvdW5kIGZvciBcIiArIHRoaXMuZGF0YS5pbWFnZSApO1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiQ2hlY2sgdGhhdCB5b3UgaGF2ZSBhIHNwZWVjaEFuaW1hdGlvbnMgc2VjdGlvbiBpbiB5b3VyIHRoZW1lLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICBhU3BlZWNoQW5pbWF0aW9uLmltYWdlc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLmFuaW1hdGlvbnMuYWRkKCd0YWxrJywgYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvblNldCA9IGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbkRlZmF1bHQgPSBhU3BlZWNoQW5pbWF0aW9uLmltYWdlc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5mbGlwTW91dGggJiYgdGhpcy5kYXRhLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdICogLTEsIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi54ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgKGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0gKiB0aGlzLmRhdGEuc2NhbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzFdICogdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmRhdGEuc2NhbGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdICogdGhpcy5kYXRhLnNjYWxlWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLnkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV0gKyAoYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSAqIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICB2YXIgYXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5hdWRpbyk7XHJcbiAgICAgICAgICAgIGlmKCBzcGVlY2gua2V5ICkge1xyXG4gICAgICAgICAgICAgICAgYXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5rZXkpICsgXCJfXCIgKyBhdWRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2cud2FybihcIk9uIGdhbWUgc3BlZWNoOiBcIiArIGF1ZGlvKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc3BlZWNoQW5pbWF0aW9uICYmIHRoaXMudGhlbWUuc291bmRTeW5jRGF0YSAmJiB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGFbYXVkaW9dICYmIHRoaXMuZGF0YS5zcGVlY2hBdWRpbyA9PT0gYXVkaW8gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGFbYXVkaW9dO1xyXG4gICAgICAgICAgICAgICAgaWYoICEgdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRlJBTUVfUkFURSA9IHRoaXMuZGF0YS5mcmFtZVJhdGUgPyB0aGlzLmRhdGEuZnJhbWVSYXRlIDogMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHRoaXMuZ2FtZS50aW1lLmNyZWF0ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lci5sb29wKDEwMDAgLyBGUkFNRV9SQVRFLCB0aGlzLmluY3JlbWVudFNwZWVjaCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmNyZW1lbnRTcGVlY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zb3VuZFN5bmNEYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25TZXRbdGhpcy5zb3VuZFN5bmNEYXRhW3RoaXMuc3BlZWNoSW5kZXhdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoU3RvcDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gJiYgdGhpcy5zb3VuZFN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGVidWdCb3ggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTm9JbnB1dENoYXJhY3RlckFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBTeWQgR3Jvc2NsYXVkZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDgvMDUvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIHF1ZXN0aW9uIGFjdG9yLCB3aGljaCB3aWxsOlxyXG4gKiAgIC0gc2hvdyB0aGUgcGxheWVyIGEgKHNpbmdsZSBzZWxlY3Rpb24vcmFkaW8pIG11bHRpcGxlIGNob2ljZSBxdWVzdGlvblxyXG4gKiAgIC0gcGxheSBhbnkgYXVkaW8vdGV4dCBhc3NvY2lhdGVkIHdpdGggYXNraW5nIHF1ZXN0aW9uXHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uc19zbml0Y2hpbmdPclRlbGxpbmdfMDFcIiwgICAgICAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInF1ZXN0aW9uXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImZvbnRcIjogXCJxdWVzdGlvblRleHRcIixcclxuICogICAgIFwic3VibWl0QnV0dG9uSW1hZ2VcIjogXCJzdWJtaXRcIiwgICAgICAgICAgICAgICAgICAvLyBidXR0b24gaW1hZ2UgZnJvbSB0aGVtZS5idXR0b25zXHJcbiAqICAgICBcInN1Ym1pdEJ1dHRvbklEXCI6IFwic25pdE9yVGVsbFN1Ym1pdEJ1dHRvblwiLCAgICAgLy8gdG8gaWRlbnRpZnkgdGhlIHRleHQgZXZlbnQgY29taW5nIGZyb20gaXRcclxuICogICAgIFwic3VibWl0QnV0dG9uTG9jYXRpb25cIjogWyA1NDYsIDI1NSBdLFxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDkwLCAzNSBdLFxyXG4gKiAgICAgXCJzdGFydFF1ZXN0aW9uXCI6IFwic25pdE9yVGVsbF9xdWVzdGlvbl8wMVwiLCAgICAgIC8vIHdoaWNoIGNob2ljZSB0byBzdGFydCB3aXRoIGZyb20gdGhlIGNob2ljZU1hcCBzZXQuXHJcbiAqICAgICBcImNob2ljZU1hcFwiOiB7XHJcbiAqICAgICAgIFwic25pdE9yVGVsbF9xdWVzdGlvbl8wMVwiOiB7IC8vIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhpcyBxdWVzdGlvbiwgdXNlZCB3aGVuIGxpbmtpbmcgcXVlc3Rpb25zXHJcbiAqICAgICAgICAgIFwidGV4dFwiOiAob3B0aW9uYWwpIFwiU2hhbmRyYSBzdHVtYmxlZCB1cG9uIHNvbWUgcHJldHR5IG5hc3R5IGNvbW1lbnRzIG9ubGluZSBhYm91dCBCcmlhbm5hLiBUaGV5IHdlcmUgY2FsbGluZyBoZXIgYSBzbHV0LCBhbW9uZyBvdGhlciB0aGluZ3MuIFNoYW5kcmEgZGVjaWRlcyB0byBtZW50aW9uIGl0IHRvIGhlciBtb20uW2JyXVticl1JcyB0aGlzIHNuaXRjaGluZyBvciB0ZWxsaW5nP1wiIC8vIHF1ZXN0aW9uXHJcbiAqICAgICAgICAgIFwiYXVkaW9cIjogKG9wdGlvbmFsKSBcInNuaXRjaGluZ09yVGVsbGluZ19xdWVzdGlvbl8wMVwiLCAvLyBhdWRpbyBrZXkuXHJcbiAqICAgICAgICAgIFwia2V5XCI6IChvcHRpb25hbCkgXCJtYW5keVwiLCAvLyBhIHByZWZpeCBmb3IgdGhlIGF1ZGlvIGtleS4gKGJlY29tZXMgXCJtYW5keV9zbml0Y2hpbmdPclRlbGxpbmdfcXVlc3Rpb25fMDFcIiBpbiB0aGlzIGV4YW1wbGUpXHJcbiAqICAgICAgICAgIFwiY2hvaWNlc1wiOiBbXHJcbiAqICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlNuaXRjaGluZ1wiLCAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXllZCB0ZXh0IG9mIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjogXCJzbml0T3JUZWxsX3F1ZXN0aW9uXzAxXCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJpbmNvcnJlY3RcIiAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIHNldCB2YXJpYWJsZSB0byB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRlbGxpbmdcIiwgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXllZCB0ZXh0IG9mIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjogXCJzbml0T3JUZWxsX3F1ZXN0aW9uXzAxXCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJjb3JyZWN0XCIgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIHNldCB2YXJpYWJsZSB0byB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgIH1cclxuICogICAgICAgICAgICAuLi4gLy8gYXMgbWFueSBjaG9pY2VzIGFzIHlvdSB3YW50LlxyXG4gKiAgICAgICAgIF1cclxuICogICAgICAgfSxcclxuICogICAgIH0sXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICB9XHJcbiAqXHJcbiAqICBGb3IgYSBkZWNpc2lvbiBwb2ludCwgeW91IGNhbiBzdGxsIGRvIGEgdmFyaWFibGUvdmFsdWUgYW5kIGxpbmsuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgUXVlc3Rpb25BY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChnYW1lLCBkYXRhLCB0aGVtZSkge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRGVjb3JhdGlvbiBhY3RvciByZXF1aXJlcyBnYW1lIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEZWNvcmF0aW9uIGFjdG9yIHJlcXVpcmVzIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkdhbWVDaG9pY2U6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcbiAgICAgICAgICAgICAgICBvbkdhbWVTcGVlY2g6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jaG9pY2VNYXAgPSB0aGlzLmRhdGEuY2hvaWNlTWFwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbk5hbWUgPSB0aGlzLmRhdGEuc3RhcnRRdWVzdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UXVlc3Rpb24gPSB0aGlzLmNob2ljZU1hcFt0aGlzLmN1cnJlbnRRdWVzdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmdpblkgPSA2O1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gdGhpcy5kYXRhLmZvbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmdldEZvbnQoKHR5cGVvZiBmb250TmFtZSAhPT0gJ3VuZGVmaW5lZCcpID8gZm9udE5hbWUgOiBcInF1ZXN0aW9uVGV4dFwiKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFjayB3aGVyZSB3ZSBhcmUgYXQgbW92aW5nIGRvd24gdGhlIHNjcmVlbi5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50WCA9ICh0aGlzLmxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblswXSA6IHRoaXMudGhlbWUuc25pdGNoaW5nT3JUZWxsaW5nbGVmdE1hcmdpbiAqIDM7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFkgPSAodGhpcy5sb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5sb2NhdGlvblsxXSA6IDM1O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgbnVtYmVyIG9mIHF1ZXN0aW9ucyBhbmQgYnVpbGQgdGhlIGNvcnJlY3QgY2hvaWNlIGxpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuZGV0ZXJtaW5lQ2hvaWNlTGlzdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNob2ljZXMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRldGVybWluZUNob2ljZUxpc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3VycmVudFF1ZXN0aW9uLnRleHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXN0aW9uVGV4dCA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmN1cnJlbnRYLCB0aGlzLmN1cnJlbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50WSArPSAodGhpcy5xdWVzdGlvblRleHQuaGVpZ2h0ICsgdGhpcy5tYXJnaW5ZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoICF0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2UgfHwgIXRoaXMuZGF0YS5zdWJtaXRCdXR0b25JRCB8fCAhdGhpcy5kYXRhLnN1Ym1pdEJ1dHRvbkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlF1ZXN0aW9uIEFjdG9yIHJlcXVpcmVzIHN1Ym1pdCBidXR0b24gY29uZmlndXJhdGlvbiBpbiBzY2VuZSBkYXRhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLmJ1dHRvbnMgfHwgIXRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlF1ZXN0aW9uIEFjdG9yIHJlcXVpcmVzIGEgc3VibWl0IGJ1dHRvbiBlbnRyeSBpbiB0aGVtZVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEuc3VibWl0QnV0dG9uTG9jYXRpb25bMF0sIHRoaXMuZGF0YS5zdWJtaXRCdXR0b25Mb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5vblN1Ym1pdEJ1dHRvblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJtaXRCdXR0b24uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3B1bGF0ZUNob2ljZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXN0aW9uID0gKHRoaXMuY3VycmVudFF1ZXN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgbGlzdCBvZiBvcHRpb25zLlxyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gdGhpcy5jdXJyZW50WSxcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbixcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uSW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNob2ljZXMgPSBxdWVzdGlvbi5jaG9pY2VzO1xyXG4gICAgICAgICAgICBfLmVhY2goY2hvaWNlcywgZnVuY3Rpb24gKGNob2ljZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uID0gdGhpcy5yYWRpb0dyb3VwLmNyZWF0ZSgwLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAudW5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyUmFkaW9CdXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbi5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMub25DaG9vc2VPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLmdyb3VwID0gdGhpcy5yYWRpb0dyb3VwO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnggPSB0aGlzLnRoZW1lLnNuaXRjaGluZ09yVGVsbGluZ2xlZnRNYXJnaW4gKiAzO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnkgPSB0aGlzLmN1cnJlbnRZICsgMjtcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbi5mcmFtZU5hbWUgPSB0aGlzLnRoZW1lLmJ1dHRvbnMucmFkaW9CdXR0b25Hcm91cC51bnNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnZhcmlhYmxlID0gY2hvaWNlLnZhcmlhYmxlO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnZhbHVlID0gY2hvaWNlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnNjYWxlLnNldCgwLjc1ICwgMC43NSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgdGhpcy50aGVtZS5zbml0Y2hpbmdPclRlbGxpbmdsZWZ0TWFyZ2luICogNCwgMCxcclxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvVGV4dEdyb3VwLmFkZChjdXJyVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC55ID0gdGhpcy5jdXJyZW50WTtcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMub25DaG9vc2VPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY3VyclRleHQuZ3JvdXAgPSB0aGlzLnJhZGlvVGV4dEdyb3VwO1xyXG4gICAgICAgICAgICAgICAgY3VyclRleHQudmFyaWFibGUgPSBjaG9pY2UudmFyaWFibGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC52YWx1ZSA9IGNob2ljZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LnJhZGlvQnV0dG9uID0gY3VyclJhZGlvQnV0dG9uOyAvLyBsaW5rIHRoZSB0ZXh0IGFuZCByYWRpbyBidXR0b24gdG9nZXRoZXIuXHJcbiAgICAgICAgICAgICAgICBjdXJyUmFkaW9CdXR0b24ub3B0aW9uVGV4dCA9IGN1cnJUZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50WSArPSBjdXJyUmFkaW9CdXR0b24ub3B0aW9uVGV4dC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25JbmRleCsrO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCBxdWVzdGlvbi50ZXh0IHx8IHF1ZXN0aW9uLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogcXVlc3Rpb24udGV4dCwgXCJhdWRpb1wiOiBxdWVzdGlvbi5hdWRpbywgXCJrZXlcIjogcXVlc3Rpb24ua2V5fTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNob29zZU9wdGlvbjogZnVuY3Rpb24gKHNlbGVjdGVkSW5wdXQpIHtcclxuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBvdGhlciByYWRpbyBidXR0b25zLlxyXG4gICAgICAgICAgICBpZiggc2VsZWN0ZWRJbnB1dC5yYWRpb0J1dHRvbiApIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5wdXQucmFkaW9CdXR0b24uZ3JvdXAuc2V0QWxsKCdmcmFtZU5hbWUnLCB0aGlzLnRoZW1lLmJ1dHRvbnMucmFkaW9CdXR0b25Hcm91cC51bnNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5wdXQucmFkaW9CdXR0b24uZnJhbWVOYW1lID0gdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElucHV0Lmdyb3VwLnNldEFsbCgnZnJhbWVOYW1lJywgdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAudW5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElucHV0LmZyYW1lTmFtZSA9IHRoaXMudGhlbWUuYnV0dG9ucy5yYWRpb0J1dHRvbkdyb3VwLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIHdoZXRoZXIgdGhlIHNlbGVjdGVkIGFuc3dlciBpcyBjb3JyZWN0LlxyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFtzZWxlY3RlZElucHV0LnZhcmlhYmxlXSA9IHNlbGVjdGVkSW5wdXQudmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3BvbnNlVmFsdWUgPSBzZWxlY3RlZElucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TdWJtaXRCdXR0b25Qb2ludGVyVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogdGhpcy5sYXN0UmVzcG9uc2VWYWx1ZSB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5mb3JFYWNoRXhpc3RzKGZ1bmN0aW9uIChyYWRpbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWRpby5vcHRpb25UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGlvLm9wdGlvblRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYWRpby5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5yYWRpb1RleHRHcm91cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAuZm9yRWFjaEV4aXN0cyhmdW5jdGlvbiAocmFkaW9UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvVGV4dC5yYWRpb0J1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpb1RleHQucmFkaW9CdXR0b24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYWRpb1RleHQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zdWJtaXRCdXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnF1ZXN0aW9uVGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVlc3Rpb25UZXh0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2guZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUXVlc3Rpb25BY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8xOS8yMDE3XHJcbiAqIENvcHlyaWdodCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIHJlY3RhbmdsZSBhY3Rvciwgd2hpY2ggd2lsbDpcclxuICogICAtIERyYXcgYSByZWN0YW5nbGUgb24gdGhlIHNjcmVlbiwgd2l0aCBvcHRpb25hbCBib3JkZXIuXHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInNuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiLCAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInJlY3RhbmdsZVwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJzdGFydFwiOiBbIHgsIHkgXSxcclxuICogICAgIFwiY29sb3JcIjogXCJyZ2JhKDAsMCwwLDEpXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrXHJcbiAqICAgICBcIndpZHRoXCI6IFwiNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxXHJcbiAqICAgICBcImhlaWdodFwiOiBcIjVcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgMVxyXG4gKiAgICAgXCJhbHBoYVwiOiBcIjAuNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxLjBcclxuICogICAgIFwiYm9yZGVyXCIgOiBcIjFcIiwgLy8gb3B0aW9uYWwsIHRoaWNrbmVzcyBvZiBib3JkZXIgKG5vbmUgb2Ygbm90IHByb3ZpZGVkKVxyXG4gKiAgICAgXCJib3JkZXJDb2xvclwiOiBcInJiZ2EoMCwwLDAsMSlcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgYmxhY2tcclxuICogICAgIFwicm91bmRuZXNzXCI6IFwiMjhcIiwgLy8gZGVmYXVsdCAyOFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFJlY3RhbmdsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwic3RhcnRcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5kYXRhLnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmVuZExvYyA9IHRoaXMuZGF0YS5lbmQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcyA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoIDAsMCk7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IDB4RkYzMzAwLCBib3JkZXJDb2xvciA9IDB4RkYzMzAwO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxO1xyXG4gICAgICAgICAgICB2YXIgcm91bmRuZXNzID0gMjg7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDQ0MCwgaGVpZ2h0ID0gMjAwO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuc3RhcnRMb2NbMF0sIHkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVjdGFuZ2xlID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5jb2xvciApIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5kYXRhLmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmJvcmRlckNvbG9yICkge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLmRhdGEuYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53aWR0aCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhlaWdodCApIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KHRoaXMuZGF0YS5oZWlnaHQsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5yb3VuZG5lc3MgKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZG5lc3MgPSBwYXJzZUludCh0aGlzLmRhdGEucm91bmRuZXNzLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYWxwaGEgKSB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQodGhpcy5kYXRhLmFscGhhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5ib3JkZXIgKSB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXIgPSBwYXJzZUludCh0aGlzLmRhdGEuYm9yZGVyLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKGNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcm91bmRuZXNzKTsgLy8gZHJhdyBhIHJvdW5kZWQgcmVjdCBtYXNrXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICBpZiggYm9yZGVyICYmIGJvcmRlciA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSggYm9yZGVyLCBib3JkZXJDb2xvciwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWxwaGEgPSBhbHBoYTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uKCBjaG9pY2UgKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSBudWxsO1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyYXBoaWNzKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgc3BlZWNoIGJ1YmJsZS4gSXQgZGlzcGxheXMgdGV4dCBhbmQgcmVxdWVzdHMgdGhhdCBhdWRpbyBiZSBwbGF5ZWQuIEEgc3BlZWNoIGJ1YmJsZSBjYW4gaGF2ZSBpdHMgb3duIHRleHQvYXVkaW9cclxuICogYW5kIGNhbiBhbHNvIGxpc3RlbiBmb3IgdGV4dC9hdWRpbyBldmVudHMgdG8gc2hvdy5cclxuICogVGhlIHNwZWVjaCBidWJibGUgd2lsbCBhZGp1c3QgaXRzIHNpemUgdG8gZml0IHRoZSBwcm92aWRlZC9zZXQgdGV4dC5cclxuICpcclxuICp7XHJcbiAqICAgIFwibmFtZVwiOiBcImNob2ljZUJ1YmJsZVwiLCAvLyBuYW1lLlxyXG4gKiAgICBcInR5cGVcIjogXCJzcGVlY2gtYnViYmxlXCIsXHJcbiAqICAgIFwidGV4dFwiOiBcIlwiLCAvLyB0ZXh0IHRvIHNob3cuXHJcbiAqICAgIFwiYXVkaW9cIjogXCJcIiwgLy8gYXVkaW8ga2V5IHRvIHBsYXkuXHJcbiAqICAgIFwiaGlkZGVuXCI6IHRydWUsIC8vIHNldCB0byB0cnVlIHRvIG9wdGlvbmFsbHkgaGlkZSB0aGUgYnViYmxlIGluaXRpYWxseSwgdXNlZCB3aGVuIGNoYXJhY3RlciBpc24ndCB0aGUgZmlyc3QgdG8gdGFsay5cclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBtYXJnaW5YID0gMTIsIG1hcmdpblkgPSAxMjtcclxuXHJcbiAgICB2YXIgU3BlZWNoQnViYmxlQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gTm8gcmVxdWlyZWQgZmllbGRzLlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmRhdGEudGV4dCB8fCBcIiBcIjtcclxuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IHRoaXMuZGF0YS5hdWRpbyB8fCBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IHRoaXMuZGF0YS5rZXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvdygyMDAsIDUwKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcGVlY2goKTtcclxuICAgICAgICAgICAgLy8gQUNULTM1MiBIaWRlIGVtcHR5IHNwZWVjaCBidWJibGVzLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhpZGRlbiB8fCAhdGhpcy50ZXh0IHx8IHRoaXMudGV4dCA9PT0gXCIgXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkV2luZG93OiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUudGV4dFdpbmRvd3MgfHwgIXRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkluc3RydWN0aW9uIGFjdG9yIHJlcXVpcmVzIHRleHRXaW5kb3dzIHRoZW1lIGVudHJ5LCBhbmQgc21hbGwgZGVmaW5pdGlvbiBpbnNpZGUgaXQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueCA9IHg7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLnkgPSB5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRvcFdpbmRvdyA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwudG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdidWJibGVUZXh0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gdGhpcy5nZXRGb250KCdyZXBsYXlBdWRpbycpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcFdpZHRoID0gdG9wV2luZG93LndpZHRoICogMC44NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW5YLCBtYXJnaW5ZLCBcIiBcIiwgdGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5hZGQodGhpcy5jdXJyZW50VGV4dCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm90dG9tV2luZG93ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIDAgLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwuYm90dG9tKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IDMwIGJlY2F1c2UgdGhlIHRvcCBzcGVlY2ggYnViYmxlIGlzIDQwIHB4IHRhbGwuXHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVXaW5kb3cgPSBuZXcgUGhhc2VyLlRpbGVTcHJpdGUodGhpcy5nYW1lLCAwLCB0b3BXaW5kb3cuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgMzM4LCB0aGlzLmN1cnJlbnRUZXh0LmhlaWdodCAtIDMwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwubWlkZGxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKG1pZGRsZVdpbmRvdyk7XHJcblxyXG4gICAgICAgICAgICBib3R0b21XaW5kb3cueSA9IHRvcFdpbmRvdy5oZWlnaHQgKyBtaWRkbGVXaW5kb3cuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gNS4gQWRkIGV2ZW50aW5nLlxyXG4gICAgICAgICAgICB0aGlzLndpbmRvd3MgPSB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFdpbmRvdyxcclxuICAgICAgICAgICAgICAgIG1pZGRsZTogbWlkZGxlV2luZG93LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBib3R0b21XaW5kb3dcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLndpbmRvd3MsIGZ1bmN0aW9uIChidWJibGUpIHtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0T3Zlci5hZGQodGhpcy5vbk1vdXNlSW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0T3V0LmFkZCh0aGlzLm9uTW91c2VPdXQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0VXAuYWRkKHRoaXMub25Qb2ludGVyVXAsIHRoaXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCAoYm90dG9tV2luZG93LnggKyBib3R0b21XaW5kb3cud2lkdGggLSA0MCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgKHRvcFdpbmRvdy5oZWlnaHQgKyBib3R0b21XaW5kb3cuaGVpZ2h0ICsgbWlkZGxlV2luZG93LmhlaWdodCkgLyAyLCBcIlJlcGxheSBBdWRpb1wiLCB0aGlzLnJTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC5hbmNob3Iuc2V0VG8oMC41LDAuNSk7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLmFkZCh0aGlzLnJlcGxheVRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAgPSB3aW5kb3dHcm91cDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueCAtPSB0b3BXaW5kb3cud2lkdGggLyAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gc3VidHJhY3QgMzAgYmVjYXVzZSB0aGUgdG9wIHNwZWVjaCBidWJibGUgaXMgNDAgcHggdGFsbC5cclxuICAgICAgICAgICAgdGhpcy53aW5kb3dzLm1pZGRsZS5oZWlnaHQgPSB0aGlzLmN1cnJlbnRUZXh0LmhlaWdodCAtIDMwO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd3MuYm90dG9tLnkgPSB0aGlzLndpbmRvd3MudG9wLmhlaWdodCArIHRoaXMud2luZG93cy5taWRkbGUuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Nb3VzZUluOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLnRoZW1lLnRpbnRzLmJ1YmJsZVRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuc2V0U3R5bGUodGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLmdldEZvbnQoJ2J1YmJsZVRleHQnKS5maWxsO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFN0eWxlKHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAge3RleHQ6IHRoaXMudGV4dCwgYXVkaW86IHRoaXMuYXVkaW8sIGtleTogdGhpcy5rZXl9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNwZWVjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy5nZXRUZXh0KHRoaXMudGV4dCwgdGhpcy5rZXkpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRUZXh0KCB0ZXh0ICk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCB7dGV4dDogdGV4dCwgYXVkaW86IHRoaXMuYXVkaW8sIGtleTogdGhpcy5rZXl9KTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICAvL2xvZy53YXJuKFwic3BlZWNoIGJ1YmJsZSByZWNlaXZlZFwiKTtcclxuICAgICAgICAgICAgLy9sb2cud2FybihzcGVlY2gpO1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSBzcGVlY2gudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5rZXkgPSBzcGVlY2gua2V5O1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvID0gc3BlZWNoLmF1ZGlvO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFRleHQoIHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy5nZXRUZXh0KHRoaXMudGV4dCwgdGhpcy5rZXkpKSApO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICAvLyBBQ1QtMzUyIEhpZGUgZW1wdHkgc3BlZWNoIGJ1YmJsZXMsIGhlcmUsIHNob3cgaXQgaWYgdGhlcmUgaXMgdGV4dC5cclxuICAgICAgICAgICAgaWYoICB0aGlzLnRleHQgJiYgdGhpcy50ZXh0ICE9PSBcIiBcIiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5yU3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dzICkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMud2luZG93cywgZnVuY3Rpb24gKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTcGVlY2hCdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgSmVmZiBCbHVtZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMjQvMjAxN1xyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgc3BlZWNoIGJ1YmJsZSB0aGF0IG9ubHkgZGlzcGxheXMgdGV4dCBhbmQgYSBidWJibGUgYmVoaW5kIGl0LiBBbGxvd3MgZm9yIG1vdmFibGUgY2Fycm90LiBBdXRvIGFkanVzdHMgdG8gdGV4dCBzaXplLlxyXG4gKiBOT1RFOiBORUVEUyBERUZBVUxUIFBBUkFNRVRFUiBWQUxVRVMgQU5EL09SIFJFUVVJUkVNRU5UIENIRUNLSU5HIEFORCBFUlJPUiBIQU5ETElOR1xyXG4gKlxyXG4gKntcclxuICogICAgXCJuYW1lXCI6IFwiY2hvaWNlQnViYmxlXCIsIC8vIG5hbWUuXHJcbiAqICAgIFwidHlwZVwiOiBcInRleHQtYnViYmxlXCIsXHJcbiAqICAgIFwiY2Fycm90U2lkZVwiOiBcImJvdHRvbVwiLCAvLyBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIgLSBzaWRlIG9mIGJ1YmJsZSB0aGUgY2Fycm90IGlzIHRvIGJlIHBvc2l0aW9uZWRcclxuICogICAgXCJsb2NhdGlvblwiOiBbMCwwXSxcclxuICogICAgXCJjYXJyb3RQb3NpdGlvblwiOiAwLjUsIC8vIGxvY2F0aW9uLCBhcyBwZXJjZW50YWdlIG9mIGxlbmd0aCBvciB3aWR0aCBvZiBjYXJyb3RTaWRlXHJcbiAqICAgIFwiY2VudGVyRmlsbFwiOiBcIjB4ZmZmZmZmXCIsXHJcbiAqICAgIFwidGV4dFwiOiBcIlwiLCAvLyB0ZXh0IHRvIHNob3cuXHJcbiAqICAgIFwiYnViYmxlV2lkdGhcIjogMjAwLFxyXG4gKiAgICBcInRleHRQYWRkaW5nXCI6IDIwLCAvLyBQYWRkaW5nIGJldHdlZW4gYnViYmxlIGFuZCB0ZXh0XHJcbiAqICAgIFwiaGlkZGVuXCI6IHRydWUsIC8vIHNldCB0byB0cnVlIHRvIG9wdGlvbmFsbHkgaGlkZSB0aGUgYnViYmxlIGluaXRpYWxseSwgdXNlZCB3aGVuIGNoYXJhY3RlciBpc24ndCB0aGUgZmlyc3QgdG8gdGFsay5cclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBtYXJnaW5YID0gMTIsIG1hcmdpblkgPSAxMjtcclxuXHJcbiAgICB2YXIgVGV4dEJ1YmJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107IC8vIE5vIHJlcXVpcmVkIGZpZWxkcy5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXJyb3RTaWRlID0gdGhpcy5kYXRhLmNhcnJvdFNpZGU7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY2Fycm90UG9zaXRpb24gPSB0aGlzLmRhdGEuY2Fycm90UG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRmlsbCA9IHRoaXMuZGF0YS5jZW50ZXJGaWxsO1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmRhdGEudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5idWJibGVXaWR0aCA9IHRoaXMuZGF0YS5idWJibGVXaWR0aFxyXG4gICAgICAgICAgICB0aGlzLnRleHRQYWRkaW5nID0gdGhpcy5kYXRhLnRleHRQYWRkaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGRlbiA9IHRoaXMuZGF0YS5oaWRkZW47XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWxheSA9IHRoaXMuZGF0YS5zdGFydERlbGF5O1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93KHRoaXMubG9jYXRpb25bMF0sIHRoaXMubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAvL3RoaXMuc2V0U3BlZWNoKCk7XHJcbiAgICAgICAgICAgIC8vIEFDVC0zNTIgSGlkZSBlbXB0eSBzcGVlY2ggYnViYmxlcy5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5oaWRkZW4gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkV2luZG93OiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcyApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiSW5zdHJ1Y3Rpb24gYWN0b3IgcmVxdWlyZXMgdGV4dEJ1YmJsZUltYWdlcyB0aGVtZSBlbnRyeS5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC54ID0geDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueSA9IHk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYnViYmxlVG9wTGVmdCA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3BMZWZ0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZVRvcCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3ApO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlVG9wUmlnaHQgPSB3aW5kb3dHcm91cC5jcmVhdGUoYnViYmxlVG9wTGVmdC53aWR0aCArIGJ1YmJsZVRvcC53aWR0aCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMudG9wUmlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlUmlnaHQgPSB3aW5kb3dHcm91cC5jcmVhdGUoYnViYmxlVG9wUmlnaHQueCwgYnViYmxlVG9wUmlnaHQuaGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5yaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVCb3R0b21SaWdodCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BSaWdodC54LCBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVSaWdodC5oZWlnaHQsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmJvdHRvbVJpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUJvdHRvbSA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3AueCwgYnViYmxlQm90dG9tUmlnaHQueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tKTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUJvdHRvbUxlZnQgPSB3aW5kb3dHcm91cC5jcmVhdGUoMCwgYnViYmxlQm90dG9tUmlnaHQueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVMZWZ0ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIGJ1YmJsZVRvcExlZnQuaGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5sZWZ0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUNlbnRlciA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoYnViYmxlVG9wTGVmdC53aWR0aCwgYnViYmxlVG9wTGVmdC5oZWlnaHQsIHdpbmRvd0dyb3VwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCd0ZXh0QnViYmxlVGV4dCcpO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLndvcmRXcmFwV2lkdGggPSB0aGlzLmJ1YmJsZVdpZHRoIC0gKHRoaXMudGV4dFBhZGRpbmcgKiAyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB0aGlzLnRleHRQYWRkaW5nLCB0aGlzLnRleHRQYWRkaW5nLCB0aGlzLnRleHQsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKHRoaXMuY3VycmVudFRleHQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1YmJsZVRvcFdpZHRoID0gdGhpcy5idWJibGVXaWR0aCAtIGJ1YmJsZVRvcExlZnQud2lkdGggLSBidWJibGVUb3BSaWdodC53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHRvcHMgPSBNYXRoLmNlaWwoYnViYmxlVG9wV2lkdGggLyBidWJibGVUb3Aud2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgdG9wUmVtYWluZGVyID0gYnViYmxlVG9wV2lkdGggJSBidWJibGVUb3Aud2lkdGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG9wczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1RvcCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoICsgKGkgKiBidWJibGVUb3Aud2lkdGgpLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRvcFJlbWFpbmRlciAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzVG9wLnggLT0gYnViYmxlVG9wLndpZHRoIC0gdG9wUmVtYWluZGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBidWJibGVUb3BSaWdodC54ID0gdGhpcy5idWJibGVXaWR0aCAtIGJ1YmJsZVRvcFJpZ2h0LndpZHRoO1xyXG4gICAgICAgICAgICBidWJibGVSaWdodC54ID0gYnViYmxlQm90dG9tUmlnaHQueCA9IGJ1YmJsZVRvcFJpZ2h0Lng7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVSaWdodEhlaWdodCA9IHRoaXMuY3VycmVudFRleHQuaGVpZ2h0ICsgKDIgKiB0aGlzLnRleHRQYWRkaW5nKSAtIGJ1YmJsZVRvcC5oZWlnaHQgLSBidWJibGVCb3R0b20uaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRzID0gTWF0aC5jZWlsKGJ1YmJsZVJpZ2h0SGVpZ2h0IC8gYnViYmxlUmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0UmVtYWluZGVyID0gYnViYmxlUmlnaHRIZWlnaHQgJSBidWJibGVSaWdodC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByaWdodHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNSaWdodCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BSaWdodC54LCBidWJibGVUb3BSaWdodC5oZWlnaHQgKyAoYnViYmxlUmlnaHQuaGVpZ2h0ICogaSksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLnJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihyaWdodFJlbWFpbmRlciAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzUmlnaHQueSAtPSBidWJibGVSaWdodC5oZWlnaHQgLSByaWdodFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUJvdHRvbVJpZ2h0LnkgPSBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVSaWdodEhlaWdodDtcclxuICAgICAgICAgICAgYnViYmxlQm90dG9tLnkgPSBidWJibGVCb3R0b21SaWdodC55O1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdG9wczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0JvdHRvbSA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoICsgKGkgKiBidWJibGVUb3Aud2lkdGgpLCBidWJibGVCb3R0b20ueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0b3BSZW1haW5kZXIgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpc0JvdHRvbS54IC09IGJ1YmJsZVRvcC53aWR0aCAtIHRvcFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUJvdHRvbUxlZnQueSA9IGJ1YmJsZUJvdHRvbVJpZ2h0Lnk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByaWdodHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNMZWZ0ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIGJ1YmJsZVRvcFJpZ2h0LmhlaWdodCArIChidWJibGVSaWdodC5oZWlnaHQgKiBpKSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMubGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYocmlnaHRSZW1haW5kZXIgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpc0xlZnQueSAtPSBidWJibGVSaWdodC5oZWlnaHQgLSByaWdodFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNhcnJvdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLmNhcnJvdFNpZGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJvdCA9IHdpbmRvd0dyb3VwLmNyZWF0ZSh0aGlzLmJ1YmJsZVdpZHRoICogdGhpcy5jYXJyb3RQb3NpdGlvbiwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LnNjYWxlLnkgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QuYW5jaG9yLnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy5idWJibGVXaWR0aCAtIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5jYXJyb3RPdmVybGFwLCAoYnViYmxlUmlnaHRIZWlnaHQgKyBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVCb3R0b21SaWdodC5oZWlnaHQpICogdGhpcy5jYXJyb3RQb3NpdGlvbiwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuY2Fycm90KTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QuYW5jaG9yLnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LnJvdGF0aW9uID0gLTkwICogKE1hdGguUEkvMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy5idWJibGVXaWR0aCAqIHRoaXMuY2Fycm90UG9zaXRpb24sIGJ1YmJsZVJpZ2h0SGVpZ2h0ICsgYnViYmxlVG9wUmlnaHQuaGVpZ2h0ICsgYnViYmxlQm90dG9tUmlnaHQuaGVpZ2h0IC0gdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LmFuY2hvci54ID0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIChidWJibGVSaWdodEhlaWdodCArIGJ1YmJsZVRvcFJpZ2h0LmhlaWdodCArIGJ1YmJsZUJvdHRvbVJpZ2h0LmhlaWdodCkgKiB0aGlzLmNhcnJvdFBvc2l0aW9uLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5jYXJyb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJvdC5hbmNob3IueCA9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3Qucm90YXRpb24gPSA5MCAqIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUNlbnRlci5iZWdpbkZpbGwodGhpcy5jZW50ZXJGaWxsKTtcclxuICAgICAgICAgICAgYnViYmxlQ2VudGVyLmRyYXdSZWN0KDAsIDAsIGJ1YmJsZVRvcFdpZHRoLCBidWJibGVSaWdodEhlaWdodCk7XHJcbiAgICAgICAgICAgIGJ1YmJsZUNlbnRlci5lbmRGaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5icmluZ1RvVG9wKHRoaXMuY3VycmVudFRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gd2luZG93R3JvdXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgLyp0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dzICkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMud2luZG93cywgZnVuY3Rpb24gKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7Ki9cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dHcm91cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHRCdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgU3lkIEdyb3NjbGF1ZGVcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA4LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSB0ZXh0IGFjdG9yLCB3aGljaCB3aWxsOlxyXG4gKiAgIC0gc2hvdyB0aGUgc3BlY2lmaWVkIHRleHRcclxuICogICAtIHBsYXkgYW55IGF1ZGlvL3RleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZXh0XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInNuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiLCAgICAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInRleHRcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiQ29ycmVjdC4gQ2xpY2sgdGhlIE5leHQgYnV0dG9uIHRvIGZpbmQgb3V0IHdoeS5cIlxyXG4gKiAgICAgXCJmb250XCI6IFwicXVlc3Rpb25UZXh0XCIsXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLCAgICAvLyBvciBcImNlbnRlclwiIGZvciBlaXRoZXIgZmllbGQuXHJcbiAqICAgICBcImFuZ2xlXCI6IC0zMCwgICAgICAgICAgICAvLyBvcHRpb25hbCwgZGVncmVlcyBmcm9tIG5vcnRoICgtMTgwIHRvIDE4MClcclxuICogICAgIFwicm90YXRpb25cIjogMC41LCAgICAgICAgIC8vIG9wdGlvbmFsLCByYWRpYW5zIGluIHVuaXRzIG9mIFBJLiBUaGlzIG92ZXJyaWRlcyBhbmdsZSBpZiBib3RoIGFyZSBzZXQuXHJcbiAqICAgICBcImFuY2hvclwiOiAob3B0aW9uYWwpIFwibGVmdFwiLCAgICAgLy8gd2hpY2ggc2lkZSB0byBhbmNob3IgdGhlIHRleHQgc3ByaXRlLiBDYW4gYWxzbyBzZXQgYW5jaG9yIHRvIHNwZWNpZmljIHBvc2l0aW9uIFt4LHldXHJcbiAqICAgICBcImF1ZGlvXCI6IChvcHRpb25hbCkgXCJzbml0Y2hpbmdPclRlbGxpbmdfZmVlZGJhY2tfMDFcIiwgICAgLy8gYXVkaW8ga2V5LlxyXG4gKiAgICAgXCJrZXlcIjogKG9wdGlvbmFsKSBcIm1hbmR5XCIsIC8vIGEgcHJlZml4IGZvciB0aGUgYXVkaW8ga2V5LiAoYmVjb21lcyBcIm1hbmR5X3NuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiIGluIHRoaXMgZXhhbXBsZSksXHJcbiAqICAgICBcIndvcmRXcmFwV2lkdGhcIjogIywgIC8vIG9wdGlvbmFsbHkgc2V0IGEgd3JhcHBpbmcgd2lkdGhcclxuICogICAgIFwiYnVsbGV0XCI6IHRydWUsXHJcbiAqICAgICBcImJ1bGxldE9mZnNldFwiOiAzLCAvLyBvcHRpb25hbCwgc3BhY2UgaW4gcGl4ZWxzIGFmdGVyIGJ1bGxldCBpZiB5b3Ugd2FudCBvdGhlciB0aGFuIGRlZmF1bHQgc3BhY2luZ1xyXG4gKiAgICAgXCJzaGFkb3dYXCI6IDUsIC8vIG9wdGlvbmFsLCBkcm9wIHNoYWRvdyB3aWR0aCBpbiBwaXhlbHM7IGRlZmF1bHQgaXMgbm8gc2hhZG93IC0gc2FtZSBhcyBzaGFkb3dZIGlmIG9ubHkgb25lIGlzIHNwZWNpZmllZCAtIDUgaWYgb25seSBjb2xvciBpcyBzcGVjaWZpZWRcclxuICogICAgIFwic2hhZG93WVwiOiA1LCAvLyBvcHRpb25hbCwgZHJvcCBzaGFkb3cgaGVpZ2h0IGluIHBpeGVsczsgZGVmYXVsdCBpcyBubyBzaGFkb3cgLSBzYW1lIGFzIHNoYWRvd1ggaWYgb25seSBvbmUgaXMgc3BlY2lmaWVkIC0gNSBpZiBvbmx5IGNvbG9yIGlzIHNwZWNpZmllZFxyXG4gKiAgICAgXCJzaGFkb3dDb2xvclwiOiBcInJnYmEoMCwwLDAsMSlcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgYmxhY2sgd2l0aCBhbHBoYSAxLjBcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcInR3ZWVuXCI6IHsgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwsIHR3ZWVuIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRleHRcclxuICogICAgICAgXCJ0aW1lXCI6IDMwMCwgICAgICAgICAgICAgICAgICAvLyAocmVxdWlyZWQgZm9yIHR3ZWVuKSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cclxuICogICAgICAgXCJsb2NhdGlvblwiOiBbIDE5MCwgMTUwIF0sICAgICAvLyAocmVxdWlyZWQgZm9yIHR3ZWVuKSBsb2NhdGlvbiB0byB0d2VlbiB0bywgcmVxdWlyZWRcclxuICogICAgICAgXCJkZWxheVwiOiAxMDAwMCwgICAgICAgICAgICAgICAvLyAob3B0aW9uYWwgZm9yIHR3ZWVuKSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHR3ZWVuaW5nXHJcbiAqICAgICAgIFwieW95b1wiOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gKG9wdGlvbmFsIGZvciB0d2VlbikgcmV0dXJuIHRvIG9yaWdpbmFsIHBvc2l0aW9uIGFmdGVyIHR3ZWVuP1xyXG4gKiAgICAgICBcImFsaWduXCI6IFwibGVmdFwiICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwsIGFsaWduIHZhbHVlIHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgc3R5bGUgc2V0dGluZyBpbiB0aGUgdGhlbWUgKGFkZGVkIGJ5IEplZmYgQmx1bWUgMTIuMTcuMjAxOSlcclxuICogICAgIH1cclxuICogIH1cclxuICpcclxuICogIE5vdGUgdGhhdCB0aGlzIGFjdG9yIHJlY29nbml6ZXMgb3B0aW9uYWwgcHJvcGVydGllcyBpbiB0aGUgZm9udCBzdHlsZTpcclxuICpcclxuICogICAgICBcImxpbmVTcGFjaW5nXCIgKGEgbnVtYmVyIG9mIHBpeGVscyB0byBhZGQgdG8gdGhlIG5vcm1hbCB3cmFwcGVkIHRleHQgbGluZSBzcGFjaW5nKS4gRm9yIGV4YW1wbGUsIHRvIHJlZHVjZSBsaW5lIHNwYWNpbmcgYnkgMTUgcGl4ZWxzOlxyXG4gKlxyXG4gKiAgICAgICAgICBcImxlc3Nvbl9saWdodFwiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcIndvcmRXcmFwXCI6IHRydWUsIFwid29yZFdyYXBXaWR0aFwiOiAyMDAsIFwibGluZVNwYWNpbmdcIjogLTE1IH1cclxuICpcclxuICogICAgIFwiYWxwaGFcIiAob3BhY2l0eSwgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxKVxyXG4gKlxyXG4gKiAgICAgICAgICBcImxlc3Nvbl9saWdodFwiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcImFscGhhXCI6IDAuNSB9XHJcbiAqXHJcbiAqICAgICBcInNoYWRvd1hcIjogKGluY2x1ZGUgYSBkcm9wIHNoYWRvdyB3aXRoIHRoaXMgd2lkdGgsIGluIHBpeGVscykgVGhpcyB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgaW4gc2hhZG93WSBpZiBvbmx5XHJcbiAqICAgICAgICAgIG9uZSBpcyBzcGVjaWZpZWQsIG9yIHNldCB0byA1IHBpeGVscyBpZiBvbmx5IHNoYWRvd0NvbG9yIGlzIHNwZWNpZmllZC5cclxuICogICAgIFwic2hhZG93WVwiOiAoaW5jbHVkZSBhIGRyb3Agc2hhZG93IHdpdGggdGhpcyBoZWlnaHQsIGluIHBpeGVscykgVGhpcyB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgaW4gc2hhZG93WCBpZiBvbmx5XHJcbiAqICAgICAgICAgIG9uZSBpcyBzcGVjaWZpZWQsIG9yIHNldCB0byA1IHBpeGVscyBpZiBvbmx5IHNoYWRvd0NvbG9yIGlzIHNwZWNpZmllZC5cclxuICogICAgIFwic2hhZG93Q29sb3JcIjogKGluY2x1ZGUgYSBkcm9wIHNoYWRvdyB3aXRoIHRoaXMgY29sb3IgYW5kIGFscGhhIHZhbHVlKSBJZiBzaGFkb3dYIGFuZC9vciBzaGFkb3dZIGFyZSBzcGVjaWZpZWRcclxuICogICAgICAgICAgYnV0IHNoYWRvd0NvbG9yIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHQgaXMgYmxhY2sgd2l0aCBhbHBoYSAxLjBcclxuICogICAgIFwic2hhZG93Qmx1clwiOiAoZ2F1c3NpYW4gYmx1ciB0byBzb2Z0ZW4gc2hhZG93KSBvcHRpb25hbCwgQSBudW1iZXIgZnJvbSAwIChubyBibHVyKSB1cCB0byBhcHByb3hpbWF0ZWx5XHJcbiAqICAgICAgICAgIDEwIChkZXBlbmRpbmcgb24gc2NlbmUpLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGUsIHRvIHNwZWNpZnkgYW4gOC1waXhlbCB3aWRlIGFuZCAzLXBpeGVsIGhpZ2ggYmx1cnJlZCBkcm9wIHNoYWRvdyBpbiByZWQ6XHJcbiAqXHJcbiAqICAgICAgICAgIFwibGVzc29uX3JlZFNoYWRvd1wiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcInNoYWRvd1hcIjogOCwgXCJzaGFkb3dZXCI6IDMsIFwic2hhZG93Q29sb3JcIjogXCJyZ2JhKDI1NSwwLDAsMSlcIiwgXCJzaGFkb3dCbHVyXCI6IDUgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFRleHRBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiZm9udFwiLCBcInRleHRcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSB0aGlzLmRhdGEuYXVkaW87XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0gdGhpcy5kYXRhLmtleTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5mb250O1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5nZXRGb250KCh0eXBlb2YgZm9udE5hbWUgIT09ICd1bmRlZmluZWQnKSA/IGZvbnROYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLndvcmRXcmFwV2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLndvcmRXcmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUud29yZFdyYXBXaWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53b3JkV3JhcFdpZHRoLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5hbGlnbil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmFsaWduID0gdGhpcy5kYXRhLmFsaWduO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy50ZXh0KTsgXHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMubG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLFxyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgYW5jaG9yWCA9IDA7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgICBhbmNob3JYID0gMC41O1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRhdGEuYW5jaG9yID09PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICBhbmNob3JYID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKCB0aGlzLmRhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IHRoaXMuZGF0YS5hbmNob3JbMF07XHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gdGhpcy5kYXRhLmFuY2hvclsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idWxsZXRYID0geDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5idWxsZXQgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlQnVsbGV0T2Zmc2V0ID0gKCh0eXBlb2YgKHRoaXMuZGF0YS5idWxsZXRPZmZzZXQpKSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1bGxldFRleHQgPSB1c2VCdWxsZXRPZmZzZXQgPyBcIuKAolwiIDogXCLigKIgXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVsbGV0T2Zmc2V0V2lkdGggPSAwOyAvL2luaXRpYWxpemUgd2lkdGggZnJvbSBidWxsZXQgdG8gdGV4dFxyXG4gICAgICAgICAgICAgICAgaWYodXNlQnVsbGV0T2Zmc2V0KXtcclxuICAgICAgICAgICAgICAgICAgICBidWxsZXRPZmZzZXRXaWR0aCA9IHRoaXMuZGF0YS5idWxsZXRPZmZzZXQ7IC8vc2V0cyBidWxsZXRPZmZzZXQgZnJvbSB0aGVtZS5qc29uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRmFjdG9yID0gYW5jaG9yWDsgXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGFuY2hvclggPT09IDAuNSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZvciBjZW50ZXJlZCB0ZXh0IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUgPSB0aGlzLmdhbWUubWFrZS50ZXh0KHgsIHksIHRoaXMudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUgPSB0aGlzLmdhbWUubWFrZS50ZXh0KHgsIHksYnVsbGV0VGV4dCwgdGhpcy5zdHlsZSk7ICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50QWRqdXN0bWVudCA9ICgodGhpcy5idWxsZXRTcHJpdGUud2lkdGggKyBidWxsZXRPZmZzZXRXaWR0aCArIHRoaXMudGV4dFNwcml0ZS53aWR0aCkvMik7IC8vIGxlbmd0aCB0byBjZW50ZXJcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnRleHQoeCAtIGFsaWdubWVudEFkanVzdG1lbnQsIHksIGJ1bGxldFRleHQsIHRoaXMuc3R5bGUpOyBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFRleHRYID0geCAtICh0aGlzLmJ1bGxldFNwcml0ZS5wb3NpdGlvbi54IC0gKHRoaXMuYnVsbGV0U3ByaXRlLndpZHRoIC8yKSk7IC8vIGdldCB4IHBvc2l0aW9uIG9mIHRleHRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuYnVsbGV0U3ByaXRlLmFkZENoaWxkKHRoaXMuZ2FtZS5tYWtlLnRleHQoY2FsY3VsYXRlZFRleHRYICwgeSAtIHRoaXMuYnVsbGV0WSwgdGhpcy50ZXh0LCB0aGlzLnN0eWxlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgbGVmdCBPUiByaWdodCBhbGlnbmVkIHRleHRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh4ICArIGJ1bGxldE9mZnNldFdpZHRoLCB5LCBidWxsZXRUZXh0LCB0aGlzLnN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUgPSB0aGlzLmJ1bGxldFNwcml0ZS5hZGRDaGlsZCh0aGlzLmdhbWUubWFrZS50ZXh0KHRoaXMuYnVsbGV0U3ByaXRlLndpZHRoLCB5IC0gdGhpcy5idWxsZXRZLCB0aGlzLnRleHQsIHRoaXMuc3R5bGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh4LCB5LCB0aGlzLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRYID0geDtcclxuXHJcbiAgICAgICAgICAgIGlmICggKHR5cGVvZiAodGhpcy5zdHlsZS5saW5lU3BhY2luZykpICE9PSAndW5kZWZpbmVkJyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5saW5lU3BhY2luZyA9IHRoaXMuc3R5bGUubGluZVNwYWNpbmc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKHR5cGVvZiAodGhpcy5zdHlsZS5hbHBoYSkpICE9PSAndW5kZWZpbmVkJyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5hbHBoYSA9IHRoaXMuc3R5bGUuYWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNYID0gKCggdHlwZW9mICh0aGlzLnN0eWxlLnNoYWRvd1gpKSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgICAgICAgICAgIHZhciBoYXNZID0gKCggdHlwZW9mICh0aGlzLnN0eWxlLnNoYWRvd1kpKSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgICAgICAgICAgIHZhciBoYXNDb2xvciA9ICgoIHR5cGVvZiAodGhpcy5zdHlsZS5zaGFkb3dDb2xvcikpICE9PSB1bmRlZmluZWQgKTtcclxuICAgICAgICAgICAgdmFyIGhhc0JsdXIgPSAoKCB0eXBlb2YgKHRoaXMuc3R5bGUuc2hhZG93Qmx1cikpICE9PSB1bmRlZmluZWQgKTtcclxuICAgICAgICAgICAgaWYgKCBoYXNYIHx8IGhhc1kgfHwgaGFzQ29sb3IgfHwgaGFzQmx1ciApIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dYID0gNTtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dZID0gNTtcclxuICAgICAgICAgICAgICAgIGlmICggaGFzWCApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dYID0gdGhpcy5zdHlsZS5zaGFkb3dYO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhhc1kgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1kgPSBzaGFkb3dYO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggaGFzWSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dZID0gdGhpcy5zdHlsZS5zaGFkb3dZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhhc1ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1ggPSBzaGFkb3dZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwxKVwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNDb2xvciApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDb2xvciA9IHRoaXMuc3R5bGUuc2hhZG93Q29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93Qmx1ciA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGhhc0JsdXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Qmx1ciA9IHRoaXMuc3R5bGUuc2hhZG93Qmx1cjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5zZXRTaGFkb3coIHNoYWRvd1gsIHNoYWRvd1ksIHNoYWRvd0NvbG9yLCBzaGFkb3dCbHVyICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmFuY2hvci5zZXRUbyggYW5jaG9yWCwgYW5jaG9yWSApO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJhdWRpb1wiOiB0aGlzLmF1ZGlvLCBcImtleVwiOiB0aGlzLmtleX07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRhdGEuYW5nbGUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWxsZXRTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5kYXRhLnJvdGF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVsbGV0U3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUucm90YXRpb24gPSBNYXRoLlBJICogdGhpcy5kYXRhLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLnJvdGF0aW9uID0gTWF0aC5QSSAqIHRoaXMuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudHdlZW4gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW5EYXRhID0gdGhpcy5kYXRhLnR3ZWVuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gdGhpcy50ZXh0WCAtIHRoaXMuYnVsbGV0WDtcclxuICAgICAgICAgICAgICAgIHZhciB5b3lvID0gKCB0eXBlb2YgdHdlZW5EYXRhLnlveW8gIT0gXCJ1bmRlZmluZWRcIiApID8gdHdlZW5EYXRhLnlveW8gOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxheSA9ICggdHlwZW9mIHR3ZWVuRGF0YS5kZWxheSAhPSBcInVuZGVmaW5lZFwiICkgPyB0d2VlbkRhdGEuZGVsYXkgOiAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9ICggdHlwZW9mIHR3ZWVuRGF0YS5lYXNpbmcgIT0gXCJ1bmRlZmluZWRcIiApID8gdHdlZW5EYXRhLmVhc2luZyA6IFwiTGluZWFyXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIHR3ZWVuRGF0YS5sb2NhdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhLmJ1bGxldCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLmJ1bGxldFNwcml0ZSkudG8oIHsgeDogdHdlZW5EYXRhLmxvY2F0aW9uWzBdLCB5OiB0d2VlbkRhdGEubG9jYXRpb25bMV0gIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEudGltZSwgZWFzaW5nLCB0cnVlLCBkZWxheSwgMCwgeW95byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlKS50byggeyB4OiAodHdlZW5EYXRhLmxvY2F0aW9uWzBdICsgdGV4dE9mZnNldCksIHk6IHR3ZWVuRGF0YS5sb2NhdGlvblsxXSAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgdHJ1ZSwgZGVsYXksIDAsIHlveW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiggdHdlZW5EYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlLnNjYWxlKS50byggeyB4OiB0d2VlbkRhdGEuc2NhbGVbMF0sIHk6IHR3ZWVuRGF0YS5zY2FsZVsxXSAgfSwgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgdHJ1ZSwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEuYWxwaGEpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlKS50byggeyBhbHBoYTogdHdlZW5EYXRhLmFscGhhIH0sIHR3ZWVuRGF0YS50aW1lLCBlYXNpbmcsIHRydWUsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiggY2hvaWNlICkge1xyXG4gICAgICAgICAgICBpZiggY2hvaWNlICYmIGNob2ljZS50ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLnNldFRleHQoY2hvaWNlLnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5idWxsZXRTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuYXVkaW8gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0geyBcImF1ZGlvXCI6IHRoaXMuYXVkaW8sIFwia2V5XCI6IHRoaXMua2V5LCBcInByaW9yaXR5XCI6IFwic3RvcFwifTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0QWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIERhdmlkIExlZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMDQvMjAxOFxyXG4gKiBDb3B5cmlnaHQgMjAxOCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogXHJcbiAqIEEgdGltZWxpbmUgYWN0b3IgdGhhdCB1cGRhdGVzIGEgdmFyaWFibGUgYWZ0ZXIgYSBnaXZlbiBwZXJpb2QgKGluIG1zKSBoYXMgZWxhcHNlZC4gXHJcbiAqIFRoaXMgYWN0b3IgaGFzIG5vIHZpc2libGUgcmVuZGVyZWQgY29tcG9uZW50LlxyXG4gKiBJdCBkb2VzICpOT1QqIHJlbW92ZSBpdHNlbGYgb25jZSB0aGUgdmFyaWFibGUgaGFzIGJlZW4gc2V0OyB0aGlzIGlzIGxlZnQgdG8gdGhlIHNjcmlwdGVyIGlmIHRoYXQgYmVoYXZpb3IgaXMgZGVzaXJlZC5cclxuICogXHJcbiAqIENyZWF0aW5nIGEgVGltZWxpbmUgYWN0b3I6XHJcbiAqIHtcclxuICogICAgICBcIm5hbWVcIjogXCJldmVudDFcIiwgICAgICAgICAgICAgICAvLyBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYWN0b3JcclxuICogICAgICBcInR5cGVcIjogXCJ0aW1lbGluZVwiLCAgICAgICAgICAgICAvLyBSZXF1aXJlZCB0eXBlXHJcbiAqICAgICAgXCJwZXJpb2RcIjogMTAwMCwgICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiBtaWxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBcclxuICogICAgICBcInZhcmlhYmxlXCI6IFwidGltZWxpbmVfZXZlbnRcIiAgICAvLyBBZnRlciB0aGUgZ2l2ZW4gcGVyaW9kIGhhcyBlbGFwc2VkLCB1cGRhdGUgdGhpcyB2YXJpYWJsZSB3aXRoIHRoZSBuYW1lIG9mIHRoaXMgYWN0b3JcclxuICpcclxuICogICAgICBcInN0YXJ0RGVsYXlcIjogMCAgICAgICAgICAgICAgICAgLy8gSSAqU1RST05HTFkqIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nIHRoaXMgdmFsdWUsIGJ1dCBpZiB5b3UgZG8sIHJlbWVtYmVyIHRoZSBldmVudCB3aWxsIG5vdCBmaXJlIHVudGlsIHBlcmlvZCArIHN0YXJ0RGVsYXkgbXMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBhY3RvciB3YXMgYWRkZWQgdG8gdGhlIHNjZW5lLlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG5cclxuICAgIHZhciBUaW1lbGluZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcblxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJwZXJpb2RcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEucGVyaW9kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRpbWVyIEFjdG9yIHJlcXVpcmVzIGEgcGVyaW9kIHRvIGJlIHNldFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRpbWVyIEFjdG9yIHJlcXVpcmVzIGEgdmFyaWFibGUgdG8gYmUgc2V0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhlcmUgbWF5IGJlIHNvbWUgdXNlIGZvciBwZXJpb2QgPT0gMCwgaW4gdGhlIHNhbWUgdmVpbiBhcyBzZXRUaW1lb3V0KGZuLCAwKSBzbyBJJ2xsIGFsbG93IGl0IGZvciBub3dcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5wZXJpb2QgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUaW1lciBBY3RvciByZXF1aXJlcyBwZXJpb2QgdG8gYmUgPj0gMFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpbWVyRXZlbnQgPSB0aGlzLmdhbWUudGltZS5ldmVudHMuYWRkKHRoaXMuZGF0YS5wZXJpb2QsIHRoaXMudGltZXJGaXJlZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW1lckZpcmVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5yZW1vdmUodGhpcy50aW1lckV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lQWN0b3I7XHJcbn0oKSk7IiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHRvZ2dsZSBidXR0b24gYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgZm9yIHNpbXBsZSBhY3Rpb25zLCBzdWNoIGFzIG9wZW5pbmcgdGhlIGNlbGwgcGhvbmUsIGFuZCB3aWxsXHJcbiAqIHJlbWVtYmVyIGl0cyBpbnRlcm5hbCBzdGF0ZSBvZiBvbiBvciBvZmYuIEluIG1hbnkgJ3BsYXlzJywgdGhpcyBhY3RvcnMgaXNuJ3QgbmVlZGVkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHRvZ2dsZSBidXR0b24gYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm11dGUxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInRvZ2dsZS1idXR0b25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiB7XHJcbiAqICAgICAgXCJvblwiOiBcIm11dGVvblwiLFxyXG4gKiAgICAgIFwib2ZmXCI6IFwibXV0ZW9mZlwiXHJcbiAqICAgICB9LCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b24gc2VjdGlvbiBvZiB0aGUgdGhlbWUuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcIm11dGVfZ2FtZVwiLFxyXG4gKiAgICAgXCJ2YWx1ZXNcIjoge1xyXG4gKiAgICAgICAgICBcIm9uXCI6IFwibXV0ZV9vblwiLCAgLy8gdGhlIHZhbHVlIHVzZWQgaW5zdGVhZCBvZiB0aGUgbmFtZSB3aGVuIHRoZSB2YXJpYWJsZSBpcyBzZXQuXHJcbiAqICAgICAgICAgIFwib2ZmXCI6IFwibXV0ZV9vZmZcIlxyXG4gKiAgICAgfVxyXG4gKiAgICAgLy8gb3B0aW9uYWwgXCJzY2FsZVwiOiBbIDEuMSwgMS4xIF0gLy8gVXNlIG5lZ2F0aXZlIHNjYWxlcyB0byAnZmxpcCcgdGhlIGltYWdlcy5cclxuICogICAgIC8vIG9wdGlvbmFsOiBcImFjdGl2ZVwiOiB0cnVlL2ZhbHNlLCAvLyB3aWxsIGRlZmF1bHQgdG8gZmFsc2UuXHJcbiAqICAgICAvLyBvcHRpb25hbDogXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBUb2dnbGVBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZXNcIiwgXCJ2YWx1ZXNcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFjdGl2ZSAmJiB0aGlzLmRhdGEuYWN0aXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSB1c2VyIGNvdWxkIHNldCBhY3RpdmUsIGNoZWNrIHRoZSBtb2RlbC4uLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnZhcmlhYmxlID09PSBcIm11dGVfZ2FtZVwiICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT24udmlzaWJsZSA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT2ZmLnZpc2libGUgPSAhdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUuYnV0dG9ucyB8fCAhdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub2ZmXSB8fCAhdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub25dKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkJ1dHRvbiBBY3RvciByZXF1aXJlcyBidXR0b25zIGVudHJ5IGluIHRoZW1lLCB3aXRoIHNwZWNpZmljIGVudHJ5IG1hdGNoaW5nIGltYWdlcyBvZmYvb25cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b25PZmYgPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vZmZdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VzLm9mZl0ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub2ZmXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vZmZdLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vbl0ub3ZlciwgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub25dLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VzLm9uXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vbl0udXApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT24uc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5pc0FjdGl2ZSA/IHRoaXMuZGF0YS52YWx1ZXNbXCJvblwiXSA6IHRoaXMuZGF0YS52YWx1ZXNbXCJvZmZcIl07XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLnZpc2libGUgPSB0aGlzLmlzQWN0aXZlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9mZi52aXNpYmxlID0gIXRoaXMuaXNBY3RpdmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oICApIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICF0aGlzLmlzQWN0aXZlO1xyXG4gICAgICAgICAgICB0aGlzLm9uQWN0aW9uKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJ1dHRvbk9mZiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT2ZmLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b25PbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT24uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvZ2dsZUFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgaW52aXNpYmxlIGJ1dHRvbiB1cmwgYWN0b3IuIFBsYWNlIGl0IG92ZXIgdGV4dCB0byBwcm92aWRlIGh5cGVybGluay1saWtlIGZ1bmN0aW9uYWxpdHksIG9wZW5pbmdcclxuICogdGhlIHNwZWNpZmllZCBsaW5rIGluIGEgbmV3IHdpbmRvdyBvciB0YWIuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgdXJsLWJ1dHRvbi1pbnZpc2libGUgYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImhyZWYxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInVybEludmlzaWJsZVwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcIndpZHRoXCI6IHcsXHJcbiAqICAgICBcImhlaWdodFwiOiBoLFxyXG4gKiAgICAgXCJ1cmxcIjogXCJ3d3cuZ29vZ2xlLmNvbVwiLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInNob3dfdXJsXCIsIC8vIGlmIHlvdSBjbGljayB0aGUgYnV0dG9uLCB0aGUgdmFyaWFibGUgJ3Nob3dfdXJsJyB3aWxsIGJlIHNldCB0byAnaHJlZjEnLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFVybEJ1dHRvbkludmlzaWJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaXMgaW4gcGFyZW50LlxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidXJsXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24ud2lkdGggPSB0aGlzLmRhdGEud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmhlaWdodCA9IHRoaXMuZGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmRhdGEudXJsLCBcIl9ibGFua1wiKTtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVXJsQnV0dG9uSW52aXNpYmxlQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFN5ZCBHcm9zY2xhdWRlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOC8yMC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHVybCBhY3Rvci4gVGhpcyBhY3RvciBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgYnV0dG9uOyB3aGVuIGNsaWNrZWQsIG9wZW4gYSB1cmwgaW4gYSBuZXcgd2luZG93L3RhYi5cclxuICpcclxuICogQ3JlYXRpbmcgYSB1cmwgYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImhyZWYxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInVybC1idXR0b25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwicmVzb3VyY2VJbWFnZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b25zIHNlY3Rpb24gb2YgdGhlIHRoZW1lLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSxcclxuICogICAgIFwidXJsXCI6IFwid3d3Lmdvb2dsZS5jb21cIixcclxuICogICAgIFwidmFyaWFibGVcIjogXCJzaG93X3VybFwiIC8vIGlmIHlvdSBjbGljayB0aGUgYnV0dG9uLCB0aGUgdmFyaWFibGUgJ3Nob3dfdXJsJyB3aWxsIGJlIHNldCB0byAnaHJlZjEnLlxyXG4gKiAgICAgLy8gb3B0aW9uYWwgXCJzY2FsZVwiOiBbIDEuMSwgMS4xIF0gLy8gVXNlIG5lZ2F0aXZlIHNjYWxlcyB0byAnZmxpcCcgdGhlIGltYWdlcy5cclxuICogICAgIC8vIG9wdGlvbmFsIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdHZhciBfID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuXHRcdEJ1dHRvbkFjdG9yID0gcmVxdWlyZShcIi4vYWN0b3ItYnV0dG9uXCIpO1xyXG5cclxuXHR2YXIgVXJsQnV0dG9uQWN0b3IgPSBCdXR0b25BY3Rvci5leHRlbmQoe1xyXG5cdFx0Z2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIG15UmVxdWlyZWQgPSBbXCJ1cmxcIl07XHJcblx0XHRcdHZhciBiYXNlUmVxdWlyZWQgPSB0aGlzLmJhc2UoKTtcclxuXHRcdFx0dmFyIGFsbFJlcXVpcmVkID1cclxuXHRcdFx0XHR0eXBlb2YgYmFzZVJlcXVpcmVkICE9IFwidW5kZWZpbmVkXCJcclxuXHRcdFx0XHRcdD8gYmFzZVJlcXVpcmVkLmNvbmNhdChteVJlcXVpcmVkKVxyXG5cdFx0XHRcdFx0OiBteVJlcXVpcmVkO1xyXG5cdFx0XHRyZXR1cm4gYWxsUmVxdWlyZWQ7XHJcblx0XHR9LFxyXG5cdFx0b25Qb2ludGVyVXA6IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHR3aW5kb3cub3Blbih0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIHRoaXMuZGF0YS51cmwsIFwiX2JsYW5rXCIpO1xyXG5cdFx0XHR0aGlzLmJhc2UoZXZlbnQpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBVcmxCdXR0b25BY3RvcjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQSBhIHZpZGVvIGFjdG9yIHVzaW4gV2lzdGlhLlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgIFwibmFtZVwiOiBcInZpZGVvMVwiLFxyXG4gKiAgICAgXCJ0eXBlXCI6IFwid2lzdGlhXCIsXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgMiwgNSBdLCAvLyBsb2NhdGlvbiBvbiBzY3JlZW4uXHJcbiAqICAgICBcInNpemVcIjogWyAzMDAsIDIwMCBdLFxyXG4gKiAgICAgXCJ2aWRlb1wiIDogXCJkdW4xZnV1MjUzXCIsXHJcbiAqICAgICBcImNsb3NlQnV0dG9uTG9jYXRpb25cIiA6IFsgNzAsIDQ0IF0sIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRvcCByaWdodCBvZiB2aWRlb1xyXG4gKiAgICAgXCJoaWRlQ2xvc2VCdXR0b25cIjogdHJ1ZSwgLy8gb3B0aW9uYWwsIHdpbGwgaGlkZSB0aGUgY2xvc2UgYnV0dG9uLlxyXG4gKiAgICAgXCJibG9ja2VyVGludFwiIDogXCIweDAwMDAwMFwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBibGFjayAoMHgwMDAwMDApXHJcbiAqICAgICBcImJsb2NrZXJBbHBoYVwiIDogMC41LCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAwLjVcclxuICogICAgIFwiYmxvY2tJbnB1dFwiOiBmYWxzZSwgLy8gYmxvY2sgaW5wdXQgdW50aWwgdmlkZW8gaXMgZG9uZSwgb3B0aW9uYWxcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcImF1dG9wbGF5XCI6IHRydWUsIC8vIG9wdGlvbmFsLiB3aWxsIGF1dG9tYXRpY2FsbHkgc3RhcnQgdGhlIHZpZGVvLlxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInN0cmluZ1wiLCAvLyBvcHRpb25hbCB2YXJpYWJsZS4gSWYgcHJlc2VudCwgd2lsbCBiZSBzZXQgdG8gc3RhcnRlZCBhbmQgZmluaXNoZWRcclxuICogICAgIFwibWFya2Vyc1wiOiBbIDUsIDE1LCAyMCBdIC8vIG9wdGlvbmFsLiBBdCBzcGVjaWZpZWQgbWFya2VycywgdmFyaWFibGUgd2lsbCBiZSBzZXQgdG8gbWFya2VyIHZhbHVlLlxyXG4gKiB9LFxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpLFxyXG5cdFx0JCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XHJcblxyXG5cdHZhciBXaXN0aWFBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcblx0XHQvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcblx0XHRnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gW1wibG9jYXRpb25cIiwgXCJzaXplXCIsIFwidmlkZW9cIl07XHJcblx0XHR9LFxyXG5cdFx0ZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIVdpc3RpYSkge1xyXG5cdFx0XHRcdHRocm93IFwiV2lzdGlhIGFwcGVhcnMgdG8gYmUgbWlzc2luZywgY2Fubm90IGNyZWF0ZSB3aXN0aWEgYWN0b3IuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy52aWRlbyA9IHRoaXMuZGF0YS52aWRlbztcclxuXHRcdFx0dGhpcy5ibG9ja0lucHV0ID0gdGhpcy5kYXRhLmJsb2NrSW5wdXQgfHwgZmFsc2U7XHJcblx0XHRcdHRoaXMuZWxlbWVudCA9ICQodGhpcy5nYW1lLmNhbnZhcy5wYXJlbnRFbGVtZW50KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmJsb2NrSW5wdXQpIHtcclxuXHRcdFx0XHR0aGlzLmJsb2NraW5nU3ByaXRlID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG5cdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG5cdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRYID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRZID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5kYXRhLnNpemVbMF07XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRYID09PSBcImNlbnRlclwiKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50WCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYIC0gdGhpcy53aWR0aCAvIDI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFkgPT09IFwiY2VudGVyXCIpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRZID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgLSB0aGlzLmhlaWdodCAvIDI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF8uYmluZEFsbCh0aGlzLCBcImFkZFdpbmRvd1wiKTtcclxuXHRcdFx0d2luZG93Lndpc3RpYUluaXQgPSB0aGlzLmFkZFdpbmRvdztcclxuXHRcdH0sXHJcblx0XHRhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gQmluZCB0aGVzZSwgb3RoZXJ3aXNlIFwidGhpc1wiIHdpbGwgYmUgbG9zdC4gV2lzdGlhIGRvZXNuJ3QgYWNjZXB0IGEgY29udGV4dCFcclxuXHRcdFx0Xy5iaW5kQWxsKHRoaXMsIFwib25XaXN0aWFFbmRcIik7XHJcblx0XHRcdF8uYmluZEFsbCh0aGlzLCBcIm9uV2lzdGlhUGxheVwiKTtcclxuXHRcdFx0dGhpcy53aXN0aWFFbWJlZC5iaW5kKFwicGxheVwiLCB0aGlzLm9uV2lzdGlhUGxheSk7XHJcblx0XHRcdHRoaXMud2lzdGlhRW1iZWQuYmluZChcImVuZFwiLCB0aGlzLm9uV2lzdGlhRW5kKTtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG5cdFx0XHRcdF8uYmluZEFsbCh0aGlzLCBcIm9uV2lzdGlhTWFya2VyXCIpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmRhdGEubWFya2VycyAmJiBfLmlzQXJyYXkodGhpcy5kYXRhLm1hcmtlcnMpKSB7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLmJpbmQoXCJzZWNvbmRjaGFuZ2VcIiwgdGhpcy5vbldpc3RpYU1hcmtlcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0b25HYW1lU3BlZWNoOiBmdW5jdGlvbiAoc3BlZWNoKSB7XHJcblx0XHRcdGlmIChzcGVlY2guYXVkaW8gJiYgc3BlZWNoLmF1ZGlvICE9PSB0aGlzLnZpZGVvKSB7XHJcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLndpc3RpYUVtYmVkICE9IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnBhdXNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYU11dGU6IGZ1bmN0aW9uIChpc011dGVkKSB7XHJcblx0XHRcdGxvZy53YXJuKFwiQ2FsbGVkIG9uV2lzdGlhTXV0ZTogXCIgKyBpc011dGVkKTtcclxuXHRcdFx0aWYgKGlzTXV0ZWQpIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnZvbHVtZSgwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnZvbHVtZSgxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uV2lzdGlhTWFya2VyOiBmdW5jdGlvbiAoc2Vjb25kcykge1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0dGhpcy5kYXRhLm1hcmtlcnMsXHJcblx0XHRcdFx0ZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0XHRcdFx0aWYgKHBhcnNlSW50KG1hcmtlciwgMTApID09PSBzZWNvbmRzKSB7XHJcblx0XHRcdFx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0XHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBzZWNvbmRzO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGV4aXQgbG9vcC5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcblx0XHRcdFx0dmFyIHZhclNldCA9IHt9O1xyXG5cdFx0XHRcdHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gXCJmaW5pc2hlZFwiO1xyXG5cdFx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYVBsYXk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5vbldpc3RpYU11dGUodGhpcy5nYW1lLnNvdW5kLm11dGUpO1xyXG5cdFx0XHR0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiB0aGlzLnZpZGVvLCBrZXk6IG51bGwgfSk7XHJcblx0XHRcdGlmICh0aGlzLmRhdGEudmFyaWFibGUpIHtcclxuXHRcdFx0XHR2YXIgdmFyU2V0ID0ge307XHJcblx0XHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBcInN0YXJ0ZWRcIjtcclxuXHRcdFx0XHR0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0YWRkV2luZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBUaGlzIHNob3VsZCBiZSBhIGhhbmRsZWJhcnMgdGVtcGxhdGUgYnV0IHdlJ3JlIGhhdmluZyBpbnRlcm5ldCB0cm91YmxlIHNvIGhlcmUgaXQgaXMuLi4gdGV4dC5cclxuXHRcdFx0ICogQHR5cGUge3N0cmluZ31cclxuXHRcdFx0ICovXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJ3aXN0aWEgYXBpIGxvYWRlZFwiKTtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC5cclxuXHJcblx0XHRcdFx0dmFyIHZpZGVvQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0XHRpZiAodGhpcy50aGVtZS5pbnRlcm5hbF9hdXRvU2NhbGUgPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBwcm9wZXJ0eSBpcyB0YWNrZWQgb250byB0aGUgdGhlbWUgYnkgcGxheS5qcyBpZiBzZXQgdG8gdHJ1ZSBpbiB0aGUgcGxheS5qc29uIHNldHRpbmdzLlxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXHJcblx0XHRcdFx0XHRcdFwiY3VycmVudFg6IFwiICsgdGhpcy5jdXJyZW50WCArIFwiIC0gY3VycmVudFk6IFwiICsgdGhpcy5jdXJyZW50WVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwidGhpcy5kYXRhLnNpemVbMF06IFwiICsgdGhpcy5kYXRhLnNpemVbMF0pO1xyXG5cdFx0XHRcdFx0dmFyIGxlZnRQY3QgPSAodGhpcy5jdXJyZW50WCAvIHRoaXMuZ2FtZS53b3JsZC53aWR0aCkgKiAxMDA7XHJcblx0XHRcdFx0XHR2YXIgdG9wUGN0ID0gKHRoaXMuY3VycmVudFkgLyB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KSAqIDEwMDtcclxuXHRcdFx0XHRcdHZhciBzY2FsZVBjdCA9ICh0aGlzLmRhdGEuc2l6ZVswXSAvIHRoaXMuZ2FtZS53b3JsZC53aWR0aCkgKiAxMDA7XHJcblx0XHRcdFx0XHR2aWRlb0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXHJcblx0XHRcdFx0XHRcdFwic3R5bGVcIixcclxuXHRcdFx0XHRcdFx0XCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDE1MDsgd2lkdGg6IFwiICtcclxuXHRcdFx0XHRcdFx0XHRzY2FsZVBjdCArXHJcblx0XHRcdFx0XHRcdFx0XCIlOyB0b3A6IFwiICtcclxuXHRcdFx0XHRcdFx0XHR0b3BQY3QgK1xyXG5cdFx0XHRcdFx0XHRcdFwiJTsgbGVmdDogXCIgK1xyXG5cdFx0XHRcdFx0XHRcdGxlZnRQY3QgK1xyXG5cdFx0XHRcdFx0XHRcdFwiJTtcIlxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmlkZW9Db250YWluZXIuc2V0QXR0cmlidXRlKFxyXG5cdFx0XHRcdFx0XHRcInN0eWxlXCIsXHJcblx0XHRcdFx0XHRcdFwicG9zaXRpb246IGFic29sdXRlOyB6LWluZGV4OiAxNTA7IHdpZHRoOiBcIiArXHJcblx0XHRcdFx0XHRcdFx0dGhpcy53aWR0aCArXHJcblx0XHRcdFx0XHRcdFx0XCJweDsgaGVpZ2h0OiBcIiArXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5oZWlnaHQgK1xyXG5cdFx0XHRcdFx0XHRcdFwicHg7IHRvcDogXCIgK1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY3VycmVudFkgK1xyXG5cdFx0XHRcdFx0XHRcdFwicHg7IGxlZnQ6IFwiICtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmN1cnJlbnRYICtcclxuXHRcdFx0XHRcdFx0XHRcInB4O1wiXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmlkZW9Db250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJ2aWRlb0NvbnRhaW5lclwiKTtcclxuXHJcblx0XHRcdFx0dGhpcy52aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdHZhciBjbGFzc1N0cmluZyA9IFwid2lzdGlhX2VtYmVkIHdpc3RpYV9hc3luY19cIiArIHRoaXMudmlkZW87XHJcblx0XHRcdFx0Ly9jbGFzc1N0cmluZyArPSBcIiBlbmRWaWRlb0JlaGF2aW9yPXJlc2V0XCI7XHJcblx0XHRcdFx0Ly9jbGFzc1N0cmluZyArPSBcIiBwbGF5YmFyPWZhbHNlXCI7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ2FtZS5kZXZpY2UuaVBhZCkge1xyXG5cdFx0XHRcdFx0Y2xhc3NTdHJpbmcgKz0gXCIgcXVhbGl0eU1heD0zNjBcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuZGF0YS5hdXRvU2NhbGUgPT0gdHJ1ZSB8fCB0aGlzLmRhdGEuYXV0b1NjYWxlID09IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIGVuYWJsZSBieSBkZWZhdWx0LCBldmVuIGlmIG5vdCBkZWNsYXJlZFxyXG5cdFx0XHRcdFx0Y2xhc3NTdHJpbmcgKz0gXCIgdmlkZW9Gb2FtPXRydWVcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy52aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY2xhc3NTdHJpbmcpO1xyXG5cdFx0XHRcdHRoaXMudmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcclxuXHRcdFx0XHRcdFwic3R5bGVcIixcclxuXHRcdFx0XHRcdFwid2lkdGg6XCIgKyB0aGlzLndpZHRoICsgXCJweDsgaGVpZ2h0OlwiICsgdGhpcy5oZWlnaHQgKyBcInB4O1wiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLnZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInZpZGVvRWxlbWVudFwiKTtcclxuXHJcblx0XHRcdFx0dmlkZW9Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlb0VsZW1lbnQpO1xyXG5cdFx0XHRcdHZhciBnYW1lQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNnYW1lQ29udGFpbmVyXCIpO1xyXG5cdFx0XHRcdGdhbWVDb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9Db250YWluZXIpO1xyXG5cclxuXHRcdFx0XHR3aW5kb3cuX3dxID0gd2luZG93Ll93cSB8fCBbXTtcclxuXHRcdFx0XHRfLmJpbmRBbGwodGhpcywgXCJvbldpc3RpYUVtYmVkXCIpO1xyXG5cdFx0XHRcdF93cS5wdXNoKHsgaWQ6IHRoaXMudmlkZW8sIG9uUmVhZHk6IHRoaXMub25XaXN0aWFFbWJlZCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uV2lzdGlhRW1iZWQ6IGZ1bmN0aW9uICh2aWRlbykge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwid2lzdGlhIHZpZGVvIGxvYWRlZFwiKTtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCAmJiAhdGhpcy53aXN0aWFFbWJlZCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC4gdGhpcy53aXN0aWFFbWJlZCBjaGVja2VkIHRvIGtlZXAgZnVuY3Rpb24gZnJvbSBydW5uaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gc2xpZGUgaXMgcmV2aXNpdGVkIC0gV2lzdGlhIHNlZW1zIHRvIGRvZXNuJ3QgY2xlYXIgdGhlIG9uUmVhZHkgZXZlbnQgYmluZGluZy5cclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkID0gdmlkZW87XHJcblxyXG5cdFx0XHRcdHRoaXMuc2hvd0Jsb2NraW5nU3ByaXRlKCk7XHJcblx0XHRcdFx0dGhpcy5hZGRDbG9zZUJ1dHRvbigpO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5ibG9ja0lucHV0KSB7XHJcblx0XHRcdFx0XHR0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRMaXN0ZW5lcnMoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLmF1dG9wbGF5ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnBsYXkoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaG93QmxvY2tpbmdTcHJpdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuYmxvY2tJbnB1dCkge1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5ibG9ja2luZ1Nwcml0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRhZGRDbG9zZUJ1dHRvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLmhpZGVDbG9zZUJ1dHRvbiAhPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHZhciBjbG9zZUJ1dHRvblgsIGNsb3NlQnV0dG9uWTtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuZGF0YS5jbG9zZUJ1dHRvbkxvY2F0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0XHRjbG9zZUJ1dHRvblggPSB0aGlzLmN1cnJlbnRYICsgdGhpcy53aWR0aDtcclxuXHRcdFx0XHRcdGNsb3NlQnV0dG9uWSA9IHRoaXMuY3VycmVudFk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNsb3NlQnV0dG9uWCA9IHRoaXMuZGF0YS5jbG9zZUJ1dHRvbkxvY2F0aW9uWzBdO1xyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25ZID0gdGhpcy5kYXRhLmNsb3NlQnV0dG9uTG9jYXRpb25bMV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmJ1dHRvbiA9IG5ldyBQaGFzZXIuQnV0dG9uKFxyXG5cdFx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25YLFxyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25ZLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdFx0dGhpcy5vbkNsb3NlLFxyXG5cdFx0XHRcdFx0dGhpcyxcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUuYnV0dG9ucy52aWRlb0Nsb3NlLm92ZXIsXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnMudmlkZW9DbG9zZS5vdXQsXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnMudmlkZW9DbG9zZS5kb3duLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS5idXR0b25zLnZpZGVvQ2xvc2UudXBcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5kYXRhLmNsb3NlQnV0dG9uTG9jYXRpb24gPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0Ly8gV2UncmUgdXNpbmcgdGhlIGRlZmF1bHQgY2xvc2UgYnV0dG9uIGxvY2F0aW9uLCBzbyBtb3ZlIGl0IHVwIGJ5IGl0cyBoZWlnaHQgdG8gc2l0IGFib3ZlIHRoZSB2aWRlby5cclxuXHRcdFx0XHRcdHRoaXMuYnV0dG9uLnkgLT0gdGhpcy5idXR0b24uaGVpZ2h0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblx0XHRcdFx0dGhpcy5idXR0b24uaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmJ1dHRvbik7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRjcmVhdGVCbG9ja2luZ1Nwcml0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYmxvY2tlclRpbnQgPVxyXG5cdFx0XHRcdHR5cGVvZiB0aGlzLmRhdGEuYmxvY2tlclRpbnQgPT09IFwidW5kZWZpbmVkXCJcclxuXHRcdFx0XHRcdD8gMHgwMDAwMDBcclxuXHRcdFx0XHRcdDogdGhpcy5kYXRhLmJsb2NrZXJUaW50O1xyXG5cdFx0XHR2YXIgYmxvY2tlckFscGhhID1cclxuXHRcdFx0XHR0eXBlb2YgdGhpcy5kYXRhLmJsb2NrZXJBbHBoYSA9PT0gXCJ1bmRlZmluZWRcIlxyXG5cdFx0XHRcdFx0PyAwLjVcclxuXHRcdFx0XHRcdDogdGhpcy5kYXRhLmJsb2NrZXJBbHBoYTtcclxuXHJcblx0XHRcdHZhciBzcHJpdGUgPSBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDApO1xyXG5cdFx0XHR2YXIgZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMCwgMCk7XHJcblx0XHRcdHNwcml0ZS5hZGRDaGlsZChncmFwaGljcyk7XHJcblx0XHRcdGdyYXBoaWNzLmJlZ2luRmlsbChibG9ja2VyVGludCwgYmxvY2tlckFscGhhKTtcclxuXHRcdFx0Z3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgdGhpcy5nYW1lLndvcmxkLndpZHRoLCB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KTtcclxuXHRcdFx0Z3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cdFx0XHRzcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIHNwcml0ZTtcclxuXHRcdH0sXHJcblx0XHRvbkNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xyXG5cdFx0fSxcclxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC5cclxuXHRcdFx0XHRpZiAodGhpcy53aXN0aWFFbWJlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy53aXN0aWFFbWJlZC51bmJpbmQoKTtcclxuXHRcdFx0XHRcdHRoaXMud2lzdGlhRW1iZWQucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuYmxvY2tJbnB1dCkge1xyXG5cdFx0XHRcdFx0dGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLmJ1dHRvbikge1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24udmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24gPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvL2xvZy53YXJuKHRoaXMudmlkZW9FbGVtZW50LmF0dHIoJ2lkJykpO1xyXG5cdFx0XHRcdCQoXCIjdmlkZW9Db250YWluZXJcIikuaGlkZSgpO1xyXG5cdFx0XHRcdHZhciB0ZW1wID0ge307XHJcblx0XHRcdFx0dGVtcFt0aGlzLmRhdGEubmFtZV0gPSBcImNsb3NlZFwiO1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdGVtcCk7XHJcblx0XHRcdFx0Ly8gTm93LCBkZWxldGUgaXQgYWxsLlxyXG5cdFx0XHRcdGlmICh0aGlzLmJsb2NrSW5wdXQpIHtcclxuXHRcdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9sb2cud2Fybih0aGlzLnZpZGVvRWxlbWVudC5hdHRyKCdpZCcpKTtcclxuXHRcdFx0XHQkKFwiI3ZpZGVvQ29udGFpbmVyXCIpLnJlbW92ZSgpO1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gV2lzdGlhQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEFuIGdlbmVyaWMgYWN0b3IuIEl0IGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gYWxsIGFjdG9yc1xyXG4gKlxyXG4gKiAgXCJpbnZlcnNlRXZlbnRzXCI6IHRydWUgLy8gb3B0aW9uYWwuIEV2ZW50cyB3aWxsIGdvIG9ubHkgdG8gdGhpcyBzcHJpdGUsIGluc3RlYWQgb2Ygb25seSB0byBvdGhlcnMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgREVGQVVMVF9GT05UID0geyBcImZvbnRcIjogXCIyMHB4IFRhaG9tYVwiLCBcImZpbGxcIjogXCIjMDAwMDAwXCIsICBcImZvbnRXZWlnaHRcIjogXCJib2xkXCJ9LFxyXG4gICAgICAgIERFRkFVTFRfVEVYVCA9IFwiVGV4dCBOb3QgRm91bmQuXCIsXHJcbiAgICAgICAgREVGQVVMVF9JTUFHRSA9IFwiSW1hZ2UgTm90IEZvdW5kLlwiO1xyXG5cclxuICAgIHZhciBBY3RvciA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgIGRhdGEsIHRoZW1lKSB7XHJcbiAgICAgICAgICAgIGlmKCAhZ2FtZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQWN0b3IgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggIWRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFjdG9yIHJlcXVpcmVzIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoICF0aGVtZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQWN0b3IgcmVxdWlyZXMgZGF0YSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkdhbWVDaG9pY2U6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcbiAgICAgICAgICAgICAgICBvbkdhbWVTcGVlY2g6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyZWVCYXNlQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAvL3RoaXMuZ2FtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYmFzaWMgdmFsaWRhdGlvbiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBUaGlzIHdpbGwgY2hlY2sgc29tZSBiYXNpYy9jb21tb24gZGF0YSBlcnJvcnMsIGluY2x1ZGluZyByZXF1aXJlZCBmaWVsZHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMuZGF0YS5uYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBY3RvciBoYXMgZGF0YSwgYnV0IG5vIG5hbWUuIE5hbWUgaXMgcmVxdWlyZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy5kYXRhLnR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFjdG9yIGhhcyBkYXRhLCBidXQgbm8gbmFtZS4gTmFtZSBpcyByZXF1aXJlZC5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmdldFJlcXVpcmVkRmllbGRzKCksIGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhW2ZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZGF0YVtmaWVsZF0gPT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJbXCIgKyB0aGlzLmRhdGEudHlwZSArIFwiXSBBY3RvciBbXCIgKyB0aGlzLmRhdGEubmFtZSArIFwiXSBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiBcIiArIGZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEubmFtZSAmJiB0aGlzLmRhdGEubmFtZS5jaGFyQXQoMCkgPT09IFwiJFwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBY3RvciBuYW1lcyBjYW5ub3QgYmUgdmFyaWFibGVzLCBhbmQgd2lsbCBub3QgYmUgcmVzb2x2ZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXROYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UHJpbWFyeVNwcml0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFic3RyYWN0IG1ldGhvZCBmb3IgY2hpbGRyZW4gdG8gaW1wbGVtZW50LlxyXG4gICAgICAgICAqIGV4OiByZXR1cm4gWyBcIm5hbWVcIiwgXCJsb2NhdGlvblwiIF07XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBcIllvdSBtdXN0IGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gYW4gYXJyYXkgb2YgZmllbGQgbmFtZXMuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRNb2RlbEludGVyZmFjZTogZnVuY3Rpb24oIG1vZGVsSW50ZXJmYWNlICkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsSW50ZXJmYWNlID0gbW9kZWxJbnRlcmZhY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRGb250OiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQXNraW5nIGZvciBmb250IHdpdGggXCIgKyBuYW1lICk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnRoZW1lICYmIHRoaXMudGhlbWUuZm9udHMgJiYgdGhpcy50aGVtZS5mb250c1tuYW1lXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMudGhlbWUuZm9udHNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZvbnQgbm90IGZvdW5kIGZvciBcIiArIG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5jbG9uZShERUZBVUxUX0ZPTlQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9vayB1cCBhIHBpZWNlIG9mIHRleHQgaW4gdGhlIHRoZW1lLlxyXG4gICAgICAgICAqIElmIG5vdCB0aGVyZSwgdHJlYXQgYXMgbGl0ZXJhbC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKCBuYW1lLCBrZXkgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQXNraW5nIGZvciB0ZXh0IHdpdGggXCIgKyBuYW1lICsgXCIgLyBcIiArIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBzTmFtZSA9IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBzS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiggdGhpcy5tb2RlbEludGVyZmFjZSApIHtcclxuICAgICAgICAgICAgICAgIHNOYW1lID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIHNLZXkgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nLndhcm4oXCItLT4gQXNraW5nIGZvciB0ZXh0IHdpdGggXCIgKyBzTmFtZSArIFwiIC8gXCIgKyBzS2V5KTtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lIHx8ICghdGhpcy50aGVtZS50ZXh0cyAmJiAhc0tleSkgKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJ0ZXh0IHVuYXZhaWxhYmxlIGZvciBcIiArIHNOYW1lICsgXCIgLyBcIiArIHNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChERUZBVUxUX1RFWFQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50aGVtZS50ZXh0c1tzTmFtZV07XHJcbiAgICAgICAgICAgIGlmKCAhdGV4dCAmJiAhc0tleSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzTmFtZTsgLy8gbWlnaHQgYmUgYSBzdHJpbmcgbGl0ZXJhbC5cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBzS2V5ICYmIHRoaXMudGhlbWUudGV4dHNbc0tleV0gKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy50aGVtZS50ZXh0c1tzS2V5XVtzTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nLndhcm4oXCJyZXR1cm5pbmcgXCIgKyB0ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQgfHwgc05hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRUZXh0dXJlS2V5OiBmdW5jdGlvbiggc3ByaXRlRGF0YSApIHtcclxuICAgICAgICAgICAgaWYoIHNwcml0ZURhdGEgJiYgc3ByaXRlRGF0YS50ZXh0dXJlS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwcml0ZURhdGEudGV4dHVyZUtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZS50ZXh0dXJlS2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9vayB1cCBhbiBpbWFnZSBpbiB0aGUgdGhlbWUuXHJcbiAgICAgICAgICogSWYgbm90IHRoZXJlLCB0cmVhdCBhcyBsaXRlcmFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEltYWdlOiBmdW5jdGlvbiggbmFtZSwga2V5ICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkFza2luZyBmb3IgaW1hZ2Ugd2l0aCBcIiArIG5hbWUgKyBcIiAvIFwiICsga2V5KTtcclxuICAgICAgICAgICAgdmFyIHNOYW1lID0gbmFtZSxcclxuICAgICAgICAgICAgICAgIHNLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLm1vZGVsSW50ZXJmYWNlICkge1xyXG4gICAgICAgICAgICAgICAgc05hbWUgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgc0tleSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2cud2FybihcIi0tPiBBc2tpbmcgZm9yIGltYWdlIHdpdGggXCIgKyBzTmFtZSArIFwiIC8gXCIgKyBzS2V5KTtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lIHx8ICghdGhpcy50aGVtZS5pbWFnZXMgJiYgIXNLZXkpICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiaW1hZ2Ugbm90IGZvdW5kIGZvciBcIiArIHNOYW1lICsgXCIgLyBcIiArIHNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChERUZBVUxUX0lNQUdFKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLnRoZW1lLmltYWdlc1tzTmFtZV07XHJcbiAgICAgICAgICAgIGlmKCAhaW1hZ2UgJiYgIXNLZXkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc05hbWU7IC8vIG1pZ2h0IGJlIGEgc3RyaW5nIGxpdGVyYWwsIHNvIHJldHVybiBpdC5cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBzS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLnRoZW1lLmltYWdlc1tzS2V5XVtzTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIoaW1hZ2UuZW5kSW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTnVtYmVyKGltYWdlLnN0YXJ0SW5kZXgpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gTnVtYmVyKGltYWdlLmVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciB6ZXJvUGFkID0gaW1hZ2UuemVyb1BhZCB8fCA0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGltYWdlLmZpbGVuYW1lUHJlZml4IHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gaW1hZ2UuZmlsZW5hbWVTdWZmaXggfHwgXCIucG5nXCI7XHJcbiAgICAgICAgICAgICAgICBpbWFnZSA9IFBoYXNlci5BbmltYXRpb24uZ2VuZXJhdGVGcmFtZU5hbWVzKHByZWZpeCwgc3RhcnQsIGVuZCwgc3VmZml4LCB6ZXJvUGFkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRNeVZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnZhcmlhYmxlICYmIHRoaXMubW9kZWxJbnRlcmZhY2UgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkXCIgKyB0aGlzLmRhdGEudmFyaWFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gaW1wbGVtZW50IGRlc3Ryb3kgZm9yIGFjdG9yIHR5cGU6IFwiICsgdGhpcy5kYXRhLnR5cGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlQmxvY2tpbmdTcHJpdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLDApO1xyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5hZGRDaGlsZChncmFwaGljcyk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweDAwMDAwMCwgMC4wMSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIHRoaXMuZ2FtZS53b3JsZC53aWR0aCwgdGhpcy5nYW1lLndvcmxkLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJzdGl0dXRlVGV4dDogZnVuY3Rpb24oIHRleHQgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRG9pbmcgc3Vic3RpdHV0aW9uIG9uOiBcIiArIHRleHQpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdEluZGV4LCByaWdodEluZGV4O1xyXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIpO1xyXG4gICAgICAgICAgICBpZiggbGVmdEluZGV4ID09PSAtMSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIsIGxlZnRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiggcmlnaHRJbmRleCA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGV4dC5zdWJzdHJpbmcoIGxlZnRJbmRleCwgcmlnaHRJbmRleCArMSk7XHJcbiAgICAgICAgICAgIHZhciBrZXkyID0ga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSB0cmFpbGluZyBkb2xsYXJzaWduLlxyXG4gICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShrZXkyKTtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGZpbmFsVGV4dCA9PT0gJ3VuZGVmaW5lZCcgfHwgZmluYWxUZXh0ID09PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbFRleHQgPSBmaW5hbFRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmaW5hbFRleHQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2Uoa2V5LCBmaW5hbFRleHQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoR2FtZUNob2ljZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCBkYXRhLCB0aGlzICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXNwYXRjaEdhbWVTcGVlY2g6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBkYXRhLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU291bmRFdmVudEludmVyc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhICYmIHRoaXMuZGF0YS5pbnZlcnNlU291bmRFdmVudHMgPT09IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBvdmVycmlkZSBpZiB5b3UgaGF2ZSBwaHlzaWNzLlxyXG4gICAgICAgIGdldEJvZHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgaWYgdGhpcyBzcHJpdGUgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBzcHJpdGUgYW5kIGdldEJvZHkoKSBkb2VzIG5vdCByZXR1cm4gbnVsbDtcclxuICAgICAgICAgKiBUaGUgb3RoZXIgc3ByaXRlIHdpbGwgYWxzbyBub3QgYmUgcmV0dXJuaW5nIG51bGwgZm9yIGdldEJvZHkoKS5cclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXJBY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uT3ZlcmxhcHBpbmc6IGZ1bmN0aW9uKCBvdGhlckFjdG9yTmFtZSApIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWNlaXZlIGEgZHJvcHBlZCBzcHJpdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25SZWNlaXZlRHJvcDogZnVuY3Rpb24oIG90aGVyQWN0b3JOYW1lICkge1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXlBdWRpbzogZnVuY3Rpb24oIGV2ZW50RGF0YSApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpb0tleSApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5jaGFubmVsID0gdGhpcy5kYXRhLmF1ZGlvS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhcmlhYmxlTGlzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbEludGVyZmFjZS5jbGVhclZhbHVlKHRoaXMuZGF0YS52YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmdldFZhcmlhYmxlTGlzdCgpLCBmdW5jdGlvbiggZWFjaFZhcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbEludGVyZmFjZS5jbGVhclZhbHVlKGVhY2hWYXIpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBib29rIGFjdG9yLCB3aGljaCB3aWxsIHNob3cgdGhlIHBsYXllciBhIGJvb2sgd2l0aCBmbGlwcGFibGUgcGFnZXMuIEl0IHdpbGwgYWxzb1xyXG4gKiBwbGF5IGFueSBhdWRpby90ZXh0IGFzc29jaWF0ZWQgd2l0aCBhc2tpbmcgcXVlc3Rpb25zIGFuZCB0ZXh0LlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJjaG9pY2VzX21hbmR5XzFcIiwgLy8gdW5pcXVlIG5hbWUgZm9yIHRoaXMgYWN0b3IuXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWNib29rXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcInBhZ2VzXCI6ICBbXHJcbiAqICAgICB7XHJcbiAqICAgICBcInRpdGxlXCI6IFwiV2hhdCBhcmUgRHJ1Z3M/XCIsXHJcbiAqICAgICBcInN1YnRpdGxlXCI6IFwiVGhpcyBpcyBhIHN1YnRpdGxlIVwiLFxyXG4gKiAgICAgXCJ0eXBlXCI6IFwicXVlc3Rpb25cInxcImluZm9ybWF0aW9uXCIgLy8gd2lsbCB0aGVyZSBiZSBxdWVzdGlvbnM/XHJcbiAqXHJcbiAqICAgICB9XHJcbiAqICAgICBdXHJcbiAqIH1cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgSXRzVXJDaG9pY2VCb29rQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1wicGFnZXNcIl07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZXMgPSB0aGlzLmRhdGEucGFnZXM7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5wYWdlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgXCJib29rUXVlc3Rpb25UaXRsZVwiOiB0aGlzLmdldEZvbnQoXCJib29rUXVlc3Rpb25UaXRsZVwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1F1ZXN0aW9uU3VidGl0bGVcIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uU3VidGl0bGVcIiksXHJcbiAgICAgICAgICAgICAgICBcImJvb2tRdWVzdGlvblRleHRcIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uVGV4dFwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1F1ZXN0aW9uUmVtZWRpYXRpb25cIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uUmVtZWRpYXRpb25cIiksXHJcbiAgICAgICAgICAgICAgICBcImJvb2tQYWdlVGl0bGVcIjogdGhpcy5nZXRGb250KFwiYm9va1BhZ2VUaXRsZVwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1BhZ2VTdWJ0aXRsZVwiOiB0aGlzLmdldEZvbnQoXCJib29rUGFnZVN1YnRpdGxlXCIpLFxyXG4gICAgICAgICAgICAgICAgXCJib29rUGFnZUNvbnRlbnRcIjogdGhpcy5nZXRGb250KFwiYm9va1BhZ2VDb250ZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgXCJib29rUGFnZU51bWJlclwiOiB0aGlzLmdldEZvbnQoXCJib29rUGFnZU51bWJlclwiKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLlBBR0VfRkxJUF9TT1VORCA9IHRoaXMudGhlbWUuYm9va1NvdW5kcy5wYWdlRmxpcFNvdW5kO1xyXG4gICAgICAgICAgICB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5EID0gdGhpcy50aGVtZS5ib29rU291bmRzLmNvcnJlY3RTb3VuZDtcclxuICAgICAgICAgICAgdGhpcy5BTlNXRVJfSU5DT1JSRUNUX1NPVU5EID0gdGhpcy50aGVtZS5ib29rU291bmRzLmluY29ycmVjdFNvdW5kO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kKCk7ICAgICAgICAgIC8vIDAxLiBCYWNrZ3JvdW5kIGltYWdlLiBUaGlzIG1heSBhbHNvIGxhdGVyIG5lZWQgYSBib3JkZXIgZHJhd24/XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQWN0aW9uQnV0dG9ucygpOyAgICAgICAvLyAwMi4gVHVybiBwYWdlcy5cclxuICAgICAgICAgICAgdGhpcy5hZGRQYWdlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRQYWdlKDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQmFja2dyb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnSW1hZ2UgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmdhbWUud29ybGQud2lkdGgvMiwgMTUsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZShcImJhY2tncm91bmRcIiwgXCJib29rXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5iZ0ltYWdlLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQYWdlSW1hZ2UgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSg5MCwgMjgsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZShcImxlZnQtcGFnZVwiLCBcImJvb2tcIikpO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGFnZUltYWdlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoNDAyLCAyOCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKFwicmlnaHQtcGFnZVwiLCBcImJvb2tcIikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQWN0aW9uQnV0dG9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRQYWdlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oNzUwLCAxNzUsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25OZXh0UGFnZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snbmV4dFBhZ2UnXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbJ25leHRQYWdlJ10ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zWyduZXh0UGFnZSddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snbmV4dFBhZ2UnXS51cCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oMTAsIDE3NSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblByZXZpb3VzUGFnZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1sncHJldmlvdXNQYWdlJ10ub3ZlciwgdGhpcy50aGVtZS5idXR0b25zWydwcmV2aW91c1BhZ2UnXS5vdXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbJ3ByZXZpb3VzUGFnZSddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1sncHJldmlvdXNQYWdlJ10udXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkUGFnZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFnZUdyb3VwO1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUsIHN1YnRpdGxlLCBjb250ZW50LCByZW1lZGlhdGlvbiwgcGFnZU51bWJlcjtcclxuICAgICAgICAgICAgdmFyIGJ1bGxldEltYWdlcywgYnVsbGV0O1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuZGF0YS5wYWdlcywgZnVuY3Rpb24ocGFnZSwgcGFnZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYXVkaW8gPSBwYWdlLmF1ZGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCBwYWdlLmNvbnRlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGl0bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA1NjUsIDUwLCBwYWdlLnRpdGxlLCB0aGlzLmZvbnRzLmJvb2tQYWdlVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLmFuY2hvci5zZXRUbyggMC41LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VidGl0bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGUgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA0MTAsIDg1LCBwYWdlLnN1YnRpdGxlLCB0aGlzLmZvbnRzLmJvb2tQYWdlU3VidGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQoc3VidGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50IVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA0MTIsIDExMCwgcGFnZS5jb250ZW50LCB0aGlzLmZvbnRzLmJvb2tQYWdlQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChjb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIHBhZ2UucXVlc3Rpb25zICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpdGxlLlxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNTY1LCA1MCwgcGFnZS50aXRsZSwgdGhpcy5mb250cy5ib29rUXVlc3Rpb25UaXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUuYW5jaG9yLnNldFRvKCAwLjUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQodGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0aXRsZS5cclxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIDU2NSwgODUsIHBhZ2Uuc3VidGl0bGUsIHRoaXMuZm9udHMuYm9va1F1ZXN0aW9uU3VidGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlLmFuY2hvci5zZXRUbyggMC41LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHN1YnRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudCFcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHBhZ2UucXVlc3Rpb25zICwgZnVuY3Rpb24oIGVhY2hRdWVzdGlvbiwgcXVlc3Rpb25JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRJbWFnZXMgPSB0aGlzLnRoZW1lLmJ1dHRvbnNbJ2Jvb2tDaG9pY2UnICsgcXVlc3Rpb25JbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldCA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCA0MTAsIDExMCArIChxdWVzdGlvbkluZGV4ICogMzUpLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlclVwLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0SW1hZ2VzLm92ZXIsIGJ1bGxldEltYWdlcy5vdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRJbWFnZXMuZG93biwgYnVsbGV0SW1hZ2VzLnVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldC5ldmVudHMub25JbnB1dE92ZXIuYWRkKCB0aGlzLm9uTW91c2VJbiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNDM1LCAxMjAgKyAocXVlc3Rpb25JbmRleCAqIDM1KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hRdWVzdGlvbi50ZXh0LCB0aGlzLmZvbnRzLmJvb2tRdWVzdGlvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LmxpbmVTcGFjaW5nID0gLTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldC5hbnN3ZXIgPSBlYWNoUXVlc3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQoYnVsbGV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChjb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZWRpYXRpb25cclxuICAgICAgICAgICAgICAgICAgICByZW1lZGlhdGlvbiA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIDQxMywgMjY1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vdGhpbmdcIiwgdGhpcy5mb250cy5ib29rUXVlc3Rpb25SZW1lZGlhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtZWRpYXRpb24ubGluZVNwYWNpbmcgPSAtMztcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHJlbWVkaWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAucmVtZWRpYXRpb24gPSByZW1lZGlhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByZW1lZGlhdGlvbi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGFnZSAjXHJcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNjkwLCA0NDgsIHBhZ2VJbmRleCArIDEsIHRoaXMuZm9udHMuYm9va1BhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChwYWdlTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHBhZ2VHcm91cCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VzWzBdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Q3VycmVudFBhZ2U6IGZ1bmN0aW9uKCBwYWdlSW5kZXggKSB7XHJcbiAgICAgICAgICAgIGlmKCBwYWdlSW5kZXggPCAwIHx8IHBhZ2VJbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2VJbmRleF0udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlSW5kZXggPSBwYWdlSW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZUluZGV4XS52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uLnZpc2libGUgPSAodGhpcy5jdXJyZW50UGFnZUluZGV4ICE9PSAwKTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0UGFnZUJ1dHRvbi52aXNpYmxlID0gKHRoaXMuY3VycmVudFBhZ2VJbmRleCAhPT0gKHRoaXMucGFnZXMubGVuZ3RoIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIHsgYXVkaW86IHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZUluZGV4XS5hdWRpbywga2V5OiBudWxsLCBwcmlvcml0eTogJ3F1ZXVlJyB9KTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk5leHRQYWdlQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oe2F1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsLCBcInByaW9yaXR5XCI6IFwic3RvcGFsbFwiIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRQYWdlKHRoaXMuY3VycmVudFBhZ2VJbmRleCArIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25QcmV2aW91c1BhZ2VBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyh7YXVkaW86IHRoaXMuUEFHRV9GTElQX1NPVU5ELCBrZXk6IG51bGwsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCIgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCB7IGF1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5jdXJyZW50UGFnZUluZGV4IC0gMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlSW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjdXJyZW50bHksIGNsaWNraW5nIHRoZSBhbnN3ZXIgYWxzbyBjYXVzZXMgYXMgbW91c2UgaW4/IFRoaXMgaXMgY2F1c2luZyBwcm9ibGVtcy4uLlxyXG4gICAgICAgICAgICAvLyB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2guZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHsgYXVkaW86IFwiYnViYmxlX3Nsb3dcIiwga2V5OiBudWxsLCByZXN0YXJ0OiB0cnVlfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24gKGNob2ljZSkge1xyXG4gICAgICAgICAgIC8vIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgeyBhdWRpbzogXCJidWJibGVfc2xvd1wiLCBrZXk6IG51bGwsIHN0b3A6IHRydWV9KTtcclxuICAgICAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2VJbmRleF07XHJcbiAgICAgICAgICAgIHBhZ2UucmVtZWRpYXRpb24uc2V0VGV4dChjaG9pY2UuYW5zd2VyLnJlc3BvbnNlLnRleHQpO1xyXG4gICAgICAgICAgICBwYWdlLnJlbWVkaWF0aW9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbygge2F1ZGlvOiB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGwsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCIgfSk7XHJcbiAgICAgICAgICAgIGlmKCBjaG9pY2UuYW5zd2VyLnJlc3BvbnNlLmNvcnJlY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbygge2F1ZGlvOiB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGx9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgeyBhdWRpbzogdGhpcy5BTlNXRVJfSU5DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGx9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIHsgYXVkaW86IGNob2ljZS5hbnN3ZXIucmVzcG9uc2UuYXVkaW8sIGtleTogbnVsbCwgXCJwcmlvcml0eVwiOiAncXVldWUnIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnSW1hZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQYWdlSW1hZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGFnZUltYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0UGFnZUJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wO1xyXG4gICAgICAgICAgICB3aGlsZSggdGhpcy5wYWdlcy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMucGFnZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLnJlbWVkaWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRlbXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEl0c1VyQ2hvaWNlQm9va0FjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBjaGF0IGFjdG9yLCB3aGljaCB3aWxsIHNob3cgdGhlIHBsYXllciBhIGNvbnZlcnNhdGlvbi4gSXQgd2lsbCBhbHNvXHJcbiAqIHBsYXkgYW55IGF1ZGlvL3RleHQgYXNzb2NpYXRlZCB3aXRoIGFza2luZyBxdWVzdGlvbi5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwiY2hvaWNlc19tYW5keV8xXCIsIC8vIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGFjdG9yLlxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaXVjY2hhdFwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJiYWNrZ3JvdW5kXCI6IFwicHVycGxlV2FsbFwiLFxyXG4gKiAgICAgXCJwb3J0cmFpdFwiOiBcIm1yc1JpbGV5XCIsXHJcbiAqICAgICBcInBvcnRyYWl0TGFiZWxcIjogXCJNcnMuIFJpbGV5XCIsXHJcbiAqICAgICBcImNob29zZUxhYmVsXCI6IFwiQ2hvb3NlIHlvdXIgcmVzcG9uc2UuXCIsXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwieFwiLCAvLyB0aGUgdmFyaWFibGUgdG8gc2V0IHdoZW4gdGhlIHVzZXIgbGVhdmVzXHJcbiAqICAgICBcImNvbnZlcnNhdGlvblwiOiAge1xyXG4gICAgICAgICAgICAgIFwicmVzcG9uc2VzXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImF1ZGlvXCI6IFwiYXVkaW8vZGF5MS9tZWxpc3NhX2ludHJvLm1wM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIk9oLCBoaS4gSSB3YXMganVzdCBhc2tpbmcgeW91ciBkYWQgaWYgSSBjb3VsZCBib3Jyb3cgaGlzIHRvb2xib3guIEknbSBmaXhpbmcgc29tZSBzaGVsdmVzIGluIEpvc2gncyByb29tLiBZb3VyIGRhZCB3aWxsIGJlIHJpZ2h0IGJhY2suIEhvdydzIGl0IGdvaW5nPyBIb3cncyBzY2hvb2w/IEknbSBraW5kIG9mIHdvcnJpZWQgYWJvdXQgU2V0aCBiZWNhdXNlIGhlIGhhc24ndCBldmVuIHRob3VnaHQgb2YgY29sbGVnZSB5ZXQsIG11Y2ggbGVzcyBoaXMgQWxnZWJyYSBob21ld29yayB0b21vcnJvdy4gSSB3aXNoIGhlIGNvdWxkIGJlIG1vcmUgbGlrZSBKb3NoIGFuZCBkZXZlbG9wIHNvbWUgc2hvcnQgYW5kIGxvbmctdGVybSBnb2Fscy4gSGUgb25jZSB0b2xkIG1lIHRoYXQgaGUgZmVsdCBsaWtlIGV2ZXJ5dGhpbmcgd2FzIG91dCBvZiBjb250cm9sIGFuZCBub3RoaW5nIG1hdHRlcmVkLiBJIGhvcGUgaGUgd2FzIGp1c3QgaW4gYSBiYWQgbW9vZCBhbmQgdGhhdCBoZSdzIG5vdCBleHBlcmltZW50aW5nIHdpdGggYW55dGhpbmcuXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJ0cmlnZ2Vyc1wiOiBcInExLHEyLHEzLHE0LHE1XCIsXHJcbiAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImludHJvXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdWRpb1wiOiBcImF1ZGlvL2RheTEvbWVsaXNzYV8xci5tcDNcIixcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJBIHNob3J0LXRlcm0gZ29hbCBpcyBzaW1wbHkgYSBnb2FsIHlvdSB3YW50IHRvIGFjaGlldmUgaW4gYSBmZXcgZGF5cywgYSBmZXcgd2Vla3Mgb3IgYSBmZXcgbW9udGhzLlwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwidHJpZ2dlcnNcIjogXCJxMV9hLHEyLHEzLHE0LHE1XCIsXHJcbiAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInIxXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgXCJxdWVzdGlvbnNcIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiTWF5YmUgU2V0aCBkb2Vzbid0IGtub3cgd2hhdCBhIHNob3J0LXRlcm0gZ29hbCBpcy4gSSBrbm93IEkgZG9uJ3QuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicTFcIixcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IFwicjFcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiWFwiIC8vIHNldCB0aGUgdmFyaWFibGUgdG8gWC5cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkFsbCByaWdodCwgTXJzLiBSaWxleS4gSSdtIGdvaW5nIHRvIG5lZWQgYW4gZXhhbXBsZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJxMV9hXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZXNwb25zZVwiOiBcInIxX2FcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiV2hhdCdzIGEgbG9uZy10ZXJtIGdvYWw/XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicTJcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdGl2ZU1ldFwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IFwicjJcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgUm91bmRlZENoYXRSZWN0ID0gcmVxdWlyZSgnLi9yb3VuZGVkLWNoYXQtcmVjdCcpO1xyXG4gICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBNQVhfQ0hPSUNFUyA9IDUsXHJcbiAgICAgICAgbWFyZ2luWSA9IDMsXHJcbiAgICAgICAgUkVTUE9OU0VfU1RBUlRfWSA9IDMyMztcclxuICAgIHZhciBSRVNQT05TRV9URVhUX1ggPSA0MDtcclxuICAgIHZhciBDT0xPUl9WSVNJVEVEX09QVElPTiA9IFwiI2I1YjNiMlwiO1xyXG4gICAgdmFyIENPTE9SX0FDVElWRV9PUFRJT04gPSBcIiMwMDAwMDBcIjtcclxuXHJcbiAgICB2YXIgQ2hhdEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcImNvbnZlcnNhdGlvblwiLCBcImJhY2tncm91bmRcIiwgXCJwb3J0cmFpdFwiLCBcInBvcnRyYWl0TGFiZWxcIiwgXCJjaG9vc2VMYWJlbFwiLCBcInZhcmlhYmxlXCJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IHRoaXMuZGF0YS5jb252ZXJzYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlID0gdGhpcy5maW5kUmVzcG9uc2UoXCJpbnRyb1wiKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJZb3UgbXVzdCBoYXZlIGFuIGludHJvIHJlc3BvbnNlOiBcIiArIHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IHRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDaG9pY2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kKCk7ICAgICAgICAgIC8vIDAxLiBCYWNrZ3JvdW5kIGltYWdlLiBUaGlzIG1heSBhbHNvIGxhdGVyIG5lZWQgYSBib3JkZXIgZHJhd24/XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUG9ydHJhaXQoKTsgICAgICAgICAgICAvLyAwMiwgMDMuIFBvcnRyYWl0ICsgTGFiZWxcclxuICAgICAgICAgICAgdGhpcy5hZGRTcGVlY2hCdWJibGUoKTsgICAgICAgIC8vIDA0LiBTcGVlY2ggQnViYmxlIChhbmQgMTAuIHNwZWVjaCB0ZXh0KVxyXG4gICAgICAgICAgICB0aGlzLmFkZFJlc3BvbnNlVGl0bGUoKTsgICAgICAgLy8gMDUsIDA2LiBcIkNob29zZSB5b3VyIHJlc3BvbnNlLlwiIHcvbGluZVxyXG4gICAgICAgICAgICB0aGlzLmFkZENob2ljZUJveCgpOyAgICAgICAgICAgLy8gMDcuIENob2ljZSBib3hcclxuICAgICAgICAgICAgdGhpcy5hZGRBY3Rpb25CdXR0b25zKCk7ICAgICAgIC8vIDA4LCAwOS4gQXVkaW8gTXV0ZSBhbmQgTGVhdmUgQ29udmVyc2F0aW9uIGJ1dHRvblxyXG4gICAgICAgICAgICB0aGlzLmFkZENob2ljZVRleHQoKTsgICAgICAgICAgLy8gMTEuIEN1cnJlbnQgQ2hvaWNlKHMpIHRleHQgLyBMaW5rcywgcG9zc2libHkgZ3JheWVkIG91dC5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEJhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5iZ0ltYWdlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKHRoaXMuZGF0YS5iYWNrZ3JvdW5kLCB0aGlzLmRhdGEua2V5KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQb3J0cmFpdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcnRyYWl0ID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoNTgxLCA0MywgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKHRoaXMuZGF0YS5wb3J0cmFpdCwgdGhpcy5kYXRhLmtleSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gMDMuIFBvcnRyYWl0IGxhYmVsXHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5wb3J0cmFpdEZvbnQ7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxTdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwiY2hhdExhYmVsXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsU3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxYID0gdGhpcy5wb3J0cmFpdC54ICsgKHRoaXMucG9ydHJhaXQud2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsWSA9IHRoaXMucG9ydHJhaXQueSArIHRoaXMucG9ydHJhaXQuaGVpZ2h0ICsgMTU7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXRMYWJlbCA9IHRoaXMuZ2FtZS5hZGQudGV4dChsYWJlbFgsIGxhYmVsWSwgdGhpcy5kYXRhLnBvcnRyYWl0TGFiZWwsIHRoaXMubGFiZWxTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXRMYWJlbC5hbmNob3Iuc2V0VG8oMC41LCAwLjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU3BlZWNoQnViYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQnViYmxlID0gbmV3IFJvdW5kZWRDaGF0UmVjdCh0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEJ1YmJsZS5zaG93KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRSZXNwb25zZVRpdGxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5jaG9vc2VGb250O1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVDaG9vc2UgPSB0aGlzLmdldEZvbnQoKHR5cGVvZiBmb250TmFtZSAhPT0gJ3VuZGVmaW5lZCcpID8gZm9udE5hbWUgOiBcImNoYXRMYWJlbFwiKTtcclxuICAgICAgICAgICAgdmFyIGNob29zZUxhYmVsWCA9IDE1MDtcclxuICAgICAgICAgICAgdmFyIGNob29zZUxhYmVsWSA9IHRoaXMucG9ydHJhaXQueSArIHRoaXMucG9ydHJhaXQuaGVpZ2h0ICsgNjU7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvb3NlTGFiZWwgPSB0aGlzLmdhbWUuYWRkLnRleHQoY2hvb3NlTGFiZWxYLCBjaG9vc2VMYWJlbFksIHRoaXMuZGF0YS5jaG9vc2VMYWJlbCwgc3R5bGVDaG9vc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNob29zZUxhYmVsLmFuY2hvci5zZXRUbygwLjUsIDEuMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRDaG9pY2VCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygwLCAwKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MubGluZVN0eWxlKDMsIDB4YzczMjQ4LCAxKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MubW92ZVRvKDQwLCBSRVNQT05TRV9TVEFSVF9ZIC0gMTUpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5saW5lVG8oNzYwLCBSRVNQT05TRV9TVEFSVF9ZIC0gMTUpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5saW5lU3R5bGUoMSwgMHhmZmZmZmYsIDEpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5iZWdpbkZpbGwoMHhGRkZGRkYsIDEpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5kcmF3UmVjdCgzMCwgUkVTUE9OU0VfU1RBUlRfWSAtIDUsIDc0MCwgMTUwKTtcclxuICAgICAgICAgICAgdGhpcy5jaG9pY2VHcmFwaGljcyA9IGNob2ljZUdyYXBoaWNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQWN0aW9uQnV0dG9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKDQ1MCwgNTM1LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTXV0ZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPZmYnXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbJ3NvdW5kT2ZmJ10ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zWydzb3VuZE9mZiddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPZmYnXS51cCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKDQ1MCwgNTM1LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTXV0ZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLnVwKTtcclxuICAgICAgICAgICAgdmFyIHRleHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBcIkF1ZGlvIE9mZlwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBcIkF1ZGlvIE9uXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBidXR0b25zID0gdGhpcy50aGVtZS5idXR0b25zLmxlYXZlQ2hhdDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5idXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25zID0gdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5idXR0b25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVhdmVCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbig1NjAsIDU0NywgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxlYXZlQWN0aW9uLCB0aGlzLCBidXR0b25zLm92ZXIsIGJ1dHRvbnMub3V0LCBidXR0b25zLmRvd24sIGJ1dHRvbnMudXApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0eWxlQ2hvb3NlID0gdGhpcy5nZXRGb250KFwiY2hhdE11dGVcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm11dGVUZXh0ID0gdGhpcy5nYW1lLmFkZC50ZXh0KDQ1MCwgNTIwLCB0ZXh0LCBzdHlsZUNob29zZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRDaG9pY2VUZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblkgPSBSRVNQT05TRV9TVEFSVF9ZLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ250LFxyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUNob29zZSA9IHRoaXMuZ2V0Rm9udChcImNoYXRPcHRpb25cIik7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVDaG9vc2Uud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlQ2hvb3NlLndvcmRXcmFwV2lkdGggPSA3MjU7XHJcbiAgICAgICAgICAgIGZvciAoYnV0dG9uQ250ID0gMDsgYnV0dG9uQ250IDwgTUFYX0NIT0lDRVM7IGJ1dHRvbkNudCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uID0gdGhpcy5nYW1lLmFkZC50ZXh0KFJFU1BPTlNFX1RFWFRfWCwgbG9jYXRpb25ZLCBcImFuc3dlciB0ZXh0XCIsIHRoaXMuc3R5bGVDaG9vc2UpO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi5saW5lU3BhY2luZyA9IC02O1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb25ZICs9IGN1cnJCdXR0b24uaGVpZ2h0ICsgbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5wdXNoKGN1cnJCdXR0b24pO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi5hbnN3ZXJJbmRleCA9IGJ1dHRvbkNudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVGV4dEFuc3dlckJveDogZnVuY3Rpb24gKGFuc3dlclRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGFuc3dlclRleHQuYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIGFuc3dlclRleHQuYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXJUZXh0LmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYW5zd2VyVGV4dC5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXJUZXh0LmJ1dHRvbkdyYXBoaWNzID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygzMCwgYW5zd2VyVGV4dC55IC0gMyk7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmJlZ2luRmlsbCgweGZmZmZmZiwgMSk7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmRyYXdSZWN0KDIsIDAsIDczNiwgYW5zd2VyVGV4dC5oZWlnaHQgKyAxKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzMiA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoMzAsIGFuc3dlclRleHQueSAtIDMpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljczIubGluZVN0eWxlKDIsIDB4ZmZmZmZmKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MyLmRyYXdSZWN0KDIsIDAsIDczNiwgYW5zd2VyVGV4dC5oZWlnaHQgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5pc1RvcEJ1dHRvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBjaG9pY2VHcmFwaGljczI7XHJcblxyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZU92ZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5ldmVudHMub25JbnB1dE91dC5hZGQodGhpcy5vbk1vdXNlT3V0LCB0aGlzKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MuZXZlbnRzLm9uSW5wdXRVcC5hZGQodGhpcy5vbk1vdXNlVXAsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgYW5zd2VyVGV4dC5idXR0b25HcmFwaGljcyA9IGNob2ljZUdyYXBoaWNzO1xyXG4gICAgICAgICAgICBhbnN3ZXJUZXh0LmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoeC5pc1RvcEJ1dHRvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgeC50aW50ID0gMHhmZmQ0ODA7XHJcbiAgICAgICAgICAgICAgICB4LmJvcmRlckdyYXBoaWMudGludCA9IDB4ZmZhYTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoeC5pc1RvcEJ1dHRvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgeC50aW50ID0gMHhmZWZmZmY7XHJcbiAgICAgICAgICAgICAgICB4LmJvcmRlckdyYXBoaWMudGludCA9IDB4ZmVmZmZmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DaG9pY2UoeC5xdWVzdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5kUmVzcG9uc2U6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNvbnZlcnNhdGlvbi5yZXNwb25zZXMsIGZ1bmN0aW9uIChlYWNoUmVzcG9uc2UsIHJlc3BvbnNlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlYWNoUmVzcG9uc2UubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZWFjaFJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmRRdWVzdGlvbnM6IGZ1bmN0aW9uIChzZXROYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghc2V0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IHNldE5hbWUuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICB2YXIgcXVlc3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIF8uZWFjaChuYW1lcywgZnVuY3Rpb24gKGVhY2hOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5jb252ZXJzYXRpb24ucXVlc3Rpb25zLCBmdW5jdGlvbiAoZWFjaFF1ZXN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhY2hRdWVzdGlvbi5uYW1lID09PSBlYWNoTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbnMucHVzaChlYWNoUXVlc3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXN0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvcHVsYXRlQ2hvaWNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcXVlc3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hCdWJibGUuc2hvd1Jlc3BvbnNlKHRoaXMuY3VycmVudFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNwb25zZS50cmlnZ2Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9ucyA9IHRoaXMuZmluZFF1ZXN0aW9ucyh0aGlzLmN1cnJlbnRSZXNwb25zZS50cmlnZ2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBSRVNQT05TRV9TVEFSVF9ZO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHF1ZXN0aW9ucyA9IF8uc2h1ZmZsZShxdWVzdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChxdWVzdGlvbnMsIGZ1bmN0aW9uIChlYWNoUXVlc3Rpb24sIHF1ZXN0aW9uSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVhY2hRdWVzdGlvbi5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbcXVlc3Rpb25JbmRleF0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5zZXRUZXh0KGVhY2hRdWVzdGlvbi50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5oZWlnaHQgKyBtYXJnaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRleHRBbnN3ZXJCb3godGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLmJ1dHRvbkdyYXBoaWNzLnF1ZXN0aW9uID0gZWFjaFF1ZXN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmNvbXBsZXRlZCwgZnVuY3Rpb24oZWFjaENvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHByZWZpeC5zdGFydHNXaXRoKGVhY2hDb21wbGV0ZWQpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLmFkZENvbG9yKENPTE9SX1ZJU0lURURfT1BUSU9OLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5hZGRDb2xvcihDT0xPUl9BQ1RJVkVfT1BUSU9OLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBsb29wID0gTUFYX0NIT0lDRVMgLSAxOyBsb29wID49IHF1ZXN0aW9ucy5sZW5ndGg7IGxvb3AtLSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvbnNbbG9vcF0uYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbbG9vcF0uYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tsb29wXS5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLmJ1dHRvbkdyYXBoaWNzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlICYmIHRoaXMuY3VycmVudFJlc3BvbnNlLnRleHQgJiYgdGhpcy5jdXJyZW50UmVzcG9uc2UudGV4dC5hdWRpbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHsgXCJhdWRpb1wiOiB0aGlzLmN1cnJlbnRSZXNwb25zZS50ZXh0LmF1ZGlvfTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcDtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMudGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gdGhpcy50ZXh0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1dHRvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMuYnV0dG9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAuYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAuYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5idXR0b25HcmFwaGljcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmdJbWFnZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnRyYWl0TGFiZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEJ1YmJsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvb3NlTGFiZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNob2ljZUdyYXBoaWNzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxlYXZlQnV0dG9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlVGV4dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiOiB0aGlzLnRoZW1lLmNoYXQuZXhpdH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKGV2ZW50RGF0YSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTXV0ZUFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5pc011dGVkID0gIXRoaXMuaXNNdXRlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IFwiQXVkaW8gT2ZmXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJBdWRpbyBPblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7XCJtdXRlX2dhbWVcIjogdGhpcy5pc011dGVkID8gXCJtdXRlX29uXCIgOiBcIm11dGVfb2ZmXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSAhdGhpcy5pc011dGVkO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24udmlzaWJsZSA9IHRoaXMuaXNNdXRlZDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlVGV4dC5zZXRUZXh0KHRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DaG9pY2U6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIjogdGhpcy50aGVtZS5jaGF0LnNvdW5kfTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBldmVudERhdGEpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmJyYW5jaGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlZC5wdXNoKGRhdGEuYnJhbmNoZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5vYmplY3RpdmVNZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhclNldFtkYXRhLm9iamVjdGl2ZU1ldF0gPSBcImNvbXBsZXRlXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZSA9IHRoaXMuZmluZFJlc3BvbnNlKGRhdGEucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNob2ljZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gZGF0YS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFsdWVTZXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhdEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgY3VzdG9tIGZpbGUgY2FiaW5ldCBkcmFnIGFjdG9yLiBEcmFnZ2VkIGFyb3VuZCB0aGUgc2NyZWVuLCByZXByZXNlbnRlZCBieSBpbWFnZSwgaGFzIGhlYWRpbmcgYW5kIHRleHQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgZGVjb3JhdGlvbiBhY3RvciwgYSBzaW1wbGUgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkcmFnXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogeyBcIm5vcm1hbFwiIDogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBpbWFnZXMgc2VjdGlvbiB0aGUgdGhlbWUuXHJcbiAqICAgICAgICAgICAgICAgICBcImRyYWdnaW5nXCIgOiBcInBob25lXCIsIC8vIG9wdGlvbmFsIGltYWdlIHdoaWxlIGRyYWdnaW5nXHJcbiAqICAgICAgICAgICAgICAgICBcIm92ZXJsYXBcIiA6IFwicGhvbmVcIiwgLy8gb3B0aW9uYWwgaW1hZ2Ugd2hlbiBvdmVybGFwcGluZy5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UocykuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInN0cmluZ1wiIC8vIG5hbWUgb2YgdmFyaWFibGUgdG8gYmUgc2V0IHdoZW4gdGhpcyBpcyBkcmFnZ2luZy9kcm9wcGVkL2V0Yy5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuLi9hY3RvclwiKTtcclxuXHJcblx0dmFyIEl0c1VyQ2hvaWNlRHJhZ0FjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuXHRcdC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudFxyXG5cdFx0Z2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIFtcImxvY2F0aW9uXCIsIFwiaW1hZ2VzXCIsIFwidmFyaWFibGVcIl07XHJcblx0XHR9LFxyXG5cdFx0ZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmJ1aWxkQWN0b3IoKTtcclxuXHRcdFx0dGhpcy5pc092ZXJsYXBwaW5nID0gbnVsbDtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5hdWRpbykge1xyXG5cdFx0XHRcdHRoaXMucGxheUF1ZGlvKHsgYXVkaW86IHRoaXMuZGF0YS5hdWRpbywga2V5OiBudWxsIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0YnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoXHJcblx0XHRcdFx0dGhpcy5kYXRhLmxvY2F0aW9uWzBdLFxyXG5cdFx0XHRcdHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuXHRcdFx0XHR0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcblx0XHRcdFx0dGhpcy5nZXRJbWFnZSh0aGlzLmdldEZyYW1lKCksIHRoaXMuZGF0YS5rZXkpXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5waHlzaWNzLmVuYWJsZShzcHJpdGUsIFBoYXNlci5QaHlzaWNzLkFSQ0FERSk7XHJcblx0XHRcdHNwcml0ZS5ib2R5LnNldFNpemUoMSwgMSwgc3ByaXRlLndpZHRoIC8gMiwgc3ByaXRlLmhlaWdodCAvIDIpO1xyXG5cdFx0XHRzcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFx0c3ByaXRlLmlucHV0LnBpeGVsUGVyZmVjdE92ZXIgPSBmYWxzZTtcclxuXHRcdFx0c3ByaXRlLmlucHV0LmVuYWJsZURyYWcoZmFsc2UsIHRydWUpO1xyXG5cdFx0XHRzcHJpdGUuZXZlbnRzLm9uRHJhZ1N0b3AuYWRkKHRoaXMuaXRlbURyYWdTdG9wLCB0aGlzKTtcclxuXHRcdFx0c3ByaXRlLmV2ZW50cy5vbkRyYWdTdGFydC5hZGQodGhpcy5pdGVtRHJhZ1N0YXJ0LCB0aGlzKTtcclxuXHRcdFx0c3ByaXRlLmV2ZW50cy5vbkRyYWdVcGRhdGUuYWRkKGZ1bmN0aW9uIChzcHJpdGUsIHBvaW50ZXIsIHgsIHkpIHtcclxuXHRcdFx0XHR2YXIgcG9zID0gc3ByaXRlLmdhbWUuaW5wdXQuZ2V0TG9jYWxQb3NpdGlvbihzcHJpdGUucGFyZW50LCBwb2ludGVyKTtcclxuXHRcdFx0XHRzcHJpdGUueCA9IHBvcy54IC0gc3ByaXRlLndpZHRoIC8gMjtcclxuXHRcdFx0XHRzcHJpdGUueSA9IHBvcy55IC0gc3ByaXRlLmhlaWdodCAvIDI7XHJcblx0XHRcdH0sIHNwcml0ZSk7XHJcblx0XHRcdHNwcml0ZS5vcmlnTG9jID0gW3Nwcml0ZS54LCBzcHJpdGUueV07XHJcblx0XHRcdHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cclxuXHRcdFx0dmFyIGZvbnRIZWFkZXJOYW1lLCBmb250Qm9keU5hbWU7XHJcblx0XHRcdGlmICh0aGlzLmRhdGEudGV4dERhdGEpIHtcclxuXHRcdFx0XHR2YXIgdGV4dERhdGEgPSB0aGlzLmRhdGEudGV4dERhdGE7XHJcblx0XHRcdFx0Zm9udEhlYWRlck5hbWUgPSB0ZXh0RGF0YS5mb250SGVhZGluZztcclxuXHRcdFx0XHRmb250Qm9keU5hbWUgPSB0ZXh0RGF0YS5mb250Qm9keTtcclxuXHRcdFx0XHR0aGlzLmhlYWRlclN0eWxlID0gdGhpcy5nZXRGb250KFxyXG5cdFx0XHRcdFx0dHlwZW9mIGZvbnRIZWFkZXJOYW1lICE9PSBcInVuZGVmaW5lZFwiXHJcblx0XHRcdFx0XHRcdD8gZm9udEhlYWRlck5hbWVcclxuXHRcdFx0XHRcdFx0OiBcInF1ZXN0aW9uVGV4dFwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLmJvZHlTdHlsZSA9IHRoaXMuZ2V0Rm9udChcclxuXHRcdFx0XHRcdHR5cGVvZiBmb250Qm9keU5hbWUgIT09IFwidW5kZWZpbmVkXCIgPyBmb250Qm9keU5hbWUgOiBcInF1ZXN0aW9uVGV4dFwiXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0dGhpcy5oZWFkaW5nU3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KFxyXG5cdFx0XHRcdFx0OCxcclxuXHRcdFx0XHRcdDgsXHJcblx0XHRcdFx0XHR0ZXh0RGF0YS5oZWFkaW5nLFxyXG5cdFx0XHRcdFx0dGhpcy5oZWFkZXJTdHlsZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5ib2R5U3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KFxyXG5cdFx0XHRcdFx0OSxcclxuXHRcdFx0XHRcdDM1LFxyXG5cdFx0XHRcdFx0dGV4dERhdGEuYm9keSxcclxuXHRcdFx0XHRcdHRoaXMuYm9keVN0eWxlXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuYWRkQ2hpbGQodGhpcy5oZWFkaW5nU3ByaXRlKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5hZGRDaGlsZCh0aGlzLmJvZHlTcHJpdGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kYXRhLmFuZ2xlKSB7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUuYW5nbGUgPSB0aGlzLmRhdGEuYW5nbGU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRyZXR1cm5Ub0hvbWU6IGZ1bmN0aW9uICgpIHt9LFxyXG5cdFx0aXRlbURyYWdTdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUltYWdlKCk7XHJcblx0XHRcdHZhciB0ZW1wID0ge307XHJcblx0XHRcdHRlbXBbXCJkcm9wcGVkXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcblx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG5cdFx0XHQvLyBJdCB3aWxsIGhhdmUgYmVlbiBkcm9wcGVkLCBhbmQgcG9zc2libHkgcmVtb3ZlZCBmcm9tIHNjZW5lLlxyXG5cdFx0XHRpZiAodGhpcy5zcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS54ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1swXTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS55ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGl0ZW1EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS5hdWRpbykge1xyXG5cdFx0XHRcdHRoaXMucGxheUF1ZGlvKHsgYXVkaW86IHRoaXMuZGF0YS5hdWRpbywga2V5OiBudWxsIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcclxuXHRcdFx0dGVtcFtcImRyYWdnaW5nXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcblx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS54ID0gdGhpcy5nYW1lLmlucHV0LmFjdGl2ZVBvaW50ZXIucG9zaXRpb24ueCAtIDEwO1xyXG5cdFx0XHR0aGlzLnNwcml0ZS5ib2R5LnggPSB0aGlzLmdhbWUuaW5wdXQuYWN0aXZlUG9pbnRlci5wb3NpdGlvbi54IC0gMTA7XHJcblx0XHRcdHRoaXMuc3ByaXRlLnkgPSB0aGlzLmdhbWUuaW5wdXQuYWN0aXZlUG9pbnRlci5wb3NpdGlvbi55IC0gMTA7XHJcblx0XHRcdHRoaXMuc3ByaXRlLmJvZHkueSA9IHRoaXMuZ2FtZS5pbnB1dC5hY3RpdmVQb2ludGVyLnBvc2l0aW9uLnkgLSAxMDtcclxuXHRcdH0sXHJcblx0XHRnZXRGcmFtZTogZnVuY3Rpb24gKHR5cGUpIHtcclxuXHRcdFx0dmFyIGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMubm9ybWFsO1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJvdmVybGFwXCIgJiYgdGhpcy5kYXRhLmltYWdlcy5vdmVybGFwKSB7XHJcblx0XHRcdFx0ZnJhbWVOYW1lID0gdGhpcy5kYXRhLmltYWdlcy5vdmVybGFwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKFxyXG5cdFx0XHRcdCh0eXBlID09PSBcImRyYWdnaW5nXCIgfHwgIWZyYW1lTmFtZSkgJiZcclxuXHRcdFx0XHR0aGlzLmRhdGEuaW1hZ2VzLmRyYWdnaW5nXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMuZHJhZ2dpbmc7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZyYW1lTmFtZTtcclxuXHRcdH0sXHJcblx0XHR1cGRhdGVJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgZnJhbWU7XHJcblx0XHRcdGlmICh0aGlzLmhlYWRpbmdTcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLmhlYWRpbmdTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMuYm9keVNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuaXNPdmVybGFwcGluZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGZyYW1lID0gdGhpcy5nZXRGcmFtZShcIm92ZXJsYXBcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc0RyYWdnaW5nID09PSB0cnVlKSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwiZHJhZ2dpbmdcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwibm9ybWFsXCIpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmhlYWRpbmdTcHJpdGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuaGVhZGluZ1Nwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHRoaXMuYm9keVNwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zcHJpdGUuZnJhbWVOYW1lID0gdGhpcy5nZXRJbWFnZShmcmFtZSwgdGhpcy5kYXRhLmtleSk7XHJcblx0XHRcdHRoaXMuc3ByaXRlLmJvZHkuc2V0U2l6ZShcclxuXHRcdFx0XHQxLFxyXG5cdFx0XHRcdDEsXHJcblx0XHRcdFx0dGhpcy5zcHJpdGUud2lkdGggLyAyLFxyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmhlaWdodCAvIDJcclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblx0XHRnZXRCb2R5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLnNwcml0ZSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNwcml0ZS5ib2R5O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fSxcclxuXHRcdG9uT3ZlcmxhcHBpbmc6IGZ1bmN0aW9uIChvdGhlckFjdG9yKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzT3ZlcmxhcHBpbmcgPT09IG90aGVyQWN0b3IpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5pc092ZXJsYXBwaW5nID0gb3RoZXJBY3RvcjtcclxuXHRcdFx0Ly8gY2hhbmdlIHRvIG92ZXJsYXBwaW5nIGltYWdlLlxyXG5cdFx0XHR0aGlzLnVwZGF0ZUltYWdlKCk7XHJcblx0XHR9LFxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5pbnB1dC5kaXNhYmxlRHJhZygpO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmJvZHkuZGVzdHJveSgpO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmV2ZW50cy5vbkRyYWdTdG9wLnJlbW92ZUFsbCgpO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmV2ZW50cy5vbkRyYWdTdGFydC5yZW1vdmVBbGwoKTtcclxuXHRcdFx0XHR0aGlzLnNwcml0ZS5ldmVudHMub25EcmFnVXBkYXRlLnJlbW92ZUFsbCgpO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMuc3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcblx0XHRcdFx0dGhpcy5zcHJpdGUgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmhlYWRpbmdTcHJpdGUpIHtcclxuXHRcdFx0XHR0aGlzLmhlYWRpbmdTcHJpdGUuZGVzdHJveSgpO1xyXG5cdFx0XHRcdHRoaXMuYm9keVNwcml0ZS5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zdHlsZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBJdHNVckNob2ljZURyYWdBY3RvcjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIG1hcCBhY3Rvci5cclxuICpcclxuICogQ3JlYXRpbmcgYSBtYXAgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm1hbmR5XCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcIml1Y21hcFwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJsb2NhdGlvbkNob2ljZVwiXHJcbiAqICAgICBcIm5pZ2h0XCI6IHRydWUsIC8vIG1ha2VzIGl0IG5pZ2h0LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gKiB9XHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBMYXJnZUJpcmQgPSByZXF1aXJlKCcuL21hcC9hY3Rvci1iaXJkLWxhcmdlJyk7XHJcbiAgICB2YXIgU21hbGxCaXJkID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItYmlyZC1zbWFsbCcpO1xyXG4gICAgdmFyIEJhc2ljQ2FyID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItY2FyLWJhc2ljJyk7XHJcbiAgICB2YXIgWWVsbG93Q2FyID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItY2FyLXllbGxvdycpO1xyXG5cclxuICAgIHZhciBFWFRSQV9XQUlUX1RJTUUgPSA4MDAwO1xyXG5cclxuICAgICB2YXIgTWFwQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuYW5pbWF0aW9ucy5wbGF5KCd3YXZlJywgMjQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnVzRmxhZy5hbmltYXRpb25zLnBsYXkoJ3dhdmUnLCAyNCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwVGltZXIuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMuZ2V0SW1hZ2UoXCJjaXR5bWFwXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5ob3VzZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLnRoZW1lLm1hcEluZm8uYnVpbGRpbmdzLCBmdW5jdGlvbiggYnVpbGRpbmcsIGJ1aWxkaW5nSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuc3ByaXRlKGJ1aWxkaW5nLngsIGJ1aWxkaW5nLnksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgYnVpbGRpbmcuaW1hZ2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gYnVpbGRpbmcuaG92ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuc3ByaXRlKGxhYmVsLngsIGxhYmVsLnksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgbGFiZWwuaW1hZ2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uY2xpY2tWYWx1ZSA9IGJ1aWxkaW5nLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaG91c2VzW2J1aWxkaW5nSW5kZXhdLmlzQnVpbGRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uYnVpbGRpbmdJbmRleCA9IGJ1aWxkaW5nSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZU92ZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uZXZlbnRzLm9uSW5wdXRPdXQuYWRkKHRoaXMub25Nb3VzZU91dCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5ldmVudHMub25JbnB1dFVwLmFkZCh0aGlzLm9uTW91c2VVcCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibHVlRmxhZyA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCAxODAsIDcwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUubWFwSW5mby5ibHVlRmxhZ0ZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuYW5pbWF0aW9ucy5hZGQoJ3dhdmUnLCB0aGlzLnRoZW1lLm1hcEluZm8uYmx1ZUZsYWdGcmFtZXMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXNGbGFnID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIDE4MCwgMzgsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5tYXBJbmZvLnVzRmxhZ0ZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMudXNGbGFnLmFuaW1hdGlvbnMuYWRkKCd3YXZlJywgdGhpcy50aGVtZS5tYXBJbmZvLnVzRmxhZ0ZyYW1lcyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zbWFsbEJpcmQgPSBuZXcgU21hbGxCaXJkKHRoaXMuZ2FtZSwgdGhpcy50aGVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFyZ2VCaXJkID0gbmV3IExhcmdlQmlyZCh0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhciA9IG5ldyBCYXNpY0Nhcih0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhciA9IG5ldyBZZWxsb3dDYXIodGhpcy5nYW1lLCB0aGlzLnRoZW1lKTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbEJpcmQuZXZlbnRzLnBsYXlBdWRpby5hZGQodGhpcy5vblN1YlNwZWVjaCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFyZ2VCaXJkLmV2ZW50cy5wbGF5QXVkaW8uYWRkKHRoaXMub25TdWJTcGVlY2gsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci5ldmVudHMucGxheUF1ZGlvLmFkZCh0aGlzLm9uU3ViU3BlZWNoLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZXZlbnRzLnBsYXlBdWRpby5hZGQodGhpcy5vblN1YlNwZWVjaCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZnID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKFwiY2l0eW1hcGZnXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEubmlnaHQgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUgPSBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmFkZENoaWxkKGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCggMHgwMDAwMDAsIDAuMzUgKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KCAwLCAwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZS5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tlclNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5sYWJlbHMsIGZ1bmN0aW9uKCBlYWNoTGFiZWwgKSB7XHJcbiAgICAgICAgICAgICAgICBlYWNoTGFiZWwuc2NhbGUuc2V0VG8oMC44MCwwLjgwKTtcclxuICAgICAgICAgICAgICAgIGVhY2hMYWJlbC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgICAgICBlYWNoTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFwVGltZXIgPSB0aGlzLmdhbWUudGltZS5jcmVhdGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFRpbWVyLmxvb3AoRVhUUkFfV0FJVF9USU1FLCB0aGlzLnNob3dFeHRyYU9uTWFwLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICBvblN1YlNwZWVjaDogZnVuY3Rpb24obmFtZSwgc3BlZWNoKSB7XHJcbiAgICAgICAgICAgICBpZiggbmFtZSAmJiBzcGVlY2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3BhdGNoKG5hbWUsIHNwZWVjaCk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24oc3BlZWNoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdGhpbmcuXHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIHNob3dFeHRyYU9uTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICB2YXIgcmFuZG9tVmFsdWUgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDAsIDQpO1xyXG4gICAgICAgICAgICAgc3dpdGNoIChyYW5kb21WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgIGNhc2UgMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmxhcmdlQmlyZC5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgIGNhc2UgMToge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnNtYWxsQmlyZC5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIucGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgIGNhc2UgMzoge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmRvbUNhci5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICBpZiAoeC5pc0J1aWxkaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHNbeC5idWlsZGluZ0luZGV4XS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgIGlmICh4LmlzQnVpbGRpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsc1t4LmJ1aWxkaW5nSW5kZXhdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZVVwOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgaWYgKHguaXNCdWlsZGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHguY2xpY2tWYWx1ZTtcclxuICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIC8vIHRoaXMub25DaG9pY2UoeC5xdWVzdGlvbik7XHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5iZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5mZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkZXN0cm95QnVpbGRpbmcgPSB0aGlzLmhvdXNlcy5wb3AoKTtcclxuICAgICAgICAgICAgd2hpbGUoIGRlc3Ryb3lCdWlsZGluZyApIHtcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3lCdWlsZGluZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBkZXN0cm95QnVpbGRpbmcgPSB0aGlzLmhvdXNlcy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvdXNlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBkZXN0cm95TGFiZWwgPSB0aGlzLmxhYmVscy5wb3AoKTtcclxuICAgICAgICAgICAgd2hpbGUoIGRlc3Ryb3lMYWJlbCApIHtcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3lMYWJlbC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBkZXN0cm95TGFiZWwgPSB0aGlzLmxhYmVscy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YXIgZGVzdHJveVR3ZWVuID0gdGhpcy5hbGxUd2VlbnMucG9wKCk7XHJcbiAgICAgICAgICAgIC8vIHdoaWxlKCBkZXN0cm95VHdlZW4gKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBkZXN0cm95VHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy5nYW1lLnR3ZWVucy5yZW1vdmUoZGVzdHJveVR3ZWVuKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUudHdlZW5zLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVzRmxhZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc21hbGxCaXJkLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5sYXJnZUJpcmQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXBUaW1lci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLm5pZ2h0ID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXBBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHBob25lIGJ1dHRvbiBhY3Rvci4gVGhpcyBhY3RvciBpcyB1c2VkIGZvciBvcGVuaW5nIHRoZSBwaG9uZSBhbmQgc2hvd2luZyBwaG9uZSBhbGVydHMuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgcGhvbmUgYnV0dG9uIGFjdG9yOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwaG9uZTFcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaXVjcGhvbmUtYnV0dG9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLipcclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcImFsZXJ0XCI6IGFueSB2YWx1ZSAvLyBwaG9uZSB3aWxsIGFsZXJ0IGltbWVkaWF0ZWx5LlxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmVCdXR0b25BY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBbGVydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFsZXJ0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkdhbWVDaG9pY2UoIHsgJ3Bob25lX2FsZXJ0JzogdGhpcy5kYXRhLmFsZXJ0IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25BbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSAsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnMucGhvbmUub3ZlciwgdGhpcy50aGVtZS5idXR0b25zLnBob25lLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9ucy5waG9uZS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnMucGhvbmUudXApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGNob2ljZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuICAgICAgICAgICBpZiggY2hvaWNlWydwaG9uZV9hbGVydCddICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FsZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QWxlcnQoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5IHRoZSByaW5nIGFuaW1hdGlvbiBhbmQgY3VycmVudCByaW5nIHRvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGxheUFsZXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYnV0dG9uQW5pbWF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkFuaW1hdGlvbiA9IHRoaXMuYnV0dG9uLmFuaW1hdGlvbnMuYWRkKCdyaW5nJywgdGhpcy50aGVtZS5waG9uZS5hbGVydHMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnBsYXkoJ3JpbmcnLCAyNCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMudGhlbWUucGhvbmUucmluZ3RvbmUsIFwicHJpb3JpdHlcIjogXCJzZnhcIiB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRoZSBwbGF5ZXIgY2xpY2tzIHRoZSBwaG9uZSBidXR0b24sIHN0b3AgYW55IGFsZXJ0IGFuZCB0aGVuIHNlbmQgb3V0IHRoZSBnYW1lIGNob2ljZS5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB0aGlzLmlzQWxlcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0WydzaG93X2NlbGxfcGhvbmUnXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSXRzVXJDaG9pY2VQaG9uZUJ1dHRvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA5LzIyLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsaXplZCBhY3RvciBmb3IgdXNlIHdpdGggV2VsY29tZSBUbyBXZXN0cG9zdCBhbmQgSXRzIFVSIENob2ljZSEgaXQgc2hvd3MgYSBjZWxsIHBob25lIHRoYXRcclxuICogc2VuZHMgb3V0IHNwZWNpYWwgZXZlbnRzLCByZXNwb25kcyB0byBldmVudHMsIGFuZCBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgdXNlciBieSBkcmF3aW5nIG92ZXIgdGhlIHNjZW5lLlxyXG4gKiBUaGUgdXNlciBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgcGhvbmUsIHdoaWNoIG11c3QgYmxvY2sgdXNlciBpbnB1dC5cclxuICpcclxuICogIHtcclxuICogICAgIFwibmFtZVwiOiBcInBob25lXzFcIixcclxuICogICAgIFwidHlwZVwiOiBcIml1Y3Bob25lXCIsXHJcbiAqICAgICBcImhlbHBWYXJpYWJsZVwiOiBcImN1cnJlbnRfaGVscF9tZXNzYWdlXCIsXHJcbiAqICAgICBcIm9iamVjdGl2ZXNcIjoge1xyXG4gKiAgICAgICBcIm9iajFcIjogXCJFeHBsb3JlIFdlc3Rwb3J0XCIsXHJcbiAqICAgICAgIFwib2JqMlwiOiBcIlRyeSBvdXQgeW91ciBjZWxsIHBob25lIGFuZCBqb3VybmFsLlwiXHJcbiAqICAgICB9LFxyXG4gKiAgICAgZGlzYWJsZVBvd2VyOiB0cnVlfGZhbHNlLCAvLyBkZWZhdWx0cyB0byBmYWxzZSwgY2FuIGtlZXAgdGhlIHBsYXllciBmcm9tIGNsb3NpbmcgdGhlIHBob25lLlxyXG4gKiAgICAgZGVtb01vZGU6IHRydWV8ZmFsc2UgLy8gZGVmYXVsdHMgdG8gZmFsc2UuIFNob3dzIHBob25lIHNtYWxsZXIgb24gbGVmdCBzaWRlIG9mIHNjcmVlbi5cclxuICogIH1cclxuICpcclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpLFxyXG4gICAgICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuICAgIHZhciBTQ1JFRU5fWCA9IDI1ODtcclxuICAgIHZhciBTQ1JFRU5fRU5EX1ggPSA3MTI7XHJcbiAgICB2YXIgU0NSRUVOX1kgPSAzMjtcclxuICAgIHZhciBTQ1JFRU5fRU5EX1kgPSAzMTc7XHJcblxyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmUgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwib2JqZWN0aXZlc1wiLCBcImhlbHBWYXJpYWJsZVwiLCBcIm9iamVjdGl2ZUF1ZGlvXCIsIFwiaGVscEF1ZGlvXCJdOyAvLyBubyByZXF1aXJlZCBmaWVsZHNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250SGVhZGVyID0gdGhpcy5nZXRGb250KCdwaG9uZUhlYWRlcicpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5ID0gdGhpcy5nZXRGb250KCdwaG9uZUJvZHknKTtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IHRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZU1hcmtlcnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEub3BlbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuICAgICAgICAgICAgaWYoIGNob2ljZVsnc2hvd19jZWxsX3Bob25lJ10gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMucGhvbmVHcm91cC52aXNpYmxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbGlja0Nsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZGF0YSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbZGF0YS52YXJpYWJsZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0hlbHA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhlbHBUZXh0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSh0aGlzLmRhdGEuaGVscFZhcmlhYmxlKTtcclxuICAgICAgICAgICAgdGhpcy5oaWRlT2JqZWN0aXZlcygpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLnRoZW1lLnBob25lLmJ1dHRvblNvdW5kIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lXCI6IFwiaGVscFwifSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0hlbHAoIGhlbHBUZXh0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tNdXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9ICF0aGlzLmlzTXV0ZWQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLnRoZW1lLnBob25lLmJ1dHRvblNvdW5kICwgXCJwcmlvcml0eVwiOiBcInNmeFwifTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBldmVudERhdGEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHtcIm11dGVfZ2FtZVwiIDogdGhpcy5pc011dGVkID8gXCJtdXRlX29uXCIgOiBcIm11dGVfb2ZmXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzTXV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmFuaW1hdGlvbnMucGxheSgndmlicmF0ZScsIDI0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUljb24uYW5pbWF0aW9ucy5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9mZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja09iamVjdGl2ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVIZWxwKCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMudGhlbWUucGhvbmUuYnV0dG9uU291bmQgLCBcInByaW9yaXR5XCI6IFwic2Z4XCJ9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd09iamVjdGl2ZXModGhpcy5kYXRhLm9iamVjdGl2ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZGlzYWJsZVBvd2VyID09PSB0cnVlIHx8IHRoaXMuZGF0YS5kaXNhYmxlUG93ZXIgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNsb3NlIGlzIHR1cm5lZCBvZmYgYnkgdGhpcyBmZWF0dXJlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy50aGVtZS5waG9uZS5idXR0b25Tb3VuZCAsIFwicHJpb3JpdHlcIjogXCJzZnhcIn07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy50aGVtZS5waG9uZS5idXR0b25Tb3VuZCAsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwge1wicGhvbmVcIjogXCJjbG9zZWRcIn0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlUGhvbmVCdXR0b246IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSBuZXcgUGhhc2VyLkJ1dHRvbih0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5waG9uZS5pY29uc1trZXldWzFdLCB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMV0sIHRoaXMudGhlbWUucGhvbmUuaWNvbnNba2V5XVswXSk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3dpbmcgdGhlIHBob25lIGlzIGEgYml0IGNvbXBsaWNhdGVkLiBFdmVyeXRoaW5nIGhhcyB0byBiZSBicm91Z2h0IHRvIHRoZSB0b3AgaW5cclxuICAgICAgICAgKiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dQaG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEhvbWVTY3JlZW5Hcm91cCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0SGVscFdpbmRvd0dyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPYmplY3RpdmVzV2luZG93R3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZGVtb01vZGUgPT09IHRydWUgfHwgdGhpcy5kYXRhLmRlbW9Nb2RlID09PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdERlbW9WaWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEJsb2NraW5nR3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmJsb2NraW5nU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMucGhvbmVHcm91cCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMuaGVscEdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLndvcmxkLmJyaW5nVG9Ub3AodGhpcy5vYmplY3RpdmVzR3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lXCI6IFwib3BlblwifSk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzTXV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmFuaW1hdGlvbnMucGxheSgndmlicmF0ZScsIDI0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUljb24uYW5pbWF0aW9ucy5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9mZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuZGF0YS5vYmplY3RpdmVzLCBmdW5jdGlvbiggb2JqZWN0aXZlLCBvYmplY3RpdmVLZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJFwiICsgb2JqZWN0aXZlS2V5KTtcclxuICAgICAgICAgICAgICAgIGlmKCBjb21wbGV0ZWQgPT09IHRydWUgfHwgY29tcGxldGVkID09PSBcInRydWVcIiB8fCBjb21wbGV0ZWQgPT09IFwiY29tcGxldGVcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdGl2ZU1hcmtlcnNbb2JqZWN0aXZlS2V5XS5mcmFtZU5hbWUgPSB0aGlzLnRoZW1lLnBob25lLmNoZWNrQm94ZXNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy5kYXRhLm9iamVjdGl2ZUF1ZGlvIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXREZW1vVmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5zY2FsZS5zZXQoIDAuNSwgMC41KTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLnggPSAyOTU7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC55ID0gMTUwO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBHcm91cC55ICs9IDE0NTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAueCAtPSAzNTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAueSArPSAxNDU7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnggLT0gMzU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnNjYWxlLnNldCgwLjUsIDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnNjYWxlLnNldCgwLjUsIDAuNSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIG1haW4gc2NyZWVuLCBpbmNsdWRpbmcgYWxsIG9mIHRoZSBidXR0b25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXRIb21lU2NyZWVuR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC54ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclg7XHJcbiAgICAgICAgICAgIHZhciBidXR0b25ZID0gMzY1O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5waG9uZUJnID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUucGhvbmUuYmFja2dyb3VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVCZy5hbmNob3Iuc2V0VG8oMC41LCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMucGhvbmVCZyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ211dGVPbicsIHRoaXMub25DbGlja011dGUsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMubXV0ZU9uQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24ueCA9IC0xMDA7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbi5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbignbXV0ZU9mZicsIHRoaXMub25DbGlja011dGUsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMubXV0ZU9mZkJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi54ID0gLTEwMDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm11dGVJY29uID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCBTQ1JFRU5fWSArIDIsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5waG9uZS5yaW5nTW9kZS5tdXRlT2ZmKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLm11dGVJY29uKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlSWNvbi5hbmltYXRpb25zLmFkZCgndmlicmF0ZScsIHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9uICk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZUljb24ueCA9IDIyMDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlSWNvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdoZWxwJywgdGhpcy5vbkNsaWNrSGVscCwgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5oZWxwQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnggPSAxMDtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdvYmplY3RpdmVzJywgdGhpcy5vbkNsaWNrT2JqZWN0aXZlcywgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5vYmplY3RpdmVzQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzQnV0dG9uLnggPSAxNTA7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0J1dHRvbi55ID0gYnV0dG9uWTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ3Bvd2VyJywgdGhpcy5vbkNsaWNrQ2xvc2UsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMuY2xvc2VCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLnggPSAyODA7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24ueSA9IGJ1dHRvblk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdEJsb2NraW5nR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tpbmdTcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRIZWxwV2luZG93R3JvdXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gU0NSRUVOX0VORF9YIC0gU0NSRUVOX1g7XHJcbiAgICAgICAgICAgIHZhciBtYXJnaW5YID0gNTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBHcm91cC54ID0gU0NSRUVOX1g7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnkgPSBTQ1JFRU5fWTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoZWFkaW5nVGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblgsIDEwLCBcIkhlbHBcIiwgdGhpcy5mb250SGVhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHkud29yZFdyYXBXaWR0aCA9IHdpZHRoICogMC45NTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwVGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblgsIGhlYWRpbmdUZXh0LmhlaWdodCArIDE1LCBcIkJPRFkgVEVTVFwiLCB0aGlzLmZvbnRCb2R5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLmFkZChoZWFkaW5nVGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLmFkZCh0aGlzLmhlbHBUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUhlbHAoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3dIZWxwOiBmdW5jdGlvbiAoIGJvZHkpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscFRleHQuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscFRleHQuc2V0VGV4dCggYm9keSApO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLmRhdGEuaGVscEF1ZGlvIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZUhlbHA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdE9iamVjdGl2ZXNXaW5kb3dHcm91cDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBTQ1JFRU5fRU5EX1ggLSBTQ1JFRU5fWDtcclxuICAgICAgICAgICAgdmFyIG1hcmdpblggPSA1LCBtYXJnaW5ZID0gMTA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAueCA9IFNDUkVFTl9YO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cC55ID0gU0NSRUVOX1k7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGVhZGluZ1RleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW5YLCBtYXJnaW5ZLCBcIk9iamVjdGl2ZXNcIiwgdGhpcy5mb250SGVhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAuYWRkKGhlYWRpbmdUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxpc3Qgb3V0IHRoZSBvYmplY3RpdmVzLCB3aXRoIGljb25zLlxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGljb25zIHdoZW4gdGhlIHBob25lIGlzIHNob3duXHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBvbkdhbWVDaG9pY2UsIHdhdGNoIGZvciBvYmplY3RpdmVzLlxyXG4gICAgICAgICAgICB2YXIgZWFjaFRleHRJdGVtO1xyXG4gICAgICAgICAgICB2YXIgZWFjaENoZWNrQm94O1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFkgPSBoZWFkaW5nVGV4dC55ICsgaGVhZGluZ1RleHQuaGVpZ2h0ICsgbWFyZ2luWTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5kYXRhLm9iamVjdGl2ZXMsIGZ1bmN0aW9uKCBvYmplY3RpdmUsIG9iamVjdGl2ZUtleSkge1xyXG4gICAgICAgICAgICAgICAgZWFjaENoZWNrQm94ID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCBjdXJyZW50WSAtIDIsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5waG9uZS5jaGVja0JveGVzWzBdKTtcclxuICAgICAgICAgICAgICAgIGVhY2hUZXh0SXRlbSA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIGVhY2hDaGVja0JveC53aWR0aCArIG1hcmdpblgsIGN1cnJlbnRZLCB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKG9iamVjdGl2ZSksIHRoaXMuZm9udEJvZHkpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFkgKz0gZWFjaFRleHRJdGVtLmhlaWdodCArIG1hcmdpblk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cC5hZGQoZWFjaENoZWNrQm94KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLmFkZChlYWNoVGV4dEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVNYXJrZXJzW29iamVjdGl2ZUtleV0gPSBlYWNoQ2hlY2tCb3g7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd09iamVjdGl2ZXM6IGZ1bmN0aW9uICggb2JqZWN0aXZlcyApIHtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMuZGF0YS5vYmplY3RpdmVBdWRpbyB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhpZGVPYmplY3RpdmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250SGVhZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5waG9uZUdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaGVscEdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2JqZWN0aXZlc0dyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYmxvY2tpbmdTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSXRzVXJDaG9pY2VQaG9uZTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIElVQyBwb3B1cCBhY3Rvci4gUG9wcyB1cCBhbiBhbGVydCwgdGhhdCBkb2VzIG5vdCBibG9jayB0aGUgc2NyZWVuLiBBbGVydCBjYW4gYmUgY2xvc2VkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHBob25lIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9wdXAxMVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWNwb3B1cFwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS4qXHJcbiAqICAgICBcImhlYWRpbmdcIjogXCJUaGlzIGFyZWEgaXMgY2xvc2VkLlwiLFxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiV2UncmUgYnVzeSBib29raW5nIHNvbWVvbmUuIENvbWUgYmFjayBhbm90aGVyIGRheS5cIixcclxuICogICAgIFwiYmFja2dyb3VuZFwiOiBcIm15aW1hZ2VcIixcclxuICogICAgIFwidmFyaWFibGVcIjogXCJ4XCJcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciB3aW5YID0gMjAwLCB3aW5ZID0gMjUwO1xyXG4gICAgdmFyIGNsb3NlWCA9IDU1MCwgY2xvc2VZID0gMzAwO1xyXG5cclxuICAgIHZhciBJdHNVckNob2ljZVBvcHVwQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImhlYWRpbmdcIiwgXCJ0ZXh0XCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3B1cEdyb3VwLnggPSB3aW5YO1xyXG4gICAgICAgICAgICB0aGlzLnBvcHVwR3JvdXAueSA9IHdpblk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmdGcmFtZSA9IHRoaXMudGhlbWUucG9wdXAuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICkge1xyXG4gICAgICAgICAgICAgICAgYmdGcmFtZSA9IHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmJhY2tncm91bmQsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCBiZ0ZyYW1lICk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5iZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCAwLCA5ICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUucG9wdXAuY2xvc2VCdXR0b25bMF0sIHRoaXMudGhlbWUucG9wdXAuY2xvc2VCdXR0b25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBvcHVwLmNsb3NlQnV0dG9uWzJdLCB0aGlzLnRoZW1lLnBvcHVwLmNsb3NlQnV0dG9uWzNdICk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5idXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi54ID0gdGhpcy5iZy53aWR0aCAtIHRoaXMuYnV0dG9uLndpZHRoIC0gODtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgaGVhZGluZ1N0eWxlID0gdGhpcy5nZXRGb250KCBcInBvcHVwSGVhZGluZ1wiKTtcclxuICAgICAgICAgICAgdmFyIGJvZHlTdHlsZSA9IHRoaXMuZ2V0Rm9udCggXCJwb3B1cEJvZHlcIik7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmZvbnRCb2R5ICkge1xyXG4gICAgICAgICAgICAgICAgYm9keVN0eWxlID0gdGhpcy5nZXRGb250KHRoaXMuZGF0YS5mb250Qm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZm9udEhlYWRpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nU3R5bGUgPSB0aGlzLmdldEZvbnQodGhpcy5kYXRhLmZvbnRIZWFkaW5nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRCb2R5WSA9IDUwO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhlYWRpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLmdhbWUuYWRkLnRleHQoMTAsIDEyLCB0aGlzLmRhdGEuaGVhZGluZywgaGVhZGluZ1N0eWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5oZWFkaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRCb2R5WSA9IDY1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2FtZS5hZGQudGV4dCggMTUsIGNvbnRlbnRCb2R5WSwgdGhpcy5kYXRhLnRleHQsIGJvZHlTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5ib2R5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnkgZ2FtZSBjaG9pY2UgZHVyaW5nIGFuIGFsZXJ0IHdpbGwgY2F1c2UgdGhlIHBob25lIHRvICd2aWJyYXRlJyBvbiBzY3JlZW4uXHJcbiAgICAgICAgICogQHBhcmFtIGNob2ljZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHsgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEl0c1VyQ2hvaWNlUG9wdXBBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIElVQyBwb3B1cCBhY3Rvci4gUG9wcyB1cCBhbiBhbGVydCwgdGhhdCBkb2VzIG5vdCBibG9jayB0aGUgc2NyZWVuLiBBbGVydCBjYW4gYmUgY2xvc2VkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHBob25lIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwid2luZG93MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWN3aW5kb3dcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuKlxyXG4gKiAgICAgXCJoZWFkaW5nXCI6IFwiRGF5IDMgQ29tcGxldGVcIixcclxuICogICAgIFwiYXVkaW9cIjogXCJhdWRpb2tleVwiLCAvLyBQbGF5IHdoZW4gd2luZG93IGlzIGluaXRpYWxsIG9wZW5lZCwgb3IgbWF4aW1pbWl6ZWQgZnJvbSBtaW4uXHJcbiAqICAgICBcInRleHRcIjogXCJXZSdyZSBidXN5IGJvb2tpbmcgc29tZW9uZS4gQ29tZSBiYWNrIGFub3RoZXIgZGF5LlwiLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInhcIixcclxuICogICAgIFwic2hvd0Nsb3NlXCI6IGZhbHNlfHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBNQVhJTUlaRSA9IFwiTUFYXCI7XHJcbiAgICB2YXIgTUlOSU1JWkUgPSBcIk1JTlwiO1xyXG4gICAgdmFyIENMT1NFID0gXCJDTE9TRVwiO1xyXG5cclxuICAgIHZhciBJdHNVckNob2ljZVdpbmRvd0FjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJoZWFkaW5nXCIsIFwidGV4dFwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnkgPSAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwKTtcclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuYWRkQ2hpbGQoZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoIDB4RUZFRkVGLCAwLjc1ICk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KCAwLCAwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5ibG9ja2VyU3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBiZ0ZyYW1lID0gdGhpcy50aGVtZS53aW5kb3cuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICkge1xyXG4gICAgICAgICAgICAgICAgYmdGcmFtZSA9IHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmJhY2tncm91bmQsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCBiZ0ZyYW1lICk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuYWRkKHRoaXMuYmcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb2dvID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIHRoaXMuZ2FtZS53b3JsZC53aWR0aCAtIDI1LCB0aGlzLmdhbWUud29ybGQuaGVpZ2h0IC0gMjUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUud2luZG93LmxvZ28gKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dvLmFuY2hvci5zZXRUbyggMS4wLCAxLjApO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmFkZCh0aGlzLmxvZ28pO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbkJ1dHRvblkgPSAyMDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zaG93Q2xvc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24odGhpcy5nYW1lLndvcmxkLndpZHRoIC0gMjUsIDIwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlQnV0dG9uLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93LmNsb3NlQnV0dG9uWzBdLCB0aGlzLnRoZW1lLndpbmRvdy5jbG9zZUJ1dHRvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5jbG9zZUJ1dHRvblsyXSwgdGhpcy50aGVtZS53aW5kb3cuY2xvc2VCdXR0b25bM10pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5jbG9zZUJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLmFuY2hvci5zZXRUbyggMS4wLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG1pbkJ1dHRvblkgKz0gdGhpcy5jbG9zZUJ1dHRvbi55ICsgdGhpcy5jbG9zZUJ1dHRvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemVCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5nYW1lLndvcmxkLndpZHRoIC0gMjUsXHJcbiAgICAgICAgICAgICAgICBtaW5CdXR0b25ZLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWluaW1pemVCdXR0b24sIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5taW5pbWl6ZUJ1dHRvblswXSwgdGhpcy50aGVtZS53aW5kb3cubWluaW1pemVCdXR0b25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5taW5pbWl6ZUJ1dHRvblsyXSwgdGhpcy50aGVtZS53aW5kb3cubWluaW1pemVCdXR0b25bM10gKTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5taW5pbWl6ZUJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemVCdXR0b24uYW5jaG9yLnNldFRvKCAxLjAsIDApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmdhbWUud29ybGQud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMub25NYXhpbWl6ZUJ1dHRvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93Lm1heGltaXplQnV0dG9uWzBdLCB0aGlzLnRoZW1lLndpbmRvdy5tYXhpbWl6ZUJ1dHRvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93Lm1heGltaXplQnV0dG9uWzJdLCB0aGlzLnRoZW1lLndpbmRvdy5tYXhpbWl6ZUJ1dHRvblszXSApO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmFkZCh0aGlzLm1heGltaXplQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi5hbmNob3Iuc2V0VG8oIDEuMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4aW1pemVCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGhlYWRpbmdTdHlsZSA9IHRoaXMuZ2V0Rm9udCggXCJ3aW5kb3dIZWFkaW5nXCIpO1xyXG4gICAgICAgICAgICB2YXIgYm9keVN0eWxlID0gdGhpcy5nZXRGb250KCBcIndpbmRvd0JvZHlcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLmdhbWUuYWRkLnRleHQoIHRoaXMuZ2FtZS53b3JsZC53aWR0aCAvIDIsIDEyMCwgdGhpcy5kYXRhLmhlYWRpbmcsIGhlYWRpbmdTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZy5hbmNob3Iuc2V0VG8oIDAuNSwgMC41KTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5oZWFkaW5nKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2FtZS5hZGQudGV4dCggdGhpcy5nYW1lLndvcmxkLndpZHRoIC8gMiwgMTYwLCB0aGlzLmRhdGEudGV4dCwgYm9keVN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmFuY2hvci5zZXRUbyggMC41LCAwICk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuYWRkKHRoaXMuYm9keSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1pbmltaXplQnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggY2hvaWNlICkgeyB9LFxyXG4gICAgICAgIG9uQ2xvc2VCdXR0b246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChDTE9TRSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1pbmltaXplQnV0dG9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goTUlOSU1JWkUpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltaXplKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1heGltaXplQnV0dG9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goTUFYSU1JWkUpO1xyXG4gICAgICAgICAgICB0aGlzLm1heGltaXplKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaW5pbWl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ29udGVudChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMub25NaW5Ud2VlbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1pblR3ZWVuQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKHsgYXVkaW86IHRoaXMuZGF0YS5hdWRpbywga2V5OiBudWxsLCBcInByaW9yaXR5XCI6IFwic3RvcFwifSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1heGltaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMud2luZG93R3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmJnLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWF4VHdlZW5Db21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25NYXhUd2VlbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVDb250ZW50KHRydWUpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICB7IGF1ZGlvOiB0aGlzLmRhdGEuYXVkaW8sIGtleTogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGVDb250ZW50OiBmdW5jdGlvbiggdmlzaWJsZSApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkaW5nLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMubG9nby52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5jbG9zZUJ1dHRvbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24udmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5taW5pbWl6ZUJ1dHRvbi52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJdHNVckNob2ljZVdpbmRvd0FjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgTGFyZ2VCaXJkID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCB0aGVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMb2MgPSBbIC0xNTAsIDEwMF07XHJcbiAgICAgICAgICAgIHRoaXMuZW5kTG9jID0gWyA4NTAsIDIzNV07XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLm1hcEluZm8ubGFyZ2VCaXJkRnJhbWVzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2ZseScsIHRoaXMudGhlbWUubWFwSW5mby5sYXJnZUJpcmRGcmFtZXMgKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUuc2V0VG8oMC4zLDAuMyk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZSkudG8oIHsgeDogdGhpcy5lbmRMb2NbMF0gfSwgNDAwMCwgJ0xpbmVhcicsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3ByaXRlKS50byggeyB5OiB0aGlzLmVuZExvY1sxXSB9LCAzNTAwLCBQaGFzZXIuRWFzaW5nLkN1YmljLkluLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIHBsYXlBdWRpbzogbmV3IFBoYXNlci5TaWduYWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGxheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzUGxheWluZyApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBjcm93U291bmQgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDEsIDEwMCk7XHJcbiAgICAgICAgICAgIHZhciB3aGljaFNvdW5kID0gJ2Nyb3cnO1xyXG4gICAgICAgICAgICBpZiggY3Jvd1NvdW5kID4gMzAgKSB7XHJcbiAgICAgICAgICAgICAgICB3aGljaFNvdW5kICs9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMSwgMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcGF0Y2goXCJMYXJnZUJpcmRcIiwge3RleHQ6XCJcIiwgYXVkaW86IHdoaWNoU291bmQsIGtleTogbnVsbCwgcHJpb3JpdHk6ICdsb3cnfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuc3RhcnRMb2NbMF07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25zLnBsYXkoJ2ZseScsIDE0LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjEuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5wbGF5QXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExhcmdlQmlyZDtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFNtYWxsQmlyZCA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGFydExvYyA9IFsgODA1LCAyNV07XHJcbiAgICAgICAgICAgIHRoaXMuZW5kTG9jID0gWyAtMTAwLCA3NV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLm1hcEluZm8uc21hbGxCaXJkRnJhbWVzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2ZseScsIHRoaXMudGhlbWUubWFwSW5mby5zbWFsbEJpcmRGcmFtZXMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZSkudG8oIHsgeDogdGhpcy5lbmRMb2NbMF0gfSwgMzAwMCwgJ0xpbmVhcicsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3ByaXRlKS50byggeyB5OiB0aGlzLmVuZExvY1sxXSB9LCAzMDAwLCBQaGFzZXIuRWFzaW5nLkN1YmljLkluT3V0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25zLnBsYXkoJ2ZseScsIDE0LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5QXVkaW86IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc1BsYXlpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYmlyZFNvdW5kID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgxLCAxMDApO1xyXG4gICAgICAgICAgICB2YXIgd2hpY2hTb3VuZCA9ICdiaXJkQ2hpcnAnO1xyXG4gICAgICAgICAgICBpZiggYmlyZFNvdW5kID4gMzAgKSB7XHJcbiAgICAgICAgICAgICAgICB3aGljaFNvdW5kICs9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMSwgNCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcGF0Y2goXCJzbWFsbEJpcmRcIiwge3RleHQ6XCJcIiwgYXVkaW86IHdoaWNoU291bmQsIGtleTogbnVsbCwgcHJpb3JpdHk6ICdsb3cnfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuc3RhcnRMb2NbMF07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuMS5zdGFydCgpO1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuMi5zdGFydCgpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5wbGF5QXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNtYWxsQmlyZDtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFJBTkRPTV9DQVJfWSA9IFsgMjM5LCAyMzYsIDIyMSwgMjEwIF07XHJcbiAgICB2YXIgUkFORE9NX0NBUl9YID0gWyA4MDEsIDY2MCwgMjc3LCAtNTAgXTtcclxuXHJcbiAgICB2YXIgTGFyZ2VCaXJkID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCB0aGVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhciA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCA4MDEsIDcwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUubWFwSW5mby52ZWhpY2xlc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyLnNjYWxlLnNldFRvKDAuOCwgMC44KTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuYW5jaG9yLnNldFRvKCAwLCAxLjApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMSAgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMucmFuZG9tQ2FyKS50byggeyB5OiBSQU5ET01fQ0FSX1lbMV0sIHg6IFJBTkRPTV9DQVJfWFsxXSB9LCA1NTAwLCAgUGhhc2VyLkVhc2luZy5RdWludGljLk91dCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjIgID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnJhbmRvbUNhcikudG8oIHsgeTogUkFORE9NX0NBUl9ZWzJdLCB4OiBSQU5ET01fQ0FSX1hbMl0gfSwgNzAwMCwgIFBoYXNlci5FYXNpbmcuUXVpbnRpYy5Jbk91dCwgZmFsc2UsIDIwMDApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMS5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMyAgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMucmFuZG9tQ2FyKS50byggeyB5OiBSQU5ET01fQ0FSX1lbM10sIHg6IFJBTkRPTV9DQVJfWFszXSB9LCA0MDAwLCAgXCJMaW5lYXJcIiwgZmFsc2UsIDIwMDApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMi5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMyk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyVHdlZW4zLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMWIgID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnJhbmRvbUNhcikudG8oIHsgeTogUkFORE9NX0NBUl9ZWzFdLCB4OiBSQU5ET01fQ0FSX1hbMV0gfSwgNjAwMCwgIFBoYXNlci5FYXNpbmcuUXVpbnRpYy5PdXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjJiICA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5yYW5kb21DYXIpLnRvKCB7IHk6IFJBTkRPTV9DQVJfWVszXSwgeDogUkFORE9NX0NBUl9YWzNdIH0sIDkwMDAsICBcIkxpbmVhclwiLCBmYWxzZSwgMjAwMCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyVHdlZW4xYi5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMmIpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMmIub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgcGxheUF1ZGlvOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNQbGF5aW5nICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIueSA9IFJBTkRPTV9DQVJfWVswXTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIueCA9IFJBTkRPTV9DQVJfWFswXTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnZlaGljbGVzW3RoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMCwgNyldO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDEsIDMpID09PSAyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjFiLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMS5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMucGxheUF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8ucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMYXJnZUJpcmQ7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIC8vIFRoaXMgZGVmaW5lcyB0aGUgc3RhcnRpbmcgcG9pbnQgYW5kIHRoZW4gNCBzdG9wcGluZyBwb2ludHMgZm9yIHRoZSB5ZWxsb3cgY2FyLlxyXG4gICAgdmFyIFlFTExPV19DQVJfWSA9IFsgNjUwLCAyNjQsIDI0NSwgMjM3LCAyNTUgXTtcclxuICAgIHZhciBZRUxMT1dfQ0FSX1ggPSBbIDUsIDU2OSwgNTkyLCA2MDcsIDg1MCBdO1xyXG5cclxuICAgIHZhciBZZWxsb3dDYXIgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGdhbWUsIHRoZW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIDE4MCwgNzAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHdlZW5TY2FsZSA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIuc2NhbGUpLnRvKCB7eDogMC43NDYsIHk6IDAuNzN9ICwgOTAwMCwgUGhhc2VyLkVhc2luZy5RdWludGljLk91dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMSA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVsxXSwgeDogWUVMTE9XX0NBUl9YWzFdIH0sIDkwMDAsICBQaGFzZXIuRWFzaW5nLlF1aW50aWMuT3V0LCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVsyXSwgeDogWUVMTE9XX0NBUl9YWzJdIH0sIDc1MCwgIFwiTGluZWFyXCIsIGZhbHNlLCAxMDAwKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjIub25Db21wbGV0ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllbGxvd0Nhci5zY2FsZS5zZXRUbyggMS4wLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUubWFwSW5mby55ZWxsb3dDYXJGcmFtZXNbMV07XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjEuY2hhaW4odGhpcy55ZWxsb3dDYXJUd2VlbjIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjMgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMueWVsbG93Q2FyKS50byggeyB5OiBZRUxMT1dfQ0FSX1lbM10sIHg6IFlFTExPV19DQVJfWFszXSB9LCA1MDAsICBcIkxpbmVhclwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4zLm9uQ29tcGxldGUuYWRkKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1syXTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMi5jaGFpbih0aGlzLnllbGxvd0NhclR3ZWVuMyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuNCA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVs0XSwgeDogWUVMTE9XX0NBUl9YWzRdIH0sIDMwMDAsICBcIkxpbmVhclwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4zLmNoYWluKHRoaXMueWVsbG93Q2FyVHdlZW40KTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjQub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgcGxheUF1ZGlvOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNQbGF5aW5nICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1swXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIueSA9IFlFTExPV19DQVJfWVswXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIueCA9IFlFTExPV19DQVJfWFswXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4xLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW5TY2FsZS5zdGFydCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLnBsYXlBdWRpbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucGxheUF1ZGlvLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucGxheUF1ZGlvLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gWWVsbG93Q2FyO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzIxLzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIHdpbGwgY3JlYXRlIGEgdGV4dCBidWJibGUgd2l0aCBhIGdyYWRpZW50IGJhY2sgZmlsbC4gSXQgcmVwcm9kdWNlcyBhIHNlcmllcyBvZiB0ZXh0IGJ1YmJsZSBpbWFnZXNcclxuICogZnJvbSBGbGFzaCB0aGF0IHdlcmUgbmluZS1zbGljZWQuIEluIHRoaXMgY2FzZSwgdGhlIG5pbmUtc2xpY2UgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmQgd2UganVzdCByZW5kZXIgYVxyXG4gKiByb3VuZGVkIHJlY3RhbmdsZSBhcyBhIG1hc2suXHJcbiAqXHJcbiAqIFRoZSByZWN0YW5nbGUgd2lsbCBiZSBwYWRkZWQgYXJvdW5kIHRoZSBmb250LlxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZShcImJhc2Vqc1wiKTtcclxuXHJcbiAgICB2YXIgUm91bmRlZENoYXRSZWN0ID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZ2FtZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJvdW5kbmVzcyA9IDI4O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSA0NDAsIGhlaWdodCA9IDIwMDtcclxuICAgICAgICAgICAgdmFyIHggPSAxNSwgeSA9IDEwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1ggPSA2MCwgcGFkZGluZ1kgPSAyMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBidWJibGVHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5idWJibGUgPSBidWJibGVHcm91cDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dCwgd2hpY2ggaXMgd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlIGZvbnQuXHJcbiAgICAgICAgICAgIHZhciBmb250SGVhZGluZyA9IF8uY2xvbmVEZWVwKHRoaXMudGhlbWUuZm9udHMuY2hhdFRleHQpO1xyXG4gICAgICAgICAgICBmb250SGVhZGluZy53b3JkV3JhcFdpZHRoID0gNDYwO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlVGV4dCA9IGdhbWUuYWRkLnRleHQoKHdpZHRoLzIpICsgcGFkZGluZ1ggLCB5ICsgcGFkZGluZ1kgLCBcIk5vIHRleHQgeWV0LlwiLCBmb250SGVhZGluZyApO1xyXG4gICAgICAgICAgICBidWJibGVUZXh0LmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVRleHQgPSBidWJibGVUZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVRleHQubGluZVNwYWNpbmcgPSAtNDtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudHMgPSBbJyNmZmZmZmYnLCAnI2ZmZmZmZiddO1xyXG5cclxuICAgICAgICAgICAgLy8gdmFyIGJ1YmJsZUJvcmRlclRoaW4gPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKDAsIDApO1xyXG4gICAgICAgICAgICAvLyBidWJibGVCb3JkZXJUaGluLmxpbmVTdHlsZSgyLCAweDAwMDAwMCwgMSk7XHJcbiAgICAgICAgICAgIC8vIGJ1YmJsZUJvcmRlclRoaW4uZHJhd1JvdW5kZWRSZWN0KHgrMSwgeSsxLCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpO1xyXG4gICAgICAgICAgICAvLyBidWJibGVCb3JkZXJUaGluLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGJ1YmJsZUJvcmRlclRoaW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyB0aGUgc2hhcGUgdGhhdCBjb250YWlucyB0aGUgZ3JhZGllbnRcclxuICAgICAgICAgICAgLy8gdmFyIGdyYWRpZW50Qm1wID0gdGhpcy5nYW1lLmFkZC5iaXRtYXBEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB2YXIgZ3JhZGllbnRGaWxsID0gZ3JhZGllbnRCbXAuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XHJcbiAgICAgICAgICAgIC8vIGdyYWRpZW50RmlsbC5hZGRDb2xvclN0b3AoMCwgdGhpcy5ncmFkaWVudHNbMF0pO1xyXG4gICAgICAgICAgICAvLyBncmFkaWVudEZpbGwuYWRkQ29sb3JTdG9wKDEsIHRoaXMuZ3JhZGllbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRCbXAuY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudEZpbGw7XHJcbiAgICAgICAgICAgIC8vIGdyYWRpZW50Qm1wLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIHZhciBncmFkaWVudFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHgsIHksIGdyYWRpZW50Qm1wKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGdyYWRpZW50U3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHZhciBncmFkaWVudE1hc2sgPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKDAsIDApO1xyXG4gICAgICAgICAgICAvLyBncmFkaWVudE1hc2suYmVnaW5GaWxsKDB4MDAwMDAwKTtcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRNYXNrLmRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpOyAvLyBkcmF3IGEgcm91bmRlZCByZWN0IG1hc2tcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRNYXNrLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGdyYWRpZW50TWFzayk7XHJcblxyXG4gICAgICAgICAgICAvLyBncmFkaWVudFNwcml0ZS5tYXNrID0gZ3JhZGllbnRNYXNrOyAvLyBhcHBseSB0aGUgbWFza1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNhcnJvdCA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCA0NTQsIDE1MCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFwic3BlZWNoX2Fycm93LnBuZ1wiKTtcclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUdyb3VwLmFkZChidWJibGVUZXh0KTtcclxuICAgICAgICAgICAgYnViYmxlR3JvdXAuYnJpbmdUb1RvcChidWJibGVUZXh0KTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKHRoaXMuY2Fycm90KTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93UmVzcG9uc2U6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcclxuICAgICAgICAgICAgdGhpcy5idWJibGVUZXh0LnNldFRleHQoIHJlc3BvbnNlLnRleHQudGV4dCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idWJibGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUm91bmRlZENoYXRSZWN0O1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIFBhdWwgS25lbGxcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEwLzIzLzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IHN1cHBvcnRzIHNldHRpbmcgdXAgVHdlZW4uICBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IEFjdG9ycy5cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBUd2VlbkhlbHBlciA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYoICFnYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUd2VlbkhlbHBlciByZXF1aXJlcyBnYW1lIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCAhYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlR3ZWVuSGVscGVyIHJlcXVpcmVzIGFjdG9yIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFR3ZWVuczogZnVuY3Rpb24odHdlZW5EYXRhQXJyYXksIHNwcml0ZSkge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHR3ZWVuRGF0YUFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVuRGF0YUFycmF5LCBmdW5jdGlvbih0d2VlbkRhdGEpIHsgdGhpcy5hZGRUd2Vlbih0d2VlbkRhdGEsIHNwcml0ZSk7IH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUd2Vlbih0d2VlbkRhdGFBcnJheSwgc3ByaXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVHdlZW46IGZ1bmN0aW9uKHR3ZWVuRGF0YSwgc3ByaXRlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHdlZW5zID0ge307XHJcblxyXG4gICAgICAgICAgICB2YXIgY29uZmlndXJlVHdlZW5zID0gZnVuY3Rpb24odHdlZW5EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSB0d2VlbkRhdGEuZGVsYXkgPyB0d2VlbkRhdGEuZGVsYXkgOiAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9IHR3ZWVuRGF0YS5lYXNpbmcgfHwgXCJMaW5lYXJcIjtcclxuICAgICAgICAgICAgICAgIGlmICh0d2VlbnMuc3ByaXRlVHdlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR3ZWVuRGF0YS5sb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueCA9IHR3ZWVuRGF0YS5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLnkgPSB0d2VlbkRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIHR3ZWVuRGF0YS5sb2NhdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgdHdlZW5EYXRhLnggYW5kIHR3ZWVuRGF0YS55IGhhcyBiZWVuIGFkZGVkIHNvIHRoYXQgZWFjaCBkaW1lbnNpb24gY2FuIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXBlbmRlbnRseSBcInR3ZWVuZWRcIiBpZiBkZXNpcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0d2VlbkRhdGEueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueCA9IHR3ZWVuRGF0YS54O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW5EYXRhLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLnkgPSB0d2VlbkRhdGEueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS5hbHBoYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLmFscGhhID0gdHdlZW5EYXRhLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLmFuZ2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuYW5nbGUgPSB0d2VlbkRhdGEuYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEucm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5yb3RhdGlvbiA9IHR3ZWVuRGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5zLnNwcml0ZVR3ZWVuLnRvKG5ld1ZhbHVlcywgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgZmFsc2UsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0d2VlbnMuc2NhbGVUd2Vlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW5EYXRhLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy54ID0gdHdlZW5EYXRhLnNjYWxlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueSA9IHR3ZWVuRGF0YS5zY2FsZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5zLnNjYWxlVHdlZW4udG8oIG5ld1ZhbHVlcywgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgZmFsc2UsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEubG9jYXRpb24gfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLmFscGhhKVxyXG4gICAgICAgICAgICAgICAgfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLnJvdGF0aW9uKSB8fCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEuYW5nbGUpXHJcbiAgICAgICAgICAgICAgICB8fCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEueCkgfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLnkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdHdlZW5zLnNwcml0ZVR3ZWVuID0gdGhpcy5nYW1lLmFkZC50d2VlbihzcHJpdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuc2NhbGUgJiYgc3ByaXRlLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0d2VlbnMuc2NhbGVUd2VlbiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4oc3ByaXRlLnNjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlndXJlVHdlZW5zKHR3ZWVuRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHdlZW5EYXRhLmNoYWluZWRUd2VlbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodHdlZW5EYXRhLmNoYWluZWRUd2VlbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVuRGF0YS5jaGFpbmVkVHdlZW5zLCBjb25maWd1cmVUd2VlbnMsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZVR3ZWVucyh0d2VlbkRhdGEuY2hhaW5lZFR3ZWVucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEubG9vcCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVucywgZnVuY3Rpb24odHdlZW4pIHsgdHdlZW4ubG9vcCgpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS55b3lvKSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVucywgZnVuY3Rpb24odHdlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gTnVtYmVyKHR3ZWVuRGF0YS55b3lvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1pbGxpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ueW95byh0cnVlLCBtaWxsaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5EYXRhLnlveW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ueW95byh0cnVlLCAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS52YXJpYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IHR3ZWVucy5zcHJpdGVUd2VlbiB8fCB0d2VlbnMuc2NhbGVUd2VlbjtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXJTZXRbdHdlZW5EYXRhLnZhcmlhYmxlXSA9ICdjb21wbGV0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfLmVhY2godHdlZW5zLCBmdW5jdGlvbih0d2VlbikgeyB0d2Vlbi5zdGFydCgpOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZVR3ZWVuczogZnVuY3Rpb24oc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS50d2VlbnMucmVtb3ZlRnJvbShzcHJpdGUpO1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3ByaXRlLnNjYWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnR3ZWVucy5yZW1vdmVGcm9tKHNwcml0ZS5zY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFR3ZWVuSGVscGVyO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBGb3Igbm93LCBqdXN0IHNlcnZlIGFzIGEgcmVnaXN0cnkgZm9yIGFjdGlvbnNcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIENob2ljZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9nYW1lLWNob2ljZScpLFxyXG4gICAgICAgIFJlbW92ZUFjdG9yQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL3JlbW92ZS1hY3RvcicpLFxyXG4gICAgICAgIEFkZEFjdG9yQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL2FkZC1hY3RvcicpLFxyXG4gICAgICAgIENoZWNrT3V0Y29tZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9jaGVjay1vdXRjb21lcycpLFxyXG4gICAgICAgIENoYW5nZU9iamVjdGl2ZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9jaGFuZ2Utb2JqZWN0aXZlJyksXHJcbiAgICAgICAgTWFya0NvbXBsZXRlQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL21hcmstY29tcGxldGUnKSxcclxuICAgICAgICBWYXJpYWJsZUluY3JlbWVudEFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy92YXJpYWJsZS1pbmNyZW1lbnQnKSxcclxuICAgICAgICBNaFNjZW5lQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL21oL21oLWNoYW5nZS1zY2VuZScpLFxyXG4gICAgICAgIFNjZW5lQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL2NoYW5nZS1zY2VuZScpO1xyXG5cclxuICAgIHZhciBQbGF5QWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJBY3Rpb246IGZ1bmN0aW9uKCB0eXBlLCBhY3Rpb24gKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1t0eXBlXSA9IGFjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEFjdGlvbjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIGlmKCAhZGF0YSB8fCAhZGF0YS50eXBlIHx8ICF0aGlzLmFjdGlvbnNbZGF0YS50eXBlXSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IHJldHJpZXZlIGFuIGFjdGlvbiB3aXRob3V0IGFuIGFjdGlvbiB0eXBlLiB7IHR5cGU6ICcuLicsIGFyZ3M6IFsuLi5dfSBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2xhenogPSB0aGlzLmFjdGlvbnNbZGF0YS50eXBlXTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjbGF6eiggZGF0YS5hcmdzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIEFjdGlvbkZhY3RvcnkgPSBuZXcgUGxheUFjdGlvbigpO1xyXG4gICAgQWN0aW9uRmFjdG9yeS5yZWdpc3RlckFjdGlvbihcImFkZC1hY3RvclwiLCBBZGRBY3RvckFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwiY2hlY2stb3V0Y29tZXNcIiwgQ2hlY2tPdXRjb21lQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJjaG9pY2VcIiwgQ2hvaWNlQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJtYXJrLWNvbXBsZXRlXCIsIE1hcmtDb21wbGV0ZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwib2JqZWN0aXZlXCIsIENoYW5nZU9iamVjdGl2ZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwicmVtb3ZlLWFjdG9yXCIsIFJlbW92ZUFjdG9yQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJzY2VuZVwiLCBTY2VuZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwidmFyaWFibGVcIiwgQ2hvaWNlQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJ2YXJpYWJsZS1pbmNyZW1lbnRcIiwgVmFyaWFibGVJbmNyZW1lbnRBY3Rpb24pO1xyXG5cclxuICAgIC8vIE1pc3Npb24tSGVhbHRoIHNwZWNpZmljIGFjdGlvbnM6XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwibWgtc2NlbmVcIiwgTWhTY2VuZUFjdGlvbik7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBY3Rpb25GYWN0b3J5O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTUsIDA5LzA3LzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgcmVnaXN0cnkgYW5kIGNvbnN0cnVjdGlvbiBmYWN0b3J5IGZvciBBY3RvcnM7IHdoaWNoIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIG9uIHRoZWlyIG93biwgb25seVxyXG4gKiBmcm9tIHRoaXMgY3JlYXRpb24gcG9pbnQuIFRoaXMgY3JlYXRpb24gcG9pbnQgYWxzbyB3b3JrcyBmb3IgdmFsaWRhdGlvbiBwdXJwb3Nlcy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIC8qIEdlbmVyYWwgQWN0b3JzLCBvciByZXVzYWJsZSBhY3Jvc3MgY291cnNlcyAqL1xyXG4gICAgdmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWFuaW1hdGlvbicpO1xyXG4gICAgdmFyIEF1ZGlvID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItYXVkaW8nKTtcclxuICAgIHZhciBCbG9ja2VyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItYmxvY2tlcicpO1xyXG4gICAgdmFyIEJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWJ1dHRvbicpO1xyXG4gICAgdmFyIEJ1dHRvbkNoYXJhY3RlciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWJ1dHRvbi1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBDaGFyYWN0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBDbGlja0FuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWNsaWNrLWFuaW1hdGlvbicpO1xyXG4gICAgdmFyIERlY29yYXRpb24gPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1kZWNvcmF0aW9uJyk7XHJcbiAgICB2YXIgRHJhZyA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWRyYWcnKTtcclxuICAgIHZhciBEcmF3ID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItZHJhdycpO1xyXG4gICAgdmFyIERyb3AgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1kcm9wJyk7XHJcbiAgICB2YXIgRmFkZW91dCA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWZhZGVvdXQnKTtcclxuICAgIHZhciBJbnB1dEZpZWxkID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItaW5wdXQtZmllbGQnKTtcclxuICAgIHZhciBJbnN0cnVjdGlvbnMgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1pbnN0cnVjdGlvbi1idWJibGUnKTtcclxuICAgIHZhciBMaW5lID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItbGluZScpO1xyXG4gICAgdmFyIE5vSW5wdXRDaGFyYWN0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1uby1pbnB1dC1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBRdWVzdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXF1ZXN0aW9uJyk7XHJcbiAgICB2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItcmVjdGFuZ2xlJyk7XHJcbiAgICB2YXIgU3BlZWNoQnViYmxlID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3Itc3BlZWNoLWJ1YmJsZScpO1xyXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci10ZXh0Jyk7XHJcbiAgICB2YXIgVGV4dEJ1YmJsZSA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXRleHQtYnViYmxlJyk7XHJcbiAgICB2YXIgVGltZWxpbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci10aW1lbGluZScpO1xyXG4gICAgdmFyIFRvZ2dsZUJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXRvZ2dsZS1idXR0b24nKTtcclxuICAgIHZhciBVcmxCdXR0b25JbnZpc2libGUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci11cmwtYnV0dG9uLWludmlzaWJsZScpO1xyXG4gICAgdmFyIFVybEJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXVybC1idXR0b24nKTtcclxuICAgIHZhciBXaXN0aWEgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci13aXN0aWEnKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgc3BlY2lmaWNhbGx5IGZvciBJdCdzIFVSIENob2ljZSB1c2FnZSAqL1xyXG4gICAgdmFyIENoYXQgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItY2hhdCcpO1xyXG4gICAgdmFyIEl0c1VyQ2hvaWNlQm9vayA9IHJlcXVpcmUoJy4vYWN0b3JzL2l1Yy9hY3Rvci1ib29rJyk7XHJcbiAgICB2YXIgSXRzVXJDaG9pY2VEcmFnID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLWZpbGUtZHJhZycpO1xyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItcGhvbmUnKTtcclxuICAgIHZhciBJdHNVckNob2ljZVBob25lQnV0dG9uID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLXBob25lLWJ1dHRvbicpO1xyXG4gICAgdmFyIE1hcEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLW1hcCcpO1xyXG4gICAgdmFyIFBvcHVwQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItcG9wdXAnKTtcclxuICAgIHZhciBXaW5kb3dBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3JzL2l1Yy9hY3Rvci13aW5kb3cnKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgc3BlY2lmaWNhbGx5IGZvciBBY3QgTm93ISB1c2FnZSAqL1xyXG4gICAgdmFyIEFubm91bmNlciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1hbm5vdW5jZXInKTtcclxuICAgIHZhciBDaG9pY2UgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3ItY2hvaWNlJyk7XHJcbiAgICB2YXIgQWN0Tm93UGhvbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3ItcGhvbmUnKTtcclxuICAgIHZhciBQaG9uZUJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS1idXR0b24nKTtcclxuICAgIHZhciBTcGlubmVyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0bm93L2FjdG9yLXNwaW5uZXInKTtcclxuICAgIHZhciBDaG9vc2VyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0bm93L2FjdG9yLWNob29zZXInKTtcclxuICAgIHZhciBaaW5rQ29tcHV0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3Itemluay1jb21wdXRlcicpO1xyXG4gICAgdmFyIFppbmtQb3N0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3Itemluay1wb3N0ZXInKTtcclxuXHJcbiAgICB2YXIgUGxheUFjdG9yID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JUeXBlcyA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJBY3RvcjogZnVuY3Rpb24oIHR5cGUsIGFjdG9yICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JUeXBlcywgZnVuY3Rpb24oa25vd25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgIGlmKCBrbm93blR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBcIllvdSBhcmUgcmVnaXN0ZXJpbmcgYW4gYWN0b3IgdHlwZSB0aGF0IGFscmVhZHkgZXhpc3RzOiBcIiArIHR5cGU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JUeXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9yc1t0eXBlXSA9IGFjdG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QWN0b3I6IGZ1bmN0aW9uKCB0eXBlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RvcnNbdHlwZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0F2YWlsYWJsZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hY3RvclR5cGVzLCBmdW5jdGlvbihrbm93blR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCBrbm93blR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QXZhaWxhYmxlVHlwZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBjbG9uZSwgdG8gbWFrZSBpdCByZWFkIG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuYWN0b3JUeXBlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIEFjdG9yRmFjdG9yeSA9IG5ldyBQbGF5QWN0b3IoKTtcclxuXHJcbiAgICAvKiBHZW5lcmFsIEFjdG9ycywgb3IgcmV1c2FibGUgYWNyb3NzIGNvdXJzZXMgKi9cclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiYW5pbWF0aW9uXCIsIEFuaW1hdGlvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJhdWRpb1wiLCBBdWRpbyApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJibG9ja2VyXCIsIEJsb2NrZXIgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiYnV0dG9uXCIsIEJ1dHRvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJidXR0b24tY2hhcmFjdGVyXCIsIEJ1dHRvbkNoYXJhY3RlciApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJjaGFyYWN0ZXJcIiwgQ2hhcmFjdGVyKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiY2xpY2stYW5pbWF0aW9uXCIsIENsaWNrQW5pbWF0aW9uKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiZGVjb3JhdGlvblwiLCBEZWNvcmF0aW9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImRyYWdcIiwgRHJhZyApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJkcmF3XCIsIERyYXcgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiZHJvcFwiLCBEcm9wICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImZhZGVvdXRcIiwgRmFkZW91dCApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpbnB1dC1maWVsZFwiLCBJbnB1dEZpZWxkICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImluc3RydWN0aW9uc1wiLCBJbnN0cnVjdGlvbnMgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwibGluZVwiLCBMaW5lICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcIm5vLWlucHV0LWNoYXJhY3RlclwiLCBOb0lucHV0Q2hhcmFjdGVyICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInJlY3RhbmdsZVwiLCBSZWN0YW5nbGUpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJzcGVlY2gtYnViYmxlXCIsIFNwZWVjaEJ1YmJsZSk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRleHRcIiwgVGV4dCk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRleHQtYnViYmxlXCIsIFRleHRCdWJibGUpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJ0aW1lbGluZVwiLCBUaW1lbGluZSk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRvZ2dsZS1idXR0b25cIiwgVG9nZ2xlQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInVybC1idXR0b25cIiwgVXJsQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInVybC1idXR0b24taW52aXNpYmxlXCIsIFVybEJ1dHRvbkludmlzaWJsZSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJxdWVzdGlvblwiLCBRdWVzdGlvbik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInZpZGVvXCIsIFdpc3RpYSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJ3aXN0aWFcIiwgV2lzdGlhICk7XHJcblxyXG4gICAgLyogQWN0b3JzIHNwZWNpZmljYWxseSBmb3IgSXQncyBVUiBDaG9pY2UgdXNhZ2UgKi9cclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiY2hhdFwiLCBDaGF0KTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjYm9va1wiLCBJdHNVckNob2ljZUJvb2sgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjZHJhZ1wiLCBJdHNVckNob2ljZURyYWcgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjcGhvbmVcIiwgSXRzVXJDaG9pY2VQaG9uZSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNwaG9uZS1idXR0b25cIiwgSXRzVXJDaG9pY2VQaG9uZUJ1dHRvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNtYXBcIiwgTWFwQWN0b3IpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNwb3B1cFwiLCBQb3B1cEFjdG9yKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjd2luZG93XCIsIFdpbmRvd0FjdG9yKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgZm9yIEFjdCBOb3chIHVzYWdlICovXHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImFubm91bmNlclwiLCBBbm5vdW5jZXIpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJjaG9pY2VcIiwgQ2hvaWNlKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwicGhvbmUtYnV0dG9uXCIsIFBob25lQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInBob25lXCIsIEFjdE5vd1Bob25lICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInNwaW5uZXJcIiwgU3Bpbm5lcik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImNob29zZXJcIiwgQ2hvb3Nlcik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInppbmstY29tcHV0ZXJcIiwgWmlua0NvbXB1dGVyICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInppbmstcG9zdGVyXCIsIFppbmtQb3N0ZXIpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQWN0b3JGYWN0b3J5O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXByZXNlbnQgYSBcIlNjZW5lXCIgYXMgcGFydCBvZiBhbiBcIkFjdFwiLiBUaGUgc2NlbmUgY29udGFpbnMgYW4gYXJyYXkgb2YgYWN0b3JzIGFuZCBkZWFscyB3aXRoIGJyb2tlcmluZyBldmVudHMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyksXHJcbiAgICAgICAgUGxheUFjdG9yID0gcmVxdWlyZSgnLi9wbGF5LWFjdG9yJyksXHJcbiAgICAgICAgUGxheVRocm91Z2hBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1wbGF5dGhyb3VnaCcpO1xyXG5cclxuICAgIHZhciBQbGF5U2NlbmUgPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCBkYXRhLCBtb2RlbEludGVyZmFjZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgaWYoICFnYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJQbGF5U2NlbmUgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggIWRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlBsYXlTY2VuZSByZXF1aXJlcyBkYXRhIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFNjZW5lKGdhbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIG9uR2FtZUNob2ljZTogbmV3IFBoYXNlci5TaWduYWwoKSxcclxuICAgICAgICAgICAgICAgIG9uR2FtZVNwZWVjaDogbmV3IFBoYXNlci5TaWduYWwoKSxcclxuICAgICAgICAgICAgICAgIG9uR2FtZU11c2ljOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxJbnRlcmZhY2UgPSBtb2RlbEludGVyZmFjZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5pc1Nob3dQbGF5VGhyb3VnaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXl0aHJvdWdoQWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdFNjZW5lOiBmdW5jdGlvbihnYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvciA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoMCwwKTtcclxuICAgICAgICAgICAgdGhpcy5iZ0NvbG9yLmJlZ2luRmlsbChcIjB4RkZGRkZGXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZHJhd1JlY3QoMCwwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuX2Nod19uYW1lID0gXCJTY2VuZUJhY2tncm91bmRHcmFwaGljc1wiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd05ld1NjZW5lRGF0YTogZnVuY3Rpb24oIG5ld0RhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnBsYXl0aHJvdWdoQWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXl0aHJvdWdoQWN0b3IuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVJZCA9IG5ld0RhdGEuaWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBzY2VuZSB0byB0aGUgcGxheWVyIGJ5IHNldHRpbmcgdGhlIGJhY2tncm91bmQgYW5kIGhhdmluZyBhbGwgYWN0b3JzIGVudGVyIHRoZSBzY2VuZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaG93U2NlbmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYmFja2dyb3VuZCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5zY2VuZUltYWdlc1t0aGlzLmRhdGEuYmFja2dyb3VuZF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuc2NlbmVJbWFnZXNbdGhpcy5kYXRhLmJhY2tncm91bmRdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmJhY2tncm91bmQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmRhdGEuYWN0b3JzLCB0aGlzLmFkZEFjdG9yLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RhbnQgJ3BsYXktdGhyb3VnaCcgYWN0b3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc1Nob3dQbGF5VGhyb3VnaCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheXRocm91Z2hBY3Rvci5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYmFja2dyb3VuZE11c2ljICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lTXVzaWMuZGlzcGF0Y2goIHRoaXMuZGF0YS5iYWNrZ3JvdW5kTXVzaWMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3dQbGF5VGhyb3VnaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy5wbGF5dGhyb3VnaEFjdG9yICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheXRocm91Z2hBY3RvciAgPSBuZXcgUGxheVRocm91Z2hBY3Rvcih0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5dGhyb3VnaEFjdG9yLnNldE1vZGVsSW50ZXJmYWNlKHRoaXMubW9kZWxJbnRlcmZhY2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5dGhyb3VnaEFjdG9yLmVudGVyU2NlbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzU2hvd1BsYXlUaHJvdWdoID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhbiBpbmRpdmlkdWFsIGFjdG9yIHRvIHRoZSBzY2VuZS4gVGhlIG9yZGVyaW5nIGlzIGltcG9ydGFudCwgdGhlIGFjdG9yIGlzIGNyZWF0ZWQsIHRoZW4gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICogYXJlIGFkZGVkLCBhbmQgdGhlbiB0aGUgYWN0b3IgaXMgYWxsb3dlZCB0byBlbnRlciB0aGUgc2NlbmUuIFdlIGRvbid0IHdhbnQgYW4gYWN0b3IgdGhhdCBpbW1lZGlhdGVseSBhY3RzXHJcbiAgICAgICAgICogdG8gaGF2ZSBpdHMgZXZlbnRzIGlnbm9yZWQgYmVjYXVzZSB0aGUgbGlzdGVuZXJzIHdlcmVuJ3QgeWV0IGluIHBsYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvckRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRBY3RvcjogZnVuY3Rpb24oYWN0b3JEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RvckNsYXNzLCBhY3RvciwgbmV3QWN0b3JEYXRhID0gYWN0b3JEYXRhO1xyXG4gICAgICAgICAgICAvLyBBY3RvcnMgY2FuIGFsc28gYmUgb2YgdHlwZSByZWZlcmVuY2UsIG1lYW5pbmcgdGhleSBsb2FkIGFuIGFjdG9yIGZyb20gdGhlIHNldCBvZiBhY3RvcnMgb3V0c2lkZSBzY2VuZXMuXHJcbiAgICAgICAgICAgIGlmKCBhY3RvckRhdGEudHlwZSA9PT0gXCJyZWZlcmVuY2VcIiApIHtcclxuICAgICAgICAgICAgICAgIG5ld0FjdG9yRGF0YSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0QWN0b3JCeVJlZiggYWN0b3JEYXRhLm5hbWUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWN0b3JDbGFzcyA9IFBsYXlBY3Rvci5nZXRBY3RvcihuZXdBY3RvckRhdGEudHlwZSk7XHJcbiAgICAgICAgICAgIGFjdG9yID0gbmV3IGFjdG9yQ2xhc3ModGhpcy5nYW1lLCBuZXdBY3RvckRhdGEsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICBhY3Rvci5zZXRNb2RlbEludGVyZmFjZSh0aGlzLm1vZGVsSW50ZXJmYWNlKTtcclxuICAgICAgICAgICAgYWN0b3IuY2xlYXJWYXJpYWJsZXMoKTtcclxuICAgICAgICAgICAgLy8gQW55IGdpdmVuIGFjdG9yIG1heSBvciBtYXkgbm90IHB1Ymxpc2ggdGhlc2UgZXZlbnRzLlxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuZXZlbnRzLm9uR2FtZUNob2ljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50cy5vbkdhbWVDaG9pY2UuYWRkKHRoaXMub25HYW1lQ2hvaWNlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5ldmVudHMub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnRzLm9uR2FtZVNwZWVjaC5hZGQodGhpcy5vbkdhbWVTcGVlY2gsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0FjdG9yRGF0YS5zdGFydERlbGF5ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLmVudGVyU2NlbmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxheUFjdG9yID0gW107XHJcbiAgICAgICAgICAgICAgICBkZWxheUFjdG9yWzBdID0gLTE7IC8vIHN0YXJ0IHRpbWUgaW4gdGlja3MsIHRvIGJlIHNldCBpbiB0aWNrVXBkYXRlKClcclxuICAgICAgICAgICAgICAgIGRlbGF5QWN0b3JbMV0gPSBuZXdBY3RvckRhdGEuc3RhcnREZWxheTsgLy8gaW4gdGlja3MgKGEgdGljayBpcyBkZWZpbmVkIGluIG1haW4pXHJcbiAgICAgICAgICAgICAgICBkZWxheUFjdG9yWzJdID0gYWN0b3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMucHVzaChkZWxheUFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYWN0b3IgaGFzIG1hZGUgYSBjaG9pY2UsIGJ1YmJsZSB0aGlzIGV2ZW50IHVwIHRvIHRoZSAnYWN0JywgYW5kIGluZm9ybSBhbGwgb3RoZXJcclxuICAgICAgICAgKiBhY3RvcnMgb2YgdGhlIGNob2ljZSBzbyB0aGF0IHRoZXkgY2FuIGFkanVzdCBhbnkgaW50ZXJuYWwgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gY2hvaWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggbmFtZSwgY2hvaWNlICkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goICBjaG9pY2UgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wVmFycyA9IF8ucGFpcnMoY2hvaWNlKVswXTtcclxuICAgICAgICAgICAgY2hvaWNlLmNvbnN1bWVkID0gdGhpcy5zY2VuZUNvbW1hbmQobmFtZSwgdGVtcFZhcnNbMF0sIHRlbXBWYXJzWzFdKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCAhY2hvaWNlLmNvbnN1bWVkICkge1xyXG4gICAgICAgICAgICAgdGhpcy5zZW5kR2FtZUNob2ljZVRvQWN0b3JzKG5hbWUsIGNob2ljZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbmRHYW1lQ2hvaWNlVG9BY3RvcnM6IGZ1bmN0aW9uKG5hbWUsIGNob2ljZSkge1xyXG4gICAgICAgICAgICAvLyBUZWxsIGFueSBhY3RvcnMgd2l0aCBhIG1ldGhvZCB0byBoYW5kbGUgY2hvaWNlcy5cclxuICAgICAgICAgICAgXy5lYWNoKHRoaXMuYWN0b3JzLCBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5nZXROYW1lKCkgIT09IG5hbWUgJiYgYWN0b3Iub25HYW1lQ2hvaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3Iub25HYW1lQ2hvaWNlKGNob2ljZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUnVuIGFuIFNjZW5lIGxldmVsIGNvbW1hbmQuIFJldHVybiB0cnVlIGlmIGEgY29tbWFuZCBoYXBwZW5lZCwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb21tYW5kXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjb21tYW5kIHdhcyBjb25zdW1lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzY2VuZUNvbW1hbmQ6IGZ1bmN0aW9uKCBhY3Rvck5hbWUsIGNvbW1hbmQsIGFyZykge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIlNjZW5lIGNvbW1hbmQ6IFwiICsgY29tbWFuZCArIFwiIC8gXCIgKyBhcmcpO1xyXG4gICAgICAgICAgICBpZiggY29tbWFuZCA9PT0gXCJkcm9wcGVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggYWN0b3IxICYmIGFjdG9yMS5nZXRUeXBlKCkgPT09IFwiZHJvcFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBhY3RvcjIuZ2V0VHlwZSgpID09PSBcImRyYWdcIiB8fCBhY3RvcjIuZ2V0VHlwZSgpID09PSBcIml1Y2RyYWdcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5nYW1lLnBoeXNpY3MuYXJjYWRlLm92ZXJsYXAoIGFjdG9yMS5nZXRQcmltYXJ5U3ByaXRlKCksIGFjdG9yMi5nZXRQcmltYXJ5U3ByaXRlKCkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjEub25SZWNlaXZlRHJvcChhY3RvcjIuZ2V0TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGxvb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBjb21tYW5kID09PSBcIm11dGVfZ2FtZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5hY3RvcnMsIGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYWN0b3IuZGF0YS5uYW1lICE9PSBhY3Rvck5hbWUgJiYgYWN0b3IuZGF0YS50eXBlID09PSBcIndpc3RpYVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5vbldpc3RpYU11dGUodGhpcy5nYW1lLnNvdW5kLm11dGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFjdG9yIGlzIHNob3dpbmcgbmV3IHRleHQgKGFuZCBwb3NzaWJseSBwbGF5aW5nIG5ldyBhdWRpbykuIHNvbWUgYWN0b3JzIGFuaW1hdGUgb3RoZXJzIHNwZWFraW5nLCBvclxyXG4gICAgICAgICAqIHNob3cgdGhlIHRleHQvYXVkaW8gdGhhdCBhbiBhY3RvciBpcyBzcGVha2luZy4gU28gYnViYmxlIHRoZSBldmVudCBhbmQgYWxzbyB0ZWxsIHRoZSBvdGhlciBhY3RvcnMuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiggbmFtZSwgc3BlZWNoLCBzb3VyY2VBY3RvciApIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3BhdGNoKCBzcGVlY2ggKTtcclxuICAgICAgICAgICAgaWYoIHNvdXJjZUFjdG9yICYmIHNvdXJjZUFjdG9yLmlzU291bmRFdmVudEludmVyc2UoKSAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggc291cmNlQWN0b3Iub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQWN0b3Iub25HYW1lU3BlZWNoKHNwZWVjaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxsIGFueSBhY3RvcnMgd2l0aCBhIG1ldGhvZCB0byBoYW5kbGUgc3BlZWNoIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5hY3RvcnMsIGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5kYXRhLm5hbWUgIT09IG5hbWUgJiYgYWN0b3Iub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLm9uR2FtZVNwZWVjaChzcGVlY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFjdG9yLmRhdGEudHlwZSA9PT0gXCJ3aXN0aWFcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3Iub25HYW1lU3BlZWNoKHNwZWVjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3BlZWNoIHN0b3AgYWN0aW9uIGhhcyBvY2N1cmVkIGZyb20gZnVydGhlciB1cCB0aGUgY2hhaW4sIGNvbnRpbnVlIHBhc3NpbmcgaXQgZG93biB0byBlYWNoIGFjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlY2hcclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkdhbWVTcGVlY2hTdG9wOiBmdW5jdGlvbiggc3BlZWNoICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggYWN0b3IgJiYgYWN0b3Iub25HYW1lU3BlZWNoU3RvcCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5vbkdhbWVTcGVlY2hTdG9wKCBzcGVlY2ggKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVBY3RvckJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yKCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpbmRleCsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYWN0b3JzW2luZGV4XS5kYXRhLm5hbWUgPT09IG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IgPSB0aGlzLmFjdG9yc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKHRoaXMuYWN0b3JzW2luZGV4XS5kYXRhLm5hbWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QWN0b3IoYWN0b3IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgZGVsYXllZCBhY3RvciB0aGF0IGhhc24ndCBiZWVuIHRyaWdnZXJlZCB5ZXRcclxuICAgICAgICAgICAgICAgIGZvciggaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuZGVsYXllZEFjdG9ycy5sZW5ndGg7IGluZGV4KysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ZWRBY3RvciA9IHRoaXMuZGVsYXllZEFjdG9yc1tpbmRleF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGRlbGF5ZWRBY3Rvci5kYXRhLm5hbWUgPT09IG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yID0gZGVsYXllZEFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihkZWxheWVkQWN0b3IuZGF0YS5uYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIGFjdG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgZm9yIGRlbGF5ZWQgYWN0b3JzLiBJZiBhIGRlbGF5ZWQgYWN0b3IncyBzdGFydCB0aW1lICBpbiB0aWNrcyBoYXMgYXJyaXZlZCwgYWRkIGl0IHRvIHRoZSBzY2VuZSBhbmRcclxuICAgICAgICAgKiByZW1vdmUgaXQgZnJvbSB0aGUgZGVsYXllZCBhY3RvcnMgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFNUUk9ORyBXQVJOSU5HOiBEb24ndCBkbyBtdWNoIGhlcmUgLSBpdCdzIGNhbGxlZCBmcm9tIHRoZSBtYWluIHVwZGF0ZSBsb29wLiBBbnkgZXh0ZW5zaXZlIG9wZXJhdGlvbnMgd2lsbFxyXG4gICAgICAgICAqIGNhdXNlIHRoZSB1c2VyIGludGVyZmFjZSB0byBsYWcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGlja1VwZGF0ZTogZnVuY3Rpb24gKHRpY2spIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZGVsYXllZEFjdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXllZEFjdG9yc1tpXVswXSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFjdG9yJ3Mgc3RhcnQgdGltZSBoYXNuJ3QgYmVlbiBzZXQgeWV0LiBTZXQgaXRzIHN0YXJ0IHRpbWUgdG8gY3VycmVudCB0aWNrIHBsdXMgaXRzIGRlbGF5LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEFjdG9yc1tpXVswXSA9IHRpY2sgKyB0aGlzLmRlbGF5ZWRBY3RvcnNbaV1bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGljayA+PSB0aGlzLmRlbGF5ZWRBY3RvcnNbaV1bMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yID0gdGhpcy5kZWxheWVkQWN0b3JzW2ldWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuZGVsYXllZEFjdG9yc1tpXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgICAgICAvL2xvZy53YXJuKFwiZGVsYXllZCBhY3RvclwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgKyAoKCh0eXBlb2YgYWN0b3IuZGF0YSAhPSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIGFjdG9yLmRhdGEubmFtZSAhPSBcInVuZGVmaW5lZFwiKSkgPyAoXCIgbmFtZWQgXFxcIlwiICsgYWN0b3IuZGF0YS5uYW1lICsgXCJcXFwiXCIpIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICArICgoKHR5cGVvZiBhY3Rvci5kYXRhICE9IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgYWN0b3IuZGF0YS50eXBlICE9IFwidW5kZWZpbmVkXCIpKSA/IChcIiBvZiB0eXBlIFxcXCJcIiArIGFjdG9yLmRhdGEudHlwZSArIFwiXFxcIlwiKSA6IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgKyBcIiBlbnRlcmluZyBzY2VuZSBhZnRlciBcIiArIGRlbGF5ICsgXCIgdGlja3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZW50ZXJTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hY3RvcnMsIGZ1bmN0aW9uKGFjdG9yMSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIGFjdG9yMS5nZXRUeXBlKCkgPT09IFwiZHJvcFwiICApIHtcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGFjdG9yMi5nZXRUeXBlKCkgPT09IFwiZHJhZ1wiIHx8IGFjdG9yMi5nZXRUeXBlKCkgPT09IFwiaXVjZHJhZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHRoaXMuZ2FtZS5waHlzaWNzLmFyY2FkZS5vdmVybGFwKCBhY3RvcjEuZ2V0UHJpbWFyeVNwcml0ZSgpLCBhY3RvcjIuZ2V0UHJpbWFyeVNwcml0ZSgpKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjEub25PdmVybGFwcGluZyhhY3RvcjIuZ2V0TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yMS5vbk92ZXJsYXBwaW5nKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QWN0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuYWN0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBrZXlzIG9mIGFueSBhZGRpdGlvbmFsIGF1ZGlvIHRoaXMgc2NlbmUgd2FudHMuXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFkZGl0aW9uYWxBdWRpbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQXVkaW8gPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmRhdGEuYWN0b3JzLCBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggYWN0b3IuYXVkaW9LZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEF1ZGlvLnB1c2goIGFjdG9yLmF1ZGlvS2V5ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbEF1ZGlvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveUFjdG9yOiBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyRm9yUmV1c2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0b3I7XHJcbiAgICAgICAgICAgIHdoaWxlKCBhY3RvciA9IHRoaXMuYWN0b3JzLnBvcCgpICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QWN0b3IoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgYWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIHZhciBkZWxheWVkQWN0b3JEYXRhO1xyXG4gICAgICAgICAgICB3aGlsZSggZGVsYXllZEFjdG9yRGF0YSA9IHRoaXMuZGVsYXllZEFjdG9ycy5wb3AoKSApIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gZGVsYXllZEFjdG9yRGF0YVsyXTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZU11c2ljLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJGb3JSZXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZU11c2ljLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGxheVNjZW5lO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzEwLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBhbiBpbnRlcmZhY2UgdG8gdGhlIFNDT1JNIEFQSSBwcm92aWRlZCB2aWEgL21haW4vc2Nvcm0vQVBJV3JhcHBlci5qc1xyXG4gKiBVc2VycyBvZiB0aGlzIG1vZHVsZSBhcmUgZXhwZWN0ZWQgdG8gY2FsbCBpbml0aWFsaXplIHdpdGggYSBzZXR0aW5ncyBvYmplY3Qgb2YgYXQgbGVhc3Q6XHJcbiAqIHtcclxuICogICAgIHNjb3JtRW5hYmxlZDogdHJ1ZXxmYWxzZVxyXG4gKiB9XHJcbiAqIFlvdSBkbyBub3QgaGF2ZSB0byBlbmFibGUgU2Nvcm0gdG8gdXNlIHRoaXMgY2xhc3MsIGl0IHdpbGwgaG9sZCBhbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBmb3IgZGVidWdnaW5nXHJcbiAqIHB1cnBvc2VzLlxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxuICAgIC8vIEBUT0RPLCBpbmplY3Qgc2Nvcm0gaW50ZXJmYWNlIGluc3RlYWQgb2YgYXNzdW1pbmcgd2luZG93LlxyXG4gICAgdmFyIFNjb3JtID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2Nvcm1JbnRlcmZhY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zY29ybUludGVyZmFjZSA9IHNjb3JtSW50ZXJmYWNlIHx8IHdpbmRvdztcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nvcm1BdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pbml0U3VjY2VzcyA9IFwiXCI7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgaW5jb21wbGV0ZTogXCJpbmNvbXBsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICBub3RBdHRlbXB0ZWQ6IFwibm90IGF0dGVtcHRlZFwiLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IFwiY29tcGxldGVkXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBTZWUgU2Nvcm0gUnVudGltZSBFTlYgUERGIFNlY3Rpb24gMy40XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLkxNU0tleXMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZXNzb25TdGF0dXM6IFwiY21pLmNvcmUubGVzc29uX3N0YXR1c1wiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Db3VudDogXCJjbWkuaW50ZXJhY3Rpb25zLl9jb3VudFwiLFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuZERhdGE6IFwiY21pLnN1c3BlbmRfZGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25JZDogXCJjbWkuaW50ZXJhY3Rpb25zLiMuaWRcIixcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uVHlwZTogXCJjbWkuaW50ZXJhY3Rpb25zLiMudHlwZVwiLCAvLyBAU0VFIExNU0ludGVyYWN0aW9uVHlwZXMgYmVsb3cuXHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkNvcnJlY3RQYXR0ZXJuOiBcImNtaS5pbnRlcmFjdGlvbnMuIy5jb3JyZWN0X3Jlc3BvbnNlcy4wLnBhdHRlcm5cIixcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uQWN0dWFsUGF0dGVybjogXCJjbWkuaW50ZXJhY3Rpb25zLiMuc3R1ZGVudF9yZXNwb25zZVwiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25SZXN1bHQ6IFwiY21pLmludGVyYWN0aW9ucy4jLnJlc3VsdFwiLCAvLyBAU0VFIExNU1Jlc3VsdFR5cGVzIGJlbG93XHJcbiAgICAgICAgICAgICAgICByYXdTY29yZTogXCJjbWkuY29yZS5zY29yZS5yYXdcIixcclxuICAgICAgICAgICAgICAgIHNlc3Npb25UaW1lOiBcImNtaS5jb3JlLnNlc3Npb25fdGltZVwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0aXZlSWQ6IFwiY21pLm9iamVjdGl2ZXMuIy5pZFwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0aXZlU3RhdHVzOiBcImNtaS5vYmplY3RpdmVzLiMuc3RhdHVzXCIgLy8gQFNFRSBMTVNPYmplY3RpdmVTdGF0dXNWYWx1ZXMgYmVsb3dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB2YWxpZCBcInN0YXR1c1wiIGZpZWxkIHdoZW4gd29ya2luZyB3aXRoIGNtaSBvYmplY3RpdmVzXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuTE1TT2JqZWN0aXZlU3RhdHVzVmFsdWVzID0gW1xyXG4gICAgICAgICAgICAgICAgXCJwYXNzZWRcIiwgXCJjb21wbGV0ZWRcIiwgXCJmYWlsZWRcIiwgXCJpbmNvbXBsZXRlXCIsIFwiYnJvd3NlZFwiLCBcIm5vdCBhdHRlbXB0ZWRcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZhbGlkIFwidHlwZVwiIGZpZWxkIHdoZW4gY3JlYXRpbmcgYW4gaW50ZXJhY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEBTZWUgU2Nvcm0gUnVudGltZSBFbnYgUERGIFNlY3Rpb24gMy40LjRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuTE1TSW50ZXJhY3Rpb25UeXBlcyA9IFtcclxuICAgICAgICAgICAgICAgIFwidHJ1ZS1mYWxzZVwiLCBcImNob2ljZVwiLCBcImZpbGwtaW5cIiwgXCJtYXRjaGluZ1wiLCBcInBlcmZvcm1hbmNlXCIsIFwic2VxdWVuY2luZ1wiLCBcImxpa2VydFwiLCBcIm51bWVyaWNcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZhbGlkIFwicmVzdWx0XCIgZmllbGQgd2hlbiBjcmVhdGluZyBhbiBpbnRlcmFjdGlvbi5cclxuICAgICAgICAgICAgICogQFNlZSBTY29ybSBSdW50aW1lIEVudiBQREYgU2VjdGlvbiAzLjQuNFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5MTVNSZXN1bHRUeXBlcyA9IFtcclxuICAgICAgICAgICAgICAgIFwiY29ycmVjdFwiLCBcIndyb25nXCIsIFwidW5hbnRpY2lwYXRlZFwiLCBcIm5ldXRyYWxcIiAvLyBhbmQgeC54XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHRoaXMuTE1TUmVzdWx0VHlwZU51bWJlciA9IC9bMC05XStcXC5bMC05XSsvOyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gZm9yICMuI1xyXG4gICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGEgPSB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsb2cuZGVidWcoXCJJbml0aWFsaXppbmcgU0NPUk0gQ0ggQVBJXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3Muc2Nvcm1FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJzY29ybUVuYWJsZWQgPT09IHRydWUsIGluaXRpYWxpemluZyBTQ09STVwiKTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9MTVNJbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiVGhlIExNUyBXcmFwcGVyIGFwcGVhcnMgdG8gYmUgbWlzc2luZy4gU2tpcHBpbmcgU0NPUk0gSW5pdGlhbGl6YXRpb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFN1Y2Nlc3MgPSBkb0xNU0luaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIC8vIGVycm9yIGluIGVhcmx5IElFLiBHSkYgY29uc29sZS5sb2coXCJpbml0aWFsaXplIHN1Y2Nlc3M/OiBcIiArIHN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdFN1Y2Nlc3MgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29ybUF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiU0NPUk0gaW5pdGlhbGl6ZWQgZnJvbSBTQ09STSBDSCBBUEkgc3VjY2Vzc2Z1bGx5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBcInRoYXRcIiBjbG9zdXJlIGZvciB0aGUgd2luZG93IGZ1bmN0aW9uLiBHSkYuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvTE1TRmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU0NPUk0gaW5pdGlhbGl6ZSBmcm9tIFNDT1JNIENIIEFQSSwgRkFJTEVEIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIkNvdWxkIG5vdCBpbml0aWFsaXplIFNDT1JNIEFQSS5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcInNjb3JtRW5hYmxlZCA9PT0gZmFsc2UsIHNraXBwaW5nIFNDT1JNXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbml0aWFsaXplU3RhdHVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gZG9MTVNHZXRWYWx1ZSh0aGlzLkxNU0tleXMubGVzc29uU3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gdGhpcy5jb25zdGFudHMubm90QXR0ZW1wdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMZXNzb25TdGF0dXModGhpcy5jb25zdGFudHMuaW5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldExlc3NvblN0YXR1cyh0aGlzLmNvbnN0YW50cy5pbmNvbXBsZXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0TGVzc29uU3RhdHVzOiBmdW5jdGlvbiAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuY29tcHV0ZVNlc3Npb25UaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5zZXNzaW9uVGltZSwgZm9ybWF0dGVkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXMsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdID0gc3RhdHVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMZXNzb25TdGF0dXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBkb0xNU0dldFZhbHVlKHRoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0xlc3NvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExlc3NvblN0YXR1cygpID09PSB0aGlzLmNvbnN0YW50cy5jb21wbGV0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE9iamVjdGl2ZTogZnVuY3Rpb24oIGluZGV4ICkge1xyXG4gICAgICAgICAgICB2YXIgaWQsIHN0YXR1cztcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlkID0gZG9MTVNHZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZUlkKS5yZXBsYWNlKFwiI1wiLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gZG9MTVNHZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlkID0gdGhpcy5sZXNzb25EYXRhWyh0aGlzLkxNU0tleXMub2JqZWN0aXZlSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV07XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5vYmplY3RpdmVTdGF0dXMpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsb2cuZGVidWcodGVtcCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0T2JqZWN0aXZlOiBmdW5jdGlvbiggaW5kZXgsIGlkLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgbG9nLmRlYnVnKFwiU2V0IG9iamVjdGl2ZSBcIiArIGluZGV4ICsgXCIgXCIgKyBpZCArIFwiIFwiICsgc3RhdHVzICk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuY29tcHV0ZVNlc3Npb25UaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5zZXNzaW9uVGltZSwgZm9ybWF0dGVkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMub2JqZWN0aXZlSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNDb21taXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5vYmplY3RpdmVJZCkucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IGlkO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SW50ZXJhY3Rpb25Db3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSBkb0xNU0dldFZhbHVlKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvdW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvdW50XSB8fCAwOyAvLyBkZWZhdWx0IHRvIDAuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjb3VudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVJbnRlcmFjdGlvbjogZnVuY3Rpb24gKGluZGV4LCBpZCwgdHlwZSwgY29ycmVjdFJlc3BvbnNlLCBzdHVkZW50UmVzcG9uc2UsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBwYXNzIGluIGFuIG9iamVjdCB3aXRoIHRoZXNlIHZhbHVlcyBpbnN0ZWFkIG9mIGFsbCBvZiB0aGUgdmFsdWVzIGRpcmVjdGx5LlxyXG4gICAgICAgICAgICBsb2cuZGVidWcoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZCA9IGluZGV4LmlkO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IGluZGV4LnR5cGU7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0UmVzcG9uc2UgPSBpbmRleC5jb3JyZWN0UmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICBzdHVkZW50UmVzcG9uc2UgPSBpbmRleC5zdHVkZW50UmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlICYmICEoXy5jb250YWlucyh0aGlzLkxNU0ludGVyYWN0aW9uVHlwZXMsIHR5cGUpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIExNU0ludGVyYWN0aW9uVHlwZTogXCIgKyB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgISggXy5jb250YWlucyh0aGlzLkxNU1Jlc3VsdFR5cGVzLHJlc3VsdCkpICYmICFyZXN1bHQubWF0Y2godGhpcy5MTVNSZXN1bHRUeXBlTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIExNU1Jlc3VsdFR5cGU6IFwiICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlkID0gdGhpcy50cmltU3RyaW5nKGlkLCAyNTUpO1xyXG4gICAgICAgICAgICBpZCA9IHRoaXMucmVwbGFjZVNwYWNlcyhpZCwgXCJfXCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uVHlwZSkucmVwbGFjZShcIiNcIiwgaW5kZXgpLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUoKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvcnJlY3RQYXR0ZXJuKS5yZXBsYWNlKFwiI1wiLCBpbmRleCksIGNvcnJlY3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25BY3R1YWxQYXR0ZXJuKS5yZXBsYWNlKFwiI1wiLCBpbmRleCksIHN0dWRlbnRSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25SZXN1bHQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGRvTE1TQ29tbWl0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbklkKS5yZXBsYWNlKFwiI1wiLCBpbmRleCldID0gaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvblR5cGUpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV0gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhWyh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25Db3JyZWN0UGF0dGVybikucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IGNvcnJlY3RSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uQWN0dWFsUGF0dGVybikucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IHN0dWRlbnRSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uUmVzdWx0KS5yZXBsYWNlKFwiI1wiLCBpbmRleCldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTdXNwZW5kRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNldHRpbmcgc3VzcGVuZCBkYXRhXCIpO1xyXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc3VzcGVuZERhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNDb21taXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVt0aGlzLkxNU0tleXMuc3VzcGVuZERhdGFdID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3VzcGVuZERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBcIlwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRvTE1TR2V0VmFsdWUodGhpcy5MTVNLZXlzLnN1c3BlbmREYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlc3NvbkRhdGFbdGhpcy5MTVNLZXlzLnN1c3BlbmREYXRhXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcmtDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMubGVzc29uU3RhdHVzLCB0aGlzLmNvbnN0YW50cy5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdID0gdGhpcy5jb25zdGFudHMuY29tcGxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFJhd1Njb3JlOiBmdW5jdGlvbiAoc2NvcmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gdGhpcy5jb21wdXRlU2Vzc2lvblRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUodGhpcy5MTVNLZXlzLnNlc3Npb25UaW1lLCBmb3JtYXR0ZWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUodGhpcy5MTVNLZXlzLnJhd1Njb3JlLCBzY29yZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5yYXdTY29yZV0gPSBzY29yZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmF3U2NvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNjb3JlID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHNjb3JlID0gZG9MTVNHZXRWYWx1ZSh0aGlzLkxNU0tleXMucmF3U2NvcmUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2NvcmUgPSB0aGlzLmxlc3NvbkRhdGFbdGhpcy5MTVNLZXlzLnJhd1Njb3JlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlU2Vzc2lvblRpbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVOb3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGltZURpZmZlcmVuY2UgPSB0aW1lTm93LmdldFRpbWUoKSAtIHRoaXMuc2Vzc2lvblN0YXJ0VGltZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlRGlmZmVyZW5jZSA9IG5ldyBEYXRlKHRpbWVEaWZmZXJlbmNlKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNlc3Npb24gdGltZSBzZXQgdG86IFwiICsgZm9ybWF0dGVkVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0RGF0ZUZvclNDT1JNKGRhdGVEaWZmZXJlbmNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdERhdGVGb3JTQ09STTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsVGltZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBociA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICB2YXIgc2VjID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaHIgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxUaW1lID0gdG90YWxUaW1lICsgXCIwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG90YWxUaW1lID0gdG90YWxUaW1lICsgaHIgKyBcIjpcIjtcclxuICAgICAgICAgICAgaWYgKG1pbiA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBcIjBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBtaW4gKyBcIjpcIjtcclxuICAgICAgICAgICAgaWYgKHNlYyA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBcIjBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBzZWM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG90YWxUaW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgdG9MZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiB0b0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCB0b0xlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VTcGFjZXM6IGZ1bmN0aW9uIChzdHIsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzL2csIHJlcGxhY2VtZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldExlc3NvbkRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVzc29uRGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjb3JtO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjEuMCBAIDA5LzIxLzE1XHJcbiAqIEBjcmVhdGlvbiAwNi8wNC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJvb3Qgc3RhdGUgY29uZmlndXJlcyB0aGUgZ2FtZSBiYXNlZCBvbiB0aGUgZGV2aWNlIGxvYWRpbmcgaXQuIFRoZSBiYXNpYyBnYW1lIGRhdGEgaXMgbG9hZGVkIHNvXHJcbiAqIHRoYXQgdGhlIHByZWxvYWQgc3RhdGUgaGFzIGFsbCBwcmVyZXF1aXNpdGVzLiBUaGUgc2V0dGluZ3NcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0dmFyIEJhc2UgPSByZXF1aXJlKFwiYmFzZWpzXCIpO1xyXG5cclxuXHR2YXIgQm9vdFN0YXRlID0gQmFzZS5leHRlbmQoe1xyXG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0IXNldHRpbmdzIHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5IHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLmxvYWRpbmdfaW1hZ2VfdXJsIHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLnBsYXlfanNvbl9rZXkgfHxcclxuXHRcdFx0XHQhc2V0dGluZ3MucGxheV9qc29uX3VybCB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5wcmVsb2FkX3N0YXRlX25hbWVcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhyb3cgXCJCb290IFN0YXRlIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkLlwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNhbGxlZCBmaXJzdCBiZWZvcmUgcHJlbG9hZC5cclxuXHRcdCAqL1xyXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLnJlYWR5ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5tYXhQb2ludGVycyA9IDE7XHJcblx0XHRcdC8vIERvbid0IHBhdXNlIHRoZSBnYW1lIHdoZW4gdGhlIG1vdXNlIGxlYXZlcy5cclxuXHRcdFx0dGhpcy5nYW1lLnN0YWdlLmRpc2FibGVWaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcclxuXHRcdFx0Ly90aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nYW1lLnNjYWxlLnJlZnJlc2goKTtcclxuXHJcblx0XHRcdGlmICh0eXBlb2YgUGhhc2VySW5wdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHR0aGlzLmdhbWUucGx1Z2lucy5hZGQoUGhhc2VySW5wdXQuUGx1Z2luKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSW4gb3JkZXIgdG8gc2hvdyB0aGUgbG9hZGluZyBpbWFnZSB3aGlsZSBhbGwgb2YgdGhlIHJlc291cmNlcyBsb2FkLCBpdCBnZXRzIGxvYWRlZCBkdXJpbmcgdGhlXHJcblx0XHQgKiBib290IHN0YXRlLCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBkdXJpbmcgcHJlbG9hZCBvZiB0aGUgcHJlbG9hZCBzdGF0ZS5cclxuXHRcdCAqL1xyXG5cdFx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUubG9hZC5pbWFnZShcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5LFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubG9hZGluZ19pbWFnZV91cmxcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQudGV4dChcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnBsYXlfanNvbl9rZXksXHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5wbGF5X2pzb25fdXJsXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5sb2FkLm9uTG9hZENvbXBsZXRlLmFkZE9uY2UodGhpcy5sb2FkQ29tcGxldGUsIHRoaXMpO1xyXG5cdFx0fSxcclxuXHRcdGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgcGxheUpzb25EYXRhID0gdGhpcy5nYW1lLmNhY2hlLmdldFRleHQodGhpcy5zZXR0aW5ncy5wbGF5X2pzb25fa2V5KTtcclxuXHRcdFx0dmFyIGNvbmZpZyA9IEpTT04ucGFyc2UocGxheUpzb25EYXRhKTtcclxuXHRcdFx0LyppZihjb25maWcuYXV0b1NjYWxlKXtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XHJcbiAgICAgICAgICAgIH0qL1xyXG5cdFx0XHR0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuXHRcdFx0dGhpcy5nYW1lLnNjYWxlLmZ1bGxTY3JlZW5TY2FsZU1vZGUgPSBQaGFzZXIuU2NhbGVNYW5hZ2VyLlNIT1dfQUxMO1xyXG5cclxuXHRcdFx0dGhpcy5nYW1lLnN0YXRlLnN0YXJ0KHRoaXMuc2V0dGluZ3MucHJlbG9hZF9zdGF0ZV9uYW1lKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFNjYWxlcyB0aGUgZ2FtZUNvbnRhaW5lciBzbyB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGUgaW5uZXIgYnJvd3NlciB3aWR0aCBvciBoZWlnaHRcclxuXHRcdCAqL1xyXG5cdFx0LypvblJlc2l6ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dSYXRpbyA9IHdpbmRvd1dpZHRoIC8gd2luZG93SGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZ2FtZUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZ2FtZUNvbnRhaW5lclwiKTtcclxuICAgICAgICAgICAgdmFyIGJveFJhdGlvID0gdGhpcy5nYW1lLndvcmxkLndpZHRoIC8gdGhpcy5nYW1lLndvcmxkLmhlaWdodDtcclxuICAgICAgICAgICAgaWYod2luZG93UmF0aW8gPCBib3hSYXRpbyl7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2luZG93V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICh3aW5kb3dXaWR0aCAvIGJveFJhdGlvKSArIFwicHhcIjtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gKHdpbmRvd0hlaWdodCAqIGJveFJhdGlvKSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIGdhbWVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gd2luZG93SGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSovXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gQm9vdFN0YXRlO1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjAgQCAwOS8yMi8xNVxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIG1haW4gc3RhdGUuIEl0IHdpbGwgYmUgcmVzdGFydGVkIGV2ZXJ5IHRpbWUgYW4gQWN0IGNoYW5nZXMuIFRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIHN0YXRlIGlzIHRvXHJcbiAqIGFsbG93IHRoZSBjdXJyZW50IEFjdCB0byBsb2FkIG1lZGlhIGJlZm9yZSBzdGFydGluZy4gRXZlcnl0aGluZyBpcyBkb25lIHZpYSB0aGUgUGxheSwgbm8gYWN0IHNob3VsZCBiZVxyXG4gKiByZWZlcmVuY2VkIG9yIGluc3RhbnRpYXRlZCBoZXJlLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIExvYWRpbmdTY3JlZW4gPSByZXF1aXJlKCcuLi9sb2FkaW5nLXNjcmVlbicpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgTWFpblN0YXRlID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgfHwgIXNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNYWluIHN0YXRlIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYmVmb3JlIHByZWxvYWQsIGR1cmluZyBlYWNoIHJlc3RhcnQuXHJcbiAgICAgICAgICogQHBhcmFtIGlzUmVzdGFydCB0cnVlIGlmIGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIGEgcmVzdGFydC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoaXNSZXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGxvZy5pbmZvKFwiTWFpbiBzdGF0ZSBjcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiggIXRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWRpbmdTY3JlZW4gPSBuZXcgTG9hZGluZ1NjcmVlbih0aGlzLmdhbWUsIHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc1Jlc3RhcnQgPSBpc1Jlc3RhcnQ7IC8vIHdlIGFyZSByZXN0YXJ0aW5nIHRoaXMgc3RhdGUgZHVlIHRvIGFjdCBjaGFuZ2UuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYWZ0ZXIgaW5pdC4gVGhpcyBpcyB3aGVyZSBtZWRpYSBjYW4gYmUgZG93bmxvYWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkucHJlbG9hZEFjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMubG9hZENvbXBsZXRlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWRDb21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLnNob3dDb21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gcHJlbG9hZCBpcyBjb21wbGV0ZSwgYWxsIG1lZGlhIGlzIGRvd25sb2FkZWQuIChCdXQgd2UnbGwgY2hlY2sgb3Vyc2VsdmVzIGFueXdheXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXIgaXMgY2FsbGVkIGVhY2ggZ2FtZSB0aWNrIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byByZW5kZXIgYW55dGhpbmcgJ29uIHRvcCcgc3VjaCBhcyBhIEhVRC5cclxuICAgICAgICAgKiBVc2VkIGhlcmUgZm9yIGRlYnVnZ2luZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkucmVuZGVyRGVidWcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBlYWNoIGdhbWUgdGljaywgdXNlZCB0byBtYW51YWxseSBjaGVjayB0aGUgbWVkaWEgc3RhdGUgYW5kIHRoZW4gc3RhcnQuIE90aGVyd2lzZSBpdCBwYXNzZXMgdGhlXHJcbiAgICAgICAgICogdXBkYXRlIGFsb25nIHRvIHRoZSBQbGF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkudGlja1VwZGF0ZSh0aGlzLmdhbWUudGltZS5ub3cpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZS5wbGF5LmlzUHJlbG9hZEFjdENvbXBsZXRlKCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkuc2hvd05leHRBY3QodGhpcy5pc1Jlc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkuc2VuZENyb3NzQWN0VmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZGluZ1NjcmVlbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1haW5TdGF0ZTtcclxufSgpKTsiLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjAgQCAwOS8yMS8xNVxyXG4gKiBAY3JlYXRpb24gMDYvMDQvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBwcmVsb2FkIHN0YXRlIHNob3dzIHRoZSBsb2FkaW5nIHNjcmVlbiB3aGlsZSBpdCBwcm9jZXNzZXMgYWxsIG9mIHRoZSB0aGVtZXMgYW5kIHNjZW5lIGRhdGEgZm9yIGVhY2hcclxuICogYWN0IGVudHJ5IGluIHRoZSBwbGF5LlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgbG9nID0gcmVxdWlyZShcImxvZ2xldmVsXCIpLFxyXG5cdFx0QmFzZSA9IHJlcXVpcmUoXCJiYXNlanNcIiksXHJcblx0XHRQbGF5ID0gcmVxdWlyZShcIi4uL3BsYXkvcGxheVwiKSxcclxuXHRcdExvYWRpbmdTY3JlZW4gPSByZXF1aXJlKFwiLi4vbG9hZGluZy1zY3JlZW5cIiksXHJcblx0XHRfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcclxuXHJcblx0dmFyIFByZWxvYWRTdGF0ZSA9IEJhc2UuZXh0ZW5kKHtcclxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdCFzZXR0aW5ncyB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX2ltYWdlX2tleSB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5wbGF5X2pzb25fa2V5IHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLm1haW5fc3RhdGVfbmFtZVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHR0aHJvdyBcIlByZWxvYWQgc3RhdGUgaXMgbWlzc2luZyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gZmllbGQuXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSBwcmVsb2FkLiBKdXN0IHJlY29yZCB0aGF0IHRoaW5ncyBhcmVuJ3QgY29tcGxldGUgeWV0LlxyXG5cdFx0ICovXHJcblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMubG9hZGluZ1NjcmVlbiA9IG5ldyBMb2FkaW5nU2NyZWVuKHRoaXMuZ2FtZSwgdGhpcy5zZXR0aW5ncyk7XHJcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBwbGF5SnNvbkRhdGEgPSB0aGlzLmdhbWUuY2FjaGUuZ2V0VGV4dCh0aGlzLnNldHRpbmdzLnBsYXlfanNvbl9rZXkpO1xyXG5cdFx0XHRpZiAoIXBsYXlKc29uRGF0YSkge1xyXG5cdFx0XHRcdHRocm93IFwiRXJyb3IgaW4gUHJlbG9hZDogRGlkIG5vdCBmaW5kIHBsYXkganNvbiBkYXRhIGluIGNhY2hlLlwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2FtZS5wbGF5ID0gbmV3IFBsYXkoXHJcblx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdEpTT04ucGFyc2UocGxheUpzb25EYXRhKSxcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTaG93IHRoZSBwcmVsb2FkIGltYWdlLCBhbGxvdyB0aGUgUGxheSB0byBsb2FkIGRhdGEuXHJcblx0XHQgKi9cclxuXHRcdHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZ2FtZS5wbGF5LmlzTG9nZ2luZygpID09PSB0cnVlKSB7XHJcblx0XHRcdFx0bG9nLmVuYWJsZUFsbCgpO1xyXG5cdFx0XHRcdGxvZy53YXJuKFwiTG9nZ2luZyBFbmFibGVkXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxvZy5kaXNhYmxlQWxsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5sb2FkaW5nU2NyZWVuLnNob3coKTtcclxuXHRcdFx0dmFyIHByZWxvYWRTZXQgPSB0aGlzLmdhbWUucGxheS5nZXRSZXF1aXJlZFJlc291cmNlTGlzdCgpO1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0cHJlbG9hZFNldCxcclxuXHRcdFx0XHRmdW5jdGlvbiAocHJlbG9hZEl0ZW0pIHtcclxuXHRcdFx0XHRcdHRoaXMuZ2FtZS5sb2FkLnRleHQocHJlbG9hZEl0ZW0ua2V5LCBwcmVsb2FkSXRlbS5maWxlKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQuYXVkaW8oXCJhdWRpb0ZpeFwiLCBbXHJcblx0XHRcdFx0dGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyBcImVuZ2luZS9zaWxlbmNlLW00YS5tNGFcIixcclxuXHRcdFx0XHR0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIFwiZW5naW5lL3NpbGVuY2Utb2dnLm9nZ1wiLFxyXG5cdFx0XHRdKTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQub25Mb2FkQ29tcGxldGUuYWRkT25jZSh0aGlzLmxvYWRDb21wbGV0ZSwgdGhpcyk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDYWxsZWQgd2hlbiBwcmVsb2FkIGlzIGNvbXBsZXRlLCBhbGwgbWVkaWEgaXMgZG93bmxvYWRlZC4gKEJ1dCB3ZSdsbCBjaGVjayBvdXJzZWx2ZXMgYW55d2F5cylcclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMubG9hZGluZ1NjcmVlbi5zaG93Q2xpY2t0aHJvdWdoKCk7XHJcblx0XHRcdC8vIHRoaXMubG9hZGluZ1NjcmVlbi5zaG93Q29tcGxldGUoKTtcclxuXHRcdFx0Ly90aGlzLmxvYWRpbmdTY3JlZW4uZGVzdHJveSgpO1xyXG5cdFx0fSxcclxuXHRcdGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUuc2Nvcm0uaW5pdGlhbGl6ZSh7XHJcblx0XHRcdFx0c2Nvcm1FbmFibGVkOiBfZW52aXJvbm1lbnRTZXR0aW5ncy5zY29ybUVuYWJsZWQsXHJcblx0XHRcdFx0Ly9zY29ybUVuYWJsZWQ6IHRoaXMuZ2FtZS5wbGF5LmlzU2Nvcm1FbmFibGVkKCksXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLmdhbWUuc2Nvcm0uaW5pdGlhbGl6ZVN0YXR1cygpO1xyXG5cdFx0XHR0aGlzLmdhbWUucGxheS5sb2FkU2Nvcm1EYXRhKCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5wbGF5LnNlbGVjdERlZmF1bHRBY3QoKTtcclxuXHRcdFx0dmFyIGF1ZGlvRml4ID0gdGhpcy5nYW1lLmFkZC5hdWRpbyhcImF1ZGlvRml4XCIpO1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQub25UYXAuYWRkKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRhdWRpb0ZpeC5wbGF5KCk7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5zdGFydCh0aGlzLnNldHRpbmdzLm1haW5fc3RhdGVfbmFtZSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHQvL3RoaXMuc3RhdGUuc3RhcnQodGhpcy5zZXR0aW5ncy5tYWluX3N0YXRlX25hbWUpOyAvLyBUaGUgXCJQbGF5XCIgY2FuIGFsc28gZG8gdGhpcy5cclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gUHJlbG9hZFN0YXRlO1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzA0LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGZpbGUgZXhpc3RzIHNvIHRoYXQgc3RhcnR1cCBvZiBhbiBlbmdpbmUgY2FuIGJlIGNvbnRyb2xsZWQuIFRoaXMgZmlsZSBpcyBzaW1wbHkgYSBzdHViIHRoYXQgd29ya3MgdG9cclxuICogYnVpbGQgdGhlIGVuZ2luZSBhbmQgdGhlbiBzdGFydCBpdC4gVGhpcyBtZWFucyB0aGF0IHRoZSBlbmdpbmUgY2FuIGJlIGxvYWRlZCB3aXRob3V0IGl0IHN0YXJ0aW5nIGZvclxyXG4gKiBwdXJwb3NlcyBvZiB0ZXN0aW5nLCBkZWJ1Z2dpbmcsIGFuZCBhZGRpbmcgYW55IGNvZGUgdGhhdCBjb21lcyB1cCB0aGF0IGhhcHBlbnMgYmVmb3JlL2FmdGVyIHRoZSBlbmdpbmUgaXNcclxuICogZG9uZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZW5naW5lL3NjZW5lLWVuZ2luZScpO1xyXG5cclxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXHJcbiAgICAgICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7fVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcbiAgICAgICAgICAgIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggJiYgdG9TdHJpbmcuY2FsbChzZWFyY2gpID09PSAnW29iamVjdCBSZWdFeHBdJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgLy8gYFRvSW50ZWdlcmBcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyAhPT0gcG9zKSB7IC8vIGJldHRlciBgaXNOYU5gXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB0aGUgYGluZGV4T2ZgIGNhbGwgaWYgbm8gbWF0Y2ggaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IHN0cmluZ0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzZWFyY2hMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoc3RhcnQgKyBpbmRleCkgIT09IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogc3RhcnRzV2l0aCxcclxuICAgICAgICAgICAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpO1xyXG4gICAgfVxyXG59KCkpO1xyXG4iXX0=
