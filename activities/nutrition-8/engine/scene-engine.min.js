(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SceneEngine = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js":[function(require,module,exports){
/*
  Based on Base.js 1.1a (c) 2006-2010, Dean Edwards
  Updated to pass JSHint and converted into a module by Kenneth Powers
  License: http://www.opensource.org/licenses/mit-license.php
*/
/*global define:true module:true*/
/*jshint eqeqeq:true*/
(function (name, global, definition) {
  if (typeof module !== 'undefined') {
    module.exports = definition();
  } else if (typeof define !== 'undefined' && typeof define.amd === 'object') {
    define(definition);
  } else {
    global[name] = definition();
  }
})('Base', this, function () {
  // Base Object
  var Base = function () {};

  // Implementation
  Base.extend = function (_instance, _static) { // subclass
    var extend = Base.prototype.extend;
    // build the prototype
    Base._prototyping = true;
    var proto = new this();
    extend.call(proto, _instance);
    proto.base = function () {
      // call this method from any other method to invoke that method's ancestor
    };
    delete Base._prototyping;
    // create the wrapper for the constructor function
    //var constructor = proto.constructor.valueOf(); //-dean
    var constructor = proto.constructor;
    var klass = proto.constructor = function () {
        if (!Base._prototyping) {
          if (this._constructing || this.constructor === klass) { // instantiation
            this._constructing = true;
            constructor.apply(this, arguments);
            delete this._constructing;
          } else if (arguments[0] !== null) { // casting
            return (arguments[0].extend || extend).call(arguments[0], proto);
          }
        }
      };
    // build the class interface
    klass.ancestor = this;
    klass.extend = this.extend;
    klass.forEach = this.forEach;
    klass.implement = this.implement;
    klass.prototype = proto;
    klass.toString = this.toString;
    klass.valueOf = function (type) {
      return (type === 'object') ? klass : constructor.valueOf();
    };
    extend.call(klass, _static);
    // class initialization
    if (typeof klass.init === 'function') klass.init();
    return klass;
  };

  Base.prototype = {
    extend: function (source, value) {
      if (arguments.length > 1) { // extending with a name/value pair
        var ancestor = this[source];
        if (ancestor && (typeof value === 'function') && // overriding a method?
        // the valueOf() comparison is to avoid circular references
        (!ancestor.valueOf || ancestor.valueOf() !== value.valueOf()) && /\bbase\b/.test(value)) {
          // get the underlying method
          var method = value.valueOf();
          // override
          value = function () {
            var previous = this.base || Base.prototype.base;
            this.base = ancestor;
            var returnValue = method.apply(this, arguments);
            this.base = previous;
            return returnValue;
          };
          // point to the underlying method
          value.valueOf = function (type) {
            return (type === 'object') ? value : method;
          };
          value.toString = Base.toString;
        }
        this[source] = value;
      } else if (source) { // extending with an object literal
        var extend = Base.prototype.extend;
        // if this object has a customized extend method then use it
        if (!Base._prototyping && typeof this !== 'function') {
          extend = this.extend || extend;
        }
        var proto = {
          toSource: null
        };
        // do the "toString" and other methods manually
        var hidden = ['constructor', 'toString', 'valueOf'];
        // if we are prototyping then include the constructor
        for (var i = Base._prototyping ? 0 : 1; i < hidden.length; i++) {
          var h = hidden[i];
          if (source[h] !== proto[h])
            extend.call(this, h, source[h]);
        }
        // copy each of the source object's properties to this object
        for (var key in source) {
          if (!proto[key]) extend.call(this, key, source[key]);
        }
      }
      return this;
    }
  };

  // initialize
  Base = Base.extend({
    constructor: function () {
      this.extend(arguments[0]);
    }
  }, {
    ancestor: Object,
    version: '1.1',
    forEach: function (object, block, context) {
      for (var key in object) {
        if (this.prototype[key] === undefined) {
          block.call(context, object[key], key, object);
        }
      }
    },
    implement: function () {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === 'function') {
          // if it's a function, call it
          arguments[i](this.prototype);
        } else {
          // add the interface using the extend method
          this.prototype.extend(arguments[i]);
        }
      }
      return this;
    },
    toString: function () {
      return String(this.valueOf());
    }
  });

  // Return Base implementation
  return Base;
});

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\inherits\\inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\jquery\\dist\\jquery.js":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js":[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel], false);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level, persist) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            if (persist !== false) {  // defaults to true
                persistLevelIfPossible(level);
            }
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function(persist) {
        self.setLevel(self.levels.TRACE, persist);
    };

    self.disableAll = function(persist) {
        self.setLevel(self.levels.SILENT, persist);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js":[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\process\\browser.js":[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\support\\isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\support\\isBufferBrowser.js","_process":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\process\\browser.js","inherits":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\inherits\\inherits_browser.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-channel.js":[function(require,module,exports){
/**
 * @author George Frick
 * Represent a playable set of sounds including a descriptive key, an audio sprite, and the set of sound keys.
 */
(function () {

    var _ = require('lodash');
    var Base = require('basejs');

    module.exports = Base.extend({
        constructor: function (key, sprite, sounds) {
            this.key = key;
            this.sprite = sprite;
            this.sounds = sounds; // json set of sounds.

            _.each(sounds, function (timing, key) {
                this.sprite.addMarker(key, timing[0], timing[1], 1, timing[2]);
            }, this);

            this.events = {
                onStop: new Phaser.Signal()
            };
            this.sprite.onStop.add(this.onSoundFinished, this);
        },
        allowMultiple: function() {
            this.sprite.allowMultiple = true;
        },
        isCurrentMarker: function(key) {
            return this.sprite.currentMarker === key;
        },
        isPlaying: function() {
            return this.sprite.isPlaying;
        },
        getKey: function() {
            return this.key;
        },
        getChannel: function() {
            return this.sprite;
        },
        hasKey: function( key ) {
            return !!(this.sounds[key]);
        },
        play: function( key ) {
            this.sprite.play(key);
        },
        stop: function() {
            this.sprite.stop();
        },
        stopNoEvent: function() {
            this.sprite.onStop.removeAll();
            this.sprite.stop();
            this.sprite.onStop.add(this.onSoundFinished, this);
        },
        onSoundFinished: function (stoppedSound, marker) {
            this.events.onStop.dispatch(stoppedSound, marker);
        },
        destroy: function() {
            this.sprite.onStop.removeAll();
            this.sprite.stop();
            this.sprite.destroy();
        }
    });

}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-service.js":[function(require,module,exports){
/**
 * @author George Frick
 * https://phasergames.com/phaser-audio-delay/
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');
    var AudioChannel = require('./audio-channel');
    var CHANNEL_PRIMARY = "primary";
    var CHANNEL_MUSIC = "secondary";
    var CHANNEL_SFX = "sfx";
    //var buildAudioLipSyncArray = require('../tools/audio-lip-sync'); //comment out when done

    var AudioService = Base.extend({
        constructor: function (game, themeData) {
            if (!game) {
                throw "AudioService requires game constructor argument.";
            }
            if (!themeData) {
                throw "AudioService requires themeData constructor argument.";
            }
            this.game = game;
            this.theme = themeData;
            this.audioQueue = [];
            this.channels = {};

            this.events = {
                soundFinished: new Phaser.Signal(),
                onSceneAudioReady: new Phaser.Signal()
            };
        },
        /**
         * If there is a scene showing, end it.
         * @TODO allow this to remove from cache?
         */
        stopAndUnload: function () {
            _.each(this.channels, function (channel) {
                channel.destroy();
            }, this);
        },
        // Stop the current scene and clean it up.
        stopScene: function () {
            if (this.channels[CHANNEL_PRIMARY]) {
                this.channels[CHANNEL_PRIMARY].stopNoEvent();
            }
            if (this.channels[CHANNEL_MUSIC]) {
                this.channels[CHANNEL_MUSIC].stop();
            }
            if (this.channels[CHANNEL_SFX]) {
                this.channels[CHANNEL_SFX].stop();
            }
        },
        /**
         * If something starts to play audio, it does it via an event, this allows for telling the other actors, the
         * scene, act and the play. In this case, we also want to stop any previously playing sound.
         * The current speech is always tracked so we can have eventing on when it stops.
         * @param data {
         *  text: "",
         *  "audio": "",
         *  "key": "",
         *  "channel": optional channel, defaults to primary, switched to sfx for sfx
         *  "priority": stop | restart | queue | low | with | stopall
         *  "stop":  => stop audio if playing the same sound.
         *  "restart":  Restart audio if playing the same sound.
         *  "queue": Queue the audio to play next, will play now if no queue.
         *  "low": Ignore request if sound is playing
         *  "stopall" : stopall sound, ignore audio key.
         *  default/interrupt: Interrupt the current sound and play the new one, emptying the queue.
         * }
         */
        playAudio: function (audio, data) {

            if (!data) {
                throw "data is required when calling playAudio";
            }

            if (!data.priority) {
                data.priority = "interrupt";
            }

            if (!data.channel) {
                data.channel = CHANNEL_PRIMARY;
            }

            if (!this.channels[CHANNEL_PRIMARY]) {
                throw "Attempting to play audio before game sounds are initialized.";
            }

            var channel = this.findChannelForKey(audio, data.channel);
            if (!channel ) {
                // Some activities play "silence", rather than adjusting the converted XML, we support it.
                if( audio === "silence" ) {
                    channel = this.channels[CHANNEL_PRIMARY];
                    data.priority = "stopall";
                } else {
                    throw "Request to play unknown key: " + audio;
                }
            }

            var gameSounds = this.channels[CHANNEL_PRIMARY];
            switch (data.priority) {
                case 'stopall': {
                    channel.stop();
                    this.audioQueue = [];
                    return;
                }
                case 'stop': {
                    // A stop is always a stop, so either stop or do nothing.
                    if (channel.isPlaying && channel.isCurrentMarker(audio) ) {
                        channel.stop();
                    }
                    return;
                }
                case 'restart': {
                    if (channel.isPlaying && channel.isCurrentMarker(audio)) {
                        channel.stop();
                    }
                    break;
                }
                case 'queue': {
                    if (channel.isPlaying() && !channel.isCurrentMarker(audio)) {
                        this.audioQueue.push(data);
                        return;
                    }
                    // Will fall through and play the sound.
                    break;
                }
                case 'low': {
                    if (channel.isPlaying()) {
                        return;
                    }
                    break;
                }
                case 'sfx': {
                    channel = this.findChannelForKey(audio, 'sfx');
                    if (!channel) {
                        throw "Request to play unknown sfx key: " + audio;
                    }
                    channel.play(audio);
                    return;
                }
                default:
                case 'interrupt': {
                    if (channel.isPlaying() && channel.isCurrentMarker(audio) ) {
                        // Already playing, just keep playing.
                        return;
                    }
                    channel.stop();
                    break;
                }
            }

            log.warn("Playing audio " + audio);
            channel.play(audio);
        },
        /**
         * Start by trying to get the preferred channel, but otherwise search.
         */
        findChannelForKey: function (key, preferredChannel) {
            var preferred = this.channels[preferredChannel];
            if (preferred && preferred.hasKey(key)) {
                return preferred;
            }
            return _.find(this.channels, function (channel) {
                return channel.hasKey(key);
            });
        },
        onGameMusic: function (audio) {
            this.channels[CHANNEL_MUSIC].play(audio);
        },
        /**
         * When audio finishes playing, actors need to know, in case they are animating speech/etc.
         */
        onSoundFinished: function (stoppedSound, marker) {
            log.warn("On sound Finished called for: " + marker);
            log.warn(stoppedSound);

            this.events.soundFinished.dispatch(stoppedSound, marker);

            if (this.audioQueue.length > 0) {
                var data = this.audioQueue.pop();
                this.playAudio(data.audio, data);
            }
        },
        initSounds: function () {
            // Uncomment this line and you will produce lip sync data.
            //buildAudioLipSyncArray(this.theme.soundFile[0], this.theme.sounds, this.theme.soundSyncData); //comment out when done
            this.channels[CHANNEL_PRIMARY] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_MUSIC] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_SFX] = new AudioChannel(this.theme.soundKey, this.game.add.audio(this.theme.soundKey), this.theme.sounds);
            this.channels[CHANNEL_PRIMARY].allowMultiple();
            this.channels[CHANNEL_MUSIC].allowMultiple();
            //this.gameSounds.onMarkerComplete.add(this.onSoundFinished, this); This event doesn't do what you think.
            this.channels[CHANNEL_PRIMARY].events.onStop.add(this.onSoundFinished, this);
        },
        /**
         * These three functions are the old loading functions used by play-act
         */
        loadAudio: function (soundKey, soundFile) {
            this.game.load.audio(soundKey, soundFile);
        },
        unloadAudio: function (soundKey) {
            this.game.cache.removeSound(soundKey);
        },
        isReady: function (soundKey) {
            return this.game.cache.isSoundDecoded(soundKey)
                && this.game.cache.isSoundReady(soundKey);
        },
        /**
         * These are the newer functions which show the loading screen during dynamic loading
         */
        showLoading: function () {
            this.game.loadingScreen.show();
        },
        loadAdditionalAudio: function (audioList) {
            if (audioList && audioList.length > 0) {
                this.showLoading();

                _.each(audioList, function (audioKey) {
                    var actorSoundData = this.theme.actorSounds[audioKey];
                    if (!actorSoundData) {
                        throw "No audio entry for audio key: " + audioKey;
                    }
                    // @TODO just go ahead and load the json as well so they don't need to be copied in!
                    this.game.load.audio(audioKey, actorSoundData.soundFile);
                }, this);

                this.audioList = audioList;
                this.game.load.onLoadComplete.addOnce(this.waitForAudioDecode, this);
                this.game.load.start();
            } else {
                this.debugOutput();
                this.events.onSceneAudioReady.dispatch(true);
            }
        },
        unloadAdditionalAudio: function (audioList) {
            if (audioList && audioList.length > 0) {

                _.each(audioList, function (audioKey) {
                   if( this.channels[audioKey] ) {
                       this.channels[audioKey].destroy();
                       delete this.channels[audioKey];
                       this.game.cache.removeSound(audioKey);
                   }
                }, this);
            }
        },
        waitForAudioDecode: function () {
            var allReady = true;

            this.game.loadingScreen.showDecoding();
            _.each(this.audioList, function (audioKey) {
                if (this.game.cache.checkSoundKey(audioKey) === false) {
                    // Scene was somehow destroyed before it finished loading it's audio.
                    return;
                }
                if (!this.game.cache.isSoundDecoded(audioKey) || !this.game.cache.isSoundReady(audioKey)) {
                    allReady = false;
                }
            }, this);

            if (allReady) {
                this.createChannels(this.audioList);
                this.audioList = null;
                this.game.loadingScreen.destroy();
                this.debugOutput();
                this.events.onSceneAudioReady.dispatch(true);
            } else {
                setTimeout(_.bind(this.waitForAudioDecode, this), 500);
            }
        },
        debugOutput: function() {
            // var channelNames = [];
            // var cacheNames = [];
            // _.each( this.channels, function(channel, key) {
            //     channelNames.push(key);
            // }, this);
            // _.each( this.game.cache.getKeys(Phaser.Cache.SOUND), function( key) {
            //     cacheNames.push(key);
            // }, this);
            // console.log( "Available Channels for scene: " + channelNames.join(", "));
            // console.log( "Available Channels in cache: " + channelNames.join(", "));
        },
        createChannels: function( audioList ) {
            _.each(audioList, function (audioKey) {
                var actorSoundData = this.theme.actorSounds[audioKey];
                if (!actorSoundData) {
                    throw "No audio entry for LOADED audio key: " + audioKey;
                }
                this.channels[audioKey] = new AudioChannel(audioKey, this.game.add.audio(audioKey), actorSoundData.sounds);
            }, this);
        }
    });

    module.exports = AudioService;
}());

},{"./audio-channel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-channel.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act-manager.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/22/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Return an act instance given a type.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
    PlayAct = require('./play-act');

    module.exports = {
        getActInstance: function (type, game, themeData, actName) {
            if( type && type !== "PlayAct" ) {
                var clazz = window[type];
                if( clazz ) {
                    var actInstance = new clazz(game,  themeData, actName);
                    actInstance.actName = actName; // make sure there is no funny business.
                    return actInstance;
                } else {
                    window.alert("Unable to load activity: " + type);
                }
            } else {
                return new PlayAct(game, themeData, actName);
            }
        }
    };
}());

},{"./play-act":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent an entire ACT. An act coordinates a set of scenes.
 */
(function () {
	var _ = require("lodash"),
		log = require("loglevel"),
		Base = require("basejs"),
		PlayScene = require("../scene/play-scene"),
		PlayAction = require("../scene/play-action"),
		PlayModel = require("../play/model"),
		ActValidator = require("./validator");
	var AudioService = require("./audio-service");

	var PlayAct = Base.extend({
		constructor: function (game, themeData, actName) {
			if (!game) {
				throw "PlayAct requires game constructor argument.";
			}
			if (!themeData) {
				throw "PlayAct requires themeData constructor argument.";
			}
			this.game = game;
			this.theme = themeData;
			this.actName = actName;
			this.audioService = new AudioService(this.game, this.theme);

			this.events = {
				onGameChoice: new Phaser.Signal(),
				onActStatus: new Phaser.Signal(),
			};

			this.isPreloaded = false;
		},
		setScormString: function (suspendData) {
			this.suspendData = suspendData;
		},
		getScormString: function () {
			return this.model.getSuspendData();
		},
		/**
		 * Show the current scene, clearing out any old scene. If there is a sound playing, stop it. This frees up
		 * memory, but in the future it could possibly recycle actors.
		 */
		start: function (isRestart) {
			log.warn("showCurrentScene called.");

			if (this.suspendData) {
				this.model.restoreData(this.suspendData);
				this.suspendData = null;
			}
			this.model.events.onGameOutcome.add(this.onGameOutcome, this);
			this.audioService.initSounds();
			this.audioService.events.onSceneAudioReady.add(
				this.onSceneStartAudioReady,
				this
			);
			this.audioService.events.soundFinished.add(this.onSoundFinished, this);

			if (isRestart) {
				log.warn("Trying to restart..." + this.model.getCurrentSceneName());
				this.model.tryResume();
				log.warn("....." + this.model.getCurrentSceneName());
			}
			this.startScene();
		},
		startScene: function () {
			var newSceneData = this.model.getCurrentScene();
			if (this.currentScene) {
				this.currentScene.showNewSceneData(newSceneData);
			} else {
				this.currentScene = new PlayScene(
					this.game,
					newSceneData,
					this.model.getVarInterface(),
					this.theme
				);
			}
			this.audioService.loadAdditionalAudio(
				this.currentScene.getAdditionalAudio()
			);
		},
		/**
		 * This is the other half of "startScene", which now waits for audio...
		 */
		onSceneStartAudioReady: function () {
			if (this.model.isShowPlayThrough()) {
				this.currentScene.showPlayThrough();
			}

			this.currentScene.events.onGameChoice.add(this.onGameChoice, this);
			this.currentScene.events.onGameSpeech.add(this.onGameSpeech, this);
			this.currentScene.events.onGameMusic.add(this.onGameMusic, this);
			this.currentScene.showScene();
			this.runSceneStartActions();
			this.events.onActStatus.dispatch("save");
		},
		/**
		 * When a scene starts, run any starting actions.
		 */
		runSceneStartActions: function () {
			var actions = this.currentScene.getActions();
			_.each(
				actions,
				function (singleAction) {
					log.warn("executing starting action:");
					log.warn(singleAction);
					PlayAction.getAction(singleAction).execute(this);
				},
				this
			);
			actions = this.model.getGlobalActions();
			_.each(
				actions,
				function (singleAction) {
					log.warn("executing starting global action:");
					log.warn(singleAction);
					PlayAction.getAction(singleAction).execute(this);
				},
				this
			);
			// The scene is done starting up, allow input.
			this.game.input.disabled = false;
		},
		/**
		 * If there is a scene showing, end it.
		 */
		stop: function () {
			this.audioService.stopAndUnload();

			// If we're not in a scene, then no input!
			this.game.input.disabled = true;
			if (this.currentScene) {
				this.currentScene.destroy();
				this.currentScene = null;
			}
			this.unload(); // remove everything that was preloaded.
		},
		// Stop the current scene and clean it up.
		stopScene: function () {
			this.audioService.stopScene();
			this.audioService.unloadAdditionalAudio(
				this.currentScene.getAdditionalAudio()
			);
			this.game.input.disabled = true;
			if (this.currentScene) {
				this.currentScene.clearForReuse();
			}
		},
		/**
		 * An outcome or starting action has set a variable (game choice). Other actors in the scene need to
		 * know about it.
		 * @param data
		 */
		onGameChoiceAction: function (data) {
			this.onGameChoice(data);
			if (!data.consumed) {
				this.currentScene.sendGameChoiceToActors("!ACTION!", data);
			}
		},
		/**
		 * Something in the game has made a choice. This choice is recorded as the setting of a variable, we then
		 * run an update in case that choice led to an action, (events bubble up, actions happen down)
		 * @param data
		 */
		onGameChoice: function (data) {
			log.warn("game choice");
			log.warn(data);

			this.events.onGameChoice.dispatch(data);
			if (data.consumed) {
				return;
			}

			var tempVars = _.pairs(data)[0];
			log.warn(tempVars);
			data.consumed = this.actCommand(tempVars[0], tempVars[1]);

			// Only record the variable if it wasn't a command, which does NOT consume it. It may result in an event,
			// otherwise, check for completed outcomes.
			if (!data.consumed) {
				var event = this.model.handleSpecialVar(tempVars[0], tempVars[1]);
				// var event = this.model.setVar(tempVars[0], tempVars[1]);
				if (event) {
					this.events.onActStatus.dispatch(event);
				}
				if (this.model.setVar(tempVars[0], tempVars[1])) {
					this.checkCurrentSceneOutcomes(tempVars[0]);
				}
			}
		},
		checkCurrentSceneOutcomes: function (variable) {
			this.model.checkForCompletedOutcomes(variable);
		},
		/**
		 * this function clears a variable out of the model manually. It should almost never be used.
		 * @param name
		 */
		clearVariable: function (name) {
			this.model.variables[name] = undefined;
		},
		/**
		 * Run an Act level command. Return true if a command happened, otherwise false.
		 * @param command
		 * @param arg
		 * @returns {boolean} true if the command was consumed.
		 */
		actCommand: function (command, arg) {
			log.warn("Act command: " + command + " / " + arg);
			if (command === "remove-actor" && this.currentScene) {
				this.currentScene.removeActorByName(arg);
			} else if (command === "add-actor" && this.currentScene) {
				this.currentScene.addActor(arg);
			} else if (
				command === "objective_complete" ||
				command === "activity_complete"
			) {
				// objective_complete => "finished this act", not a scorm objective.
				this.events.onActStatus.dispatch("complete");
				// objective => "finish a scorm objective"
			} else if (command === "objective") {
				this.events.onActStatus.dispatch("objective", arg);
			} else {
				return false;
			}
			return true;
		},
		/**
		 * If something starts to play audio, it does it via an event, this allows for telling the other actors, the
		 * scene, act and the play. In this case, we also want to stop any previously playing sound.
		 * The current speech is always tracked so we can have eventing on when it stops.
		 * @param data
		 */
		onGameSpeech: function (data) {
			log.warn("on game speech");
			log.warn(data);

			var audio = this.model.getValue(data.audio);
			if (data.key) {
				audio = this.model.getValue(data.key) + "_" + audio;
			}

			this.audioService.playAudio(audio, data);
		},
		onGameMusic: function (audio) {
			this.audioService.onGameMusic(audio);
		},
		/**
		 * When audio finishes playing, actors need to know, in case they are animating speech/etc.
		 */
		onSoundFinished: function (stoppedSound, marker) {
			// _tempMarker because currentMarker is now blank...
			if (this.currentScene) {
				this.currentScene.onGameSpeechStop(marker);
			}
		},
		/**
		 * The model has signaled that outcomes need to execute actions. Execute those actions.
		 * @param pendingActions
		 * Will look like:
		 * [
		 *  [ "outcome_1": [ { ACTION } , { ACTION } ],
		 *    "outcome_2": [ { ACTION } , { ACTION } ], ... ]
		 */
		onGameOutcome: function (pendingActions) {
			_.each(
				pendingActions,
				function (actionData) {
					log.warn("executing actions for " + actionData.name);
					_.each(
						actionData.actions,
						function (singleAction) {
							log.warn("executing action:");
							log.warn(actionData);
							PlayAction.getAction(singleAction).execute(this);
						},
						this
					);
				},
				this
			);
		},
		showNewScene: function (scene) {
			if (this.model.setCurrentScene(scene)) {
				this.stopScene();
				this.startScene();
			}
		},
		/**
		 * This returns the paths to everything, based on the theme/
		 * @returns {{textureKey: string, texture: string, textureMap: string, soundKey: string, soundFile: string}}
		 */
		getMediaData: function () {
			var soundFiles = null;
			if (this.theme.hasOwnProperty("soundFile")) {
				soundFiles = [];
				for (var i = 0; i < this.theme.soundFile.length; i++) {
					soundFiles[i] = this.game.config.assetPath + this.theme.soundFile[i];
				}
			}

			return {
				textureKey: this.theme.textureKey,
				texture: this.game.config.assetPath + this.theme.texture,
				textureMap: this.game.config.assetPath + this.theme.textureMap,
				soundKey: this.theme.soundKey,
				soundFile: soundFiles,
				dataFile: this.game.config.assetPath + this.theme.data,
				animations: this.theme.animations,
			};
		},
		/**
		 * Allow the current scene to perform timed operations. The size of a "tick" is defined in main.js, but think of
		 * it as a millisecond.
		 *
		 * STRONG WARNING: Don't do much here - it's called from the main update loop. Any extensive operations will
		 * cause the user interface to lag.
		 */
		tickUpdate: function (tick) {
			if (!(typeof this.currentScene === "undefined")) {
				this.currentScene.tickUpdate(tick);
			}
		},
		renderDebug: function () {
			//if( this.gameSounds  ) {
			//    this.game.debug.soundInfo(this.gameSounds, 10, 20);
			//}
		},
		preload: function () {
			if (!this.isPreloaded) {
				log.warn("!!! Called Preload in Act " + this.actName);
				this.mediaData = this.getMediaData();
				this.game.load.text(
					this.actName + "_scene_data",
					this.mediaData.dataFile
				);
				this.game.load.atlasJSONHash(
					this.mediaData.textureKey,
					this.mediaData.texture,
					this.mediaData.textureMap
				);
				if (this.mediaData.soundFile) {
					this.audioService.loadAudio(
						this.mediaData.soundKey,
						this.mediaData.soundFile
					);
				}
				if (this.mediaData.animations) {
					_.each(
						this.mediaData.animations,
						function (animationSet) {
							this.game.load.atlasJSONHash(
								animationSet.textureKey,
								animationSet.texture,
								animationSet.textureMap
							);
						},
						this
					);
				}
				this.isPreloaded = true;
			}
		},
		onPreloadFinished: function () {
			this.model = new PlayModel(
				JSON.parse(this.game.cache.getText(this.actName + "_scene_data"))
			);
			this.validator = new ActValidator(this.model.getRawData());
			this.validator.validate();
		},
		unload: function () {
			if (this.isPreloaded) {
				this.mediaData = this.getMediaData();
				this.game.cache.removeImage(this.mediaData.textureKey);
				if (this.mediaData.animations) {
					_.each(
						this.mediaData.animations,
						function (animationSet) {
							this.game.cache.removeImage(animationSet.textureKey);
						},
						this
					);
				}
				this.game.cache.removeText(this.mediaData.textureMap);
				this.game.cache.removeText(this.actName + "_scene_data");
				if (this.mediaData.soundFile) {
					this.audioService.unloadAudio(this.mediaData.soundKey);
				}
				this.isPreloaded = false;
			}
		},
		/**
		 * Check that sound has decoded.
		 */
		isPreloadComplete: function () {
			if (this.isPreloaded !== true) {
				return false;
			}
			/**
			 * @TODO GJF this was incorrect before, (act + "_..."), Was it being reached or just failing?
			 * Should the above line be removed/changed? (probably)
			 */
			if (!this.game.cache.getText(this.actName + "_scene_data")) {
				return false;
			}
			return (
				!this.mediaData.soundFile ||
				this.audioService.isReady(this.mediaData.soundKey)
			);
		},
		setStandAlone: function (isStandAlone) {},
	});

	module.exports = PlayAct;
})();

},{"../play/model":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\model.js","../scene/play-action":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-action.js","../scene/play-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-scene.js","./audio-service":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\audio-service.js","./validator":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\validator.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\validator.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A validator for the sceneData.json (act) file to make sure the basic
 * fields are there for each object.
 *
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    // A small validation model for a set of sceneData.
    var actValidationModel =
        {
            "play": {
                "description": "Top level container for all scene data",
                "validationModel": {
                    "start": { "description": "act.play.start specifies the starting scene."},
                    "scenes": { "description": "act.play.scenes specified all scenes." }
                }
            }
        };

    var sceneValidationModel = {
        "id": { "description": "Unique identifier for a scene." },
        "background": { "description": "Reference background image for a scene." },
        "actors": { "description": "Set of actors to add to a scene." },
        "outcomes": { "description": "Set of possible outcomes from a scene." }
    };

    var actorValidationModel = {
        "name": { "description": "Identifier for actor." },
        "type": { "description": "Type of actor to be created." }
    };

    var outcomeValidationModel = {
        "events": { "description": "Set of variables/value pairs that trigger the outcome." },
        "actions": { "description": "Array of actions to take when outcome is triggered." }
    };

    var ActValidator = Base.extend( {
        constructor: function( jsonData) {
            this.rawData = jsonData;
        },
        /**
         * run some basic validation on the available data.
         */
        validate: function() {
            if( ! this.rawData ) {
                throw "PlayModel requires game data constructor argument.";
            }

            var data = this.rawData;
            this.runActValidator( data, actValidationModel);
            _.each( data.play.scenes, function(scene) {
                this.runSceneValidator(scene, sceneValidationModel);
            },this);
            log.warn("Validation complete.");
        },
        runActValidator: function( entryPoint, validationModel ) {
            _.each( validationModel, function( toValidate, index ) {
                if( !entryPoint[index]) {
                    throw "Missing: " + toValidate.description;
                } else if( toValidate.validationModel ) {
                    this.runActValidator( entryPoint[index], toValidate.validationModel );
                }
            }, this);
        },
        runSceneValidator: function( entryPoint, validationModel ) {
            _.each( validationModel, function( toValidate, index ) {
                if( !entryPoint[index]) {
                    throw "Missing: " + toValidate.description;
                }
            }, this);
            _.each( entryPoint.actors, function (actor, actorIndex) {
                _.each( actorValidationModel, function( toValidate, index ) {
                    if( !actor[index]) {
                        throw "Missing: " + toValidate.description;
                    }
                }, this);
            }, this);
            _.each( entryPoint.outcomes, function (outcome, outcomeIndex) {
                _.each( outcomeValidationModel, function( toValidate, index ) {
                    if( !outcome[index]) {
                        throw "Missing: " + toValidate.description;
                    }
                }, this);
            }, this);
        }
    });

    module.exports = ActValidator;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/21/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 *  Draw a loading screen in Phaser. Expects resources to already be loaded.
 */
(function () {
	"use strict";
	var Base = require("basejs");

	var LoadingScreen = Base.extend({
		constructor: function (game, settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.loading_bg_color ||
				!settings.loading_text ||
				!settings.loading_font
			) {
				throw "Loading screen is missing a required configuration field.";
			}
			this.game = game;
			this.settings = settings;
			this.progress = 0;
			this.spinner = [".", "..", "...", "...."];
		},
		show: function () {
			// 1. Create solid background.
			this.bgColor = this.game.add.graphics(0, 0);
			this.bgColor.beginFill(this.settings.loading_bg_color);
			this.bgColor.drawRect(
				0,
				0,
				this.game.world.width,
				this.game.world.height
			);
			this.bgColor.endFill();
			this.bgColor.inputEnabled = true;
			this.game.input.disabled = true;

			// 2. Create a loading image/icon/splash
			this.splashImage = this.game.add.sprite(
				this.game.world.centerX,
				this.game.world.centerY,
				this.settings.loading_image_key
			);
			this.splashImage.anchor.setTo(0.5, 0);
			// this.splashImage.alpha = 0;
			// this.tween = this.game.add.tween(this.splashImage).to({alpha: 1}, 2000, "Linear", true, 0, -1);

			//  And this tells it to repeat, i.e. fade in again 10 times.
			//  The 1000 tells it to wait for 1 second before restarting the fade.
			// this.tween.yoyo(true, 1000);

			// 3. Add a progress indicator
			this.progressText = this.game.add.text(
				this.game.world.centerX,
				this.game.world.centerY,
				this.settings.loading_text,
				this.settings.loading_font
			);
			this.progressText.anchor.setTo(0.5, 0);

			var jointHeight = this.splashImage.height + this.progressText.height;
			this.splashImage.y = this.game.world.centerY - jointHeight / 2;
			this.progressText.y = this.splashImage.y + this.splashImage.height + 25;
			this.game.load.onFileComplete.add(this.fileComplete, this);
		},
		showComplete: function () {
			this.game.input.disabled = false;
			// https://phaser.io/docs/2.4.4/Phaser.Cache.html#onSoundUnlock
			// but can't use :-(
			if (this.game.device.desktop) {
				this.progressText.setText("");
			} else {
				this.progressText.setText("");
			}
			// this.progressText.setText("");
		},
		showClickthrough: function () {
			this.game.input.disabled = false;
			// https://phaser.io/docs/2.4.4/Phaser.Cache.html#onSoundUnlock
			// but can't use :-(
			if (this.game.device.desktop) {
				this.progressText.setText("Click here to begin.");
			} else {
				this.progressText.setText("Touch screen to begin.");
			}
			// this.progressText.setText("");
		},
		showDecoding: function () {
			//this.progressText.setText("Preparing Audio: " + this.getFakeProgress());
		},
		getFakeProgress: function () {
			//return this.spinner[this.progress++ % 4];
		},
		destroy: function () {
			this.game.input.disabled = false;
			// this.tween.stop();
			// this.tween.target = null; // disconnect from splash image.
			// this.tween = null;
			this.splashImage.cropEnabled = false;
			this.splashImage.destroy();
			this.splashImage = null;
			this.bgColor.destroy();
			this.bgColor = null;
			this.progressText.destroy();
			this.progressText = null;
			this.game.load.onFileComplete.removeAll();
		},
		fileComplete: function (
			progress,
			cacheKey,
			success,
			totalLoaded,
			totalFiles
		) {
			// this.progressText.setText(this.settings.loading_text + progress + "%");
		},
	});

	module.exports = LoadingScreen;
})();

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\model.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a Play as a model, this is the collection of scene data, etc.
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        util = require('util'),
        Base = require('basejs'),
        ModelRegistry = require('./models/model-registry'),
        NO_CHAR = "none";

    var PlayModel = Base.extend( {
        constructor: function( jsonData) {
            this.rawData = jsonData;

            if( !jsonData ) {
                throw "PlayModel requires game data constructor argument.";
            }

            if( !jsonData.play ) {
                throw "PlayModel has no play data.";
            }

            this.events = {
                onGameOutcome: new Phaser.Signal()
            };
            var modelClass = ModelRegistry.getModel(this.getModelType());
            this.dataModel = new modelClass();
            this.dataModel.setVar("start_scene", this.getDefaultSceneName());
            this.setPreviousSceneName( "!NONE!");
            this.setCurrentSceneName( this.getDefaultSceneName() );
            this.dataModel.setVar("default_scene_name", this.getDefaultSceneName());
        },
        getRawData: function() {
            return this.rawData;
        },
        getModelType: function() {
            // Default to "actnow", since that was the original and makes all play files backwards compatible.
          return this.rawData.play.modelType || "actnow";
        },
        /**
         * @returns the current scene object
         */
        getCurrentScene: function() {
            var scene = this.getSceneByName(this.getCurrentSceneName());
            if( !scene ) {
                log.error("getCurrentScene failed to return a scene.");
            }
            return scene;
        },
        getSceneByName: function( sceneName ) {
            if( !sceneName ) {
                return undefined;
            }
            return this.rawData.play.scenes[sceneName];
        },
        getGlobalActions: function() {
            var actions = [];
            if( this.rawData.play.global ) {
                actions = this.rawData.play.global.actions || [];
            }
           return actions;
        },
        getGlobalOutcomes: function() {
            if( this.rawData.play && this.rawData.play.global ) {
                return this.rawData.play.global.outcomes;
            }
            return null;
        },
        /**
         * Provide a an interface to the model that doesn't allow for anything but
         * read-only access. This returns a function that allows the referencing object
         * to use getValue
         * @returns {{getVar: Function}}
         */
        getVarInterface: function() {
            var that = this;
            return {
                getActorByRef: function( actorName ) {
                    return that.rawData.play.global.actors[actorName];
                },
                getValue: function( varName ) {
                    return that.getValue(varName);
                },
                clearValue: function( varName ) {
                    that.setVar(varName, null);
                }
            }
        },
        /**
         * Get a true value for a field that may be a variable.
         */
        getValue: function( varName ) {
            if( varName && typeof varName === 'string' && varName.indexOf('$') === 0 ) {
                return this.getVar(varName.substr(1));
            }
            return varName;
        },
        /**
         * Set a new scene in the model. This only affects tracking until getCurrentScene is called.
         * Attempting to switch to the same scene is ignored.
         * @param newSceneId
         * @returns {boolean} try is scene changed.
         */
        setCurrentScene: function( newSceneId ) {
            if( newSceneId ) {
                var newSceneName = this.getValue(newSceneId);
                if ( newSceneName !== this.getCurrentSceneName() && this.getSceneByName(newSceneName) ) {
                    var currentSceneName = this.getCurrentSceneName();
                    this.setCurrentSceneName(newSceneName);
                    this.setPreviousSceneName(currentSceneName);
                    return true;
                }
            } else {
                log.error("setCurrentScene called without newSceneId");
            }
            return false;
        },
        handleSpecialVar: function( variable, value ) {
            return this.dataModel.handleSpecialVar(variable, value);
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         */
        setVar: function( variable, value ) {
            return this.dataModel.setVar(variable, value);
        },
        getVar: function( variable ) {
            return this.dataModel.getVar(variable);
        },
        /**
         * Check for outcomes that were completed by changing a variable.
         * @param variable
         */
        checkForCompletedOutcomes: function( variable ) {
            log.warn("checking for completed outcome: " + variable);
            var scene = this.getCurrentScene(),
                gOutcomes = this.getGlobalOutcomes(),
                pendingActions = [];

            if( !scene.outcomes && !gOutcomes) {
                log.error("Scene with no outcomes in checkForCompletedOutcomes.");
                log.error(scene);
                return;
            }

            if( gOutcomes  ) {
                _.each(gOutcomes, function (outcome, outcomeName) {
                    log.warn("Checking global outcome: " + outcomeName);
                    if (this.checkOutcome(outcome, variable) === true) {
                        log.warn("Pending action on outcome: " + outcomeName);
                        pendingActions.push({"name": outcomeName, "actions": outcome.actions});
                    }
                }, this);
            }

            _.each( scene.outcomes, function(outcome, outcomeName) {
                 log.warn("Checking outcome: " + outcomeName);
                if( this.checkOutcome(outcome, variable) === true  ) {
                    log.warn("Pending action on outcome: " + outcomeName);
                    pendingActions.push( { "name": outcomeName, "actions": outcome.actions } );
                }
            },this);

            if( pendingActions.length > 0 ) {
                this.events.onGameOutcome.dispatch( pendingActions );
            }
        },
        /**
         * Check all of the variables in an outcome against the variables in the model.
         *
         * @param outcome object that should have 'events' object on it.
         * @variable This is the variable that changed, a variable involved in the outcome has to have changed.
         * @returns {boolean} true if the outcome is currently matches the model's state.
         */
        checkOutcome: function( outcome , variable ) {
            if( !outcome.events ) {
                return false;
            }
            var arrays = _.pairs( outcome.events),
                matched = true,
                answer,
                foundVar = false;
            _.each( arrays, function( singleVar ) {
                answer = this.getVar(singleVar[0]);
                // The outcome can only match if one of the variables involved is the one chat changed.
                if( singleVar[0] === variable ) {
                    foundVar = true;
                }
                matched = matched && this.matchSingleOutcome( answer, singleVar[1]);
            }, this );
            return matched && foundVar;
        },
        matchSingleOutcome: function( leftSide, rightSide ) {
            // log.warn("matchSingleOutcome: " + leftSide + " / " + rightSide);
            if( leftSide === null || leftSide === undefined ) {
                return (typeof rightSide === "string" && (rightSide[0] === '!' || rightSide === 'undefined'));
            }

            if( typeof rightSide === "string") {
                if( leftSide === rightSide || rightSide === '*' || (rightSide[0] === '!' && leftSide !== _.trim(rightSide,"!") ) ) {
                    return true;
                }

            } else if( typeof rightSide === "number" ) {
                if( parseInt(leftSide,10) === parseInt(rightSide,10) ) {
                    return true;
                }
            } else if(_.isArray( rightSide ) ) {
                var innerMatch = false;
                _.each( rightSide , function( singleRightSide ) {
                    innerMatch = innerMatch || this.matchSingleOutcome(leftSide, singleRightSide);
                }, this);
                return innerMatch;
            }

            return false;
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: SCENE,[... depends on data model]
         * SCENE = current scene. Handle the scene at the base model level because we always store scene, regardless
         * of current activity.
         */
        restoreData: function (suspendData) {
            log.warn(suspendData);
            if (suspendData) {
                this.dataModel.restoreData( suspendData );
            }
        },
        /**
         * calling this will attempt to divert the model to setting the current scene to the
         * special resume scene. The current scene will be saved as the 'restore' scene.
         */
        tryResume: function() {
            if ( this.getCurrentSceneName() !== this.getDefaultSceneName() && this.getResumeScene() ) {
                log.warn(this.getCurrentSceneName());
                this.setCurrentSceneName( this.getResumeScene() );
            }
        },
        getResumeScene: function() {
            return this.rawData.play.resume;
        },
        getSuspendData: function () {
            return this.dataModel.getSuspendData(this.getPersistList());
        },
        /**
         * Clear out any saved choices to undefined. currently this involves which characters the
         * player selected.
         */
        clearSavedChoices: function() {
            this.dataModel.clearSavedChoices();
        },
        isShowPlayThrough: function() {
            return this.rawData && this.rawData.play && this.rawData.play.showPlayThrough;
        },
        getDefaultSceneName: function() {
            return this.rawData.play.start;
        },
        getPersistList: function() {
            return this.rawData.play.persist;
        },
        getCurrentSceneName: function() {
            return this.dataModel.getVar("current_scene_name");
        },
        setCurrentSceneName: function( sceneName ) {
            this.dataModel.setVar("current_scene_name", sceneName);
        },
        setPreviousSceneName: function( sceneName ) {
            this.dataModel.setVar("previous_scene_name", sceneName);
        }
    });

    module.exports = PlayModel;
}());

},{"./models/model-registry":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\model-registry.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","util":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\actnow.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a specific Play Model strategy for a set of courses/activities.
 *
 * PA = Participate
 * DI = Discourage
 * AL = Allow
 * EN = Encourage
 * PR = Prevent
 * XX = Unanswered
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        util = require('util'),
        Base = require('basejs'),
        NO_CHAR = "none";

    var ActNowData = Base.extend( {
        constructor: function() {

            this.variables = {
                "score": 0,
                "playThrough": 1,
                "decisionsCurrent": ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"],
                "decisionsPrevious": ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"],
                "phoneRingerIndex": 0,
                "phoneBgIndex": 0
            };

            this.scores = {
                "PA": -2,
                "DI": 1,
                "AL": 0,
                "EN": -1,
                "PR": 2,
                "XX": 0
            };

        },
        /**
         * This is the special behavior for actnow based acts which expect decision points
         * and special act_complete / complete variables.
         * @param variable
         * @param value
         * @returns {*}
         */
        handleSpecialVar: function( variable, value ) {
            var returnValue = null;
            if( variable.substr(0,2) === "dp" ) {
                this.recordDecision(variable, value);
                returnValue = "save";
            } else if( variable === "act_complete" ) {
                this.clearSavedChoices();
                if( this.incrementPlaythrough(value) ) {
                    returnValue = "complete";
                }
            }
            return returnValue;
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         * Returns TRUE if the variable was changed.
         */
        setVar: function( variable, value ) {
            //log.warn("Set Variable: " + variable + " = " + value);
            if( variable === "score" ) {
                this.variables["score"] += parseInt(value,10);
                return true;
            } else if( this.variables[variable] !== value )  {
                // Do not act on a value staying the same.
                this.variables[variable] = value;
                return true;
            }
            return false;
        },
        getVar: function( variable ) {
            return this.variables[variable];
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: [playThrough,char1,char2,char3,1|2|3|4|5|6|7|8|9,1|2|3|4|5|6|7|8|9,1|2|3|4|5|6|7|8|9]
         * 1|2|3|4|5|6|7|8|9 = answers per play through.
         */
        restoreData: function (unparsedSuspendData) {
            log.warn(unparsedSuspendData);
            var  splitData = unparsedSuspendData.split(",");
            this.variables['current_scene_name'] = splitData[0];
            var suspendData = _.drop(splitData,1);
            if (suspendData) {
                this.variables.playThrough = parseInt(suspendData[0], 10);
                this.variables['character_1'] = this.resolveCharacter(suspendData[1]);
                this.variables['character_2'] = this.resolveCharacter(suspendData[2]);
                this.variables['character_3'] = this.resolveCharacter(suspendData[3]);
                this.variables.decisionsPrevious = suspendData[4].split("|");
                this.variables.decisionsCurrent = suspendData[5].split("|");
                this.variables.score = 0;
                _.each( this.variables.decisionsCurrent , function(score) {
                    this.variables.score += this.convertToPoints(score);
                }, this);
            }
        },
        /**
         * Unchosen characters are saved as NO_CHAR, resolve them back to 'undefined' or their
         * actual value.
         */
        resolveCharacter: function( value ) {
            if( value === NO_CHAR ) {
                return undefined;
            } else {
                return value;
            }
        },
        convertToPoints: function(str) {
            if( this.scores[str] !== undefined ) {
                return this.scores[str];
            }
            return "0";
        },
        getSuspendData: function (persistList) {
            // persistList is not used in ActNow!, which has a fixed set of saves.
            var character1 = this.variables['character_1'] || NO_CHAR,
                character2 = this.variables['character_2'] || NO_CHAR,
                character3 = this.variables['character_3'] || NO_CHAR;

            var suspendData = this.variables['current_scene_name']
                + "," + this.variables.playThrough
                + "," + character1
                + "," + character2
                + "," + character3
                + "," + this.variables.decisionsPrevious.join("|")
                + "," + this.variables.decisionsCurrent.join("|");
            log.warn(suspendData);
            return suspendData;
        },
        recordDecision: function (dp, answer) {
            log.warn("Recording decision " + dp + " / " + answer);
            var dIndex = parseInt(dp.substr(2), 10);
            this.variables.decisionsCurrent[dIndex-1] = answer;
            this.variables.score += this.scores[answer];
        },
        /**
         * Increase the playthrough count, optionally marking this act complete.
         * This function assumes the numbers may be strings, and forces them to numbers.
         * @param completeCount optional value at which to mark the act complete.
         */
        incrementPlaythrough: function( completeCount ) {
            log.warn("increasing play through");
            if( !completeCount ) {
                throw "You must provide a complete count.";
            }
            var completed = false;
            this.variables.playThrough = parseInt(this.variables.playThrough, 10);

            completeCount = parseInt(completeCount,10);

            // If we've completed the desired number of play throughs, mark complete.
            if( this.variables.playThrough === completeCount ) {
                log.warn("Target playthroughs reached");
                this.variables.playThrough = 0;
                completed = true;
            }

            // Now go to the next playThrough.
            this.variables.playThrough++;
            this.variables['current_scene_name'] = this.variables['default_scene_name'];
            // Copy the decision points and start a new set.
            this.variables.decisionsPrevious = this.variables.decisionsCurrent;
            this.variables.decisionsCurrent =  ["XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX", "XX"];
            return completed;
        },
        /**
         * Clear out any saved choices to undefined. currently this involves which characters the
         * player selected.
         */
        clearSavedChoices: function() {
            this.variables['character_1'] = undefined;
            this.variables['character_2'] = undefined;
            this.variables['character_3'] = undefined;
        }
    });

    module.exports = ActNowData;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","util":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\util\\util.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\basic.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 10/30/2017
 * Copyright 2017 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a specific Play Model strategy for a set of courses/activities.
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    var BasicData = Base.extend( {
        constructor: function() {
            this.variables = {
                score: 0
            };
        },
        /**
         * This is where you would implement special behavior for a custome model strategy.
         * You can return an event string from this and it will be dispatched.
         */
        handleSpecialVar: function( variable, value ) {
           return null;
        },
        /**
         * Something has changed in the model. If a variable changes, the state
         * of the act might change, so ignore a value staying the same.
         */
        setVar: function( variable, value ) {
            //log.warn("Set Variable: " + variable + " = " + value);
            if( variable === "score" ) {
                this.variables["score"] += parseInt(value,10);
                return true;
            } else if( this.variables[variable] !== value )  {
                // Do not act on a value staying the same.
                this.variables[variable] = value;
                return true;
            }
            return false;
        },
        getVar: function( variable ) {
            var temp = this.variables[variable];
            return temp;
        },
        /**
         * Handle data that already existed in SCORM.
         * Data looks like: [VAR:VALUE|VAR:VALUE]
         */
        restoreData: function (suspendData) {
            if( suspendData ) {
                var suspendSet = suspendData.split("|");
                var pair;
                _.each(suspendSet, function (valuePair) {
                    pair = valuePair.split(":");
                    if (pair.length === 2 && pair[1] !== 'undefined' && pair[1] !== "null") {
                        this.variables[pair[0]] = pair[1];
                    }
                }, this);
                log.warn(suspendData);
                if (suspendData) {
                    this.variables.score = 0;
                }
            }
        },
        /**
         * For the basic model, save everything that it's told to save.
         * @param persistList
         * @returns {string}
         */
        getSuspendData: function (persistList) {
            var suspendData = "";
            var suspendEntries = [];
            _.each( persistList, function( keyValue ) {
                // only save defined variables.
                if( this.variables[keyValue] ) {
                    suspendEntries.push(keyValue + ":" + this.variables[keyValue]);
                }
            }, this);
            if( suspendEntries.length > 0 ) {
                suspendData = suspendEntries.join("|");
            }
            return suspendData;
        }
    });

    module.exports = BasicData;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\model-registry.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/11/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a registry and construction factory for Model Strategies; which should not be instantiated on their own, only
 * from this creation point.
 */
(function () {
    'use strict';
    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    var ActNow = require('./actnow');
    var Basic = require('./basic');

    var ModelRegistry = Base.extend( {
        constructor: function() {
            this.models = {};
            this.modelTypes = [];
        },
        registerModel: function( type, model ) {
            _.each( this.modelTypes, function(knownType) {
                if( knownType === type ) {
                    throw "You are registering a model type that already exists: " + type;
                }
            });
            this.modelTypes.push(type);
            this.models[type] = model;
        },
        getModel: function( type ) {
            log.warn("Returning model of type: " + type);
            return this.models[type];
        },
        isAvailableType: function(type) {
            var found = false;
            _.each( this.modelTypes, function(knownType) {
                if( knownType === type ) {
                    found = true;
                }
            });
            return found;
        },
        getAvailableTypes: function() {
            // Return a clone, to make it read only.
            return _.clone(this.modelTypes);
        }
    });

    var ModelFactory = new ModelRegistry();

    /* General Actors, or reusable across courses */
    ModelFactory.registerModel("actnow", ActNow );
    ModelFactory.registerModel("basic", Basic );

    module.exports = ModelFactory;
}());

},{"./actnow":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\actnow.js","./basic":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\models\\basic.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\play.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 2.0.0
 * @creation 10/27/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the top level controller for the scene engine, Play->Act(s)->Scene(s)->Actors
 * The Play object manages all of the Acts in a Play, showing one act at a time and accepting events from Act objects.
 *
 * The general idea is that an Act is allowed to use the game object for drawing to the screen, sound, and I/O. There
 * can be more than one act instantiated, and they are stacked on top of each other (z-index). Each Act is responsible
 * for cleaning itself up and removing from the game anything it added. An Act must only conform to the act interface,
 * it does not have to be a play-scene.
 *
 * If any of the acts have objectives, then the entire play (scorm activity) will not be marked complete until all
 * objective acts have reported as completed. If no acts have objectives, then the entire play will be marked complete
 * when the default act reports complete.
 *
 * This what the configuration should look like. In the general case, this will come from phaser. But you could just
 * pass a configuration object in.
 * {
 *   "name": "Name of the play",
 *   "description": "You may use this line as in-data documentation.",
 *   "scorm": true|false,
 *   "logging": true|false,
 *   "acts": {
 *     "default": { // You MUST have an act called 'default' !
 *       "id": "default", // this is an internal ID used to store things in the phaser cache. It should be unique among acts.
 *       "description": "Every set of acts has a default, which is the act that is started by default.",
 *       "name": "Grade 6 Act Now!",
 *       "data": "media/sceneData.json",
 *       "theme": "media/theme.json",
 *       "objective": "x", // Optional, object to complete when act is complete
 *       "objectives": [ "a", "b", c"] // optional, may still have "objective" as well.
 *       "type": "scene" // optional, defaults to "scene", specifies what type of Act to instantiate.
 *     },
 *     "act2": {
 *       "id": "act2",
 *       "description": "this is the exciting second act!",
 *       "name": "Act Two!",
 *       "data": "media/sceneData.json",
 *       "theme": "media/theme.json"
 *     },
 *     ...
 *   }
 * }
 */
(function () {
	"use strict";
	var log = require("loglevel"),
		_ = require("lodash"),
		Base = require("basejs"),
		ActManager = require("../act/play-act-manager"),
		ScormService = require("./scorm-service");

	var OBJECTIVE_PREFIX = "objective_";

	var Play = Base.extend({
		/**
		 * Creations of the Play object, requiring both a Phaser game and a configuration object (JSON)
		 * the configuration should include a name, description and a set of acts. The acts MUST include
		 * an act labelled 'default'.
		 */
		constructor: function (game, config, settings) {
			if (!game || !config || !settings) {
				throw "Creating a Play requires a Phaser game instance, configuration object and settings.";
			}
			if (!config.acts) {
				throw "There is no 'acts' field in the play.json";
			}
			this.game = game;
			this.config = config;
			this.playActSet = config.acts;
			this.settings = settings;
			this.actInstances = {};
			this.previousAct = null;
			this.waitingOn = [];
			this.scormService = new ScormService(
				this.game.scorm,
				this.settings,
				this.playActSet
			);

			this.commands = {
				change_act: "change_act",
				mute_game: "mute_game",
				mute_game_on: "mute_on",
				save: "save",
				complete: "complete",
				objective: "objective",
			};

			if (!this.playActSet[this.settings.default_act_name]) {
				throw "Play could not start. You do not have a default ACT. See play.js header.";
			}

			if (config.autoScale) {
				this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
			}
		},
		/**
		 * Set the Default Act as the next Act.
		 */
		selectDefaultAct: function () {
			this.selectNextAct(this.settings.default_act_name);
		},
		/**
		 * Creates or looks up an existing Act. Any currently running Act will
		 * be stopped. When a new Act is created, it is cached.
		 * This does NOT start the Act, after selectNextAct(), startNextAct() must be called.
		 * @param actName Name of Act from Play.json to start.
		 */
		selectNextAct: function (actName) {
			// Exit any current act.
			if (this.currentAct) {
				// the default act should not be stopped.
				if (this.currentAct.actName !== this.settings.default_act_name) {
					this.currentAct.stop();
				}
				this.previousAct = this.currentAct;
			}

			// Don't create an act that already exists.
			if (this.actInstances[actName]) {
				this.currentAct = this.actInstances[actName];
				this.currentAct.setScormString(this.playActSet[actName].suspendData);
				return;
			}

			// Look up and create an Act that doesn't exist.
			var nextActData = this.playActSet[actName];
			var nextActTheme = JSON.parse(
				this.game.cache.getText(this.settings.theme_prefix + nextActData.id)
			);
			if (this.config.autoScale) {
				// If autoScale is set to true in the play.json file add a property to the theme to smuggle it into the act for use by actors, who do not have access to the play.json settings. For example, the WISTIA actor sizes the video div differently according to the autoScale setting.
				nextActTheme.internal_autoScale = true;
			}

			this.currentAct = ActManager.getActInstance(
				nextActData.type,
				this.game,
				nextActTheme,
				actName
			);
			// Only the default Act counts as stand alone.
			if (this.currentAct.setStandAlone) {
				this.currentAct.setStandAlone(
					actName === this.settings.default_act_name
				);
			}
			// Subscribe to all events.
			this.currentAct.events.onGameChoice.add(this.onGameChoiceEvent, this);
			this.currentAct.events.onActStatus.add(this.onActStatusEvent, this);
			// Restore the Act from the "Save" point.
			this.currentAct.setScormString(nextActData.suspendData);
			this.actInstances[actName] = this.currentAct;
		},
		/**
		 *  This is the hook into restarting the main Phaser state and launching a new Act.
		 *  The new Act should have already been selected using selectNextAct().
		 *  This will lead to showAct() being called from the main state.
		 */
		startNextAct: function (isRestart) {
			this.game.state.restart(false, false, isRestart); // true, false means "clear world, keep cache"
		},
		/**
		 * This functional will actually start an act up, and then provide it with information on the other acts.
		 * It will tell an act which previous act exited, allowing an act to know both which act came before and
		 * that it isn't first.
		 * Second, it will inform a non-first act if the previous acts objective status (act_exited + objective status)
		 * For a first (Default) act, the status of every other act objective will be passed in, but only if that
		 * act is tracking by objective.
		 * @param isRestart
		 */
		showNextAct: function (isRestart) {
			if (!this.currentAct) {
				throw "No current Act to start!";
			}

			var singleActData = this.playActSet[this.currentAct.actName];

			// If we have an objective, it may need to be marked as started.
			this.scormService.markActStarted(singleActData.id);

			// There is no need to start the default act, it's not stopped. But this may be the first call.
			if (
				!this.previousAct ||
				this.currentAct.actName !== this.settings.default_act_name
			) {
				if (this.currentAct.onPreloadFinished) {
					this.currentAct.onPreloadFinished();
				}
				this.currentAct.start(isRestart);
			}
		},
		/**
		 * This will send variables to the current act from the previous or all acts, so when the default
		 * act starts, it will know about all tracked objective variables in other acts.
		 */
		sendCrossActVariables: function () {
			var objectiveSet = [];
			var temp;

			if (this.previousAct) {
				this.currentAct.onGameChoice({ act_exited: this.previousAct.actName });
				var previousActData = this.playActSet[this.previousAct.actName];
				objectiveSet = this.scormService.getActObjectiveStatusSet(
					previousActData.id
				);
			} /* default act */ else {
				objectiveSet = this.scormService.getPlayObjectiveStatusSet();
			}
			_.each(
				objectiveSet,
				function (eachObjective) {
					temp = {};
					temp[OBJECTIVE_PREFIX + eachObjective.getId()] =
						eachObjective.getStatus();
					this.currentAct.onGameChoice(temp);
				},
				this
			);
		},
		/**
		 * The player made a game choice. This may be a special command for the Play.
		 * Attempt to execute it, and allow the execution to determine if the event was
		 * consumed.
		 * @param eventPair
		 */
		onGameChoiceEvent: function (eventPair) {
			var tempVars = _.pairs(eventPair)[0];
			eventPair.consumed = this.playCommand(tempVars[0], tempVars[1]);
		},
		/**
		 * The player caused a status event; usually either a save or a completion of an activity. These aren't
		 * caued by player's directly, but by the Scenes/Acts.
		 * "act_complete" -> increment playthrough -> "complete" status event.
		 * @param eventCommand
		 */
		onActStatusEvent: function (eventCommand, eventArg) {
			if (eventCommand === this.commands.save) {
				this.saveScormData();
			} else if (eventCommand === this.commands.complete) {
				this.scormService.handleActComplete(this.currentAct.actName); // actName === actId
			} else if (eventCommand === this.commands.objective) {
				this.scormService.markObjectiveComplete(eventArg);
				this.saveScormData();
			}
		},
		/**
		 * Execute a Play level command, such as saving or changing acts.
		 * Returns true if it consumes the command/choice.
		 */
		playCommand: function (command, arg) {
			log.warn("play command: " + command + " / " + arg);
			if (command === this.commands.change_act) {
				log.warn("Changing act to " + arg);
				if (this.playActSet[arg]) {
					this.selectNextAct(arg);
					this.startNextAct(true);
				} else {
					log.error("Request to change to non-existant act: " + arg);
				}
			} else if (command === this.commands.save) {
				this.saveScormData();
			} else if (command === this.commands.mute_game) {
				// GJF - 09/20/17 - I may have just broke mute for all past activities by fixing this line.
				this.game.sound.mute =
					arg === this.commands.mute_game_on ? true : false;
				return false; // Return false because this isn't 'consuming', it's a side effect special case.
			} else {
				return false;
			}
			return true;
		},
		/**
		 * Load the theme and data files for each act in play.json
		 * This used to "preload", but now it returns a set, the play is no longer responsible for loading
		 * resources.
		 * This can't be done for the act because it would break backwards compatibility :-(
		 */
		getRequiredResourceList: function () {
			var preloadSet = [];
			_.each(
				this.getActsList(),
				function (act) {
					log.warn(
						"loading text " +
							act.theme +
							" as " +
							(this.settings.theme_prefix + act.id)
					);
					preloadSet.push({
						key: this.settings.theme_prefix + act.id,
						file: this.game.config.assetPath + act.theme,
						type: "json",
					});
				},
				this
			);
			return preloadSet;
		},
		/**
		 * When the main Phaser state is restarted, during the Phaser preload function, this preload will be called
		 * so that the new Act has a valid entry point to loading assets. The Act can load any resources necessary.
		 */
		preloadAct: function () {
			if (this.currentAct) {
				this.currentAct.preload();
			}
		},
		/**
		 * The act determines when it is done loading, so when asked, delegate to the Act.
		 */
		isPreloadActComplete: function () {
			return this.currentAct && this.currentAct.isPreloadComplete();
		},
		isLogging: function () {
			return this.config && this.config.logging === true;
		},
		getActsList: function () {
			return this.playActSet;
		},
		isScormEnabled: function () {
			return this.config && this.config.scorm === true;
		},
		renderDebug: function () {
			if (this.currentAct && this.settings.debug === true) {
				this.currentAct.renderDebug();
			}
		},
		/**
		 * this is the game loop. If the act is a game, or has a delay, or needs to do timing, it SHOULD NOT
		 * use its own update function, but should instead provide a tickUpdate. This will be called here so
		 * that the update() calls are controlled from the play.
		 * @param time
		 */
		tickUpdate: function (time) {
			if (this.currentAct) {
				this.currentAct.tickUpdate(this.game.time.now);
			}
		},
		loadScormData: function () {
			this.scormService.loadScormObjectiveData();
			this.scormService.loadScormSuspendData();
		},
		saveScormData: function () {
			this.scormService.saveScormObjectiveData();
			var scormString = this.currentAct.getScormString();
			if (scormString && scormString.length > 0) {
				this.scormService.saveScormSuspendData(
					this.currentAct.actName,
					scormString
				);
			}
		},
	});

	module.exports = Play;
})();

},{"../act/play-act-manager":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\act\\play-act-manager.js","./scorm-service":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\scorm-service.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\scorm-service.js":[function(require,module,exports){
/**
 * Represent the set of scorm operations that are required by a Play. This involves the saving, loading and updating
 * of all objectives and suspend data.
 *
 * This service does not handle game events or send game notifications to acts/scenes/etc. It only manages scorm
 * related data as required.
 */
(function () {
    'use strict';
    var log = require('loglevel');
    var _ = require('lodash');
    var Base = require("basejs");

    var STATUS_NOT_ATTEMPTED = "not attempted";
    var STATUS_ATTEMPTED = "incomplete";
    var STATUS_COMPLETED = "completed";

    var ScormObjective = Base.extend({
        constructor: function( actId, index, id, status ) {
            this.actId = actId;
            this.index = index;
            this.id = id;
            this.status = status;
        },
        setStatus: function( newValue ) {
            this.status = newValue;
        },
        getStatus: function() {
            return this.status;
        },
        getId: function() {
            return this.id;
        },
        getIndex: function() {
            return this.index;
        },
        getActId: function() {
            return this.actId;
        }
    });

    var ScormService = Base.extend({
        constructor: function (scorm, settings, playActSet) {
            if (!scorm || !settings || !playActSet) {
                throw "You must provide an interface to scorm and settings.";
            }
            this.scorm = scorm;
            this.settings = settings;
            this.playActSet = playActSet;
            this.objectiveSet = [];
        },
        markActStarted: function (actId) {
            _.each( this.getActObjectiveStatusSet(actId), function(objective) {
                if (objective.getStatus() !== STATUS_COMPLETED) {
                    objective.setStatus(STATUS_ATTEMPTED);
                    this.saveObjective(objective);
                }
            }, this);
        },
        markObjectiveComplete: function( objectiveId ) {
            var objective = _.findWhere( this.objectiveSet, { id: objectiveId});
            if( objective ) {
                objective.setStatus(STATUS_COMPLETED);
                this.saveObjective(objective);
                this.checkPlayComplete();
            }
        },
        getActObjectiveStatusSet: function (actId) {
            return _.where(this.objectiveSet, {actId: actId});
        },
        getPlayObjectiveStatusSet: function () {
           return this.objectiveSet;
        },
        playHasObjectives: function() {
           return (this.objectiveSet.length > 0);
        },
        /**
         * This should be private, it's part of the startup of this service and outside sources should not access
         * the raw data like this; which is in json that should be considered read only.
         * This builds a raw list of objective names based on every act in the play data.
         */
        getRawObjectiveList: function( actData ) {
          var objectList = [];
          if( actData.objective ) {
              objectList.push(actData.objective);
          }
          if( actData.objectives ) {
              objectList = objectList.concat(actData.objectives);
          }
          return objectList;
        },
        /**
         * This will load or initialize an objective object for every objective in the play. It will initialize
         * the object with SCORM if it hasn't been previously initialized.
         */
        loadScormObjectiveData: function() {
            var objectiveIndex = 0;
            var existingObjective;
            var actObjectiveList;
            var newObjective;

            _.each( this.playActSet, function( singleAct ) {
                actObjectiveList = this.getRawObjectiveList(singleAct);
                _.each( actObjectiveList, function( eachObjective ) {
                    newObjective = new ScormObjective(singleAct.id, objectiveIndex, eachObjective, STATUS_NOT_ATTEMPTED);
                    existingObjective = this.loadObjective(objectiveIndex);

                    // Already existed, otherwise we wouldn't have a matching id!
                    if( existingObjective.status && existingObjective.id === newObjective.getId() ) {
                        newObjective.setStatus(existingObjective.status);
                    } else {
                        this.saveObjective(newObjective);
                    }
                    objectiveIndex++;
                    this.objectiveSet.push(newObjective);
                }, this);

            }, this);
        },
        saveScormObjectiveData: function() {
            // Scorm objectives are not regularly saved.
        },
        loadScormSuspendData: function() {
             var scormData = this.scorm.getSuspendData() || "";
            var index = 0;
            log.warn(scormData);

            scormData = scormData.split(this.settings.scorm_separator_char);

            _.each( this.playActSet, function( singleAct ) {
                singleAct.suspendData = scormData[index] || "";
                index++;
            }, this);
        },
        saveScormSuspendData: function( actId, scormString ) {
            var scormData = [];
            var saveString;

            this.playActSet[actId].suspendData = scormString;

            _.each( this.playActSet, function(singleAct) {
                scormData.push(singleAct.suspendData);
            }, this);

            saveString = scormData.join(this.settings.scorm_separator_char);
            log.warn(saveString);
            this.scorm.setSuspendData(saveString);
        },
        /**
         * An act complete event has been sent, generally meaning "complete the only objective for this act".
         * If there is more than on objective in the act, this function only checks for 'all complete'.
         *
         * In "Act Now", both "objective_complete" and "act_complete" would lead to this. For non-actnow, currently
         * only "objective_complete" will lead to this, but other models may act differently. This depends on a
         *  "complete" act-status event.
         * @param actId
         */
        handleActComplete: function(actId) {
            var actObjectives = [];
            if( this.playHasObjectives() ) {
                actObjectives =  this.getActObjectiveStatusSet(actId);

                // There is only one objective, so mark it complete.
                if( actObjectives.length === 1 ) {
                    actObjectives[0].setStatus(STATUS_COMPLETED);
                    this.saveObjective(actObjectives[0]);
                }
                this.checkPlayComplete();
            } else {
                // No objectives - you're done!
                this.scorm.markComplete();
            }
        },
        checkPlayComplete: function() {
            var allComplete = true;
            _.each( this.objectiveSet, function(objective) {
                if( objective.getStatus() !== STATUS_COMPLETED ) {
                    allComplete = false;
                }
            }, this);
            if( allComplete ) {
                this.scorm.markComplete();
            }
        },
        loadObjective: function( objectiveIndex ) {
            return this.scorm.getObjective(objectiveIndex);
        },
        saveObjective: function( objective ) {
            this.scorm.setObjective(objective.getIndex(), objective.getId(), objective.getStatus());
        }
    });

    module.exports = ScormService;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene-engine.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 */
(function () {
	var BootState = require("./states/boot.js"),
		PreloadState = require("./states/preload.js"),
		MainState = require("./states/main.js"),
		Scorm = require("./scorm");

	module.exports = function (domElement, width, height) {
		var config = {
			width: width,
			height: height,
			renderer: Phaser.CANVAS, // Set to Canvas to help IE.
			parent: domElement,
			transparent: false,
			antialias: true,
			forceSetTimeOut: false,
			assetPath: _environmentSettings.assetPath, // not a standard Phaser property - used to pass in relative loading paths for different host environments (LMS, CMS, etc.). _environmentSettings.assetPath is declared in HTML file.
		};

		var settings = {
			play_json_key: "playData",
			loading_image_key: "preloaderBar",
			loading_image_url: config.assetPath + "media/cwlogo.png",
			loading_bg_color: "0x0074c8",
			loading_font: {
				font: "Arial, Helvetica, Sans",
				fontSize: 26,
				fill: "#ffffff",
			},
			loading_text: "Loading...",
			play_json_url: config.assetPath + "media/play.json",
			theme_prefix: "theme_",
			data_prefix: "data_",
			preload_state_name: "preload",
			main_state_name: "main",
			boot_state_name: "boot",
			default_act_name: "default",
			scorm_separator_char: "$",
			logging: true,
		};

		var game = new Phaser.Game(config);
		game.scorm = new Scorm();
		game.state.add(settings.boot_state_name, new BootState(settings));
		game.state.add(settings.preload_state_name, new PreloadState(settings));
		game.state.add(settings.main_state_name, new MainState(settings));
		game.state.start(settings.boot_state_name);

		return game;
	};
})();

},{"./scorm":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scorm.js","./states/boot.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\boot.js","./states/main.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\main.js","./states/preload.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\preload.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\add-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var AddActorAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("add-actor", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = AddActorAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-objective.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var ChangeObjectiveAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("objective", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = ChangeObjectiveAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-scene.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that changes the scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var SceneAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            act.showNewScene(this.args[0]);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = SceneAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\check-outcomes.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that does an additional outcome check based on given variable(s), can be used to force the check
 * of outcomes even when the player hasn't directly acted on it.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var CheckOutcomesAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.checkCurrentSceneOutcomes(eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = CheckOutcomesAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The most basic of actions, record a variable.
 * This action takes three arguments.
 * 1 - name of variable|choice|command
 * 2 - value of variable|choice|command
 * 3 - boolean force value, optional.
 *
 * If you set the 'force value', the value will first be removed from the model manually. This would allow you to
 * set a value (and cause an outcome) multiple times in a row. This would normally be blocked because the model
 * ignores values being set repeatedly.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var VariableAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            var temp = {};
            temp[act.model.getValue(this.args[0])] = act.model.getValue(this.args[1]);
            if( this.args[3] === true ) {
                act.clearVariable(this.args[0]);
            }
            act.onGameChoiceAction(temp);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = VariableAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mark-complete.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that adds an actor to a scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var MarkCompleteAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("activity_complete", eachArg);
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = MarkCompleteAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mh\\mh-change-scene.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 12/20/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This action is customized for Mission-Health and used
 * to update SCORM data prior to switching scenes. This was needed
 * because setting the SCORM "completed" flag (at the end of the lesson)
 * may take 1-2 seconds.  Consequently, we need to set this immediately
 * prior to switching to the mission-completed scene AND we need to stop
 * audio first to avoid it being interfered with by the synchronous HTTP request
 * that SCORM uses. Refer to GitLab Issue #427.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        VariableAction = require('../game-choice.js'),
        Base = require('basejs');

    var MhSceneAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }

            var newSceneName = this.args[0];
            var varsMap = this.args[1] || {};

            _.forOwn(varsMap, function(value, varName) {
                (new VariableAction([varName, value])).execute(act);
            });

            act.audioService.stopScene(); // Stop audio before sending SCORM updates to avoid interrupted audio

            act.events.onActStatus.dispatch("save");

            act.showNewScene(newSceneName);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = MhSceneAction;
}());

},{"../game-choice.js":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\remove-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An action that changes the scene.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var RemoveActorAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }
            _.each( this.args, function( eachArg ) {
                act.actCommand("remove-actor",act.model.getValue(eachArg));
            }, this);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = RemoveActorAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\variable-increment.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 10/15/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This action adds a value to a numeric variable.
 * Since all variables are stored as strings, it will first be parsed into a number.
 * 
 * This action takes three arguments.
 * 1 - name of the variable to increment
 * 2 - numeric amount of the increment (or decrement, if negative)
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var VariableIncrementAction = Base.extend( {
        execute: function(act) {
            if( !act ) {
                throw "action requires an act to work on.";
            }

            var numericValue = Number(act.model.getValue('$'+this.args[0]));
            if (isNaN(numericValue)) {
                throw "action requires the variable to be number.";
            }

            var increment = Number(this.args[1]);
            if (isNaN(increment)) {
                throw "action requires the increment to be number.";
            }

            numericValue += increment;

            var temp = {};
            temp[act.model.getValue(this.args[0])] = numericValue.toString();

            act.onGameChoiceAction(temp);
        },
        constructor: function( data ) {
            this.args = data;
        }
    });

    module.exports = VariableIncrementAction;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-announcer.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An announcer bubble. The announcer box is optional.
 * It will display text and optionally play audio.
 * This is very similar to the speech bubble, only it isn't listening for events to change its text.
 *
 * {
 *    "name": "announcerBox",
 *     "type": "announcer",
 *     "location": [ 2, 5 ], // location on screen.
 *     "text": "Welcome to Newbridge Middle School.", // text to display.
 *     "audio": "nar_6th_int_01", // Audio to play
 *     "announcerBox": true // show the announcer box
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * },
 *
 * @TODO update this class to show any icon as the 'announcer'.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var AnnouncerActor = Actor.extend({
        // Constructor is in parent.
        enterScene: function () {
            this.text = this.data.text;
            this.audio = this.data.audio;
            this.key = this.data.key;

            this.currentX = this.data.location[0];
            this.currentY = this.data.location[1];
            if (this.data.announcerBox) {
                this.addAnnouncerBox();
            }
            this.data.inverseSoundEvents = true;
            this.addWindow();
            this.setSpeech();
        },
        getRequiredFields: function() {
            return [ "location" ];
        },
        addAnnouncerBox: function () {
            this.announcerBox = this.game.add.sprite(this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.getImage( 'announcer-box', 'actorImages') );
            this.currentX += this.announcerBox.width - 10;
        },
        /**
         * Add 5 things to a group:
         * 1. A top "sprite" which is the top of the text bubble.
         * 2. Text, representing the text for this sprite and wrapping its font.
         * 3. A middle "tilesprite" which is a repeating middle sprite made to match the height of the text.
         * 4. A bottom "sprite" which is the bottom of the text bubble.
         */
        addWindow: function () {
            if( !this.theme.textWindows || !this.theme.textWindows.announce ) {
                throw "Announcer actor requires textWindows theme entry, and announce section inside it.";
            }
            var windowGroup = this.game.add.group();
            windowGroup.x = this.currentX;
            windowGroup.y = this.currentY;

            var marginX = 8,
                marginY = 20;
            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.announce.top);

            this.fStyle = this.getFont('bubbleText');
            this.rStyle = this.getFont('replayAudio');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * .85;

            this.currentText = new Phaser.Text(this.game, marginX + 50, marginY, this.text, this.fStyle);
            windowGroup.add(this.currentText);

            var middleHeight = this.currentText.height - (topWindow.height - marginY);
            if( middleHeight < 5 ) {
                middleHeight = 5;
            }
            var middleWindow = new Phaser.TileSprite(this.game, 0, topWindow.height,
                topWindow.width, middleHeight, this.theme.textureKey, this.theme.textWindows.announce.middle);
            windowGroup.add(middleWindow);

            var bottomY = this.currentText.y + this.currentText.height + marginY;
            var bottomWindow = windowGroup.create(0, topWindow.height + middleWindow.height, this.theme.textureKey, this.theme.textWindows.announce.bottom);

            // 5. Add eventing.
            this.windows = {
                top: topWindow,
                middle: middleWindow,
                bottom: bottomWindow
            };

            _.each(this.windows, function (bubble) {
                bubble.inputEnabled = true;
                bubble.events.onInputOver.add(this.onMouseIn, this);
                bubble.events.onInputOut.add(this.onMouseOut, this);
                bubble.events.onInputUp.add(this.onPointerUp, this);
            }, this);

            this.replayText = new Phaser.Text(this.game, (bottomWindow.x + bottomWindow.width - 40) / 2,
                (topWindow.height + bottomWindow.height + middleWindow.height) / 2, "Replay Audio", this.rStyle);
            this.replayText.anchor.setTo(0.5, 0.5);
            windowGroup.add(this.replayText);
            this.replayText.visible = false;

            this.currentText.bringToTop();
            this.replayText.bringToTop();
            this.windowGroup = windowGroup;
        },
        onMouseIn: function () {
            this.fStyle.fill = this.theme.tints.bubbleText;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = true;
        },
        onMouseOut: function () {
            this.fStyle.fill = this.getFont('bubbleText').fill;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = false;
        },
        onPointerUp: function () {
            this.dispatchGameSpeech( {text: this.text, audio: this.audio, key: this.key});
        },
        setSpeech: function () {
            this.currentText.setText(this.text);
            // may need to adjust heights/etc.
            this.dispatchGameSpeech( {text: this.text, audio: this.audio, key: this.key});
        },
        destroy: function () {
            this.rStyle = null;
            this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            if( this.announcerBox ) {
                this.announcerBox.destroy();
                this.announcerBox = null;
            }
            this.freeBaseActor();
        }
    });

    module.exports = AnnouncerActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-choice.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the choice actor, which will show the player a multiple choice question. It will also
 * play any audio/text associated with asking question.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "choice", // required type.
 *     "startChoice": "dp1", // which choice to start with from the choiceMap set.
 *     "choiceMap": {
 *         "dp1": { // this is the name of this choice, used when linking choices
 *             "text": "Im Mandy. Click one of the response bubbles below to respond to me.", // question. It can be blank.
 *             "audio": "6th_int_01", // audio, it is optional.
 *             "key": "mandy", // a key into a set of audio. optional.
 *             "decisionPoint": true, // mark this option for saving.
 *             "choices": [
 *                 {
 *                    "link": "dp2",  // which question/choices to show next.
 *                    "text": "One of these?" // displayed text of this choice.
 *                    "decision": "PR"event | "AL"low | "EN"courage | "PA"rticpate | "DI"scourage  (Required if decisionPoint === true )
 *                 },
 *                 {
 *                    "link": "dp2",
 *                    "text": "So, this is how we talk?"*
 *                 },
 *                 {
 *                    "text": "You mean these bubbles?", // text to show for this choice.
 *                    "variable": "choice_2", // variable to set when this choice is selected.
 *                    "value": "zink_mandy"   // value to set variable to.
 *                }
 *              ]
 *            },
 *            ... // as many choices as you want.
 *          }
 *         },
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *
 *  For a decision point, you can stll do a variable/value and link.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var MAX_CHOICES = 5,
        choiceMap = { "PR" : 0, "DI" : 1, "AL": 2, "EN": 3, "PA": 4},
        marginY = 6,
        marginFont = 25;

    var ChoiceActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "choiceMap", "startChoice" ];
        },
        enterScene: function() {
            this.choiceMap = this.data.choiceMap;
            this.currentChoice = this.choiceMap[this.data.startChoice];

            /**
             * Determine the number of questions and build the correct choice list.
             * If this is a decision point choice, use the previous choices per the formula..
             */
            this.buildActor();
            this.populateChoice();
        },
        buildActor: function () {
            this.buttons = [];
            this.text = [];
            var locationY = 50,
                buttonCnt,
                currButton,
                currText,
                locationX = 0;
            this.fStyle = this.getFont('bubbleText');

            for( buttonCnt = MAX_CHOICES; buttonCnt > 0; buttonCnt-- ) {
                currButton = this.game.add.button(0, 0, this.theme.textureKey, this.onChoice, this,
                    'response-bg-over.png', 'response-bg-up.png', 'response-bg-down.png', 'response-bg-up.png');
                // this.theme.buttons.responses.over, this.theme.buttons.responses.out, this.theme.buttons.responses.down, this.theme.buttons.responses.up
                locationX = (this.game.world.width - currButton.width ) / 2;
                locationY = this.game.world.height - ( (currButton.height + marginY) * buttonCnt);
                currButton.x = locationX;
                currButton.y = locationY;

                currText = new Phaser.Text(this.game, marginFont, currButton.height / 2, "", this.fStyle);
                currButton.addChild(currText);
                currText.anchor.setTo(0, 0.5);

                this.buttons.push(currButton);
                this.text.push(currText);
            }
        },
        populateChoice: function () {
            var index,
                options = this.currentChoice,
                buttonHideCount = MAX_CHOICES - options.choices.length,// how many choices to hide.
                buttonCnt,
                answer,
                showQuestions = [ true, true, true, true, true],
                dpChoices = [],
                chosenIndex,
                previousPlayHidden = -1;

            if( options.decisionPoint === true || options.decisionPoint === "true") {
                this.dpIndex = this.getDecisionIndex();
                log.warn("Showing decision point: " + this.dpIndex);

                // The first two questions are a special case, and we'll only hide one...
                if( this.dpIndex === 0 || this.dpIndex === 1 ) {
                    answer = this.getPreviousPlayAnswer( this.dpIndex );
                    if( answer && answer !== "XX" ) {
                        log.warn("Hiding answer " + answer + " from previous playthrough.");
                        previousPlayHidden = choiceMap[answer];
                    }
                }
                // The questions after that, just use the previous answer.
                if( this.dpIndex > 0 ) {
                    answer = this.getPreviousAnswer( this.dpIndex );
                    log.warn("got previous answer of " + answer);
                    chosenIndex = choiceMap[answer];

                    // if index is the beginning or end, go up/down 2, otherwise, go both sides.
                    if( chosenIndex === 0) {
                        showQuestions[3] = false;
                        showQuestions[4] = false;
                    } else if( chosenIndex === 4 ) {
                        showQuestions[0] = false;
                        showQuestions[1] = false;
                    } else {
                        showQuestions = [ false, false, false, false, false];
                        showQuestions[chosenIndex] = true;
                        showQuestions[chosenIndex+1] = true;
                        showQuestions[chosenIndex-1] = true;
                    }
                }

                /**
                 * Since we may have overriden the hide with a true, hide AFTER parsing previous.
                 */
                if( previousPlayHidden !== -1 ) {
                    showQuestions[previousPlayHidden] = false;
                }

                for (index = 0; index < options.choices.length; index++) {
                    if( showQuestions[index] ) {
                        dpChoices.push( options.choices[index]);
                    }
                }
                // redo the offset, now that choices are being hidden.
                buttonHideCount = MAX_CHOICES - dpChoices.length;
                log.warn("determined button offset of " + buttonHideCount);
            } else {
                for (index = 0; index < options.choices.length; index++) {
                    dpChoices.push( options.choices[index]);
                }
            }

            // Had button up to the count.
            for( buttonCnt = 0; buttonCnt < buttonHideCount; buttonCnt++ ) {
                if( this.buttons[buttonCnt]) {
                    this.buttons[buttonCnt].visible = false;
                    this.buttons[buttonCnt].inputEnabled = false;
                } else {
                    log.error("Bad button count: " + buttonCnt );
                }
            }

            /**
             * Make a list of the indexes, and then randomize that list.
             * This is randomize the order the answers are presented to the user.
             */
            var randomizedIndex = [];
            for (index = 0; index < dpChoices.length; index++) {
                randomizedIndex.push( index );
            }
            Phaser.ArrayUtils.shuffle(randomizedIndex);

            var randomKey;
            for (index = 0; index < dpChoices.length; index++) {
                randomKey = randomizedIndex[index];
                this.text[index + buttonHideCount].setText(dpChoices[randomKey].text);
                this.buttons[index + buttonHideCount].currentOption = dpChoices[randomKey];
                this.buttons[index + buttonHideCount].visible = true;
                this.buttons[index + buttonHideCount].inputEnabled = true;
            }

            if( options.text || options.audio ) {
                var eventData = {"text": options.text, "audio": options.audio, "key": options.key};
                //log.warn("Choice actor sending game speech");
                //log.warn(eventData);
                this.playAudio( eventData );
            }
        },
        destroy: function () {
            var temp;
            while( this.text.length > 0 ) {
                temp = this.text.shift();
                temp.destroy();
                temp = null;
            }
            while( this.buttons.length > 0 ) {
                temp = this.buttons.shift();
                temp.destroy();
                temp = null;
            }
            this.freeBaseActor();
        },
        onChoice: function (data) {
            //log.warn("Choice made, popuplating new choice");
            //log.warn(_.cloneDeep(data.currentOption));
            var choice = data.currentOption;
            if( choice.variable ) {
                var varSet = {};
                varSet[choice.variable] = choice.value;
                this.events.onGameChoice.dispatch( this.data.name, varSet );
            }
            if( choice.link ) {
                this.currentChoice = this.choiceMap[choice.link];
                this.populateChoice();
            }
        },
        /**
         * Figure out which decision the player is making, by assuming they make them in order.
         * So find the first index that is XX.
         * @returns {number} index of next decision point.
         */
        getDecisionIndex: function() {
            var decisionSet = this.modelInterface.getValue("$decisionsCurrent"),
                dpIndex;

            for( dpIndex = 0; dpIndex < decisionSet.length; dpIndex++ ) {
                if( decisionSet[dpIndex] === "XX" ) {
                    return dpIndex;
                }
            }
            return -1;
        },
        /**
         * For a given decision index, find the answer from the previous play through.
         */
        getPreviousPlayAnswer: function(decisionIndex) {
            return this.modelInterface.getValue("$decisionsPrevious")[decisionIndex];
        },
        /**
         * Get the answer to the previous decision from this play through.
         */
        getPreviousAnswer: function( decisionIndex ) {
            return this.modelInterface.getValue("$decisionsCurrent")[decisionIndex-1];
        }
    });

    module.exports = ChoiceActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-chooser.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 04/23/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 *  A chooser actor which randomly toggles a hi-lited selection through a specified number of changes before
 *  ultimately ending on a selection which will either be (not rigged) always random or (rigged) unique first and then random.
 *  The "toggling" action will increase in interval until stopping, that is, the chooser decelerates until it stops, somewhat 
 *  like a roulette wheel.
 * 
 * Creating a Chooser actor:
 * {
 *      "name": "chooser1",             // A unique name for the actor
 *      "type": "chooser",              // Required type
 *      "startButton": {                // The image which should trigger the choosing sequence, and where to put it
 *          "image": "choose_button",
 *          "location": [ 300, 200 ]
 *      },
 *      "images": "chooser_1",          // Refers to theme.images.chooserImages.chooser_1 which is a collection of objects 
 *                                          { "base": "image1.png", "hi": "image1_hi.png"  }
 *      "location": [ 100, 100 ],       // Where the first image is positioned
 *      "audio": "tick_sound",          // An optional sound to play for each change
 *      "numChanges": 24,               // How many different events are emited before reaching the ultimate selection. If this is too much it could cause performance issues
 *      "rigged": true,                 // Optional, if this is true the chooser will select each option once until each is used, then begin randomly selecting things.
 *      "variable": "chooser_value",    // When actor is added, the variable 'chooser_value' will be set to a number between 0 and numOptions - 1 .
 *      "startDelay": 1000              // Optional delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var ChooserActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "variable", "numChanges", "images", "location", "startButton" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        randomIntFromInterval: function(min,max)
        {
            return Math.floor(Math.random() * ( max - min));
        },
        buildActor: function() {
            this.riggedSpinValues = this.data.rigged ? _.shuffle(_.range(0, this.theme.images.chooserImages[this.data.images].length)) : [];
            
            var i = 0;
            this.choice = [];
            this.hi_choice = [];
            while (i < this.theme.images.chooserImages[this.data.images].length) {

                var x_pos = this.data.location[0] + (i % 2) * this.game.cache.getFrameByName(this.theme.textureKey, this.theme.images.chooserImages[this.data.images][i].base).width;
                var y_pos = this.data.location[1];
                if (i > 1) {
                    y_pos += this.game.cache.getFrameByName(this.theme.textureKey, this.theme.images.chooserImages[this.data.images][i].base).height;
                }
                this.choice.push(this.game.add.sprite( x_pos, y_pos,
                    this.theme.textureKey, this.getImage( this.theme.images.chooserImages[this.data.images][i].base, null)));
                this.hi_choice.push(this.game.add.sprite( x_pos, y_pos,
                    this.theme.textureKey, this.getImage( this.theme.images.chooserImages[this.data.images][i].hi, null)));
                this.hi_choice[i].visible = false;
                i++;

            }
            this.startButton = this.game.add.button( this.data.startButton.location[0], this.data.startButton.location[1], this.theme.textureKey,
                this.onClick, this,
                this.theme.buttons[this.data.startButton.image].over, this.theme.buttons[this.data.startButton.image].out,
                this.theme.buttons[this.data.startButton.image].down, this.theme.buttons[this.data.startButton.image].up);

        },
        choiceIterator: function (choices, cb) {
            var start = 10;
            for (var i = 1; i < choices.length; i++) {
                if (i === choices.length - 1) {
                    this.game.time.events.add(start, this.toggleSelection, this, choices[i - 1], choices[i], cb.bind(this));
                } else {
                    this.game.time.events.add(start, this.toggleSelection, this, choices[i - 1], choices[i]);
                    start += 12 * i;
                }
            }
        },
        toggleSelection: function (last, next, done) {
            if (this.data.audio) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": "stopAll" };
                this.playAudio( eventData);
            }
            this.hi_choice[last].visible = false;
            this.hi_choice[next].visible = true;
            if (typeof done === 'function') {
                done();
            }
        },
        onClick: function () {
            var numOptions = this.theme.images.chooserImages[this.data.images].length
            if (this.isChoosing) {
                return;
            };
            var varSet = {};
            varSet[this.data.variable] = 100;
            this.dispatchGameChoice(varSet);
            this.isChoosing = true;
            for (var i = 0; i < numOptions; i++) {
                this.hi_choice[i].visible = false;
            }
            var randomInt = this.riggedSpinValues.length ? this.riggedSpinValues.pop() : this.randomIntFromInterval(1, numOptions);
            var choices = [Math.floor(Math.random() * numOptions)];

            for (var i = 1; i < this.data.numChanges - 1; i++) {
                var choice = Math.floor(Math.random() * numOptions);
                while (choice === choices[i - 1]) {
                    choice = Math.floor(Math.random() * numOptions);
                }
                choices.push(choice);
            }
            while (randomInt === choices[choices.length -1]) {
                choices.push(Math.floor(Math.random() * numOptions));
            }

            choices.push(randomInt);

            this.choiceIterator(choices, function() {
                this.isChoosing = false;
            });
            var varSet = {};
            varSet[this.data.variable] = randomInt.toString();
            this.dispatchGameChoice(varSet);
        },
        destroy: function() {
            if (this.center) {
                this.center.destroy();
            }
            if (this.arrow) {
                this.arrow.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ChooserActor;
}());
},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The phone button actor. This actor is used for opening the phone and showing phone alerts.
 *
 * Creating a phone button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "phone-button", // the required type.
 *     "images": "phone", // where in the theme to find the images.
 *     "location": [ x, y ],
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  Handles special variables:
 *  phone_alert : type // show an alert, of the type given.
 */
(function () {

    var Actor = require('../actor');

    var PhoneButtonActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location", "image" ];
        },
        enterScene: function() {
            this.isAlerted = false;
            this.buildActor();
            if( this.data.alert ) {
                this.onGameChoice( { 'phone_alert': this.data.alert });
            }
        },
        buildActor: function() {
            this.alertGroup = null;
            this.buttonAnimation = null;
            var tLoc = this.data.image;

            this.button = this.game.add.button( this.data.location[0], this.data.location[1] + 36, this.theme.textureKey,
                this.onPointerUp, this,
                this.theme[tLoc].button.over, this.theme[tLoc].button.out,
                this.theme[tLoc].button.down, this.theme[tLoc].button.up);
            this.button.inputEnabled = true;
        },
        buildActorAlerts: function() {
            this.alertGroup = this.game.add.group();
            this.alertGroup.x = this.data.location[0];
            this.alertGroup.y = this.data.location[1];
            var tLoc = this.data.image;

            this.alerts = {
                game: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.game),
                message: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.message),
                pdf: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.pdf),
                video: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.video),
                gtfs: new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme[tLoc].alerts.gtfs)
            };

            this.alertGroup.add(this.alerts.game);
            this.alertGroup.add(this.alerts.message);
            this.alertGroup.add(this.alerts.pdf);
            this.alertGroup.add(this.alerts.video);
            this.alertGroup.add(this.alerts.gtfs);
            this.showAlert(false);
        },
        /**
         * Any game choice during an alert will cause the phone to 'vibrate' on screen.
         * @param choice
         */
        onGameChoice: function( choice ) {
            if( this.isAlerted ) {
                this.playAlert();
            } else if( choice['phone_alert'] ) {
                this.isAlerted = true;
                this.showAlert(choice['phone_alert']);
                this.playAlert();
            }
        },
        /**
         * Show one of the alerts, or hide them all if no type (or false) is passed.
         * @param type game|message|pdf|video|false
         */
        showAlert: function( type ) {
            if( this.alertGroup === null ) {
                this.buildActorAlerts();
            }
            this.alerts.game.visible = false;
            this.alerts.message.visible = false;
            this.alerts.pdf.visible = false;
            this.alerts.video.visible = false;
            this.alerts.gtfs.visible = false;
            if( type ) {
                this.alerts[type].visible = true;
            }
        },
        /**
         * Play the ring animation and current ring tone.
         */
        playAlert: function() {
            var ringToneIndex = parseInt(this.modelInterface.getValue("$phoneRingerIndex"), 10);
            if( this.buttonAnimation === null) {
                this.buttonAnimation = this.button.animations.add('ring', this.theme[this.data.image].ring);
            }
            this.button.animations.play('ring', 4);
            var eventData = {"text": "", "audio" : this.theme.phone.ringtones[ringToneIndex] };
            this.playAudio( eventData);
        },
        /**
         * When the player clicks the phone button, stop any alert and then send out the game choice.
         * @param event
         */
        onPointerUp: function( event ) {
            this.isAlerted = false;
            this.showAlert(false);
            this.button.animations.stop();

            var varSet = {};
            varSet['show_cell_phone'] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            this.alerts = null;
            if ( this.alertGroup ) {
                this.alertGroup.destroy();
            }
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = PhoneButtonActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/20/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a very specialized actor for use with Welcome To Newbridge and Act Now! it shows a cell phone that sends out
 * special events, responds to events, and can interact with the user by drawing over the scene. The user can interact
 * with the phone and possibly launch sub-activities from it. Because of this, the phone must block user input, which
 * is the purpose of the blockingSprite(s).
 *
 * ringtone and background are now stored on the play-model of the current scene.
 *
 *  {
 *     "name": "phone_1",
 *     "type": "phone",
 *     "help": {
 *       "variable": "phone_1", // these variables will be set to 'open' or 'closed' automatically. It's optional.
 *       "text" : "You'll find good advice here." // text to display for this 'icon'
 *     },
 *     "gtfs": {
 *       "variable": "phone_2",
 *       "text": "You'll be notified when it's time to learn some facts about bullying."
 *     },
 *     "games": {
 *       "text": "Sometimes you can choose this icon to play another game within the school day."
 *    },
 *     "messages": {
 *       "variable": "phone_3",
 *       "from": "anonymous", // messages has a 'from'; since they are displayed as text messages.
 *       "text": "this is a text message."
 *     },
 *     "videos": {
 *       "link": "",
 *       "text": "You'll be directed when to watch videos about bullying. Click this icon when told to see a video on your phone."
 *     },
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 *  Special data stored on model. These data are stored on the model to make them stateful between instances:
 *     "phoneRingerIndex": the index of the current ring tone.
 *     "phoneBgIndex": the index of the current background image.
 *
 */
(function () {
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor'),
        moment = require('moment');

    var Phone = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ ]; // no required fields
        },
        enterScene: function () {
            this.fontHeader = this.getFont('phoneHeader');
            this.fontBody = this.getFont('phoneBody');
            this.fontBodyLink = this.getFont('phoneBodyLink');
            this.isInitialized = false;

            if( this.data.open ) {
                this.showPhone();
            }
        },
        onGameChoice: function( choice ) {
            if( choice['show_cell_phone'] ) {
                if( this.isInitialized && this.phoneGroup.visible ) {
                    this.onClickClose();
                } else {
                    this.showPhone();
                }
            }
        },
        dispatch: function (data, value) {
            var varSet = {};
            varSet[data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onClickHelp: function () {
            this.currentIcon = this.data.help;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Help", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickGtfs: function () {
            this.currentIcon = this.data.gtfs;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Get The Facts", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickMessages: function () {
            this.currentIcon = this.data.messages;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText(this.currentIcon.from, this.currentIcon.text, true, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickVideos: function () {
            this.currentIcon = this.data.videos;
            if (this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "open");
            }
            this.showText("Videos", this.currentIcon.text, false, this.currentIcon.link,  this.currentIcon.value);
        },
        onClickRingtone: function () {
            var ringToneIndex = parseInt(this.modelInterface.getValue("$phoneRingerIndex"), 10);
            ringToneIndex++;
            ringToneIndex %= this.theme.phone.ringtones.length;
            this.playAudio(  { "audio": this.theme.phone.ringtones[ringToneIndex]});
            this.events.onGameChoice.dispatch(this.data.name, {"phoneRingerIndex": ringToneIndex });
        },
        onClickBackground: function () {
            var phoneBgIndex = parseInt(this.modelInterface.getValue("$phoneBgIndex"), 10);
            phoneBgIndex++;
            phoneBgIndex %= this.theme.phone.backgrounds.length;
            this.phoneBg.frameName = this.theme.phone.backgrounds[phoneBgIndex];
            this.events.onGameChoice.dispatch(this.data.name, {"phoneBgIndex": phoneBgIndex});
        },
        onClickClose: function () {
            this.phoneGroup.visible = false;
            this.textGroup.visible = false;
            this.blockingSprite.visible = false;
            this.blockingSprite2.visible = false;
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "closed"});
        },
        createPhoneButton: function (key, callback, context) {
            var button = new Phaser.Button(this.game, 0, 0, this.theme.textureKey,
                callback, context,
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0],
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0]);
            button.input.useHandCursor = true;
            return button;
        },
        /**
         * Showing the phone is a bit complicated. Everything has to be brought to the top in
         * reverse order.
         */
        showPhone: function () {
            if( this.isInitialized === false ) {
                this.initHomeScreenGroup();
                this.initBlockingGroup();
                this.initMessageWindowGroup();
            }
            this.phoneGroup.visible = true;
            this.blockingSprite.visible = true;
            this.blockingSprite2.visible = false;
            this.blockingSprite.bringToTop();
            this.game.world.bringToTop(this.phoneGroup);
            this.blockingSprite2.bringToTop();
            this.game.world.bringToTop(this.textGroup);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "open"});
        },
        /**
         * Create the main screen, including all of the buttons.
         */
        initHomeScreenGroup: function() {
            var phoneBgIndex = parseInt(this.modelInterface.getValue("$phoneBgIndex"), 10);
            this.phoneGroup = this.game.add.group();
            this.phoneGroup.x = this.game.world.centerX;

            this.phoneBg = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.backgrounds[phoneBgIndex]);
            this.phoneBg.anchor.setTo(0.5, 0.0);
            this.phoneGroup.add(this.phoneBg);

            this.helpButton = this.createPhoneButton('help', this.onClickHelp, this, 2);
            this.phoneGroup.add(this.helpButton);
            this.helpButton.x = -this.helpButton.width;
            this.helpButton.y = 50;
            this.helpButton.anchor.setTo(0.5, 0);
            this.helpButton.bringToTop();

            this.gtfsButton = this.createPhoneButton('gtfs', this.onClickGtfs, this, 2);
            this.phoneGroup.add(this.gtfsButton);
            this.gtfsButton.x = 0;
            this.gtfsButton.y = 50;
            this.gtfsButton.anchor.setTo(0.5, 0);
            this.gtfsButton.bringToTop();

            this.messagesButton = this.createPhoneButton('messages', this.onClickMessages, this, 2);
            this.phoneGroup.add(this.messagesButton);
            this.messagesButton.x = this.messagesButton.width;
            this.messagesButton.y = 50;
            this.messagesButton.anchor.setTo(0.5, 0);
            this.messagesButton.bringToTop();

            this.videosButton = this.createPhoneButton('videos', this.onClickVideos, this, 2);
            this.phoneGroup.add(this.videosButton);
            this.videosButton.x = -this.videosButton.width;
            this.videosButton.y = 50 + this.videosButton.height;
            this.videosButton.anchor.setTo(0.5, 0);
            this.videosButton.bringToTop();

            this.ringtoneButton = this.createPhoneButton('ringtones', this.onClickRingtone, this, 2);
            this.phoneGroup.add(this.ringtoneButton);
            this.ringtoneButton.x = 0;
            this.ringtoneButton.y = 50 + this.videosButton.height;
            this.ringtoneButton.anchor.setTo(0.5, 0);
            this.ringtoneButton.bringToTop();

            this.backgroundButton = this.createPhoneButton('background', this.onClickBackground, this, 2);
            this.phoneGroup.add(this.backgroundButton);
            this.backgroundButton.x = this.messagesButton.width; // this is on purpose.
            this.backgroundButton.y = 50 + this.videosButton.height;
            this.backgroundButton.anchor.setTo(0.5, 0);
            this.backgroundButton.bringToTop();

            this.closeButton = this.createPhoneButton('close', this.onClickClose, this, 2);
            this.phoneGroup.add(this.closeButton);
            this.closeButton.x = 0;
            this.closeButton.y = 50 + (this.gtfsButton.height * 3);
            this.closeButton.anchor.setTo(0.5, 0);
            this.closeButton.bringToTop();
            this.phoneGroup.visible = false;


        },
        initBlockingGroup: function() {
            this.blockingSprite = this.createBlockingSprite();
            this.blockingSprite2 = this.createBlockingSprite();
            this.game.add.existing(this.blockingSprite);
            this.game.add.existing(this.blockingSprite2);
            this.blockingSprite.visible = false;
            this.blockingSprite2.visible = false;
        },
        initMessageWindowGroup: function () {
            var width = this.phoneBg.width - 32;
            var x = this.game.world.centerX - (width / 2),
                y = this.phoneBg.y + 32,
                height = this.phoneBg.height - 74,
                heightHeading = height / 7,
                margin = 10;

            height -= (heightHeading);

            this.textGroup = this.game.add.group();
            this.textGroup.x = x;
            this.textGroup.y = y;

            this.headingText = new Phaser.Text(this.game, width / 2, heightHeading / 2, "HEADING TEST", this.fontHeader);
            this.headingText.anchor.setTo(0.5, 0.5);

            this.fontBody.wordWrap = true;
            this.fontBody.wordWrapWidth = width * 0.9;
            this.fontBodyLink.wordWrap = true;
            this.fontBodyLink.wordWrapWidth = width * 0.9;
            this.bodyText = new Phaser.Text(this.game, margin, heightHeading + margin, "THIS IS A TEXT MESSAGE FOR YOU TO SEE TEST", this.fontBody);
            this.bodyText.anchor.setTo(0.0, 0.0);
            this.bodyText.inputEnabled = true;
            this.bodyText.events.onInputDown.add(this.clickedBodyText, this);

            var graphics = new Phaser.Graphics(this.game);
            this.textGroup.add(graphics);

            // set a fill and line style
            graphics.beginFill(0x353535);
            graphics.lineStyle(1, 0x000000, 1);
            graphics.drawRect(0, 0, width, heightHeading);
            graphics.beginFill(0xFFFFFF, 0.9);
            graphics.drawRect(0, heightHeading, width, height);
            graphics.endFill();

            var buttonSprite = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.messages.button);
            buttonSprite.x = width - buttonSprite.width - margin;
            buttonSprite.y = heightHeading + height - margin - buttonSprite.height;
            buttonSprite.inputEnabled = true;
            buttonSprite.events.onInputDown.add(this.chooseOk, this);

            this.playButton = new Phaser.Sprite(this.game, margin, 0, this.theme.textureKey, this.theme.phone.playButton);
            this.playButton.inputEnabled = true;
            this.playButton.events.onInputDown.add(this.clickedBodyText, this);
            this.playButton.visible = false;

            this.textGroup.add(this.headingText);
            this.textGroup.add(this.bodyText);
            this.textGroup.add(buttonSprite);
            this.textGroup.add(this.playButton);

            this.hideText();
        },
        showText: function (heading1, body, isTextMessage, link, valueIn) {
            var value = null;
            if( valueIn ) {
                value = this.modelInterface.getValue( valueIn);
            }
            this.headingText.setText(heading1);
            this.setBodyText( body, link, valueIn );

            this.textGroup.visible = true;
            this.blockingSprite2.visible = true;
            if( isTextMessage ) {
                var dt = "Received: " + moment().format("MMM Do YYYY, h:mm a "); // Jul 21st 2015, 11:12 am
                var from = this.modelInterface.getValue(heading1);
                from = from.charAt(0).toUpperCase() + from.slice(1);
                this.headingText.setText( "From: " + from + "\n" + dt);
            }
        },
        setBodyText: function( text, isLink, useValue) {
            log.warn("In set body text.");
            if( isLink === true ) {
                this.bodyText.inputEnabled = true;
                this.playButton.visible = true;
                this.playButton.inputEnabled = true;
            } else {
                this.bodyText.inputEnabled = false;
                this.playButton.visible = false;
                this.playButton.inputEnabled = false;
            }
            if( typeof text === 'string') {
                log.warn("Setting as simple string");
                this.bodyText.setStyle( this.fontBody );
                this.bodyText.setText( this.substituteText(text) );
            } else {
                log.warn("not a string, parsing everything..");
                this.bodyText.setStyle( this.fontBodyLink );
                if( useValue ) {
                    log.warn("useValue defined, as: " + useValue);
                    var value = parseInt(this.modelInterface.getValue(useValue), 10);
                    log.warn("value is " + value);
                    var foundScoreRange = false;
                    _.each( text, function(singleEntry) {
                        if( value >= singleEntry[0] && value <= singleEntry[1] ) {
                            this.bodyText.setText( this.substituteText(singleEntry[2]));
                            foundScoreRange = true;
                        }
                    }, this);
                    if (foundScoreRange === false) {
                        //log.warn("$$$$$$$$$$$ noted value out of range");
                        // The score wasn't within any range. It could be higher than any or lower than
                        // any, or there could be a hole in the ranges.
                        var highestScore = 0;
                        var lowestScore = 0;
                        var highestText = "";
                        var lowestText = "";
                        _.each( text, function(singleEntry) {
                            if( singleEntry[0] > highestScore ) {
                                highestScore = singleEntry[0];
                                highestText = singleEntry[2];
                            }
                            if( singleEntry[1] > highestScore ) {
                                highestScore = singleEntry[1];
                                highestText = singleEntry[2];
                            }
                            if ( singleEntry[0] < lowestScore ) {
                                lowestScore = singleEntry[0];
                                lowestText = singleEntry[2];
                            }
                            if ( singleEntry[1] < lowestScore ) {
                                lowestScore = singleEntry[1];
                                lowestText = singleEntry[2];
                            }
                        }, this);
                        if (value > highestScore) {
                            // score is higher than highest range; use highest range text
                            this.bodyText.setText( this.substituteText(highestText));
                        } else if (value < lowestScore) {
                            // score is lower than lowest range; use lowest range text
                            this.bodyText.setText( this.substituteText(lowestText));
                        } else {
                            // there must be a hole in the ranges; just use the first entry
                            this.bodyText.setText(this.substituteText(text[0][2]));
                        }
                    }
                } else {
                    this.bodyText.setText( this.substituteText(text[0][2])); // just use first entry.
                }
            }
            this.playButton.y = this.bodyText.y + this.bodyText.height + 5;
        },
        substituteText: function( text ) {
            log.warn("Doing substitution on: " + text);
            var leftIndex, rightIndex;
            leftIndex = text.indexOf("$");
            if( leftIndex === -1 ) {
                return text;
            }
            rightIndex = text.indexOf("$", leftIndex + 1);
            if( rightIndex === -1 ) {
                return text;
            }
            var key = text.substring( leftIndex, rightIndex +1);
            var key2 = key.substring(0, key.length - 1); // remove trailing dollarsign.
            var finalText = this.modelInterface.getValue(key2);
            finalText = finalText.charAt(0).toUpperCase() + finalText.slice(1);
            return text.replace(key, finalText );
        },
        hideText: function () {
            this.textGroup.visible = false;
            this.blockingSprite2.visible = false;
        },
        chooseOk: function () {
            if (this.currentIcon && this.currentIcon.variable) {
                this.dispatch(this.currentIcon, "closed");
                this.currentIcon = null;
            }
            this.hideText();
        },
        clickedBodyText: function() {
            this.dispatch(this.currentIcon, "clicked");
            /**
             * Phone links must behave differently than other buttons in the scene engine.
             * They can be clicked over and over. So, after sending the clicked event, we send an
             * afterClicked event, which forces the variable to change, so that the next time the
             * link is clicked, the 'clicked' event is seen as a change again.
             */
            this.dispatch(this.currentIcon, "afterClicked");
        },
        destroy: function () {
            this.fontHeader = null;
            this.fontBody = null;
            if ( this.phoneGroup ) {
                this.phoneGroup.destroy();
            }
            if ( this.textGroup ) {
                this.textGroup.destroy();
            }
            if ( this.blockingSprite ) {
                this.blockingSprite.destroy(true);
            }
            if ( this.blockingSprite2 ) {
                this.blockingSprite2.destroy(true);
            }
            if ( this.playButton ) {
                this.playButton.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = Phone;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","moment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-playthrough.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The decoration actor. Just an image on the screen.
 *
 * Creating a button actor:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "decoration", // the required type.
 *     "image": "phone", // the images to use from the button section of the theme.
 *     "key": "something", // an optional key to look under for the image.
 *     "location": [ x, y ],
 *     "scale": [ x, y], // optional x/y scale.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var PlayThroughActor = Actor.extend( {
        constructor: function(game, theme) {
            if( !game ) {
                throw "actor requires game constructor argument.";
            }
            this.game = game;
            this.data = {
                "name": "playthroughdisplay"
            };
            this.theme = theme;
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            if( !this.theme.playthroughDisplayContainer ) {
                throw "You cannot display playthrough without providing an image in the theme.";
            }

            this.sprite = this.game.add.sprite( 0, 0, this.theme.textureKey, this.theme.playthroughDisplayContainer );
            this.sprite.x = this.game.world.width - this.sprite.width;
            this.sprite.y = 0;
            var fStyle = this.getFont('playThrough');
            var currentText = new Phaser.Text(this.game, this.sprite.width/2, this.sprite.height/2, "Playthrough: " + this.modelInterface.getValue("$playThrough"), fStyle);
            currentText.anchor.setTo(0.5,0.5);
            this.sprite.addChild(currentText);
            this.sprite.visible = false;
        },
        hide: function() {
            if( this.sprite ) {
                this.sprite.visible = false;
            }
        },
        show: function() {
            if( this.sprite ) {
                this.sprite.visible = true;
                this.sprite.bringToTop();
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = PlayThroughActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-spinner.js":[function(require,module,exports){
/**
 * @author David Lee
 * @version 1.0.0
 * @creation 04/03/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 * A spinner actor with a central button and a pointer that extends off it.
 * 
 * Creating a Spinner actor:
 * {
 *      "name": "spinner1",             // A unique name for the actor
 *      "type": "spinner",              // Required type
 *      "images": "spinner",            // The key to use from the spinners section of the theme
 *      "centerImage": "center"         // The key to use within the theme file for the center image
 *      "arrowImage": "arrow"           // The key to use within the theme file for the arrow image
 *      "offset": 0.25                  // Offset in radians used by the starting position / when spinning
 *      "numOptions": 4                 // How many different options the spinner uses. Defaults to 4
 *      "audio": "spin",                // An optional sound to play when the spinner is clicked. Don't play long audio!
 *      "audioPriority": "sfx",         // An optional priority to use for the spinner audio property. If this is not set, it defaults to "sfx"
 *      "location": [ x, y ],           // Where to put the center of the spinner
 *      "spinDuration": 3600,           // How long the spin animation should take. If this is not specified, a duration based on the number of spins will be used by default
 *      "fakeSpinsRange": [2, 5],       // Range [min, max] of fake spins to show before the arrow is set to the randomly selected section. This defaults to [2, 5] if not specified
 *      "rigged": true,                 // Optional, if this is true the spinner will select each option once until each is used, then begin randomly selecting things.
 *      "clickValue": "reset",          // Optional, if this is set, when the center is clicked the variable will be set to this value. This is useful to trigger events on click that must happen before the spin is completed and the variable is updated to the final value
 *      "variable": "spinner_value"     // if you click the spinner, the variable 'spinner_value' will be set to a number between 1 and 4.
 *      "startDelay": 1000              // optional delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 *      "arrowOffsetX": 0.05            // optional offset for spinner arrowX
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var DEFAULT_NUM_OPTIONS = 4;

    var SpinnerActor = Actor.extend({
        // constructor in parent.

        getRequiredFields: function() {
            return [ "location", "images", "centerImage", "arrowImage", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        randomIntFromInterval: function(min,max)
        {
            return Math.floor(Math.random() * ( max - min + 1)) + min;
        },
        buildActor: function() {
            if( !this.theme.spinners || !this.theme.spinners[this.data.images] ) {
                throw "Spinner Actor requires spinners entry in theme, with specific entry matching " + this.data.images;
            }
            if (!this.theme.spinners[this.data.images][this.data.centerImage]) {
                throw "Spinner Actor requires spinner entry to have a center image, with a specific entry matching " + this.data.images + "." + this.data.centerImage;
            }
            if (!this.theme.spinners[this.data.images][this.data.arrowImage]) {
                throw "Spinner Actor requires spinner entry to have an arrow image, with a specific entry matching " + this.data.images + "." + this.data.arrowImage;
            }

            if(!this.data.numOptions) {
                this.data.numOptions = DEFAULT_NUM_OPTIONS;
            }

            if(!this.data.fakeSpinsRange) {
                this.data.fakeSpinsRange = [2, 5];
            }

            if(!this.data.audioPriority) {
                this.data.audioPriority = "sfx";
            }

            this.riggedSpinValues = this.data.rigged ? _.shuffle(_.range(1, this.data.numOptions + 1)) : [];

            var anchorX = 0.5,
                anchorY = 0.5;

            var x = this.data.location[0];
            var y = this.data.location[1];

            this.arrow = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.spinners[this.data.images][this.data.arrowImage]);
            this.center = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.spinners[this.data.images][this.data.centerImage]);
            
            this.center.anchor.setTo(anchorX, anchorY);

            if (this.data.arrowOffsetX) {
                this.arrow.anchor.setTo(anchorX - this.data.arrowOffsetX, anchorY);
            } else {
                this.arrow.anchor.setTo(anchorX, anchorY);
            }

            this.arrow.rotation = Math.PI * this.data.offset;

            this.center.inputEnabled = true;
            this.center.input.useHandCursor = true;
            this.arrow.inputEnabled = true;
            this.arrow.input.useHandCursor = true;
            
            this.center.events.onInputDown.add(this.onClick, this);
            this.arrow.events.onInputDown.add(this.onClick, this);

        },
        onClick: function( event ) {

            if (this.spinning) {
                return;
            }

            if (this.data.clickValue) {
                var varSet = {};
                varSet[this.data.variable] = this.data.clickValue;
                this.dispatchGameChoice(varSet);
            }
            
            this.spinning = true;

            if (this.data.audio) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": this.data.audioPriority };
                this.playAudio( eventData);
            }

            var randomInt = this.riggedSpinValues.length ? this.riggedSpinValues.shift() : this.randomIntFromInterval(1, this.data.numOptions);

            var randomFullSpins = this.randomIntFromInterval(this.data.fakeSpinsRange[0], this.data.fakeSpinsRange[1]);

            var randomRotation = ((Math.PI * 2) / this.data.numOptions) * randomInt;
            var rotation = (2 * randomFullSpins * Math.PI) + randomRotation + (Math.PI * this.data.offset);

            if (! this.data.spinDuration) {
                // If the spinDuration isn't passed in, override it with the old code by default
                this.data.spinDuration = (rotation / (2 * Math.PI)) * 1000;
            }
            this.tween = this.game.add.tween(this.arrow).to( { rotation: rotation }, this.data.spinDuration, Phaser.Easing.Quadratic.Out, true, 0, 0, false);
            this.tween.onComplete.add( function() {
                    this.arrow.rotation = this.arrow.rotation % (2 * Math.PI);
                    this.spinning = false;
                    var varSet = {};
                    varSet[this.data.variable] = randomInt.toString();
                    this.dispatchGameChoice(varSet);
            }, this);
        },
        destroy: function() {
            if (this.center) {
                this.center.destroy();
            }
            if (this.arrow) {
                this.arrow.destroy();
            }
            if (this.tween) {
                this.tween.stop();
            }
            this.freeBaseActor();
        }
    });

    module.exports = SpinnerActor;
}());
},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-computer.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble. It displays text and requests that audio be played. A speech bubble can have its own text/audio
 * and can also listen for text/audio events to show.
 * The speech bubble will adjust its size to fit the provided/set text.
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "speech-bubble",
 *    "text": "", // text to show.
 *    "audio": "", // audio key to play.
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var marginX = 15, marginY = 20;

    var ZinkComputerActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location" ];
        },
        enterScene: function () {
            this.text = this.data.text || " ";
            this.key = this.data.key;

            this.addWindow(this.data.location[0], this.data.location[1]);
            this.setSpeech();
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.zink ) {
                throw "Instruction actor requires textWindows theme entry, and zink definition inside it.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.zink);

            this.fStyle = this.getFont('bubbleText');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * 0.55;

            this.currentText = new Phaser.Text(this.game, marginX, marginY, " ", this.fStyle);
            windowGroup.add(this.currentText);

            this.currentText.bringToTop();
            this.windowGroup = windowGroup;
        },
        setSpeech: function () {
            this.currentText.setText( this.getText(this.text, this.key) );
            this.playAudio( {text: this.text, audio: this.audio, key: this.key});
        },
        onGameSpeech: function (speech) {
            this.text = speech.text;
            this.key = speech.key;
            this.currentText.setText( this.getText(this.text, this.key) );
        },
        destroy: function () {
            this.fStyle = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.windowGroup = null;
            this.currentText = null;
            this.freeBaseActor();
        }
    });

    module.exports = ZinkComputerActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-poster.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The zink poster actor. This is a special actor that requires only text and font configuration. It will show a
 * zink poster with text on it.
 *
 * Creating a zink poster actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "zink-poster", // the required type.
 *     "text": "Yo, I'm zink", // what to put on the poster.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var ZinkPosterActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ ]; // no required fields.
        },
        enterScene: function() {
            this.buildActor();
            if( this.data.text ) {
                this.addTextBox();
            }
        },
        buildActor: function() {
            this.darkOut = new Phaser.Graphics(this.game, 0,0);
            this.darkOut.beginFill( 0x000000, 0.4 );
            this.darkOut.drawRect( 0,  0, this.game.world.width, this.game.world.height );
            this.darkOut.endFill();
            this.game.add.existing(this.darkOut);
            this.sprite = this.game.add.sprite( (this.game.world.centerX), 0, this.theme.textureKey,
                this.getImage('zink-poster', 'actorImages'));
            this.sprite.x = this.game.world.centerX - (this.sprite.width / 2);
            this.sprite.angle -= 3;
        },
        addTextBox: function() {
            this.font = this.getFont('zinkPoster');

            this.boxY = this.sprite.y + (this.sprite.height * 0.75);
            this.boxWidth = this.sprite.width - 2;
            this.boxHeight = 115;

            this.font.wordWrap = true;
            this.font.wordWrapWidth = this.boxWidth * 0.9;

            this.text = new Phaser.Text(this.game, 10 , 5, this.data.text , this.font);

            this.graphics = new Phaser.Graphics(this.game, 1, this.boxY);
            this.graphics.beginFill( 0xEFEFEF, 1.0 );
            this.graphics.drawRect( 0,  0, this.boxWidth, this.boxHeight );
            this.graphics.endFill();

            this.graphics.addChild(this.text);
            this.sprite.addChild(this.graphics);
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy();
            }
            if( this.darkOut ) {
                this.darkOut.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ZinkPosterActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-animation.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 10/023/2017
 * Copyright 2017 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The animation actor. Will run it's animation, and can optionally be clicked.
 *
 * Creating a click-animation actor, a starting, animation set, and ending image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "animation", // the required type.
 *     "images": "phone", // the images to use
 *     "key": "whatevs", // optional image key
 *     "textureKey": "key", // optional text key to get animation from
 *     "location": [ x, y ],
 *     "scale": [ x, y], // optional x/y scale.
 *     "fps": 10, // frames were second, will default to 30
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "variable": "x", // variable to send out 2nd click events, will be name + "_playing" and name + "_finished"
 *     "loop": true // true=loop indefinitly, false=no loop, or number of times to play the animation; defaults to true.
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor'),
        TweenHelper = require("./tween-helper");

    var AnimationActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "images" ];
        },
        getVariableList: function() {
            return this.data.variable ? [ this.data.variable + "_playing", this.data.variable + "_finished" ] : [];
        },
        enterScene: function() {
            this.buildActor();
            var loopIndefinitely = this.data.loop === undefined || this.data.loop == true;
            this.sprite.animations.play("animation", this.fps, loopIndefinitely);
        },
        buildActor: function() {
            this.fps = 30;

            this.sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.getTextureKey(this.data), this.getImage( this.data.images, this.data.key)[0]);

            this.sprite.inputEnabled = true;
            this.sprite.input.pixelPerfectOver = true;
            this.sprite.events.onInputUp.add( this.onPointerUp, this);
            if( this.data.variable ) {
                this.sprite.input.useHandCursor = true;
            }

            this.animation = this.sprite.animations.add('animation', this.getImage( this.data.images, this.data.key) );
            this.animation.onStart.add(this.animationStarted, this);
            this.animation.onComplete.add(this.animationStopped, this);

            if( this.data.fps ) {
                this.fps = this.data.fps;
            }

            var anchorX = 0, anchorY = 0;
            var x = this.data.location[0],
                y = this.data.location[1];
            this.scaleX = 1.0;
            this.scaleY = 1.0;

            if( this.data.scale ) {
                this.scaleX = this.data.scale[0];
                this.scaleY = this.data.scale[1];
            }
            this.sprite.scale.setTo( this.scaleX, this.scaleY );

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.sprite.anchor.setTo( anchorX, anchorY);
            this.sprite.x = x;
            this.sprite.y = y;

            if (this.data.loop) {
                var repeatCount = Number(this.data.loop);
                if (repeatCount > 1) {
                    this.repeatCount = repeatCount;
                }
            }

            if (this.data.tween) {
                if (_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper = new TweenHelper(this.game, this);
                }
                this.tweenHelper.addTweens(this.data.tween, this.sprite);
            }
        },
        animationStarted: function() {
            if( this.data.variable ) {
                var varSet = {};
                varSet[this.data.variable + "_playing" ] = this.data.name;
                this.events.onGameChoice.dispatch(this.data.name, varSet, this);
            }
        },
        animationStopped: function() {
            if (this.repeatCount && --this.repeatCount) {
                this.animation.restart();
            } else if (this.data.variable) {
                var varSet = {};
                varSet[this.data.variable + "_finished" ] = this.data.name;
                this.events.onGameChoice.dispatch(this.data.name, varSet, this);
            }
        },
        onPointerUp: function() {
            if( this.data.variable ) {
                var varSet = {};
                varSet[this.data.variable] = this.data.name;
                this.events.onGameChoice.dispatch(this.data.name, varSet, this);
            }
        },
        destroy: function() {
            if (!_.isUndefined(this.tweenHelper)) {
                this.tweenHelper.removeTweens(this.sprite);
            }
            if ( this.sprite ) {
                this.sprite.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = AnimationActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./tween-helper":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-audio.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An audio actor. It will play a sound(s) and then set the variable.
 * It is up to the user/script writer to make sure this audio isn't being interrupted by other audio.
 *
 *{
 *    "name": "audio_actor_1", // name.
 *    "type": "audio",
 *    "audio": ["sound1, sound2"], // audio key(s) to play.
 *    "variable": "x", // variable to set when sounds have completed playing.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *    "priority": sfx | interrupt | queue | stop | stopall | low
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var AudioActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "audio", "variable" ];
        },
        enterScene: function () {
            this.audio = this.data.audio;
            // Allow a single string through.
            if( typeof this.audio === 'string' ) {
                this.audio = [ this.audio ];
            }
            this.audioIndex = 0;
            this.playCurrent();
        },
        playCurrent: function() {
            if( this.audioIndex > (this.audio.length-1) ) {
                log.warn("Setting audio sprite variable");
                var varSet = {};
                varSet[this.data.variable] = "played";
                this.events.onGameChoice.dispatch( this.data.name, varSet );
                return;
            }
            var audioKey = this.audio[this.audioIndex];
            this.playAudio({ audio: audioKey, key: null, priority: this.data.priority} );
        },
        onGameSpeechStop: function( speech ) {
            // log.warn("On game speech reached audio actor: " + speech);
            if( speech === this.audio[this.audioIndex] ) {
                this.audioIndex++;
                this.playCurrent();
            }
        },
        destroy: function () {
            this.audio = null;
            this.freeBaseActor();
        }
    });

    module.exports = AudioActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-blocker.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 09/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The blocker actor. This actor can be used to block input events from the actors behind it.
 *
 * Creating a blocker actor:
 *
 * {
 *     "name": "alertBlocker", // a unique identifier
 *     "type": "blocker", // the required type.
 *     "location": [ 0, 0 ], // optional, default is [0,0]; where on the screen to play this actor
 *     "size": [ 800, 600 ], // optional, default is [game.world.width,game.world.height] how large
 *     "blockerTint" : "0x000000", // optional, default is black (0x000000)
 *     "blockerAlpha" : 0.5, // optional, default is 0.5
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

     var BlockerActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [];
        },
        buildActor: function() {
            var blockerX = (typeof this.data.location === 'undefined') ? 0 : this.data.location[0];
            var blockerY = (typeof this.data.location === 'undefined') ? 0 : this.data.location[1];
            var blockerWidth = (typeof this.data.size === 'undefined') ? this.game.world.width : this.data.size[0];
            var blockerHeight = (typeof this.data.size === 'undefined') ? this.game.world.height : this.data.size[1];
            var blockerTint = (typeof this.data.blockerTint === 'undefined') ? 0x000000 : this.data.blockerTint;
            var blockerAlpha = (typeof this.data.blockerAlpha === 'undefined') ? 0.5 : this.data.blockerAlpha;

            this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            this.blockerSprite.addChild(graphics);
            graphics.beginFill( blockerTint, blockerAlpha );
            graphics.drawRect( blockerX, blockerY, blockerWidth, blockerHeight );
            graphics.endFill();
            this.blockerSprite.inputEnabled = true;

            this.blockerSprite.bringToTop();

            this.game.add.existing(this.blockerSprite);

            this.addDebugBox();
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        destroy: function() {
            if ( this.blockerSprite ) {
                this.blockerSprite.inputEnabled = false;
                this.blockerSprite.destroy(true);
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = BlockerActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button-character.js":[function(require,module,exports){
/**
 * @author Zack biernat
 * @version 1.0.0
 * @creation 04/18/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The button-character actor. This actor can be used for selecting a character, and can be
 * used for animating a character that is talking (provide mouth animation). It is differentiated from the
 * NoInputCharacter Actor by allowing the image field to access "buttons" from the theme instead of "actorImages". 
 * This allows button-like behavior for the graphic.
 *
 * Creating a button-character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "button-character", // the required type.
 *     "image": "mandy", // the button image to use from the theme (should include "up", "down", "over", "out").
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "frameRate": 24 // optional frame rate for the speech animation, defaults to 10.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "speechAudio": "6th_01", // The actor should animate this piece of audio.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "variable": "character_2", // if you click this character, the variable 'character_2' will be set to 'mandy'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  If you set speechAnimation to true, -talk must be appended to the button-character's image name to differentiate
 *  from the non-speaking version (which may have a different mouth graphic!)
 *
 *  For the speech animations to work, you'll need a speechAnimations section in the theme.json, which specifies
 *  speaking-animation images and location offsets for the mouth:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 *
 *  There must additionally be "Sound Sync Data", defining which image to show...
 *
 * "soundSyncData": {
 *   "6th_01": [
 *     0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1
 *   ], ...
 * }
 *
 *  The 0s and 1s represent which image, and could be 0,1,2,3 etc if there are more than 2. They key should match
 *  the "speechAudio" of this actor as well as the audio being played. 
 *  NOTE: Most of the speechSyncData does not contain '1's and looks like [0,0,2,3,3,3,2,0,2,3,2,0,0,0,2,3,4,4,3,4,2,0].
 *  In this case it is advised to use the [A, B, B, C, D] pattern for the different frames in your theme.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

     var ButtonCharacterActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            if( this.data.speechAnimation ) {
                this.addSpeechAnimation();
            }
        },
        getRequiredFields: function() {
            return [ "location", "variable" ];
        },
        buildActor: function() {
            var imageId = this.modelInterface.getValue(this.data.image);
            if( imageId ) {
                if (this.data.speechAnimation) {
                    imageId += "-talk";
                }
                this.sprite = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                    this.onClick, this,
                    this.theme.buttons[this.data.image].over, this.theme.buttons[this.data.image].out,
                    this.theme.buttons[this.data.image].down, this.theme.buttons[this.data.image].up);

                if( this.data.scale ) {
                    this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
                }
            } else {
                this.sprite = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                    this.onClick, this,
                    this.theme.buttons[this.data.image].over, this.theme.buttons[this.data.image].out,
                    this.theme.buttons[this.data.image].down, this.theme.buttons[this.data.image].up);
                this.sprite.width = this.data.size[0];
                this.sprite.height = this.data.size[1];
                this.addDebugBox();
            }
            this.sprite.inputEnabled = true;
            this.sprite.input.useHandCursor = true;
                /**
             * This is one of the most CPU/expensive things you can do in phaser.
             */
            this.sprite.input.pixelPerfectOver = true;
            

        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        addSpeechAnimation: function() {
            var aSpeechAnimation = this.theme.speechAnimations[this.modelInterface.getValue(this.data.image)];
            if( !aSpeechAnimation ) {
                log.error("Could not add speech animation for character: " + this.data.name);
                log.error("Speech animation not found for " + this.data.image );
                log.error("Check that you have a speechAnimations section in your theme.");
                return;
            }
            this.speechAnimation = this.game.add.sprite(
                this.data.location[0] + aSpeechAnimation.mouthOffset[0],
                this.data.location[1] + aSpeechAnimation.mouthOffset[1],
                this.theme.textureKey,
                aSpeechAnimation.images[0]);
            this.speechAnimation.animations.add('talk', aSpeechAnimation.images);
            this.speechAnimationSet = aSpeechAnimation.images;
            this.speechAnimationDefault = aSpeechAnimation.images[0];

            if( this.data.scale ) {
                this.speechAnimation.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            }
        },
        onGameSpeech: function (speech) {
            var audio = this.modelInterface.getValue(speech.audio);
            if( speech.key ) {
                audio = this.modelInterface.getValue(speech.key) + "_" + audio;
            }
            log.warn("On game speech: " + audio);
            if( this.speechAnimation && this.theme.soundSyncData
              && this.theme.soundSyncData[audio] && this.data.speechAudio === audio ) {
                this.soundSyncData = this.theme.soundSyncData[audio];
                if( ! this.timer ) {
                    var FRAME_RATE = this.data.frameRate ? this.data.frameRate : 10;
                    this.timer = this.game.time.create(false);
                    this.speechIndex = 0;
                    this.timer.loop(1000 / FRAME_RATE, this.incrementSpeech, this);
                    this.timer.start();
                }
            }
        },
        incrementSpeech: function() {
            if( this.soundSyncData ) {
                this.speechIndex++;
                this.speechAnimation.frameName = this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
            }
        },
        onGameSpeechStop: function (speech) {
            if( this.speechAnimation && this.soundSyncData) {
                this.timer.stop();
                this.timer.destroy();
                this.timer = null;
                this.soundSyncData = null;
                this.speechAnimation.frameName = this.speechAnimationDefault;
            }
        },
        onClick: function( event ) {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.dispatchGameChoice( varSet );
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.inputEnabled = false;
                this.sprite.destroy();
            }
            if( this.speechAnimation ) {
                this.speechAnimation.destroy();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            if( this.timer ) {
                this.timer.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ButtonCharacterActor;
}());
},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The button actor. This actor can be used for simple actions, such as opening the cell phone. In many 'plays', this actors
 * isn't needed.
 *
 * Creating a button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "button", // the required type.
 *     "image": "phone", // the images to use from the button section of the theme.
 *     "audio": "ring", // an optional sound to play when the button is clicked. Don't play long audio!***
 *     "sfx": {
 *        "over": "ding" // optional sounds to play on up/over/down/out. Add support as needed. Over added.
 *     },
 *     "location": [ x, y ],
 *     "variable": "show_cell_phone" // if you open the phone, the variable 'show_cell_phone' will be set to 'phone1'.
 *     "animated": "true", // optional; theme.buttonAnimations.<image> item name containing a list of images
 *     "animationFrameRate": 30, // optional, default is 30 fps; ignored if animated is not true
 *     "animationLoop": "true", // optional, default is false; ignored if animated is not true
 *     "animationRepeat": 4000, // optional, time in seconds, default is no repeat; overrides animationLoop if both are specified; ignored if animated is not true
 *     "alpha": 0.4 // optional, opacity coefficient
 *     // optional "scale": [ 1.1, 1.1 ], // Use negative scales to 'flip' the images.
 *     // optional "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond; it is defined in main.js)
 * }
 *
 *  *** If you want to play long audio on a button, use an event and add the audio actor. This is meant for things like
 *      clicks and beeps that play for about a second.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor'),
        TweenHelper = require("./tween-helper");

    var BUTTON_TIMEOUT = 200; // Use this so the audio has a chance to play.

    var ButtonActor = Actor.extend( {
        // constructor is in parent.
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [ "location", "image", "variable" ];
        },
        buildActor: function() {
            if( !this.theme.buttons || !this.theme.buttons[this.data.image] ) {
                throw "Button Actor requires buttons entry in theme, with specific entry matching " + this.data.image;
            }

            var x = this.data.location[0],
                y = this.data.location[1],
                anchorX = 0,
                anchorY = 0;

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if (this.data.anchor === "left") {
                anchorX = 0;
            } else if (this.data.anchor === "center") {
                anchorX = 0.5;
            } else if (this.data.anchor === "right") {
                anchorX = 1;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.button = this.game.add.button( x,y, this.getTextureKey(this.data),
                this.onPointerUp, this,
                this.theme.buttons[this.data.image].over, this.theme.buttons[this.data.image].out,
                this.theme.buttons[this.data.image].down, this.theme.buttons[this.data.image].up);
            this.buttonIsAnimated = ( typeof this.data.animated !== "undefined" ) && ( this.data.animated === true );
            if ( this.buttonIsAnimated ) {
                this.button.animations.add(this.data.image, this.theme.buttonAnimations[this.data.image]);
                this.animationFrameRate = ( typeof this.data.animationFrameRate !== "undefined" ) ? this.data.animationFrameRate : 30;
                this.loopAnimation = ( typeof this.data.animationLoop !== "undefined" ) ? this.data.animationLoop : false;
                this.animationRepeat = ( typeof this.data.animationRepeat !== "undefined" ) ? this.data.animationRepeat : 0;
                if ( this.animationRepeat > 0 ) {
                    this.loopAnimation = false; // timed repeat overrides looping
                    this.animationTimerEvent = this.game.time.events.loop( this.animationRepeat, this.animateButton, this );
                }
                this.animateButton();
            }
            this.button.inputEnabled = true;
            this.button.input.useHandCursor = true;
            this.button.anchor.setTo( anchorX, anchorY );

            if( this.data.scale ) {
                this.button.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if (this.data.alpha) {
                this.button.alpha = this.data.alpha;
            }

            var fontName;
            var textX = this.button.width / 2;
            var textY = this.button.height / 2;
            var anchor = [0.5, 0.45];

            /**
             * GJF - this was already here and I don't want to break backwards compatibility. so I'm adding a
             * "textData" section below.
             */
            if( this.data.text ) {
                fontName = this.data.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");
                this.textSprite = this.game.add.text(textX, textY, this.data.text, this.style);
            }

            if( this.data.textData ) {
                var textData = this.data.textData;
                fontName = textData.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

                if( textData.textX ) {
                    textX = textData.textX;
                }
                if( textData.textY ) {
                    textY = textData.textY;
                }
                if( textData.anchor ) {
                    anchor = textData.anchor;
                }
                this.textSprite = this.game.add.text(textX, textY, textData.text, this.style);
            }

            if( this.textSprite ) {
                this.textSprite.anchor.setTo( anchor[0], anchor[1] );
                this.button.addChild(this.textSprite);
            }

            this.button.onInputOver.add(this.onMouseOver, this);

            if( this.data.tween ) {
                if (_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper = new TweenHelper(this.game, this);
                }
                this.tweenHelper.addTweens(this.data.tween, this.button);
                if (this.textSprite) {
                    this.tweenHelper.addTweens(this.data.tween, this.textSprite);
                }
            }
        },
        onMouseOver: function() {
           if( this.data.sfx && this.data.sfx.over ) {
               var eventData = {"text": "", "audio" : this.data.sfx.over, "priority": "sfx" };
               this.playAudio( eventData);
           }
        },
        animateButton: function() {
            if ( this.buttonIsAnimated ) {
                this.button.animations.play(this.data.image, this.animationFrameRate, this.loopAnimation, false);
            }
        },
        onPointerUp: function( event ) {

            if( this.data.audio ) {
                var eventData = {"text": "", "audio" : this.data.audio, "priority": "sfx" };
                this.playAudio( eventData);
            }

            this.button.inputEnabled = false;
            var that = this;
            setTimeout( function() {
                that.button.inputEnabled = true;
                var varSet = {};
                varSet[that.data.variable] = that.data.name;
                that.events.onGameChoice.dispatch( that.data.name, varSet );

            }, BUTTON_TIMEOUT);

        },
        destroy: function() {
            if ( this.button ) {
                if (!_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper.removeTweens(this.button);
                }
                if ( typeof this.animationTimerEvent != 'undefined' ) {
                    this.game.time.events.remove( this.animationTimerEvent );
                }
                this.button.destroy();
            }
            if( this.textSprite ) {
                if (!_.isUndefined(this.tweenHelper)) {
                    this.tweenHelper.removeTweens(this.textSprite);
                }
                this.textSprite.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ButtonActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./tween-helper":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-character.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The character actor. This actor can be used for selecting a character (clickable with text bubble), or can be
 * used for animating a character that is talking (provide mouth animation)
 *
 * Creating a character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "character", // the required type.
 *     "image": "mandy", // the image to use from the theme.
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "text": "Mandy", // what to put in a text bubble during mouse over.
 *     "audio": "6th_01", // optional audio to speak on mouse over.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "variable": "character_2", // if you click this character, the variable 'character_2' will be set to 'mandy'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *
 * }
 *
 *  If you set speechAnimation to true, -talk will be appended to the characters image name.
 * speechAnimation/speechLocation are optional.
 *
 * See also theme.json's speechAnimations, which specify speaking-animation images and location offsets:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 *
 *  Your theme should have a 'bubbleTextWidth' entry to specify how wide to make the text bubble.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

     var CharacterActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            if( this.data.text ) {
                this.addTextBox();
            }
            if( this.data.speechAnimation ) {
                this.addSpeechAnimation();
            }
        },
        getRequiredFields: function() {
            return [ "location" ];
        },
        buildActor: function() {
            var imageId = this.modelInterface.getValue(this.data.image);
            if( imageId ) {
                if (this.data.speechAnimation) {
                    imageId += "-talk";
                }
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1], this.theme.textureKey,
                    this.getImage(imageId, 'actorImages'));
                
                if( this.data.scale ) {
                    this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
                }
            } else {
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1]);
                this.sprite.width = this.data.size[0];
                this.sprite.height = this.data.size[1];
                this.addDebugBox();
            }

            if (this.data.text) {
                this.sprite.events.onInputOver.add( this.onMouseIn, this);
                this.sprite.events.onInputOut.add( this.onMouseOut, this);
            }
            if (this.data.variable) {
                this.sprite.events.onInputUp.add( this.onPointerUp, this);
            }

            if (this.data.text || this.data.variable) {
                this.sprite.inputEnabled = true;
                this.sprite.input.useHandCursor = true;
                /**
                 * This is one of the most CPU/expensive things you can do in phaser.
                 */
                this.sprite.input.pixelPerfectOver = true;
            }
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        addTextBox: function() {
            if( !this.theme.bubbleTextWidth ) {
                log.error("You must specify a bubbleTextWidth in your theme when using character labels.");
            }
            var boxY = this.sprite.height / 4,
                boxX = this.sprite.width / 2,
                boxWidth = this.theme.bubbleTextWidth,
                font = this.getFont('bubbleIcon'),
                labelX = this.data.location[0] + boxX,
                labelY = this.data.location[1] + boxY;

            font.wordWrap = true;
            font.wordWrapWidth = boxWidth * 0.9;

            var text = new Phaser.Text(this.game, boxWidth / 2, 10, this.data.text, font  );
            text.anchor.setTo( 0.5, 0 );

            var boxHeight = text.height + 10;

            // ACT-353 If it is overlapping the edge of the screen, adjust the location.
            if( labelX + boxWidth + 3 > this.game.world.width ) {
                labelX = (this.game.world.width - boxWidth - 3);
            }

            if( labelY + boxHeight + 3 > this.game.world.height) {
                labelY = (this.game.world.height - boxHeight - 3);
            }

            this.graphics = new Phaser.Graphics(this.game, labelX, labelY);
            this.graphics.beginFill( 0x000000, 1.0 );
            this.graphics.drawRoundedRect( 3, 3, boxWidth, boxHeight, 9 );
            this.graphics.endFill();
            this.graphics.beginFill(0xffffff);
            this.graphics.drawRoundedRect(0, 0, boxWidth, boxHeight , 9);
            this.graphics.endFill();
            this.graphics.visible = false;
            this.graphics.addChild(text);
            this.game.add.existing(this.graphics);

        },
        addSpeechAnimation: function() {
            var aSpeechAnimation = this.theme.speechAnimations[this.modelInterface.getValue(this.data.image)];
            if( !aSpeechAnimation ) {
                log.error("Could not add speech animation for character: " + this.data.name);
                log.error("Speech animation not found for " + this.data.image );
                log.error("Check that you have a speechAnimations section in your theme.");
                return;
            }
            this.speechAnimation = this.game.add.sprite(
                this.data.location[0] + aSpeechAnimation.mouthOffset[0],
                this.data.location[1] + aSpeechAnimation.mouthOffset[1],
                this.theme.textureKey,
                aSpeechAnimation.images[0]);
            this.speechAnimation.animations.add('talk', aSpeechAnimation.images);
            this.speechAnimationSet = aSpeechAnimation.images;
            this.speechAnimationDefault = aSpeechAnimation.images[0];

            if( this.data.scale ) {
                this.speechAnimation.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            }
        },
        onGameSpeech: function (speech) {
            var audio = this.modelInterface.getValue(speech.audio);
            if( speech.key ) {
                audio = this.modelInterface.getValue(speech.key) + "_" + audio;
            }
            log.warn("On game speech: " + audio);
            if( this.speechAnimation && this.theme.soundSyncData && this.theme.soundSyncData[audio] ) {
                this.soundSyncData = this.theme.soundSyncData[audio];
                if( ! this.timer ) {
                    this.timer = this.game.time.create(false);
                    this.speechIndex = 0;
                    this.timer.loop(100, this.incrementSpeech, this);
                    this.timer.start();
                }
            }
        },
        incrementSpeech: function() {
            if( this.soundSyncData ) {
                this.speechIndex++;
                this.speechAnimation.frameName = this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
            }
        },
        onGameSpeechStop: function (speech) {
            if( this.speechAnimation && this.soundSyncData) {
                this.timer.stop();
                this.timer.destroy();
                this.timer = null;
                this.soundSyncData = null;
                this.speechAnimation.frameName = this.speechAnimationDefault;
            }
        },
        onMouseIn: function( event ) {
            if( this.graphics ) {
                this.graphics.visible = true;
                this.game.world.bringToTop(this.graphics);
                if( this.data.audio ) {
                    this.dispatchGameSpeech( {
                        "text": this.data.text,
                        "audio": this.data.audio,
                        "key": this.data.key || this.data.name });
                }
            }
        },
        onMouseOut: function( event ) {
            if( this.graphics && this.graphics.visible === true) {
                this.graphics.visible = false;
            }
        },
        onPointerUp: function( event ) {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.dispatchGameChoice( varSet );
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.inputEnabled = false;
                this.sprite.destroy();
            }
            if( this.data.text ) {
                this.graphics.destroy(true);
            }
            if( this.speechAnimation ) {
                this.speechAnimation.destroy();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            if( this.timer ) {
                this.timer.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = CharacterActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-click-animation.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The click-animation actor. Will start with an image, and when clicked; will animate and then set to final image.
 * Will generate events for each
 *
 * Creating a click-animation actor, a starting, animation set, and ending image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "click-animation", // the required type.
 *     "images": "phone", // the images to use from the button section of the theme.
 *     "key": "whatevs", // optional image key
 *     "textureKey": "key", // optional text key to get animation from
 *     "location": [ x, y ],
 *     "audio": "audio", // optional audio to play during animation.
 *     "scale": [ x, y], // optional x/y scale.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "variable": "x" // variable to send out 2nd click events, will be name + "_playing" and name + "_finished"
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor');

    var ClickAnimationActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "images" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            this.sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.getTextureKey(this.data), this.getImage( this.data.images, this.data.key)[0]);
            this.sprite.inputEnabled = true;
            /**
             * This is one of the most CPU/expensive things you can do in phaser.
             */
            this.sprite.input.pixelPerfectOver = true;
            this.sprite.input.useHandCursor = true;

            this.sprite.events.onInputUp.add( this.onPointerUp, this);

            this.animation = this.sprite.animations.add('animation', this.getImage( this.data.images, this.data.key) );
            this.animation.onComplete.add( this.onAnimationComplete, this);

            var anchorX = 0, anchorY = 0;
            var x = this.data.location[0],
                y = this.data.location[1];
            this.scaleX = 1.0;
            this.scaleY = 1.0;

            if( this.data.scale ) {
                this.scaleX = this.data.scale[0];
                this.scaleY = this.data.scale[1];
            }
            this.sprite.scale.setTo( this.scaleX, this.scaleY );

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.sprite.anchor.setTo( anchorX, anchorY);
            this.sprite.x = x;
            this.sprite.y = y;
            this.animated = false;
        },
        onPointerUp: function(  ) {
            var varSet = {};
            var suffix;
            if( this.isAnimated === true ) {
                suffix = "_finished";
            } else {
                suffix = "_playing";
                varSet[this.data.variable] = this.data.name + "_playing";
                this.sprite.animations.play("animation", 10, false);
                this.isAnimated = true;
                if (this.data.audio) {
                    this.playAudio( { audio: this.data.audio, key: null});
                }
            }
            varSet[this.data.variable] = this.data.name + suffix;
            this.events.onGameChoice.dispatch(this.data.name, varSet, this);
        },
        onAnimationComplete: function(  ) {
            this.isAnimated = true;
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ClickAnimationActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-decoration.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The decoration actor. Just an image on the screen.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1",     // a unique identifier
 *     "type": "decoration",    // the required type.
 *     "image": "phone",        // the images to use from the button section of the theme.
 *     "key": "something",      // an optional key to look under for the image.
 *     "location": [ x, y ],
 *     "scale": [ x, y],        // optional x/y scale.
 *     "angle": -30,            // optional, degrees from north (-180 to 180)
 *     "rotation": 0.5,         // optional, radians in units of PI. This overrides angle if both are set.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "alpha": 0.5 // optional alpha transparency
 *     "tween": [Object] // optional transition object
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor');

    var DecorationActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "image" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            this.sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.getTextureKey(this.data), this.getImage( this.data.image, this.data.key));
            var anchorX = 0, anchorY = 0;
            var x = this.data.location[0],
                y = this.data.location[1];

            if( this.data.scale ) {
                this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.sprite.anchor.setTo( anchorX, anchorY);
            this.sprite.x = x;
            this.sprite.y = y;

            if ( this.data.alpha ) {
                this.sprite.alpha = this.data.alpha;
            }

            if ( this.data.angle ) {
                this.sprite.angle = this.data.angle;
            }

            if ( this.data.rotation ) {
                this.sprite.rotation = Math.PI * this.data.rotation;
            }

            if( this.data.tween ) {
                var tweenData = this.data.tween;

                var delay = tweenData.delay ? tweenData.delay : 0;
                var easing = ( typeof tweenData.easing != "undefined" ) ? tweenData.easing : "Linear";

                if( tweenData.location ) {
                    this.game.add.tween(this.sprite).to( { x: tweenData.location[0], y: tweenData.location[1]  }, tweenData.time, easing, true, delay);
                }
                if( tweenData.scale ) {
                    this.game.add.tween(this.sprite.scale).to( { x: tweenData.scale[0], y: tweenData.scale[1]  }, tweenData.time, easing, true, delay);
                }
                if( !_.isUndefined(tweenData.alpha) ) {
                    this.game.add.tween(this.sprite).to( {alpha: tweenData.alpha}, tweenData.time, easing, true, delay);
                }
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = DecorationActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drag.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The drag actor. An image on the screen with optional text that can be dragged around.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drag", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "dragging" : "phone", // optional image while dragging
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "variable": "string" // name of variable to be set when this is dragging/dropped/etc.
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var DragActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "images", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            var sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.theme.textureKey, this.getImage( this.getFrame(), this.data.key));
            this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
            sprite.body.setSize( 1, 1,  sprite.width/2, sprite.height/2);
            sprite.inputEnabled = true;
            sprite.input.pixelPerfectOver = true;
            sprite.input.enableDrag(true, true);
            sprite.input.useHandCursor = true;
            sprite.events.onDragStop.add(this.itemDragStop, this);
            sprite.events.onDragStart.add(this.itemDragStart, this);
            sprite.origLoc = [ sprite.x, sprite.y];
            this.sprite = sprite;

            var fontName;
            var textX = this.sprite.width / 2;
            var textY = this.sprite.height / 2;
            var anchor = [0.5, 0.5];

            if( this.data.textData ) {
                var textData = this.data.textData;
                fontName = textData.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

                if( textData.textX ) {
                    textX = textData.textX;
                }
                if( textData.textY ) {
                    textY = textData.textY;
                }
                if( textData.anchor ) {
                    anchor = textData.anchor;
                }
                this.textSprite = this.game.add.text(textX, textY, textData.text, this.style);
            }

            if( this.textSprite ) {
                this.textSprite.anchor.setTo( anchor[0], anchor[1] );
                this.sprite.addChild(this.textSprite);
            }
        },
        returnToHome: function() {

        },
        itemDragStop: function () {
            this.isDragging = false;
            this.updateImage();
            var temp = {};
            temp["dropped"] = this.data.name;
            this.dispatchGameChoice(temp);
            // It will have been dropped, and possibly removed from scene.
            if( this.sprite ) {
                this.sprite.x = this.sprite.origLoc[0];
                this.sprite.y = this.sprite.origLoc[1];
            }
        },
        itemDragStart: function ( ) {
            this.isDragging = true;
            this.updateImage();
            var temp = {};
            temp["dragging"] = this.data.name;
            this.dispatchGameChoice(temp);
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.body.destroy();
                this.sprite.inputEnabled = false;
                this.sprite.events.onDragStop.removeAll();
                this.sprite.events.onDragStart.removeAll();
                this.sprite.destroy(true);
                this.sprite = null;
            }
            if( this.textSprite ) {
                this.textSprite.destroy();
            }
            this.style = null;
            this.freeBaseActor();
        },
        getFrame: function(type) {
            var frameName = this.data.images.normal;
            if(type === "overlap" && this.data.images.overlap ) {
                frameName = this.data.images.overlap;
            } else if( (type === "dragging" || !frameName) && this.data.images.dragging ) {
                frameName = this.data.images.dragging;
            }
            return frameName;
        },
        updateImage: function() {
            var frame;
            if( this.isOverlapping !== null ) {
                frame = this.getFrame("overlap");
            } else if( this.isDragging === true ) {
                frame = this.getFrame("dragging");
            } else {
                frame = this.getFrame("normal");
            }
            this.sprite.frameName = this.getImage( frame, this.data.key);
            this.sprite.body.setSize( 1, 1,  this.sprite.width/2, this.sprite.height/2);
        },
        getBody: function() {
            if( this.sprite ) {
                return this.sprite.body;
            }
            return null;
        },
        onOverlapping: function( otherActor ) {
            if( this.isOverlapping === otherActor ) {
                return;
            }
            this.isOverlapping = otherActor;
            // change to overlapping image.
            this.updateImage();
        }
    });

    module.exports = DragActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-draw.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 6/26/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The blocker actor. This actor can be used to block input events from the actors behind it.
 *
 * Creating a draw actor:
 *
 * {
 *     "name": "draw-demo", // a unique identifier
 *     "type": "draw", // the required type.
 *     "fieldLocations": [[400, 300], [500, 300]], // The target coordinates for each selectable field
 *     "fieldSize": 50, // the radius of each area
 *     "variable": "drawChooser" // The variable name for dispatched events
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

     var DrawActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [];
        },
        buildActor: function() {
            if (!this.data.fieldSize || !this.data.fieldLocations) {
                throw "Required field size or field locations not found";
            }
            this.bmd = this.game.make.bitmapData(this.game.width, this.game.height);
            this.bmd.addToWorld();
            this.addDebugBox();
            this.game.input.onDown.add(this.onMouseDown, this);
            this.game.input.onUp.add(this.onMouseUp, this);

            this.positions = [];
        },
        onMouseDown: function(pointer) {
            if (this.bmd) {
                this.bmd.clear();
            }

            this.bmd.ctx.beginPath();
            this.bmd.ctx.strokeStyle = "#005996"
            this.bmd.ctx.lineWidth = 8;
            this.bmd.ctx.moveTo(pointer.x, pointer.y);

            this.game.input.addMoveCallback(this.onDraw, this);
        },
        onDraw: function(pointer, x, y) {
            if (this.positions.length < 100) {
                this.positions.push([x, y])
            }
            this.bmd.ctx.lineTo(x, y);
            this.bmd.ctx.stroke();
        },
        onMouseUp: function() {
            this.calculateAverage();
            this.bmd.ctx.closePath();
            this.game.input.deleteMoveCallback(this.onDraw, this);
        },
        calculateAverage: function() {
            if (this.positions.length < 20) {
                return;
            }
            var aveX = 0;
            var aveY = 0;
            for (var i = 0; i < this.positions.length; i++) {
                aveX += this.positions[i][0];
                aveY += this.positions[i][1];
            }
            aveX /= this.positions.length;
            aveY /= this.positions.length;

            this.positions = [];

            this.checkTargets(aveX, aveY);
            
        },
        checkTargets: function(x, y) {
            var targets = this.data.fieldLocations;
            var range = this.data.fieldSize;
            var choice = targets.length;

            for (var i = 0; i < targets.length; i++) {
                if (y < range + targets[i][1] && 
                    targets[i][1] < y && 
                    x < 100 + targets[i][0] && 
                    targets[i][0] < x) {
                    choice = i;
                }
            }

            var varSet = {};
            varSet[this.data.variable] = choice; //This needs to determine which thing was selected
            this.dispatchGameChoice(varSet);
            this.game.time.events.add(10, function() {
                this.lastBmd = this.bmd;
                this.lastBmd.addToWorld(); 
            }, this)
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        destroy: function() {
            if ( this.bmd ) {
                this.bmd.clear();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            this.game.input.deleteMoveCallback(this.onDraw, this);
            this.game.input.onDown.remove(this.onMouseDown, this);
            this.game.input.onUp.remove(this.onMouseUp, this);
            this.freeBaseActor();
        }
    });

    module.exports = DrawActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drop.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The drop actor. You can drop drag actors onto this one, triggering it's variable and optional image stage.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drop", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "body": [ width%, height%, offsetx, offsety ], // optional body.
 *     "variable": "string" // name of variable to be set when this is dropped/etc.
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var DropActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "images", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            var sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.theme.textureKey, this.getImage( this.data.images.overlap, this.data.key));
            this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
            var body = [sprite.width * 0.6, sprite.height * 0.6,  sprite.width * 0.2, sprite.height * 0.2];
            if( this.data.body ) {
                body[0] = sprite.width * this.data.body[0];
                body[1] = sprite.height * this.data.body[1];
                body[2] = this.data.body[2] || body[2];
                body[3] = this.data.body[3] || body[3];
            }
            sprite.body.setSize( body[0], body[1], body[2], body[3] );
            sprite.inputEnabled = true;
            sprite.input.pixelPerfectOver = true;
            this.sprite = sprite;
            sprite.visible = false;

            var fontName;
            var textX = this.sprite.width / 2;
            var textY = this.sprite.height / 2;
            var anchor = [0.5, 0.5];

            if( this.data.textData ) {
                var textData = this.data.textData;
                fontName = textData.font;
                this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

                if( textData.textX ) {
                    textX = textData.textX;
                }
                if( textData.textY ) {
                    textY = textData.textY;
                }
                if( textData.anchor ) {
                    anchor = textData.anchor;
                }
                this.textSprite = this.game.add.text(textX, textY, textData.text, this.style);
                if ( (typeof (this.style["lineSpacing"])) !== 'undefined' ) {
                    this.textSprite.lineSpacing = this.style["lineSpacing"];
                }

            }

            if( this.textSprite ) {
                this.textSprite.anchor.setTo( anchor[0], anchor[1] );
                this.sprite.addChild(this.textSprite);
            }
        },
        getFrame: function(type) {
            var frameName = null;
            if( type === "normal" && this.data.images.normal ) {
                frameName = this.data.images.normal;
            } else if(type === "overlap" && this.data.images.overlap ) {
                frameName = this.data.images.overlap;
            } else if( (type === "dragging" || !frameName) && this.data.images.dragging ) {
                frameName = this.data.images.dragging;
            }
            return frameName;
        },
        updateImage: function() {
            var frame = null;
            if( this.isOverlapping !== null ) {
                frame = this.getFrame("overlap");
            } else if( this.isDragging === true ) {
                frame = this.getFrame("dragging");
            } else {
                frame = this.getFrame("normal");
            }
            if( frame !== null ) {
                this.sprite.visible = true;
                this.sprite.frameName = this.getImage(frame, this.data.key);
            } else {
                this.sprite.visible = false;
            }
        },
        getBody: function() {
            if( this.sprite ) {
                return this.sprite.body;
            }
            return null;
        },
        onOverlapping: function( otherActor ) {

            if( this.isOverlapping === otherActor ) {
                return;
            }
            this.isOverlapping = otherActor;
            // change to overlapping image.
            this.updateImage();
        },
        onReceiveDrop: function( otherActorName ) {
            log.warn("Received drop? " + otherActorName);
            var temp = {};
            temp[this.data.variable] = otherActorName;
            this.dispatchGameChoice(temp);
        },
        destroy: function() {
            this.isOverlapping = null;
            if ( this.sprite ) {
                this.sprite.body.destroy();
                this.sprite.inputEnabled = false;
                this.sprite.destroy(true);
                this.sprite = null;
            }
            if( this.textSprite ) {
                this.textSprite.destroy();
            }
            this.style = null;
            this.freeBaseActor();
        }
    });

    module.exports = DropActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-fadeout.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 09/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The fadeout actor. This actor can be used to fade out the screen
 *
 * Creating a blocker actor:
 *
 * {
 *     "name": "alertBlocker", // a unique identifier
 *     "type": "fadeout", // the required type.
 *     "location": [ 0, 0 ], // optional, default is [0,0]; where on the screen to play this actor
 *     "size": [ 800, 600 ], // optional, default is [game.world.width,game.world.height] how large
 *     "color" : "0x000000", // optional, default is black (0x000000)
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "fadePeriod": 3000, //  how long to fade over.
 *     "variable": "x" // variable to set upon completion.
 * }
 */
(function () {

    var log = require('loglevel'),
        Actor = require('./actor');

    var FadeoutActor = Actor.extend({
        // constructor is now in base class!
        enterScene: function () {
            this.buildActor();
        },
        getRequiredFields: function () {
            return ["fadePeriod", "variable"];
        },
        buildActor: function () {
            var blockerX = (typeof this.data.location === 'undefined') ? 0 : this.data.location[0];
            var blockerY = (typeof this.data.location === 'undefined') ? 0 : this.data.location[1];
            var blockerWidth = (typeof this.data.size === 'undefined') ? this.game.world.width : this.data.size[0];
            var blockerHeight = (typeof this.data.size === 'undefined') ? this.game.world.height : this.data.size[1];
            var blockerTint = (typeof this.data.blockerTint === 'undefined') ? 0x000000 : this.data.blockerTint;

            this.graphics = this.game.add.graphics(0, 0);
            this.graphics.beginFill(blockerTint);
            this.graphics.drawRect(blockerX, blockerY, blockerWidth, blockerHeight);
            this.graphics.endFill();
            this.graphics.inputEnabled = true;

            if (this.data.fadePeriod) {
                this.graphics.alpha = 0;
                this.fadeTween = this.game.add.tween(this.graphics).to({alpha: 1}, this.data.fadePeriod, 'Linear', false);
                this.fadeTween.onComplete.add(this.onComplete, this);
                this.fadeTween.start();
            }
        },
        onComplete: function () {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        destroy: function () {
            if (this.graphics) {
                this.graphics.inputEnabled = false;
                this.graphics.destroy(true);
            }
            if( this.fadeTween ) {
                this.fadeTween.stop();
                this.fadeTween = null;
            }
            this.freeBaseActor();
        }
    });

    module.exports = FadeoutActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-input-field.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 11/02/2018
 * Copyright Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This actor uses the phaser-input.js extension to add a text input field to the scene.
 *
 * {
 *     "name": "textInput1", // unique name for this actor.
 *     "type": "input-field", // required type.
 *     "location": [ x, y ],
 *     "options": {padding: 8, borderWidth: 1, borderColor: '#000'} // optional options to be passed to the InputField, refer to phaser-input.js docs for full details: https://github.com/orange-games/phaser-input
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var InputFieldActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "location" ]
        },
        enterScene: function() {
            this.location = this.data.location;
            this.options = this.data.options;

            this.buildActor();
        },
        buildActor: function () {
            this.inputField = this.game.add.inputField(
                this.location[0], this.location[1], this.options);
        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.location = null;
            this.options = null;
            this.inputField.destroy();
            this.freeBaseActor();
        }
    });

    module.exports = InputFieldActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-instruction-bubble.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An instruction bubble. This is a specialized actor for showing large font text with no speech in a fixed size
 * bubble. Normally used for the end of an activity.
 *
 *  Creating an instruction bubble actor:
 *
 * {
 *     "name": "endofactivity", // a unique identifier
 *     "type": "instruction", // the required type.
 *     "text": "Please move on to next activity", // text to show.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 8,
        marginY = 12;

    var InstructionBubbleActor = Actor.extend({
        getRequiredFields: function() {
            return [ "text", "location" ];
        },
        enterScene: function () {
            this.text = this.data.text;
            this.addWindow(this.data.location[0], this.data.location[1]);
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.instruction ) {
                throw "Instruction actor requires textWindows theme entry, and instruction area inside it.";
            }

            this.window = this.game.add.sprite(x, y, this.theme.textureKey, this.theme.textWindows.instruction);
            this.fStyle = this.getFont('moveOn');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = this.window.width * 0.9;
            this.currentText = new Phaser.Text(this.game, this.window.width / 2, this.window.height/2, this.text, this.fStyle);
            this.currentText.anchor.setTo(0.5,0.5);
            this.window.addChild(this.currentText);
        },
        destroy: function () {
            if ( this.window ) {
                this.window.destroy(true);
            }
            this.fStyle = null;
            this.freeBaseActor();
        }
    });

    module.exports = InstructionBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-line.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/17/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the line actor, which will:
 *   - Draw a line on the screen
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01", // unique name for this actor.
 *     "type": "line", // required type.
 *     "start": [ x, y ], // or "center" for either field.
 *     "end": [ x, y ], // or "center" for either field.
 *     "color": "rgba(0,0,0,1)", // optional, default is black
 *     "width": "5", // optional, default is 1
 *     "alpha": "0.5", // optional, default is 1.0
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var LineActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "start", "end"]
        },
        enterScene: function() {
            this.startLoc = this.data.start;
            this.endLoc = this.data.end;

            this.buildActor();
        },
        buildActor: function () {
            this.graphics = this.game.add.graphics( 0,0);
            var color = 0xFF3300;
            var width = 20;
            var alpha = 1;

            if( this.data.color ) {
                color = this.data.color;
            }

            if( this.data.width ) {
                width = parseInt(this.data.width, 10);
            }

            if( this.data.alpha ) {
                alpha = parseFloat(this.data.alpha);
            }

            this.graphics.lineStyle(width, color, alpha);
            this.graphics.moveTo(this.startLoc[0], this.startLoc[1]);
            this.graphics.lineTo(this.endLoc[0], this.endLoc[1]);

        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.startLoc = null;
            this.endLoc = null;
            this.graphics.destroy();
            this.freeBaseActor();
        }
    });

    module.exports = LineActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-no-input-character.js":[function(require,module,exports){
/**
 * @author Zack Biernat
 * @version 1.0.0
 * @creation 04/23/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The no-input-character actor. This actor cannot be interacted with. It speaks when it's audio bit is played, but is otherwise a decoration.
 * Creating a no-input-character actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "character", // the required type.
 *     "image": "mandy", // the image to use from the theme.
 *     "speechAnimation": true|false, // if there is a speech animation.
 *     "frameRate": 24 // optional frame rate for the speech animation, defaults to 10.
 *     "location": [ 200, 200 ], // where on the screen to play this actor
 *     "size": [ w, h ], // provide this if you do not provide an image.
 *     "audio": "6th_01", // optional audio to speak on mouse over.
 *     "key": "mandy", // optional audio key, if not present, name will be used.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 *  If you set speechAnimation to true, -talk will be appended to the characters image name.
 * speechAnimation/speechLocation are optional.
 *
 * See also theme.json's speechAnimations, which specify speaking-animation images and location offsets:
 *
 *   "speechAnimations": {
 *    "janelle": {
 *      "images": ["talking-janelle-mouth1.png", "talking-janelle-mouth1.png", "talking-janelle-mouth2.png"],
 *      "mouthOffset": [65, 165]   // where within the actor "-talk" image to place the animation
 *    }
 * 
 * There must additionally be "Sound Sync Data", defining which image to show...
 *
 * "soundSyncData": {
 *   "6th_01": [
 *     0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1
 *   ], ...
 * }
 *
 *  The 0s and 1s represent which image, and could be 0,1,2,3 etc if there are more than 2. The key should match
 *  the "speechAudio" of this actor as well as the audio being played. 
 *  NOTE: Most of the speechSyncData does not contain '1's and looks like [0,0,2,3,3,3,2,0,2,3,2,0,0,0,2,3,4,4,3,4,2,0].
 *  In this case it is advised to use the [A, B, B, C, D] pattern for the different frames in your theme.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

     var NoInputCharacterActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            if( this.data.speechAnimation ) {
                this.addSpeechAnimation();
            }
        },
        getRequiredFields: function() {
            return [ "location" ];
        },
        buildActor: function() {
            var imageId = this.data.image;
            if( imageId ) {
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1], this.theme.textureKey,
                    this.getImage(imageId, 'actorImages'));
                
                if( this.data.scale ) {
                    this.sprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
                }
            } else {
                this.sprite = this.game.add.sprite(this.data.location[0], this.data.location[1]);
                this.sprite.width = this.data.size[0];
                this.sprite.height = this.data.size[1];
                this.addDebugBox();
            }
        },
        addDebugBox: function() {
            if( window.isDebugging ) {
                this.debugBox = new Phaser.Graphics(this.game, this.data.location[0], this.data.location[1]);
                this.debugBox.beginFill(0x000000, 1.0);
                this.debugBox.drawRect(0, 0, this.data.size[0], this.data.size[1]);
                this.debugBox.endFill();
                this.game.add.existing(this.debugBox);
            }
        },
        addSpeechAnimation: function() {
            var aSpeechAnimation = this.theme.speechAnimations[this.modelInterface.getValue(this.data.image)];
            if( !aSpeechAnimation ) {
                log.error("Could not add speech animation for character: " + this.data.name);
                log.error("Speech animation not found for " + this.data.image );
                log.error("Check that you have a speechAnimations section in your theme.");
                return;
            }
            this.speechAnimation = this.game.add.sprite(
                this.data.location[0] + aSpeechAnimation.mouthOffset[0],
                this.data.location[1] + aSpeechAnimation.mouthOffset[1],
                this.theme.textureKey,
                aSpeechAnimation.images[0]);
            this.speechAnimation.animations.add('talk', aSpeechAnimation.images);
            this.speechAnimationSet = aSpeechAnimation.images;
            this.speechAnimationDefault = aSpeechAnimation.images[0];
            if (this.data.flipMouth && this.data.scale) {
                this.speechAnimation.scale.setTo( this.data.scale[0] * -1, this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            } else if( this.data.scale ) {
                this.speechAnimation.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.speechAnimation.x = this.data.location[0] + (aSpeechAnimation.mouthOffset[0] * this.data.scale[0]);
                this.speechAnimation.y = this.data.location[1] + (aSpeechAnimation.mouthOffset[1] * this.data.scale[1]);
            }
        },
        onGameSpeech: function (speech) {
            var audio = this.modelInterface.getValue(speech.audio);
            if( speech.key ) {
                audio = this.modelInterface.getValue(speech.key) + "_" + audio;
            }
            log.warn("On game speech: " + audio);
            if( this.speechAnimation && this.theme.soundSyncData && this.theme.soundSyncData[audio] && this.data.speechAudio === audio ) {
                this.soundSyncData = this.theme.soundSyncData[audio];
                if( ! this.timer ) {
                    var FRAME_RATE = this.data.frameRate ? this.data.frameRate : 10;
                    this.timer = this.game.time.create(false);
                    this.speechIndex = 0;
                    this.timer.loop(1000 / FRAME_RATE, this.incrementSpeech, this);
                    this.timer.start();
                }
            }
        },
        incrementSpeech: function() {
            if( this.soundSyncData ) {
                this.speechIndex++;
                this.speechAnimation.frameName = this.speechAnimationSet[this.soundSyncData[this.speechIndex]];
            }
        },
        onGameSpeechStop: function (speech) {
            if( this.speechAnimation && this.soundSyncData) {
                this.timer.stop();
                this.timer.destroy();
                this.timer = null;
                this.soundSyncData = null;
                this.speechAnimation.frameName = this.speechAnimationDefault;
            }
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.inputEnabled = false;
                this.sprite.destroy();
            }
            if( this.data.text ) {
                this.graphics.destroy(true);
            }
            if( this.speechAnimation ) {
                this.speechAnimation.destroy();
            }
            if( this.debugBox ) {
                this.debugBox.destroy();
            }
            if( this.timer ) {
                this.timer.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = NoInputCharacterActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-question.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/05/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the question actor, which will:
 *   - show the player a (single selection/radio) multiple choice question
 *   - play any audio/text associated with asking question
 *
 * {
 *     "name": "questions_snitchingOrTelling_01",      // unique name for this actor.
 *     "type": "question", // required type.
 *     "font": "questionText",
 *     "submitButtonImage": "submit",                  // button image from theme.buttons
 *     "submitButtonID": "snitOrTellSubmitButton",     // to identify the text event coming from it
 *     "submitButtonLocation": [ 546, 255 ],
 *     "location": [ 90, 35 ],
 *     "startQuestion": "snitOrTell_question_01",      // which choice to start with from the choiceMap set.
 *     "choiceMap": {
 *       "snitOrTell_question_01": { // this is the name of this question, used when linking questions
 *          "text": (optional) "Shandra stumbled upon some pretty nasty comments online about Brianna. They were calling her a slut, among other things. Shandra decides to mention it to her mom.[br][br]Is this snitching or telling?" // question
 *          "audio": (optional) "snitchingOrTelling_question_01", // audio key.
 *          "key": (optional) "mandy", // a prefix for the audio key. (becomes "mandy_snitchingOrTelling_question_01" in this example)
 *          "choices": [
 *            {
 *               "text": "Snitching",                  // displayed text of this choice.
 *               "variable": "snitOrTell_question_01", // variable to set when chosen
 *               "value": "incorrect"                  // value to set variable to when chosen
 *            },
 *            {
 *               "text": "Telling",                    // displayed text of this choice.
 *               "variable": "snitOrTell_question_01", // variable to set when chosen
 *               "value": "correct"                    // value to set variable to when chosen
 *            }
 *            ... // as many choices as you want.
 *         ]
 *       },
 *     },
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 *  For a decision point, you can stll do a variable/value and link.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var QuestionActor = Actor.extend({
        constructor: function (game, data, theme) {
            if (!game) {
                throw "Decoration actor requires game constructor argument.";
            }
            if (!data) {
                throw "Decoration actor requires data constructor argument.";
            }

            this.game = game;
            this.theme = theme;
            this.data = data;
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal()
            };
            this.choiceMap = this.data.choiceMap;
            this.currentQuestionName = this.data.startQuestion;
            this.currentQuestion = this.choiceMap[this.currentQuestionName];
            this.marginY = 6;

            var fontName = this.data.font;
            this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

            this.location = this.data.location;

            this.radioGroup = this.game.add.group();
            this.radioTextGroup = this.game.add.group();

            // Track where we are at moving down the screen.
            this.currentX = (this.location !== 'undefined') ?
                this.location[0] : this.theme.snitchingOrTellingleftMargin * 3;
            this.currentY = (this.location !== 'undefined') ? this.location[1] : 35;
        },
        enterScene: function() {
            // Determine the number of questions and build the correct choice list.
            this.determineChoiceList();
            this.buildActor();
            this.populateChoices();
        },
        determineChoiceList: function() {
        },
        buildActor: function () {
            if (typeof this.currentQuestion.text !== 'undefined') {
                this.questionText = this.game.add.text(this.currentX, this.currentY,
                    this.currentQuestion.text, this.style);
                this.currentY += (this.questionText.height + this.marginY);
            }

            if( !this.data.submitButtonImage || !this.data.submitButtonID || !this.data.submitButtonLocation) {
                throw "Question Actor requires submit button configuration in scene data";
            }
            if( !this.theme.buttons || !this.theme.buttons[this.data.submitButtonImage]) {
                throw "Question Actor requires a submit button entry in theme";
            }

            this.submitButton = this.game.add.button( this.data.submitButtonLocation[0], this.data.submitButtonLocation[1],
                this.theme.textureKey, this.onSubmitButtonPointerUp, this,
                this.theme.buttons[this.data.submitButtonImage].over, this.theme.buttons[this.data.submitButtonImage].out,
                this.theme.buttons[this.data.submitButtonImage].down, this.theme.buttons[this.data.submitButtonImage].up);
            this.submitButton.inputEnabled = false;
        },
        populateChoices: function () {
            var question = (this.currentQuestion);

            // Build a list of options.
            var startY = this.currentY,
                currRadioButton,
                currText,
                optionIndex = 0;

            var choices = question.choices;
            _.each(choices, function (choice) {
                currRadioButton = this.radioGroup.create(0, 0,
                    this.theme.textureKey, this.theme.buttons.radioButtonGroup.unselected);
                currRadioButton.inputEnabled = true;
                currRadioButton.events.onInputDown.add(this.onChooseOption, this);
                currRadioButton.group = this.radioGroup;
                currRadioButton.x = this.theme.snitchingOrTellingleftMargin * 3;
                currRadioButton.y = this.currentY + 2;
                currRadioButton.frameName = this.theme.buttons.radioButtonGroup.unselected;
                currRadioButton.variable = choice.variable;
                currRadioButton.value = choice.value;
                currRadioButton.scale.set(0.75 , 0.75 );

                currText = new Phaser.Text(this.game, this.theme.snitchingOrTellingleftMargin * 4, 0,
                    choice.text, this.style);
                this.radioTextGroup.add(currText);
                currText.y = this.currentY;
                currText.inputEnabled = true;
                currText.events.onInputDown.add(this.onChooseOption, this);
                currText.group = this.radioTextGroup;
                currText.variable = choice.variable;
                currText.value = choice.value;
                currText.radioButton = currRadioButton; // link the text and radio button together.
                currRadioButton.optionText = currText;
                this.currentY += currRadioButton.optionText.height;
                optionIndex++;
            }, this);

            if( question.text || question.audio ) {
                var eventData = {"text": question.text, "audio": question.audio, "key": question.key};
                this.playAudio( eventData);
            }
        },
        onChooseOption: function (selectedInput) {
            // Adjust the other radio buttons.
            if( selectedInput.radioButton ) {
                selectedInput.radioButton.group.setAll('frameName', this.theme.buttons.radioButtonGroup.unselected);
                selectedInput.radioButton.frameName = this.theme.buttons.radioButtonGroup.selected;
            } else {
                selectedInput.group.setAll('frameName', this.theme.buttons.radioButtonGroup.unselected);
                selectedInput.frameName = this.theme.buttons.radioButtonGroup.selected;
            }
            // Save the whether the selected answer is correct.
            var varSet = {};
            varSet[selectedInput.variable] = selectedInput.value;

            this.events.onGameChoice.dispatch( this.data.name, varSet );

            this.lastResponseValue = selectedInput.value;
            this.submitButton.inputEnabled = true;
        },
        onSubmitButtonPointerUp: function( event ) {
            var eventData = {"text": this.lastResponseValue };
            this.playAudio(  eventData);
        },
        destroy: function () {
            if (this.radioGroup) {
                this.radioGroup.forEachExists(function (radio) {
                    if (radio.optionText) {
                        radio.optionText = null;
                    }
                    radio.destroy();
                },this);
                this.radioGroup.destroy();
            }
            if( this.radioTextGroup ) {
                this.radioTextGroup.forEachExists(function (radioText) {
                    if (radioText.radioButton) {
                        radioText.radioButton = null;
                    }
                    radioText.destroy();
                },this);
                this.radioTextGroup.destroy();
            }
            if ( this.submitButton ) {
                this.submitButton.destroy();
            }
            if ( this.questionText ) {
                this.questionText.destroy();
            }
            this.events.onGameChoice.dispose();
            this.events.onGameSpeech.dispose();
            this.events.length = 0;
        }
    });

    module.exports = QuestionActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-rectangle.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/19/2017
 * Copyright Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the rectangle actor, which will:
 *   - Draw a rectangle on the screen, with optional border.
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01", // unique name for this actor.
 *     "type": "rectangle", // required type.
 *     "start": [ x, y ],
 *     "color": "rgba(0,0,0,1)", // optional, default is black
 *     "width": "5", // optional, default is 1
 *     "height": "5", // optional, default is 1
 *     "alpha": "0.5", // optional, default is 1.0
 *     "border" : "1", // optional, thickness of border (none of not provided)
 *     "borderColor": "rbga(0,0,0,1)", // optional, default is black
 *     "roundness": "28", // default 28
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *  }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var RectangleActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "start"]
        },
        enterScene: function() {
            this.startLoc = this.data.start;
            this.endLoc = this.data.end;

            this.buildActor();
        },
        buildActor: function () {
            this.graphics = this.game.add.graphics( 0,0);
            var color = 0xFF3300, borderColor = 0xFF3300;
            var alpha = 1;
            var roundness = 28;
            var width = 440, height = 200;
            var x = this.startLoc[0], y = this.startLoc[1];
            var border = 0;

            this.rectangle = this.game.add.group();

            if( this.data.color ) {
                color = this.data.color;
            }

            if( this.data.borderColor ) {
                borderColor = this.data.borderColor;
            }

            if( this.data.width ) {
                width = parseInt(this.data.width, 10);
            }

            if( this.data.height ) {
                height = parseInt(this.data.height, 10);
            }

            if( this.data.roundness ) {
                roundness = parseInt(this.data.roundness, 10);
            }

            if( this.data.alpha ) {
                alpha = parseFloat(this.data.alpha);
            }

            if( this.data.border ) {
                border = parseInt(this.data.border, 10);
            }

            this.graphics.beginFill(color);
            this.graphics.drawRoundedRect(x, y, width, height, roundness); // draw a rounded rect mask
            this.graphics.endFill();
            if( border && border > 0 ) {
                this.graphics.lineStyle( border, borderColor, 1);
                this.graphics.drawRoundedRect(x, y, width, height, roundness);
            }
            this.graphics.alpha = alpha;

        },
        onGameSpeech: function( choice ) {

        },
        destroy: function () {
            this.startLoc = null;
            this.endLoc = null;
            if(this.graphics){
                this.graphics.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = RectangleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-speech-bubble.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble. It displays text and requests that audio be played. A speech bubble can have its own text/audio
 * and can also listen for text/audio events to show.
 * The speech bubble will adjust its size to fit the provided/set text.
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "speech-bubble",
 *    "text": "", // text to show.
 *    "audio": "", // audio key to play.
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 12, marginY = 12;

    var SpeechBubbleActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return []; // No required fields.
        },
        enterScene: function () {
            this.text = this.data.text || " ";
            this.audio = this.data.audio || "";
            this.key = this.data.key;

            this.addWindow(200, 50);
            this.setSpeech();
            // ACT-352 Hide empty speech bubbles.
            if( this.data.hidden || !this.text || this.text === " " ) {
                this.windowGroup.visible = false;
            }
        },
        addWindow: function (x, y) {
            if( !this.theme.textWindows || !this.theme.textWindows.small ) {
                throw "Instruction actor requires textWindows theme entry, and small definition inside it.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var topWindow = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textWindows.small.top);

            this.fStyle = this.getFont('bubbleText');
            this.rStyle = this.getFont('replayAudio');

            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = topWindow.width * 0.85;

            this.currentText = new Phaser.Text(this.game, marginX, marginY, " ", this.fStyle);
            windowGroup.add(this.currentText);

            var bottomWindow = windowGroup.create(0, 0 , this.theme.textureKey, this.theme.textWindows.small.bottom);

            // subtract 30 because the top speech bubble is 40 px tall.
            var middleWindow = new Phaser.TileSprite(this.game, 0, topWindow.height,
                338, this.currentText.height - 30, this.theme.textureKey, this.theme.textWindows.small.middle);
            windowGroup.add(middleWindow);

            bottomWindow.y = topWindow.height + middleWindow.height;

            // 5. Add eventing.
            this.windows = {
                top: topWindow,
                middle: middleWindow,
                bottom: bottomWindow
            };

            _.each(this.windows, function (bubble) {
                bubble.inputEnabled = true;
                bubble.events.onInputOver.add(this.onMouseIn, this);
                bubble.events.onInputOut.add(this.onMouseOut, this);
                bubble.events.onInputUp.add(this.onPointerUp, this);
            }, this);


            this.replayText = new Phaser.Text(this.game, (bottomWindow.x + bottomWindow.width - 40) / 2,
                (topWindow.height + bottomWindow.height + middleWindow.height) / 2, "Replay Audio", this.rStyle);
            this.replayText.anchor.setTo(0.5,0.5);
            windowGroup.add(this.replayText);
            this.replayText.visible = false;

            this.currentText.bringToTop();
            this.replayText.bringToTop();
            this.windowGroup = windowGroup;
            windowGroup.x -= topWindow.width / 2;
        },
        resize: function() {
            // subtract 30 because the top speech bubble is 40 px tall.
            this.windows.middle.height = this.currentText.height - 30;
            this.windows.bottom.y = this.windows.top.height + this.windows.middle.height;
        },
        onMouseIn: function () {
            this.fStyle.fill = this.theme.tints.bubbleText;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = true;
        },
        onMouseOut: function () {
            this.fStyle.fill = this.getFont('bubbleText').fill;
            this.currentText.setStyle(this.fStyle);
            this.replayText.visible = false;
        },
        onPointerUp: function () {
            this.playAudio(  {text: this.text, audio: this.audio, key: this.key});
        },
        setSpeech: function () {
            var text = this.substituteText(this.getText(this.text, this.key));
            this.currentText.setText( text );
            this.playAudio( {text: text, audio: this.audio, key: this.key});
            this.resize();
        },
        onGameSpeech: function (speech) {
            //log.warn("speech bubble received");
            //log.warn(speech);
            this.text = speech.text;
            this.key = speech.key;
            this.audio = speech.audio;
            this.currentText.setText( this.substituteText(this.getText(this.text, this.key)) );
            this.resize();
            // ACT-352 Hide empty speech bubbles, here, show it if there is text.
            if(  this.text && this.text !== " " ) {
                this.windowGroup.visible = true;
            }
        },
        destroy: function () {
            this.rStyle = null;
            this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;
            this.currentText = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = SpeechBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text-bubble.js":[function(require,module,exports){
/**
 * @author Jeff Blume
 * @version 1.0.0
 * @creation 07/24/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A speech bubble that only displays text and a bubble behind it. Allows for movable carrot. Auto adjusts to text size.
 * NOTE: NEEDS DEFAULT PARAMETER VALUES AND/OR REQUIREMENT CHECKING AND ERROR HANDLING
 *
 *{
 *    "name": "choiceBubble", // name.
 *    "type": "text-bubble",
 *    "carrotSide": "bottom", // "top", "bottom", "left" or "right" - side of bubble the carrot is to be positioned
 *    "location": [0,0],
 *    "carrotPosition": 0.5, // location, as percentage of length or width of carrotSide
 *    "centerFill": "0xffffff",
 *    "text": "", // text to show.
 *    "bubbleWidth": 200,
 *    "textPadding": 20, // Padding between bubble and text
 *    "hidden": true, // set to true to optionally hide the bubble initially, used when character isn't the first to talk.
 *    "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *},
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var marginX = 12, marginY = 12;

    var TextBubbleActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return []; // No required fields.
        },
        enterScene: function () {
            this.carrotSide = this.data.carrotSide;
            this.location = this.data.location;
            this.carrotPosition = this.data.carrotPosition;
            this.centerFill = this.data.centerFill;
            this.text = this.data.text;
            this.bubbleWidth = this.data.bubbleWidth
            this.textPadding = this.data.textPadding;
            this.hidden = this.data.hidden;
            this.startDelay = this.data.startDelay;


            this.addWindow(this.location[0], this.location[1]);
            //this.setSpeech();
            // ACT-352 Hide empty speech bubbles.
            if( this.data.hidden ) {
                this.windowGroup.visible = false;
            }
        },
        addWindow: function (x, y) {
            if( !this.theme.textBubbleImages ) {
                throw "Instruction actor requires textBubbleImages theme entry.";
            }

            var windowGroup = this.game.add.group();
            windowGroup.x = x;
            windowGroup.y = y;

            var bubbleTopLeft = windowGroup.create(0, 0, this.theme.textureKey, this.theme.textBubbleImages.topLeft);
            var bubbleTop = windowGroup.create(bubbleTopLeft.width, 0, this.theme.textureKey, this.theme.textBubbleImages.top);
            var bubbleTopRight = windowGroup.create(bubbleTopLeft.width + bubbleTop.width, 0, this.theme.textureKey, this.theme.textBubbleImages.topRight);
            var bubbleRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height, this.theme.textureKey, this.theme.textBubbleImages.right);
            var bubbleBottomRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height + bubbleRight.height, this.theme.textureKey, this.theme.textBubbleImages.bottomRight);
            var bubbleBottom = windowGroup.create(bubbleTop.x, bubbleBottomRight.y, this.theme.textureKey, this.theme.textBubbleImages.bottom);
            var bubbleBottomLeft = windowGroup.create(0, bubbleBottomRight.y, this.theme.textureKey, this.theme.textBubbleImages.bottomLeft);
            var bubbleLeft = windowGroup.create(0, bubbleTopLeft.height, this.theme.textureKey, this.theme.textBubbleImages.left);
            var bubbleCenter = this.game.add.graphics(bubbleTopLeft.width, bubbleTopLeft.height, windowGroup);

            this.fStyle = this.getFont('textBubbleText');
            this.fStyle.wordWrap = true;
            this.fStyle.wordWrapWidth = this.bubbleWidth - (this.textPadding * 2);

            this.currentText = new Phaser.Text(this.game, this.textPadding, this.textPadding, this.text, this.fStyle);
            windowGroup.add(this.currentText);

            var bubbleTopWidth = this.bubbleWidth - bubbleTopLeft.width - bubbleTopRight.width;
            var tops = Math.ceil(bubbleTopWidth / bubbleTop.width);
            var topRemainder = bubbleTopWidth % bubbleTop.width;
            for (var i = 1; i < tops; i++) {
                var thisTop = windowGroup.create(bubbleTopLeft.width + (i * bubbleTop.width), 0, this.theme.textureKey, this.theme.textBubbleImages.top);
            }
            if(topRemainder !== 0){
                thisTop.x -= bubbleTop.width - topRemainder;
            }

            bubbleTopRight.x = this.bubbleWidth - bubbleTopRight.width;
            bubbleRight.x = bubbleBottomRight.x = bubbleTopRight.x;
            var bubbleRightHeight = this.currentText.height + (2 * this.textPadding) - bubbleTop.height - bubbleBottom.height;
            var rights = Math.ceil(bubbleRightHeight / bubbleRight.height);
            var rightRemainder = bubbleRightHeight % bubbleRight.height;
            for (i = 1; i < rights; i++) {
                var thisRight = windowGroup.create(bubbleTopRight.x, bubbleTopRight.height + (bubbleRight.height * i), this.theme.textureKey, this.theme.textBubbleImages.right);
            }
            if(rightRemainder !== 0){
                thisRight.y -= bubbleRight.height - rightRemainder;
            }


            bubbleBottomRight.y = bubbleTopRight.height + bubbleRightHeight;
            bubbleBottom.y = bubbleBottomRight.y;
            for (i = 1; i < tops; i++) {
                var thisBottom = windowGroup.create(bubbleTopLeft.width + (i * bubbleTop.width), bubbleBottom.y, this.theme.textureKey, this.theme.textBubbleImages.bottom);
            }
            if(topRemainder !== 0){
                thisBottom.x -= bubbleTop.width - topRemainder;
            }


            bubbleBottomLeft.y = bubbleBottomRight.y;
            for (i = 1; i < rights; i++) {
                var thisLeft = windowGroup.create(0, bubbleTopRight.height + (bubbleRight.height * i), this.theme.textureKey, this.theme.textBubbleImages.left);
            }
            if(rightRemainder !== 0){
                thisLeft.y -= bubbleRight.height - rightRemainder;
            }

            var carrot = null;
            switch(this.carrotSide){
                case "top":
                    carrot = windowGroup.create(this.bubbleWidth * this.carrotPosition, this.theme.textBubbleImages.carrotOverlap, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.scale.y = -1;
                    carrot.anchor.x = 0.5;
                    break;
                case "right":
                    carrot = windowGroup.create(this.bubbleWidth - this.theme.textBubbleImages.carrotOverlap, (bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height) * this.carrotPosition, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    carrot.rotation = -90 * (Math.PI/180);
                    break;
                case "bottom":
                    carrot = windowGroup.create(this.bubbleWidth * this.carrotPosition, bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height - this.theme.textBubbleImages.carrotOverlap, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    break;
                case "left":
                    carrot = windowGroup.create(this.theme.textBubbleImages.carrotOverlap, (bubbleRightHeight + bubbleTopRight.height + bubbleBottomRight.height) * this.carrotPosition, this.theme.textureKey, this.theme.textBubbleImages.carrot);
                    carrot.anchor.x = 0.5;
                    carrot.rotation = 90 * (Math.PI/180);
                    break;
            }

            bubbleCenter.beginFill(this.centerFill);
            bubbleCenter.drawRect(0, 0, bubbleTopWidth, bubbleRightHeight);
            bubbleCenter.endFill();

            windowGroup.bringToTop(this.currentText);
            this.windowGroup = windowGroup;
        },
        destroy: function () {
            this.rStyle = null;
            /*this.fStyle = null;
            if ( this.windows ) {
                _.each(this.windows, function (bubble) {
                    bubble.inputEnabled = false;
                }, this);
            }
            this.windows = null;*/
            this.currentText = null;
            if ( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = TextBubbleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/07/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the text actor, which will:
 *   - show the specified text
 *   - play any audio/text associated with the text
 *
 * {
 *     "name": "snitchingOrTelling_feedback_01",    // unique name for this actor.
 *     "type": "text",                              // required type.
 *     "text": "Correct. Click the Next button to find out why."
 *     "font": "questionText",
 *     "location": [ x, y ],    // or "center" for either field.
 *     "angle": -30,            // optional, degrees from north (-180 to 180)
 *     "rotation": 0.5,         // optional, radians in units of PI. This overrides angle if both are set.
 *     "anchor": (optional) "left",     // which side to anchor the text sprite. Can also set anchor to specific position [x,y]
 *     "audio": (optional) "snitchingOrTelling_feedback_01",    // audio key.
 *     "key": (optional) "mandy", // a prefix for the audio key. (becomes "mandy_snitchingOrTelling_feedback_01" in this example),
 *     "wordWrapWidth": #,  // optionally set a wrapping width
 *     "bullet": true,
 *     "bulletOffset": 3, // optional, space in pixels after bullet if you want other than default spacing
 *     "shadowX": 5, // optional, drop shadow width in pixels; default is no shadow - same as shadowY if only one is specified - 5 if only color is specified
 *     "shadowY": 5, // optional, drop shadow height in pixels; default is no shadow - same as shadowX if only one is specified - 5 if only color is specified
 *     "shadowColor": "rgba(0,0,0,1)", // optional, default is black with alpha 1.0
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "tween": {                      // optional, tween to be applied to the text
 *       "time": 300,                  // (required for tween) duration of the tween
 *       "location": [ 190, 150 ],     // (required for tween) location to tween to, required
 *       "delay": 10000,               // (optional for tween) delay in milliseconds before tweening
 *       "yoyo": true                  // (optional for tween) return to original position after tween?
 *       "align": "left"               // optional, align value that will override the style setting in the theme (added by Jeff Blume 12.17.2019)
 *     }
 *  }
 *
 *  Note that this actor recognizes optional properties in the font style:
 *
 *      "lineSpacing" (a number of pixels to add to the normal wrapped text line spacing). For example, to reduce line spacing by 15 pixels:
 *
 *          "lesson_light": { "font": "35px flashdligregular", "wordWrap": true, "wordWrapWidth": 200, "lineSpacing": -15 }
 *
 *     "alpha" (opacity, a number between 0 and 1)
 *
 *          "lesson_light": { "font": "35px flashdligregular", "alpha": 0.5 }
 *
 *     "shadowX": (include a drop shadow with this width, in pixels) This will be set to the value in shadowY if only
 *          one is specified, or set to 5 pixels if only shadowColor is specified.
 *     "shadowY": (include a drop shadow with this height, in pixels) This will be set to the value in shadowX if only
 *          one is specified, or set to 5 pixels if only shadowColor is specified.
 *     "shadowColor": (include a drop shadow with this color and alpha value) If shadowX and/or shadowY are specified
 *          but shadowColor is not specified, default is black with alpha 1.0
 *     "shadowBlur": (gaussian blur to soften shadow) optional, A number from 0 (no blur) up to approximately
 *          10 (depending on scene).
 *
 *     For example, to specify an 8-pixel wide and 3-pixel high blurred drop shadow in red:
 *
 *          "lesson_redShadow": { "font": "35px flashdligregular", "shadowX": 8, "shadowY": 3, "shadowColor": "rgba(255,0,0,1)", "shadowBlur": 5 }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var TextActor = Actor.extend({
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "font", "text" ]
        },
        enterScene: function() {
            this.text = this.data.text;
            this.location = this.data.location;
            this.audio = this.data.audio;
            this.key = this.data.key;

            var fontName = this.data.font;
            this.style = this.getFont((typeof fontName !== 'undefined') ? fontName : "questionText");

            if( this.data.wordWrapWidth ) {
                this.style.wordWrap = true;
                this.style.wordWrapWidth = parseInt(this.data.wordWrapWidth, 10);
            }

            if(this.data.align){
                this.style.align = this.data.align;
            }

            this.buildActor();
        },
        buildActor: function () {
            
            this.text = this.substituteText(this.text); 

            var x = this.location[0],
                y = this.location[1],
                anchorX = 0,
                anchorY = 0;

            if( x === "center" ) {
                x = this.game.world.centerX;
                anchorX = 0.5;
            }

            if( y === "center" ) {
                y = this.game.world.centerY;
                anchorY = 0.5;
            }

            if (this.data.anchor === "left") {
              anchorX = 0;
            } 
            else if (this.data.anchor === "center") {
              anchorX = 0.5;
            } 
            else if (this.data.anchor === "right") {
              anchorX = 1;
            }
            else if( this.data.anchor ) {
                anchorX = this.data.anchor[0];
                anchorY = this.data.anchor[1];
            }

            this.bulletX = x;
            if( this.data.bullet ) {
                var useBulletOffset = ((typeof (this.data.bulletOffset)) !== 'undefined');
                var bulletText = useBulletOffset ? "" : " ";
                var bulletOffsetWidth = 0; //initialize width from bullet to text
                if(useBulletOffset){
                    bulletOffsetWidth = this.data.bulletOffset; //sets bulletOffset from theme.json
                }
                var anchorFactor = anchorX; 
                
                if(anchorX === 0.5)
                {
                    //for centered text only
                    this.textSprite = this.game.make.text(x, y, this.text, this.style);
                    this.bulletSprite = this.game.make.text(x, y,bulletText, this.style);  
                    var alignmentAdjustment = ((this.bulletSprite.width + bulletOffsetWidth + this.textSprite.width)/2); // length to center
                    this.bulletSprite.destroy();
                    this.bulletSprite = this.game.add.text(x - alignmentAdjustment, y, bulletText, this.style); 
                    var calculatedTextX = x - (this.bulletSprite.position.x - (this.bulletSprite.width /2)); // get x position of text
                    this.textSprite.destroy();
                    this.textSprite = this.bulletSprite.addChild(this.game.make.text(calculatedTextX , y - this.bulletY, this.text, this.style));
                }
                else
                {
                    //for left OR right aligned text
                    this.bulletSprite = this.game.add.text(x  + bulletOffsetWidth, y, bulletText, this.style);
                    this.textSprite = this.bulletSprite.addChild(this.game.make.text(this.bulletSprite.width, y - this.bulletY, this.text, this.style));
                }
            }
            else
            {
                this.textSprite = this.game.add.text(x, y, this.text, this.style);
            }

            this.textX = x;

            if ( (typeof (this.style.lineSpacing)) !== 'undefined' ) {
                this.textSprite.lineSpacing = this.style.lineSpacing;
            }

            if ( (typeof (this.style.alpha)) !== 'undefined' ) {
                this.textSprite.alpha = this.style.alpha;
            }

            var hasX = (( typeof (this.style.shadowX)) !== undefined );
            var hasY = (( typeof (this.style.shadowY)) !== undefined );
            var hasColor = (( typeof (this.style.shadowColor)) !== undefined );
            var hasBlur = (( typeof (this.style.shadowBlur)) !== undefined );
            if ( hasX || hasY || hasColor || hasBlur ) {
                var shadowX = 5;
                var shadowY = 5;
                if ( hasX ) {
                    shadowX = this.style.shadowX;
                    if ( !hasY ) {
                        shadowY = shadowX;
                    }
                }
                if ( hasY ) {
                    shadowY = this.style.shadowY;
                    if ( !hasX ) {
                        shadowX = shadowY;
                    }
                }
                var shadowColor = "rgba(0,0,0,1)";
                if ( hasColor ) {
                    shadowColor = this.style.shadowColor;
                }
                var shadowBlur = 0;
                if ( hasBlur ) {
                    shadowBlur = this.style.shadowBlur;
                }
                this.textSprite.setShadow( shadowX, shadowY, shadowColor, shadowBlur );
            }
            this.textSprite.anchor.setTo( anchorX, anchorY );

            if( this.data.scale ) {
                this.textSprite.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }

            if( this.audio ) {
                var eventData = {"audio": this.audio, "key": this.key};
                this.playAudio( eventData);
            }

            if ( this.data.angle ) {
                if (this.bulletSprite) {
                    this.bulletSprite.angle = this.data.angle;
                }
                else {
                    this.textSprite.angle = this.data.angle;
                }
            }
            

            if ( this.data.rotation ) {
                if (this.bulletSprite) {
                    this.bulletSprite.rotation = Math.PI * this.data.rotation;
                }
                else {
                    this.textSprite.rotation = Math.PI * this.data.rotation;
                }
            }
            

            if( this.data.tween ) {
                var tweenData = this.data.tween;

                var textOffset = this.textX - this.bulletX;
                var yoyo = ( typeof tweenData.yoyo != "undefined" ) ? tweenData.yoyo : false;
                var delay = ( typeof tweenData.delay != "undefined" ) ? tweenData.delay : 0;
                var easing = ( typeof tweenData.easing != "undefined" ) ? tweenData.easing : "Linear";

                if( tweenData.location ) {
                    if( this.data.bullet ) {
                        this.game.add.tween(this.bulletSprite).to( { x: tweenData.location[0], y: tweenData.location[1]  },
                            tweenData.time, easing, true, delay, 0, yoyo);
                    }else{
                        this.game.add.tween(this.textSprite).to( { x: (tweenData.location[0] + textOffset), y: tweenData.location[1]  },
                        tweenData.time, easing, true, delay, 0, yoyo);
                    }
                }

                if( tweenData.scale ) {
                    this.game.add.tween(this.textSprite.scale).to( { x: tweenData.scale[0], y: tweenData.scale[1]  }, tweenData.time, easing, true, delay);
                }

                if( !_.isUndefined(tweenData.alpha) ) {
                    this.game.add.tween(this.textSprite).to( { alpha: tweenData.alpha }, tweenData.time, easing, true, delay);
                }
            }
        },
        onGameSpeech: function( choice ) {
            if( choice && choice.text ) {
                this.textSprite.setText(choice.text);
            }
        },
        destroy: function () {
            if ( this.textSprite ) {
                this.textSprite.destroy();
            }
            if( this.bulletSprite ) {
                this.bulletSprite.destroy();
            }
            if( this.audio ) {
                var eventData = { "audio": this.audio, "key": this.key, "priority": "stop"};
                this.playAudio(  eventData);
            }
            this.location = null;
            this.freeBaseActor();
        }
    });

    module.exports = TextActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-timeline.js":[function(require,module,exports){
/**
 * @author David Lee
 * @version 1.0.0
 * @creation 04/04/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital
 * 
 * A timeline actor that updates a variable after a given period (in ms) has elapsed. 
 * This actor has no visible rendered component.
 * It does *NOT* remove itself once the variable has been set; this is left to the scripter if that behavior is desired.
 * 
 * Creating a Timeline actor:
 * {
 *      "name": "event1",               // A unique name for the actor
 *      "type": "timeline",             // Required type
 *      "period": 1000,                 // Number of miliseconds to wait before 
 *      "variable": "timeline_event"    // After the given period has elapsed, update this variable with the name of this actor
 *
 *      "startDelay": 0                 // I *STRONGLY* recommend against using this value, but if you do, remember the event will not fire until period + startDelay ms have elapsed since the actor was added to the scene.
 * }
 */

(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');


    var TimelineActor = Actor.extend({
        // constructor in parent.

        getRequiredFields: function() {
            return [ "period", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            if (!this.data.period) {
                throw "Timer Actor requires a period to be set";
            }
            if (!this.data.variable) {
                throw "Timer Actor requires a variable to be set";
            }
            // There may be some use for period == 0, in the same vein as setTimeout(fn, 0) so I'll allow it for now
            if (this.data.period < 0 ) {
                throw "Timer Actor requires period to be >= 0";
            }

            this.timerEvent = this.game.time.events.add(this.data.period, this.timerFired, this);
        },
        timerFired: function() {
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.dispatchGameChoice(varSet);
        },
        destroy: function() {
            if (this.timerEvent) {
                this.game.time.events.remove(this.timerEvent);
            }
            this.freeBaseActor();
        }
    });

    module.exports = TimelineActor;
}());
},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-toggle-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The toggle button actor. This actor can be used for simple actions, such as opening the cell phone, and will
 * remember its internal state of on or off. In many 'plays', this actors isn't needed.
 *
 * Creating a toggle button actor:
 * {
 *     "name": "mute1", // a unique identifier
 *     "type": "toggle-button", // the required type.
 *     "images": {
 *      "on": "muteon",
 *      "off": "muteoff"
 *     }, // the images to use from the button section of the theme.
 *     "location": [ x, y ],
 *     "variable": "mute_game",
 *     "values": {
 *          "on": "mute_on",  // the value used instead of the name when the variable is set.
 *          "off": "mute_off"
 *     }
 *     // optional "scale": [ 1.1, 1.1 ] // Use negative scales to 'flip' the images.
 *     // optional: "active": true/false, // will default to false.
 *     // optional: "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('./actor');

    var ToggleActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location", "images", "values", "variable" ];
        },
        enterScene: function() {
            this.isActive = false;
            if( this.data.active && this.data.active === true) {
                this.isActive = true;
            }

            this.buildActor();
            // Even though the user could set active, check the model...
            if( this.data.variable === "mute_game"   ) {
                this.isActive = !this.game.sound.mute;
            }
            this.buttonOn.visible = this.isActive;
            this.buttonOff.visible = !this.isActive;
        },
        buildActor: function() {
            if( !this.theme.buttons || !this.theme.buttons[this.data.images.off] || !this.theme.buttons[this.data.images.on]) {
                throw "Button Actor requires buttons entry in theme, with specific entry matching images off/on";
            }

            this.buttonOff = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons[this.data.images.off].over, this.theme.buttons[this.data.images.off].out,
                this.theme.buttons[this.data.images.off].down, this.theme.buttons[this.data.images.off].up);
            this.buttonOff.inputEnabled = true;

            this.buttonOn = this.game.add.button( this.data.location[0], this.data.location[1], this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons[this.data.images.on].over, this.theme.buttons[this.data.images.on].out,
                this.theme.buttons[this.data.images.on].down, this.theme.buttons[this.data.images.on].up);
            this.buttonOn.inputEnabled = true;

            if( this.data.scale ) {
                this.buttonOff.scale.setTo( this.data.scale[0], this.data.scale[1]);
                this.buttonOn.scale.setTo( this.data.scale[0], this.data.scale[1]);
            }
        },
        onAction: function() {
            var varSet = {};
            varSet[this.data.variable] = this.isActive ? this.data.values["on"] : this.data.values["off"];
            this.events.onGameChoice.dispatch( this.data.name, varSet );
            this.buttonOn.visible = this.isActive;
            this.buttonOff.visible = !this.isActive;
        },
        onPointerUp: function(  ) {
            this.isActive = !this.isActive;
            this.onAction();
        },
        destroy: function() {
            if ( this.buttonOff ) {
                this.buttonOff.inputEnabled = false;
                this.buttonOff.destroy();
            }
            if ( this.buttonOn ) {
                this.buttonOn.inputEnabled = false;
                this.buttonOn.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ToggleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button-invisible.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The invisible button url actor. Place it over text to provide hyperlink-like functionality, opening
 * the specified link in a new window or tab.
 *
 * Creating a url-button-invisible actor:
 * {
 *     "name": "href1", // a unique identifier
 *     "type": "urlInvisible", // the required type.
 *     "location": [ x, y ],
 *     "width": w,
 *     "height": h,
 *     "url": "www.google.com",
 *     "variable": "show_url", // if you click the button, the variable 'show_url' will be set to 'href1'.
 *     "startDelay": 1000 // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        Actor = require('./actor');

    var UrlButtonInvisibleActor = Actor.extend( {
        // constructor is in parent.
        enterScene: function() {
            this.buildActor();
        },
        getRequiredFields: function() {
            return [ "location", "width", "height", "url", "variable" ];
        },
        buildActor: function() {
            this.button = this.game.add.button( this.data.location[0], this.data.location[1],
                null,
                this.onPointerUp, this,
                null, null, null, null);
            this.button.inputEnabled = true;
            this.button.width = this.data.width;
            this.button.height = this.data.height;
        },
        onPointerUp: function( event ) {
            window.open(this.data.url, "_blank");
            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = UrlButtonInvisibleActor;
}());

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button.js":[function(require,module,exports){
/**
 * @author Syd Grosclaude
 * @version 1.0.0
 * @creation 08/20/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The url actor. This actor can be used to provide a button; when clicked, open a url in a new window/tab.
 *
 * Creating a url actor:
 * {
 *     "name": "href1", // a unique identifier
 *     "type": "url-button", // the required type.
 *     "image": "resourceImage", // the images to use from the buttons section of the theme.
 *     "location": [ x, y ],
 *     "url": "www.google.com",
 *     "variable": "show_url" // if you click the button, the variable 'show_url' will be set to 'href1'.
 *     // optional "scale": [ 1.1, 1.1 ] // Use negative scales to 'flip' the images.
 *     // optional "startDelay": 1000 // delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 * }
 *
 */
(function () {
	var _ = require("lodash"),
		ButtonActor = require("./actor-button");

	var UrlButtonActor = ButtonActor.extend({
		getRequiredFields: function () {
			var myRequired = ["url"];
			var baseRequired = this.base();
			var allRequired =
				typeof baseRequired != "undefined"
					? baseRequired.concat(myRequired)
					: myRequired;
			return allRequired;
		},
		onPointerUp: function (event) {
			window.open(this.game.config.assetPath + this.data.url, "_blank");
			this.base(event);
		},
	});

	module.exports = UrlButtonActor;
})();

},{"./actor-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-wistia.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A a video actor usin Wistia.
 *
 * {
 *    "name": "video1",
 *     "type": "wistia",
 *     "location": [ 2, 5 ], // location on screen.
 *     "size": [ 300, 200 ],
 *     "video" : "dun1fuu253",
 *     "closeButtonLocation" : [ 70, 44 ], // optional, default is top right of video
 *     "hideCloseButton": true, // optional, will hide the close button.
 *     "blockerTint" : "0x000000", // optional, default is black (0x000000)
 *     "blockerAlpha" : 0.5, // optional, default is 0.5
 *     "blockInput": false, // block input until video is done, optional
 *     "startDelay": 1000, // optional, delay in ticks before adding the actor (think of a tick as a millisecond, defined in main.js)
 *     "autoplay": true, // optional. will automatically start the video.
 *     "variable": "string", // optional variable. If present, will be set to started and finished
 *     "markers": [ 5, 15, 20 ] // optional. At specified markers, variable will be set to marker value.
 * },
 *
 */
(function () {
	"use strict";
	var _ = require("lodash"),
		log = require("loglevel"),
		Actor = require("./actor"),
		$ = require("jquery");

	var WistiaActor = Actor.extend({
		// constructor in parent.
		getRequiredFields: function () {
			return ["location", "size", "video"];
		},
		enterScene: function () {
			if (!Wistia) {
				throw "Wistia appears to be missing, cannot create wistia actor.";
			}
			this.video = this.data.video;
			this.blockInput = this.data.blockInput || false;
			this.element = $(this.game.canvas.parentElement);

			if (this.blockInput) {
				this.blockingSprite = this.createBlockingSprite();
				this.blockingSprite.bringToTop();
				this.blockingSprite.visible = false;
			}

			this.currentX = this.data.location[0];
			this.currentY = this.data.location[1];
			this.width = this.data.size[0];
			this.height = this.data.size[1];
			if (this.currentX === "center") {
				this.currentX = this.game.world.centerX - this.width / 2;
			}
			if (this.currentY === "center") {
				this.currentY = this.game.world.centerY - this.height / 2;
			}

			_.bindAll(this, "addWindow");
			window.wistiaInit = this.addWindow;
		},
		addListeners: function () {
			// Bind these, otherwise "this" will be lost. Wistia doesn't accept a context!
			_.bindAll(this, "onWistiaEnd");
			_.bindAll(this, "onWistiaPlay");
			this.wistiaEmbed.bind("play", this.onWistiaPlay);
			this.wistiaEmbed.bind("end", this.onWistiaEnd);
			if (this.data.variable) {
				_.bindAll(this, "onWistiaMarker");
				if (this.data.markers && _.isArray(this.data.markers)) {
					this.wistiaEmbed.bind("secondchange", this.onWistiaMarker);
				}
			}
		},
		onGameSpeech: function (speech) {
			if (speech.audio && speech.audio !== this.video) {
				this.pause();
			}
		},
		pause: function () {
			if (typeof this.wistiaEmbed != "undefined") {
				this.wistiaEmbed.pause();
			}
		},
		onWistiaMute: function (isMuted) {
			log.warn("Called onWistiaMute: " + isMuted);
			if (isMuted) {
				this.wistiaEmbed.volume(0);
			} else {
				this.wistiaEmbed.volume(1);
			}
		},
		onWistiaMarker: function (seconds) {
			_.each(
				this.data.markers,
				function (marker) {
					if (parseInt(marker, 10) === seconds) {
						var varSet = {};
						varSet[this.data.variable] = seconds;
						this.dispatchGameChoice(varSet);
						return false; // exit loop.
					}
				},
				this
			);
		},
		onWistiaEnd: function () {
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable] = "finished";
				this.dispatchGameChoice(varSet);
			}
		},
		onWistiaPlay: function () {
			this.onWistiaMute(this.game.sound.mute);
			this.playAudio({ audio: this.video, key: null });
			if (this.data.variable) {
				var varSet = {};
				varSet[this.data.variable] = "started";
				this.dispatchGameChoice(varSet);
			}
		},
		addWindow: function () {
			/**
			 * This should be a handlebars template but we're having internet trouble so here it is... text.
			 * @type {string}
			 */
			//console.log("wistia api loaded");
			if (this.element) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it.

				var videoContainer = document.createElement("div");
				if (this.theme.internal_autoScale == true) {
					// This property is tacked onto the theme by play.js if set to true in the play.json settings.
					console.log(
						"currentX: " + this.currentX + " - currentY: " + this.currentY
					);
					console.log("this.data.size[0]: " + this.data.size[0]);
					var leftPct = (this.currentX / this.game.world.width) * 100;
					var topPct = (this.currentY / this.game.world.height) * 100;
					var scalePct = (this.data.size[0] / this.game.world.width) * 100;
					videoContainer.setAttribute(
						"style",
						"position: absolute; z-index: 150; width: " +
							scalePct +
							"%; top: " +
							topPct +
							"%; left: " +
							leftPct +
							"%;"
					);
				} else {
					videoContainer.setAttribute(
						"style",
						"position: absolute; z-index: 150; width: " +
							this.width +
							"px; height: " +
							this.height +
							"px; top: " +
							this.currentY +
							"px; left: " +
							this.currentX +
							"px;"
					);
				}

				videoContainer.setAttribute("id", "videoContainer");

				this.videoElement = document.createElement("div");
				var classString = "wistia_embed wistia_async_" + this.video;
				//classString += " endVideoBehavior=reset";
				//classString += " playbar=false";
				if (this.game.device.iPad) {
					classString += " qualityMax=360";
				}
				if (this.data.autoScale == true || this.data.autoScale == null) {
					// enable by default, even if not declared
					classString += " videoFoam=true";
				}
				this.videoElement.setAttribute("class", classString);
				this.videoElement.setAttribute(
					"style",
					"width:" + this.width + "px; height:" + this.height + "px;"
				);
				this.videoElement.setAttribute("id", "videoElement");

				videoContainer.appendChild(this.videoElement);
				var gameContainer = document.querySelector("#gameContainer");
				gameContainer.appendChild(videoContainer);

				window._wq = window._wq || [];
				_.bindAll(this, "onWistiaEmbed");
				_wq.push({ id: this.video, onReady: this.onWistiaEmbed });
			}
		},
		onWistiaEmbed: function (video) {
			//console.log("wistia video loaded");
			if (this.element && !this.wistiaEmbed) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it. this.wistiaEmbed checked to keep function from running multiple times when slide is revisited - Wistia seems to doesn't clear the onReady event binding.
				this.wistiaEmbed = video;

				this.showBlockingSprite();
				this.addCloseButton();

				if (this.blockInput) {
					this.blockingSprite.visible = true;
				}

				this.addListeners();
				if (this.data.autoplay === true) {
					this.wistiaEmbed.play();
				}
			}
		},
		showBlockingSprite: function () {
			if (this.blockInput) {
				this.game.add.existing(this.blockingSprite);
			}
		},
		addCloseButton: function () {
			if (this.data.hideCloseButton !== true) {
				var closeButtonX, closeButtonY;
				if (typeof this.data.closeButtonLocation === "undefined") {
					closeButtonX = this.currentX + this.width;
					closeButtonY = this.currentY;
				} else {
					closeButtonX = this.data.closeButtonLocation[0];
					closeButtonY = this.data.closeButtonLocation[1];
				}

				this.button = new Phaser.Button(
					this.game,
					closeButtonX,
					closeButtonY,
					this.theme.textureKey,
					this.onClose,
					this,
					this.theme.buttons.videoClose.over,
					this.theme.buttons.videoClose.out,
					this.theme.buttons.videoClose.down,
					this.theme.buttons.videoClose.up
				);
				if (typeof this.data.closeButtonLocation == "undefined") {
					// We're using the default close button location, so move it up by its height to sit above the video.
					this.button.y -= this.button.height;
				}
				this.button.bringToTop();
				this.button.input.useHandCursor = true;
				this.game.add.existing(this.button);
			}
		},
		createBlockingSprite: function () {
			var blockerTint =
				typeof this.data.blockerTint === "undefined"
					? 0x000000
					: this.data.blockerTint;
			var blockerAlpha =
				typeof this.data.blockerAlpha === "undefined"
					? 0.5
					: this.data.blockerAlpha;

			var sprite = new Phaser.Sprite(this.game, 0, 0);
			var graphics = new Phaser.Graphics(this.game, 0, 0);
			sprite.addChild(graphics);
			graphics.beginFill(blockerTint, blockerAlpha);
			graphics.drawRect(0, 0, this.game.world.width, this.game.world.height);
			graphics.endFill();
			sprite.inputEnabled = true;
			return sprite;
		},
		onClose: function () {
			this.destroy();
		},
		destroy: function () {
			if (this.element) {
				// Check for existance in case someone is 'fast' and tries closing the video before Wistia is done
				// loading it.
				if (this.wistiaEmbed) {
					this.wistiaEmbed.unbind();
					this.wistiaEmbed.remove();
					this.wistiaEmbed = null;
				}
				if (this.blockInput) {
					this.blockingSprite.visible = false;
				}
				if (this.button) {
					this.button.visible = false;
					this.button.destroy();
					this.button = null;
				}
				//log.warn(this.videoElement.attr('id'));
				$("#videoContainer").hide();
				var temp = {};
				temp[this.data.name] = "closed";
				this.events.onGameChoice.dispatch(this.data.name, temp);
				// Now, delete it all.
				if (this.blockInput) {
					this.blockingSprite.destroy(true);
				}
				//log.warn(this.videoElement.attr('id'));
				$("#videoContainer").remove();
				this.element = null;
				this.freeBaseActor();
			}
		},
	});

	module.exports = WistiaActor;
})();

},{"./actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","jquery":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\jquery\\dist\\jquery.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * An generic actor. It cannot be instantiated. It provides functionality to all actors
 *
 *  "inverseEvents": true // optional. Events will go only to this sprite, instead of only to others.
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var DEFAULT_FONT = { "font": "20px Tahoma", "fill": "#000000",  "fontWeight": "bold"},
        DEFAULT_TEXT = "Text Not Found.",
        DEFAULT_IMAGE = "Image Not Found.";

    var Actor = Base.extend({
        constructor: function(game,  data, theme) {
            if( !game ) {
                throw "Actor requires game constructor argument.";
            }
            if( !data ) {
                throw "Actor requires data constructor argument.";
            }
            if( !theme ) {
                throw "Actor requires data constructor argument.";
            }
            this.game = game;
            this.theme = theme;
            this.data = data;
            this.validate();
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal()
            };
        },
        freeBaseActor: function() {
            if (this.events) {
                if (this.events.onGameChoice) {
                    this.events.onGameChoice.removeAll();
                    this.events.onGameChoice.dispose();
                }
                if (this.events.onGameSpeech) {
                    this.events.onGameSpeech.removeAll();
                    this.events.onGameSpeech.dispose();
                }
            }
            this.events = null;
            this.theme = null;
            //this.game = null;
            //this.data = null;
        },
        /**
         * A basic validation function.
         * This will check some basic/common data errors, including required fields.
         */
        validate: function() {
            if( !this.data.name ) {
                throw "Actor has data, but no name. Name is required.";
            }

            if( !this.data.type ) {
                throw "Actor has data, but no name. Name is required.";
            }

            _.each( this.getRequiredFields(), function(field) {
                if( this.data[field] === undefined || this.data[field] === null ) {
                    throw "[" + this.data.type + "] Actor [" + this.data.name + "] is missing required field: " + field;
                }
            }, this);

            if( this.data.name && this.data.name.charAt(0) === "$" ) {
                throw "Actor names cannot be variables, and will not be resolved.";
            }
        },
        getType: function() {
            return this.data.type;
        },
        getName: function() {
            return this.data.name;
        },
        getPrimarySprite: function() {
            return this.sprite;
        },
        /**
         * An abstract method for children to implement.
         * ex: return [ "name", "location" ];
         */
        getRequiredFields: function() {
            throw "You must implement this function. Return an array of field names.";
        },
        setModelInterface: function( modelInterface ) {
            this.modelInterface = modelInterface;
        },
        getFont: function(name) {
            log.warn("Asking for font with " + name );
            if( this.theme && this.theme.fonts && this.theme.fonts[name] ) {
                return _.clone(this.theme.fonts[name]);
            }
            log.error("Font not found for " + name);
            return _.clone(DEFAULT_FONT);
        },
        /**
         * Look up a piece of text in the theme.
         * If not there, treat as literal.
         *
         */
        getText: function( name, key ) {
            log.warn("Asking for text with " + name + " / " + key);
            var sName = name,
                sKey = key;
            if( this.modelInterface ) {
                sName = this.modelInterface.getValue(name);
                sKey = this.modelInterface.getValue(key);
            }
            log.warn("--> Asking for text with " + sName + " / " + sKey);
            if( !this.theme || (!this.theme.texts && !sKey) ) {
                log.error("text unavailable for " + sName + " / " + sKey);
                return (DEFAULT_TEXT);
            }
            var text = this.theme.texts[sName];
            if( !text && !sKey ) {
                return sName; // might be a string literal.
            } else if( sKey && this.theme.texts[sKey] ) {
                text = this.theme.texts[sKey][sName];
            }
            log.warn("returning " + text);
            return text || sName;
        },
        getTextureKey: function( spriteData ) {
            if( spriteData && spriteData.textureKey ) {
                return spriteData.textureKey;
            }
            return this.theme.textureKey;
        },
        /**
         * Look up an image in the theme.
         * If not there, treat as literal.
         */
        getImage: function( name, key ) {
            log.warn("Asking for image with " + name + " / " + key);
            var sName = name,
                sKey = key;
            if( this.modelInterface ) {
                sName = this.modelInterface.getValue(name);
                sKey = this.modelInterface.getValue(key);
            }
            log.warn("--> Asking for image with " + sName + " / " + sKey);
            if( !this.theme || (!this.theme.images && !sKey) ) {
                log.error("image not found for " + sName + " / " + sKey);
                return (DEFAULT_IMAGE);
            }
            var image = this.theme.images[sName];
            if( !image && !sKey ) {
                return sName; // might be a string literal, so return it.
            } else if( sKey ) {
                image = this.theme.images[sKey][sName];
            }
            if (!isNaN(Number(image.endIndex))) {
                var start = Number(image.startIndex) || 1;
                var end = Number(image.endIndex);
                var zeroPad = image.zeroPad || 4;
                var prefix = image.filenamePrefix || "";
                var suffix = image.filenameSuffix || ".png";
                image = Phaser.Animation.generateFrameNames(prefix, start, end, suffix, zeroPad);
            }
            return image;
        },
        getMyValue: function() {
            var value;
            if( this.data.variable && this.modelInterface ) {
                value = this.modelInterface.getValue("$" + this.data.variable);
            }
            return value;
        },
        destroy: function() {
            log.error("Failed to implement destroy for actor type: " + this.data.type);
        },
        createBlockingSprite: function() {
            var sprite = new Phaser.Sprite(this.game, 0,0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            sprite.addChild(graphics);
            graphics.beginFill(0x000000, 0.01);
            graphics.drawRect(0, 0, this.game.world.width, this.game.world.height);
            graphics.endFill();
            sprite.inputEnabled = true;
            return sprite;
        },
        substituteText: function( text ) {
            log.warn("Doing substitution on: " + text);
            var leftIndex, rightIndex;
            leftIndex = text.indexOf("$");
            if( leftIndex === -1 ) {
                return text;
            }
            rightIndex = text.indexOf("$", leftIndex + 1);
            if( rightIndex === -1 ) {
                return text;
            }
            var key = text.substring( leftIndex, rightIndex +1);
            var key2 = key.substring(0, key.length - 1); // remove trailing dollarsign.
            var finalText = this.modelInterface.getValue(key2);
            if(typeof finalText === 'undefined' || finalText === null)
            {
                return text;
            }
            finalText = finalText.charAt(0).toUpperCase() + finalText.slice(1);
            return text.replace(key, finalText );
        },
        dispatchGameChoice: function(data) {
            this.events.onGameChoice.dispatch( this.data.name, data, this );
        },
        dispatchGameSpeech: function(data) {
            this.playAudio(  data, this);
        },
        isSoundEventInverse: function() {
            return this.data && this.data.inverseSoundEvents === true;
        },
        // override if you have physics.
        getBody: function() {
            return null;
        },
        /**
         * This will be called if this sprite is overlapping another sprite and getBody() does not return null;
         * The other sprite will also not be returning null for getBody().
         * @param otherActor
         */
        onOverlapping: function( otherActorName ) {

        },
        /**
         * Receive a dropped sprite.
         */
        onReceiveDrop: function( otherActorName ) {

        },
        playAudio: function( eventData ) {
            if( this.data.audioKey ) {
                eventData.channel = this.data.audioKey;
            }
            this.events.onGameSpeech.dispatch(this.data.name, eventData);
        },
        getVariableList: function() {
            return [];
        },
        clearVariables: function() {
            if( this.data.variable) {
                this.modelInterface.clearValue(this.data.variable);
            }
            _.each( this.getVariableList(), function( eachVar) {
                this.modelInterface.clearValue(eachVar);
            }, this);
        }
    });

    module.exports = Actor;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-book.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the book actor, which will show the player a book with flippable pages. It will also
 * play any audio/text associated with asking questions and text.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "iucbook", // required type.
 *     "pages":  [
 *     {
 *     "title": "What are Drugs?",
 *     "subtitle": "This is a subtitle!",
 *     "type": "question"|"information" // will there be questions?
 *
 *     }
 *     ]
 * }
 */
(function () {

    var _ = require('lodash');
    var log = require('loglevel');
    var Actor = require('../actor');

    var ItsUrChoiceBookActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function () {
            return ["pages"];
        },
        enterScene: function () {
            this.pages = this.data.pages;
            this.buildActor();
        },
        buildActor: function () {
            this.buttons = [];
            this.pages = [];
            this.currentPageIndex = 0;
            this.fonts = {
                "bookQuestionTitle": this.getFont("bookQuestionTitle"),
                "bookQuestionSubtitle": this.getFont("bookQuestionSubtitle"),
                "bookQuestionText": this.getFont("bookQuestionText"),
                "bookQuestionRemediation": this.getFont("bookQuestionRemediation"),
                "bookPageTitle": this.getFont("bookPageTitle"),
                "bookPageSubtitle": this.getFont("bookPageSubtitle"),
                "bookPageContent": this.getFont("bookPageContent"),
                "bookPageNumber": this.getFont("bookPageNumber")
            };
            this.PAGE_FLIP_SOUND = this.theme.bookSounds.pageFlipSound;
            this.ANSWER_CORRECT_SOUND = this.theme.bookSounds.correctSound;
            this.ANSWER_INCORRECT_SOUND = this.theme.bookSounds.incorrectSound;

            this.addBackground();          // 01. Background image. This may also later need a border drawn?
            this.addActionButtons();       // 02. Turn pages.
            this.addPages();
            this.setCurrentPage(0);
        },
        addBackground: function () {
            this.bgImage = this.game.add.sprite(this.game.world.width/2, 15, this.theme.textureKey, this.getImage("background", "book"));
            this.bgImage.anchor.setTo(0.5, 0);
            this.leftPageImage = this.game.add.sprite(90, 28, this.theme.textureKey, this.getImage("left-page", "book"));
            this.rightPageImage = this.game.add.sprite(402, 28, this.theme.textureKey, this.getImage("right-page", "book"));
        },
        addActionButtons: function () {
            this.nextPageButton = this.game.add.button(750, 175, this.theme.textureKey,
                this.onNextPageAction, this,
                this.theme.buttons['nextPage'].over, this.theme.buttons['nextPage'].out,
                this.theme.buttons['nextPage'].down, this.theme.buttons['nextPage'].up);
            this.previousPageButton = this.game.add.button(10, 175, this.theme.textureKey,
                this.onPreviousPageAction, this,
                this.theme.buttons['previousPage'].over, this.theme.buttons['previousPage'].out,
                this.theme.buttons['previousPage'].down, this.theme.buttons['previousPage'].up);
        },
        addPages: function() {
            var pageGroup;
            var title, subtitle, content, remediation, pageNumber;
            var bulletImages, bullet;
            _.each( this.data.pages, function(page, pageIndex) {
                pageGroup = this.game.add.group();
                pageGroup.audio = page.audio;

                if( page.content ) {
                    // Title.
                    title = new Phaser.Text(this.game, 565, 50, page.title, this.fonts.bookPageTitle);
                    title.anchor.setTo( 0.5, 0);
                    pageGroup.add(title);

                    // Subtitle.
                    subtitle = new Phaser.Text(this.game, 410, 85, page.subtitle, this.fonts.bookPageSubtitle);
                    pageGroup.add(subtitle);

                    // Content!
                    content = new Phaser.Text(this.game, 412, 110, page.content, this.fonts.bookPageContent);
                    pageGroup.add(content);

                } else if( page.questions ) {
                    // Title.
                    title = new Phaser.Text(this.game, 565, 50, page.title, this.fonts.bookQuestionTitle);
                    title.anchor.setTo( 0.5, 0);
                    pageGroup.add(title);

                    // Subtitle.
                    subtitle = new Phaser.Text(this.game, 565, 85, page.subtitle, this.fonts.bookQuestionSubtitle);
                    subtitle.anchor.setTo( 0.5, 0);
                    pageGroup.add(subtitle);

                    // Content!
                    _.each( page.questions , function( eachQuestion, questionIndex) {
                        bulletImages = this.theme.buttons['bookChoice' + questionIndex];
                        bullet = this.game.add.button( 410, 110 + (questionIndex * 35), this.theme.textureKey,
                            this.onPointerUp, this,
                            bulletImages.over, bulletImages.out,
                            bulletImages.down, bulletImages.up);
                        bullet.inputEnabled = true;
                        bullet.events.onInputOver.add( this.onMouseIn, this);

                        content = new Phaser.Text(this.game, 435, 120 + (questionIndex * 35),
                            eachQuestion.text, this.fonts.bookQuestionText);
                        content.lineSpacing = -6;
                        bullet.answer = eachQuestion;
                        pageGroup.add(bullet);
                        pageGroup.add(content);
                    }, this);

                    // Remediation
                    remediation = new Phaser.Text(this.game, 413, 265,
                        "nothing", this.fonts.bookQuestionRemediation);
                    remediation.lineSpacing = -3;
                    pageGroup.add(remediation);
                    pageGroup.remediation = remediation;
                    remediation.visible = false;
                }

                // Page #
                pageNumber = new Phaser.Text(this.game, 690, 448, pageIndex + 1, this.fonts.bookPageNumber);
                pageGroup.add(pageNumber);

                pageGroup.visible = false;
                this.pages.push(pageGroup);
            }, this);
            this.pages[0].visible = true;
        },
        setCurrentPage: function( pageIndex ) {
            if( pageIndex < 0 || pageIndex >= this.pages.length ) {
                return;
            }
            this.pages[this.currentPageIndex].visible = false;
            this.currentPageIndex = pageIndex;
            this.pages[this.currentPageIndex].visible = true;

            this.previousPageButton.visible = (this.currentPageIndex !== 0);
            this.nextPageButton.visible = (this.currentPageIndex !== (this.pages.length - 1));

            this.playAudio( { audio: this.pages[this.currentPageIndex].audio, key: null, priority: 'queue' });

        },
        onNextPageAction: function() {
            this.playAudio({audio: this.PAGE_FLIP_SOUND, key: null, "priority": "stopall" });
            this.playAudio({ audio: this.PAGE_FLIP_SOUND, key: null });
            this.setCurrentPage(this.currentPageIndex + 1);
        },
        onPreviousPageAction: function() {
            this.playAudio({audio: this.PAGE_FLIP_SOUND, key: null, "priority": "stopall" });
            this.playAudio( { audio: this.PAGE_FLIP_SOUND, key: null});
            this.setCurrentPage(this.currentPageIndex - 1);
        },
        onMouseIn: function() {
            // currently, clicking the answer also causes as mouse in? This is causing problems...
            // this.events.onGameSpeech.dispatch(this.data.name, { audio: "bubble_slow", key: null, restart: true});
        },
        onPointerUp: function (choice) {
           // this.events.onGameSpeech.dispatch(this.data.name, { audio: "bubble_slow", key: null, stop: true});
            var page = this.pages[this.currentPageIndex];
            page.remediation.setText(choice.answer.response.text);
            page.remediation.visible = true;
            this.playAudio( {audio: this.ANSWER_CORRECT_SOUND, key: null, "priority": "stopall" });
            if( choice.answer.response.correct ) {
                this.playAudio( {audio: this.ANSWER_CORRECT_SOUND, key: null});
            } else {
                this.playAudio(  { audio: this.ANSWER_INCORRECT_SOUND, key: null});
            }
            this.playAudio(  { audio: choice.answer.response.audio, key: null, "priority": 'queue' });
        },
        destroy: function () {
            this.bgImage.destroy();
            this.leftPageImage.destroy();
            this.rightPageImage.destroy();
            this.nextPageButton.destroy();
            this.previousPageButton.destroy();

            var temp;
            while( this.pages.length > 0 ) {
                temp = this.pages.pop();
                temp.remediation = null;
                temp.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoiceBookActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-chat.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the chat actor, which will show the player a conversation. It will also
 * play any audio/text associated with asking question.
 *
 * {
 *     "name": "choices_mandy_1", // unique name for this actor.
 *     "type": "iucchat", // required type.
 *     "background": "purpleWall",
 *     "portrait": "mrsRiley",
 *     "portraitLabel": "Mrs. Riley",
 *     "chooseLabel": "Choose your response.",
 *     "variable": "x", // the variable to set when the user leaves
 *     "conversation":  {
              "responses": [
                {
                  "text": {
                    "audio": "audio/day1/melissa_intro.mp3",
                    "text": "Oh, hi. I was just asking your dad if I could borrow his toolbox. I'm fixing some shelves in Josh's room. Your dad will be right back. How's it going? How's school? I'm kind of worried about Seth because he hasn't even thought of college yet, much less his Algebra homework tomorrow. I wish he could be more like Josh and develop some short and long-term goals. He once told me that he felt like everything was out of control and nothing mattered. I hope he was just in a bad mood and that he's not experimenting with anything."
                  },
                  "triggers": "q1,q2,q3,q4,q5",
                  "name": "intro"
                },
                {
                  "text": {
                    "audio": "audio/day1/melissa_1r.mp3",
                    "text": "A short-term goal is simply a goal you want to achieve in a few days, a few weeks or a few months."
                  },
                  "triggers": "q1_a,q2,q3,q4,q5",
                  "name": "r1"
                },

              ],
              "questions": [
                  {
                    "text": "Maybe Seth doesn't know what a short-term goal is. I know I don't.",
                    "name": "q1",
                    "response": "r1",
                    "value": "X" // set the variable to X.
                  },
                  {
                    "text": "All right, Mrs. Riley. I'm going to need an example.",
                    "name": "q1_a",
                    "response": "r1_a"
                  },
                  {
                    "text": "What's a long-term goal?",
                    "name": "q2",
                    "objectiveMet": "4",
                    "response": "r2"
                  }
                ]
            }
 * }
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        RoundedChatRect = require('./rounded-chat-rect');
    Actor = require('../actor');

    var MAX_CHOICES = 5,
        marginY = 3,
        RESPONSE_START_Y = 323;
    var RESPONSE_TEXT_X = 40;
    var COLOR_VISITED_OPTION = "#b5b3b2";
    var COLOR_ACTIVE_OPTION = "#000000";

    var ChatActor = Actor.extend({
        // constructor in parent.
        getRequiredFields: function () {
            return ["conversation", "background", "portrait", "portraitLabel", "chooseLabel", "variable"];
        },
        enterScene: function () {
            this.conversation = this.data.conversation;
            this.currentResponse = this.findResponse("intro");
            if (!this.currentResponse) {
                throw "You must have an intro response: " + this.data.name;
            }
            this.isMuted = this.game.sound.mute;

            this.buildActor();
            this.populateChoice();
        },
        buildActor: function () {
            this.buttons = [];
            this.text = [];
            this.completed = [];

            this.addBackground();          // 01. Background image. This may also later need a border drawn?
            this.addPortrait();            // 02, 03. Portrait + Label
            this.addSpeechBubble();        // 04. Speech Bubble (and 10. speech text)
            this.addResponseTitle();       // 05, 06. "Choose your response." w/line
            this.addChoiceBox();           // 07. Choice box
            this.addActionButtons();       // 08, 09. Audio Mute and Leave Conversation button
            this.addChoiceText();          // 11. Current Choice(s) text / Links, possibly grayed out.
        },
        addBackground: function () {
            this.bgImage = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage(this.data.background, this.data.key));
        },
        addPortrait: function () {
            this.portrait = this.game.add.sprite(581, 43, this.theme.textureKey, this.getImage(this.data.portrait, this.data.key));

            // 03. Portrait label
            var fontName = this.data.portraitFont;
            this.labelStyle = this.getFont((typeof fontName !== 'undefined') ? fontName : "chatLabel");
            this.labelStyle.align = "center";
            var labelX = this.portrait.x + (this.portrait.width / 2);
            var labelY = this.portrait.y + this.portrait.height + 15;
            this.portraitLabel = this.game.add.text(labelX, labelY, this.data.portraitLabel, this.labelStyle);
            this.portraitLabel.anchor.setTo(0.5, 0.0);
        },
        addSpeechBubble: function () {
            this.speechBubble = new RoundedChatRect(this.game, this.theme);
            this.speechBubble.show();
        },
        addResponseTitle: function () {
            var fontName = this.data.chooseFont;
            var styleChoose = this.getFont((typeof fontName !== 'undefined') ? fontName : "chatLabel");
            var chooseLabelX = 150;
            var chooseLabelY = this.portrait.y + this.portrait.height + 65;
            this.chooseLabel = this.game.add.text(chooseLabelX, chooseLabelY, this.data.chooseLabel, styleChoose);
            this.chooseLabel.anchor.setTo(0.5, 1.0);
        },
        addChoiceBox: function () {
            var choiceGraphics = this.game.add.graphics(0, 0);
            choiceGraphics.lineStyle(3, 0xc73248, 1);
            choiceGraphics.moveTo(40, RESPONSE_START_Y - 15);
            choiceGraphics.lineTo(760, RESPONSE_START_Y - 15);
            choiceGraphics.lineStyle(1, 0xffffff, 1);
            choiceGraphics.beginFill(0xFFFFFF, 1);
            choiceGraphics.drawRect(30, RESPONSE_START_Y - 5, 740, 150);
            this.choiceGraphics = choiceGraphics;
        },
        addActionButtons: function () {
            this.muteOnButton = this.game.add.button(450, 535, this.theme.textureKey,
                this.onMuteAction, this,
                this.theme.buttons['soundOff'].over, this.theme.buttons['soundOff'].out,
                this.theme.buttons['soundOff'].down, this.theme.buttons['soundOff'].up);
            this.muteOffButton = this.game.add.button(450, 535, this.theme.textureKey,
                this.onMuteAction, this,
                this.theme.buttons['soundOn'].over, this.theme.buttons['soundOn'].out,
                this.theme.buttons['soundOn'].down, this.theme.buttons['soundOn'].up);
            var text;
            if (this.isMuted) {
                this.muteOnButton.visible = false;
                text = "Audio Off";
            } else {
                this.muteOffButton.visible = false;
                text = "Audio On";
            }

            var buttons = this.theme.buttons.leaveChat;
            if( this.data.button ) {
                buttons = this.theme.buttons[this.data.button];
            }
            this.leaveButton = this.game.add.button(560, 547, this.theme.textureKey,
                this.onLeaveAction, this, buttons.over, buttons.out, buttons.down, buttons.up);

            var styleChoose = this.getFont("chatMute");

            this.muteText = this.game.add.text(450, 520, text, styleChoose);
        },
        addChoiceText: function () {
            var locationY = RESPONSE_START_Y,
                buttonCnt,
                currButton;
            this.styleChoose = this.getFont("chatOption");
            this.styleChoose.wordWrap = true;
            this.styleChoose.wordWrapWidth = 725;
            for (buttonCnt = 0; buttonCnt < MAX_CHOICES; buttonCnt++) {
                currButton = this.game.add.text(RESPONSE_TEXT_X, locationY, "answer text", this.styleChoose);
                currButton.lineSpacing = -6;
                locationY += currButton.height + marginY;
                this.buttons.push(currButton);
                currButton.answerIndex = buttonCnt;
            }
        },
        addTextAnswerBox: function (answerText) {
            if (answerText.buttonGraphics) {
                answerText.buttonGraphics.borderGraphic.destroy();
                answerText.buttonGraphics.borderGraphic = null;
                answerText.buttonGraphics.destroy();
                answerText.buttonGraphics = null;

            }
            var choiceGraphics = this.game.add.graphics(30, answerText.y - 3);
            choiceGraphics.beginFill(0xffffff, 1);
            choiceGraphics.drawRect(2, 0, 736, answerText.height + 1);
            choiceGraphics.endFill();

            var choiceGraphics2 = this.game.add.graphics(30, answerText.y - 3);
            choiceGraphics2.lineStyle(2, 0xffffff);
            choiceGraphics2.drawRect(2, 0, 736, answerText.height + 1);

            choiceGraphics.inputEnabled = true;
            choiceGraphics.input.useHandCursor = true;
            choiceGraphics.isTopButton = true;
            choiceGraphics.borderGraphic = choiceGraphics2;

            choiceGraphics.events.onInputOver.add(this.onMouseOver, this);
            choiceGraphics.events.onInputOut.add(this.onMouseOut, this);
            choiceGraphics.events.onInputUp.add(this.onMouseUp, this);

            answerText.buttonGraphics = choiceGraphics;
            answerText.bringToTop();
        },
        onMouseOver: function (x) {
            if (x.isTopButton === true) {
                x.tint = 0xffd480;
                x.borderGraphic.tint = 0xffaa00;
            }
        },
        onMouseOut: function (x) {
            if (x.isTopButton === true) {
                x.tint = 0xfeffff;
                x.borderGraphic.tint = 0xfeffff;
            }
        },
        onMouseUp: function (x) {
            this.onChoice(x.question);
        },
        findResponse: function (name) {
            var response = null;
            _.each(this.conversation.responses, function (eachResponse, responseIndex) {
                if (eachResponse.name === name) {
                    response = eachResponse;
                    return false;
                }
            }, this);
            return response;
        },
        findQuestions: function (setName) {
            if (!setName) {
                return [];
            }
            var names = setName.split(",");
            var questions = [];
            _.each(names, function (eachName) {
                _.each(this.conversation.questions, function (eachQuestion) {
                    if (eachQuestion.name === eachName) {
                        questions.push(eachQuestion);
                    }
                }, this);
            }, this);
            return questions;
        },
        populateChoice: function () {

            var questions = [];
            if (this.currentResponse) {
                this.speechBubble.showResponse(this.currentResponse);
                if (this.currentResponse.triggers) {
                    questions = this.findQuestions(this.currentResponse.triggers);
                    var y = RESPONSE_START_Y;
                    // questions = _.shuffle(questions);
                    _.each(questions, function (eachQuestion, questionIndex) {
                        var prefix = eachQuestion.name;
                        this.buttons[questionIndex].visible = true;
                        this.buttons[questionIndex].setText(eachQuestion.text);
                        this.buttons[questionIndex].y = y;
                        y += this.buttons[questionIndex].height + marginY;
                        this.addTextAnswerBox(this.buttons[questionIndex]);
                        this.buttons[questionIndex].buttonGraphics.question = eachQuestion;
                        var found = false;
                        _.each( this.completed, function(eachCompleted) {
                            if( prefix.startsWith(eachCompleted) ) {
                                found = true;
                            }
                        }, this);
                        if (found) {
                            this.buttons[questionIndex].addColor(COLOR_VISITED_OPTION, 0);
                        } else {
                            this.buttons[questionIndex].addColor(COLOR_ACTIVE_OPTION, 0);
                        }
                    }, this);
                }
            }

            for (var loop = MAX_CHOICES - 1; loop >= questions.length; loop--) {
                this.buttons[loop].visible = false;
                if (this.buttons[loop].buttonGraphics) {
                    this.buttons[loop].buttonGraphics.borderGraphic.destroy();
                    this.buttons[loop].buttonGraphics.borderGraphic = null;
                    this.buttons[loop].buttonGraphics.destroy();
                    this.buttons[loop].buttonGraphics = null;
                }
            }

            if (this.currentResponse && this.currentResponse.text && this.currentResponse.text.audio) {
                var eventData = { "audio": this.currentResponse.text.audio};
                this.playAudio( eventData );
            }
        },
        destroy: function () {
            var temp;
            while (this.text.length > 0) {
                temp = this.text.shift();
                temp.destroy();
                temp = null;
            }
            while (this.buttons.length > 0) {
                temp = this.buttons.shift();
                if (temp.buttonGraphics) {
                    temp.buttonGraphics.borderGraphic.destroy();
                    temp.buttonGraphics.borderGraphic = null;
                    temp.buttonGraphics.destroy();
                    temp.buttonGraphics = null;
                }
                temp.destroy();
                temp = null;
            }
            this.bgImage.destroy();
            this.portrait.destroy();
            this.portraitLabel.destroy();
            this.speechBubble.destroy();
            this.chooseLabel.destroy();
            this.choiceGraphics.destroy();
            this.muteOnButton.destroy();
            this.muteOffButton.destroy();
            this.leaveButton.destroy();
            this.muteText.destroy();
            this.freeBaseActor();
        },
        onLeaveAction: function () {

            var eventData = {"text": "", "audio": this.theme.chat.exit};
            this.playAudio(eventData);

            var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onMuteAction: function () {
            var text;
            this.isMuted = !this.isMuted;
            if (this.isMuted) {
                text = "Audio Off";
            } else {
                text = "Audio On";
            }
            var varSet = {"mute_game": this.isMuted ? "mute_on" : "mute_off"};
            this.events.onGameChoice.dispatch(this.data.name, varSet);
            this.muteOnButton.visible = !this.isMuted;
            this.muteOffButton.visible = this.isMuted;
            this.muteText.setText(text);
        },
        onChoice: function (data) {
            var eventData = {"text": "", "audio": this.theme.chat.sound};
            this.playAudio(  eventData);


            if (data.branched) {
                this.completed.push(data.branched);
            }

            if (data.objectiveMet) {
                var varSet = {};
                varSet[data.objectiveMet] = "complete";
                this.events.onGameChoice.dispatch(this.data.name, varSet);
            }

            if (data.response) {
                this.currentResponse = this.findResponse(data.response);
                this.populateChoice();
            }

            if (data.value) {
                var valueSet = {};
                valueSet[this.data.variable] = data.value;
                this.events.onGameChoice.dispatch(this.data.name, valueSet);
            }

        }
    });

    module.exports = ChatActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./rounded-chat-rect":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\rounded-chat-rect.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-file-drag.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The custom file cabinet drag actor. Dragged around the screen, represented by image, has heading and text.
 *
 * Creating a decoration actor, a simple image:
 * {
 *     "name": "portrait1", // a unique identifier
 *     "type": "drag", // the required type.
 *     "images": { "normal" : "phone", // the images to use from the images section the theme.
 *                 "dragging" : "phone", // optional image while dragging
 *                 "overlap" : "phone", // optional image when overlapping.
 *     "key": "something", // an optional key to look under for the image(s).
 *     "location": [ x, y ],
 *     "variable": "string" // name of variable to be set when this is dragging/dropped/etc.
 * }
 *
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');

    var ItsUrChoiceDragActor = Actor.extend( {
        // constructor in parent
        getRequiredFields: function() {
            return [ "location", "images", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
            this.isOverlapping = null;
            if( this.data.audio ) {
                this.playAudio( { audio: this.data.audio, key: null});
            }
        },
        buildActor: function() {
            var sprite = this.game.add.sprite( this.data.location[0], this.data.location[1],
                this.theme.textureKey, this.getImage( this.getFrame(), this.data.key));
            this.game.physics.enable(sprite, Phaser.Physics.ARCADE);
            sprite.body.setSize( 1, 1,  sprite.width/2, sprite.height/2);
            sprite.inputEnabled = true;
            sprite.input.pixelPerfectOver = true;
            sprite.input.enableDrag(false, true);
            sprite.events.onDragStop.add(this.itemDragStop, this);
            sprite.events.onDragStart.add(this.itemDragStart, this);
            sprite.events.onDragUpdate.add(function (sprite, pointer, x, y) {
                var pos = sprite.game.input.getLocalPosition(sprite.parent, pointer);
                    sprite.x = pos.x - sprite.width/2;
                    sprite.y = pos.y - sprite.height/2;

            }, sprite);
            sprite.origLoc = [ sprite.x, sprite.y];
            this.sprite = sprite;

            var fontHeaderName, fontBodyName;
            if( this.data.textData ) {
                var textData = this.data.textData;
                fontHeaderName = textData.fontHeading;
                fontBodyName = textData.fontBody;
                this.headerStyle = this.getFont((typeof fontHeaderName !== 'undefined') ? fontHeaderName : "questionText");
                this.bodyStyle = this.getFont((typeof fontBodyName !== 'undefined') ? fontBodyName : "questionText");

                this.headingSprite = this.game.add.text(8, 8, textData.heading, this.headerStyle);
                this.bodySprite = this.game.add.text(9, 35, textData.body, this.bodyStyle);

                this.sprite.addChild(this.headingSprite);
                this.sprite.addChild(this.bodySprite);
            }

            if( this.data.angle ) {
                this.sprite.angle = this.data.angle;
            }

        },
        returnToHome: function() {

        },
        itemDragStop: function () {
            this.isDragging = false;
            this.updateImage();
            var temp = {};
            temp["dropped"] = this.data.name;
            this.dispatchGameChoice(temp);
            // It will have been dropped, and possibly removed from scene.
            if( this.sprite ) {
                this.sprite.x = this.sprite.origLoc[0];
                this.sprite.y = this.sprite.origLoc[1];
            }
        },
        itemDragStart: function ( ) {
            if( this.data.audio ) {
                this.playAudio(  { audio: this.data.audio, key: null});
            }
            this.isDragging = true;
            this.updateImage();
            var temp = {};
            temp["dragging"] = this.data.name;
            this.dispatchGameChoice(temp);
            this.sprite.x = this.game.input.activePointer.position.x - 10;
            this.sprite.body.x = this.game.input.activePointer.position.x - 10;
            this.sprite.y = this.game.input.activePointer.position.y - 10;
            this.sprite.body.y = this.game.input.activePointer.position.y - 10;
        },
        getFrame: function(type) {
            var frameName = this.data.images.normal;
            if(type === "overlap" && this.data.images.overlap ) {
                frameName = this.data.images.overlap;
            } else if( (type === "dragging" || !frameName) && this.data.images.dragging ) {
                frameName = this.data.images.dragging;
            }
            return frameName;
        },
        updateImage: function() {
            var frame;
            if( this.headingSprite ) {
                this.headingSprite.visible = false;
                this.bodySprite.visible = false;
            }
            if( this.isOverlapping !== null ) {
                frame = this.getFrame("overlap");
            } else if( this.isDragging === true ) {
                frame = this.getFrame("dragging");
            } else {
                frame = this.getFrame("normal");
                if( this.headingSprite ) {
                    this.headingSprite.visible = true;
                    this.bodySprite.visible = true;
                }
            }
            this.sprite.frameName = this.getImage( frame, this.data.key);
            this.sprite.body.setSize( 1, 1,  this.sprite.width/2, this.sprite.height/2);
        },
        getBody: function() {
            if( this.sprite ) {
                return this.sprite.body;
            }
            return null;
        },
        onOverlapping: function( otherActor ) {
            if( this.isOverlapping === otherActor ) {
                return;
            }
            this.isOverlapping = otherActor;
            // change to overlapping image.
            this.updateImage();
        },
        destroy: function() {
            if ( this.sprite ) {
                this.sprite.input.disableDrag();
                this.sprite.body.destroy();
                this.sprite.events.onDragStop.removeAll();
                this.sprite.events.onDragStart.removeAll();
                this.sprite.events.onDragUpdate.removeAll();
                this.sprite.inputEnabled = false;
                this.sprite.destroy(true);
                this.sprite = null;
            }
            if( this.headingSprite ) {
                this.headingSprite.destroy();
                this.bodySprite.destroy();
            }
            this.style = null;
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoiceDragActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-map.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The map actor.
 *
 * Creating a map actor:
 *
 * {
 *     "name": "mandy", // a unique identifier
 *     "type": "iucmap", // the required type.
 *     "variable": "locationChoice"
 *     "night": true, // makes it night, defaults to false
 * }
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor');
    var Base = require('basejs');

    var LargeBird = require('./map/actor-bird-large');
    var SmallBird = require('./map/actor-bird-small');
    var BasicCar = require('./map/actor-car-basic');
    var YellowCar = require('./map/actor-car-yellow');

    var EXTRA_WAIT_TIME = 8000;

     var MapActor = Actor.extend( {
        // constructor is now in base class!
        enterScene: function() {
            this.buildActor();
            this.blueFlag.animations.play('wave', 24, true);
            this.usFlag.animations.play('wave', 24, true);
            this.mapTimer.start();
        },
        getRequiredFields: function() {
            return [  "variable" ];
        },
        buildActor: function() {
            this.bg = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage("citymap"));
            this.houses = [];
            this.labels = [];
            _.each( this.theme.mapInfo.buildings, function( building, buildingIndex ) {
                this.houses.push(
                    this.game.add.sprite(building.x, building.y, this.theme.textureKey, building.image)
                );
                var label = building.hover;
                this.labels.push(
                    this.game.add.sprite(label.x, label.y, this.theme.textureKey, label.image)
                );
                this.houses[buildingIndex].clickValue = building.key;
                this.houses[buildingIndex].isBuilding = true;
                this.houses[buildingIndex].buildingIndex = buildingIndex;
                this.houses[buildingIndex].inputEnabled = true;
                this.houses[buildingIndex].input.useHandCursor = true;
                this.houses[buildingIndex].events.onInputOver.add(this.onMouseOver, this);
                this.houses[buildingIndex].events.onInputOut.add(this.onMouseOut, this);
                this.houses[buildingIndex].events.onInputUp.add(this.onMouseUp, this);
            }, this);

            this.blueFlag = this.game.add.sprite( 180, 70, this.theme.textureKey, this.theme.mapInfo.blueFlagFrames[0]);
            this.blueFlag.animations.add('wave', this.theme.mapInfo.blueFlagFrames );

            this.usFlag = this.game.add.sprite( 180, 38, this.theme.textureKey, this.theme.mapInfo.usFlagFrames[0]);
            this.usFlag.animations.add('wave', this.theme.mapInfo.usFlagFrames );

            this.smallBird = new SmallBird(this.game, this.theme);
            this.largeBird = new LargeBird(this.game, this.theme);
            this.randomCar = new BasicCar(this.game, this.theme);
            this.yellowCar = new YellowCar(this.game, this.theme);
            this.smallBird.events.playAudio.add(this.onSubSpeech, this);
            this.largeBird.events.playAudio.add(this.onSubSpeech, this);
            this.randomCar.events.playAudio.add(this.onSubSpeech, this);
            this.yellowCar.events.playAudio.add(this.onSubSpeech, this);

            this.fg = this.game.add.sprite(0, 0, this.theme.textureKey, this.getImage("citymapfg"));

            if( this.data.night === true ) {
                this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
                var graphics = new Phaser.Graphics(this.game, 0, 0);
                this.blockerSprite.addChild(graphics);
                graphics.beginFill( 0x000000, 0.35 );
                graphics.drawRect( 0, 0, this.game.world.width, this.game.world.height );
                graphics.endFill();
                this.blockerSprite.bringToTop();
                this.game.add.existing(this.blockerSprite);
            }

            _.each( this.labels, function( eachLabel ) {
                eachLabel.scale.setTo(0.80,0.80);
                eachLabel.bringToTop();
                eachLabel.visible = false;
            }, this);

            this.mapTimer = this.game.time.create(false);
            this.mapTimer.loop(EXTRA_WAIT_TIME, this.showExtraOnMap, this);
        },
         onSubSpeech: function(name, speech) {
             if( name && speech ) {
                 this.events.onGameSpeech.dispatch(name, speech);
             }
         },
         onGameSpeech: function(speech) {
            // nothing.
         },
         showExtraOnMap: function () {
             var randomValue = this.game.rnd.integerInRange(0, 4);
             switch (randomValue) {
                 case 0: {
                     this.largeBird.play();
                     break;
                 }
                 default:
                 case 1: {
                     this.smallBird.play();
                     break;
                 }
                 case 2: {
                     this.yellowCar.play();
                     break;
                 }
                 case 4:
                 case 3: {
                     this.randomCar.play();
                     break;
                 }
             }
         },
         onMouseOver: function (x) {
             if (x.isBuilding === true) {
                 this.labels[x.buildingIndex].visible = true;
             }
         },
         onMouseOut: function (x) {
             if (x.isBuilding === true) {
                 this.labels[x.buildingIndex].visible = false;
             }
         },
         onMouseUp: function (x) {
             if (x.isBuilding === true) {
                 var varSet = {};
                 varSet[this.data.variable] = x.clickValue;
                 this.events.onGameChoice.dispatch( this.data.name, varSet );
             }
             // this.onChoice(x.question);
         },
        destroy: function() {
            if ( this.bg ) {
                this.bg.destroy();
            }
            if ( this.fg ) {
                this.fg.destroy();
            }
            var destroyBuilding = this.houses.pop();
            while( destroyBuilding ) {
                destroyBuilding.destroy();
                destroyBuilding = this.houses.pop();
            }
            this.houses = null;
            var destroyLabel = this.labels.pop();
            while( destroyLabel ) {
                destroyLabel.destroy();
                destroyLabel = this.labels.pop();
            }
            // var destroyTween = this.allTweens.pop();
            // while( destroyTween ) {
            //     destroyTween.stop();
            //     this.game.tweens.remove(destroyTween);
            // }
            this.game.tweens.removeAll();
            this.labels = null;
            this.blueFlag.destroy();
            this.usFlag.destroy();
            this.smallBird.destroy();
            this.largeBird.destroy();
            this.mapTimer.stop();
            this.mapTimer.destroy();
            this.yellowCar.destroy();
            this.randomCar.destroy();
            if( this.data.night === true ) {
                this.blockerSprite.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = MapActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","./map/actor-bird-large":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-large.js","./map/actor-bird-small":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-small.js","./map/actor-car-basic":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-basic.js","./map/actor-car-yellow":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-yellow.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone-button.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The phone button actor. This actor is used for opening the phone and showing phone alerts.
 *
 * Creating a phone button actor:
 * {
 *     "name": "phone1", // a unique identifier
 *     "type": "iucphone-button", // the required type.*
 *     "location": [ x, y ],
 *     "alert": any value // phone will alert immediately.
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var ItsUrChoicePhoneButtonActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "location" ];
        },
        enterScene: function() {
            this.isAlerted = false;
            this.buildActor();
            if( this.data.alert ) {
                this.onGameChoice( { 'phone_alert': this.data.alert });
            }
        },
        buildActor: function() {
            this.buttonAnimation = null;
            this.button = this.game.add.button( this.data.location[0], this.data.location[1] , this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.buttons.phone.over, this.theme.buttons.phone.out,
                this.theme.buttons.phone.down, this.theme.buttons.phone.up);
            this.button.inputEnabled = true;
        },
        /**
         * @param choice
         */
        onGameChoice: function( choice ) {
           if( choice['phone_alert'] ) {
                this.isAlerted = true;
                this.playAlert();
           }
        },
        /**
         * Play the ring animation and current ring tone.
         */
        playAlert: function() {
            if( this.buttonAnimation === null) {
                this.buttonAnimation = this.button.animations.add('ring', this.theme.phone.alerts );
            }
            this.button.animations.play('ring', 24);
            var eventData = {"text": "", "audio" : this.theme.phone.ringtone, "priority": "sfx" };
            this.playAudio(  eventData);
        },
        /**
         * When the player clicks the phone button, stop any alert and then send out the game choice.
         * @param event
         */
        onPointerUp: function( event ) {
            this.isAlerted = false;
            this.button.animations.stop();

            var varSet = {};
            varSet['show_cell_phone'] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            if ( this.button ) {
                this.button.destroy();
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePhoneButtonActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 09/22/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a very specialized actor for use with Welcome To Westpost and Its UR Choice! it shows a cell phone that
 * sends out special events, responds to events, and can interact with the user by drawing over the scene.
 * The user can interact with the phone, which must block user input.
 *
 *  {
 *     "name": "phone_1",
 *     "type": "iucphone",
 *     "helpVariable": "current_help_message",
 *     "objectives": {
 *       "obj1": "Explore Westport",
 *       "obj2": "Try out your cell phone and journal."
 *     },
 *     disablePower: true|false, // defaults to false, can keep the player from closing the phone.
 *     demoMode: true|false // defaults to false. Shows phone smaller on left side of screen.
 *  }
 *
 *
 */
(function () {
    var _ = require('lodash'),
        log = require('loglevel'),
        Actor = require('../actor'),
        moment = require('moment');

    var SCREEN_X = 258;
    var SCREEN_END_X = 712;
    var SCREEN_Y = 32;
    var SCREEN_END_Y = 317;

    var ItsUrChoicePhone = Actor.extend({
        // constructor in parent.
        getRequiredFields: function() {
            return [ "objectives", "helpVariable", "objectiveAudio", "helpAudio"]; // no required fields
        },
        enterScene: function () {
            this.fontHeader = this.getFont('phoneHeader');
            this.fontBody = this.getFont('phoneBody');
            this.isInitialized = false;
            this.isMuted = this.game.sound.mute;
            this.objectiveMarkers = {};

            if( this.data.open ) {
                this.showPhone();
            }
        },
        onGameChoice: function( choice ) {
            if( choice['show_cell_phone'] ) {
                if( this.isInitialized && this.phoneGroup.visible ) {
                    this.onClickClose();
                } else {
                    this.showPhone();
                }
            }
        },
        dispatch: function (data, value) {
            var varSet = {};
            varSet[data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        onClickHelp: function () {
            var helpText = this.modelInterface.getValue(this.data.helpVariable);
            this.hideObjectives();
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound };
            this.playAudio( eventData);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "help"});
            this.showHelp( helpText);
        },
        onClickMute: function () {
            this.isMuted = !this.isMuted;

            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);

            var varSet = {"mute_game" : this.isMuted ? "mute_on" : "mute_off"};
            this.events.onGameChoice.dispatch( this.data.name, varSet );

            if( this.isMuted ) {
                this.muteIcon.animations.play('vibrate', 24, true);
                this.muteOnButton.visible = false;
                this.muteOffButton.visible = true;
            } else {
                this.muteOnButton.visible = true;
                this.muteOffButton.visible = false;
                this.muteIcon.animations.stop();
                this.muteIcon.frameName = this.theme.phone.ringMode.muteOff;
            }
        },
        onClickObjectives: function() {
            this.hideHelp();
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);
            this.showObjectives(this.data.objectives);
        },
        onClickClose: function () {
            if( this.data.disablePower === true || this.data.disablePower === "true") {
                return; // close is turned off by this feature.
            }
            this.phoneGroup.visible = false;
            this.helpGroup.visible = false;
            this.objectivesGroup.visible = false;
            this.blockingSprite.visible = false;
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "sfx"};
            this.playAudio(  eventData);
            var eventData = {"text": "", "audio" : this.theme.phone.buttonSound , "priority": "stopall"};
            this.playAudio(  eventData);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "closed"});
        },
        createPhoneButton: function (key, callback, context) {
            var button = new Phaser.Button(this.game, 0, 0, this.theme.textureKey,
                callback, context,
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0],
                this.theme.phone.icons[key][1], this.theme.phone.icons[key][0]);
            button.input.useHandCursor = true;
            return button;
        },
        /**
         * Showing the phone is a bit complicated. Everything has to be brought to the top in
         * reverse order.
         */
        showPhone: function () {
            if( this.isInitialized === false ) {
                this.initHomeScreenGroup();
                this.initHelpWindowGroup();
                this.initObjectivesWindowGroup();
                if( this.data.demoMode === true || this.data.demoMode === "true") {
                    this.initDemoView();
                } else {
                    this.initBlockingGroup();
                }
            }
            this.phoneGroup.visible = true;
            if( this.blockingSprite ) {
                this.blockingSprite.visible = true;
                this.blockingSprite.bringToTop();
            }
            this.game.world.bringToTop(this.phoneGroup);
            this.game.world.bringToTop(this.helpGroup);
            this.game.world.bringToTop(this.objectivesGroup);
            this.events.onGameChoice.dispatch(this.data.name, {"phone": "open"});
            if( this.isMuted ) {
                this.muteIcon.animations.play('vibrate', 24, true);
                this.muteOnButton.visible = false;
                this.muteOffButton.visible = true;
            } else {
                this.muteOnButton.visible = true;
                this.muteOffButton.visible = false;
                this.muteIcon.animations.stop();
                this.muteIcon.frameName = this.theme.phone.ringMode.muteOff;
            }
            _.each( this.data.objectives, function( objective, objectiveKey) {
                var completed = this.modelInterface.getValue("$" + objectiveKey);
                if( completed === true || completed === "true" || completed === "complete" ) {
                    this.objectiveMarkers[objectiveKey].frameName = this.theme.phone.checkBoxes[1];
                }
            }, this);

            var eventData = {"text": "", "audio" : this.data.objectiveAudio };
            this.playAudio(  eventData);
        },
        initDemoView: function() {
            this.phoneGroup.scale.set( 0.5, 0.5);
            this.phoneGroup.x = 295;
            this.phoneGroup.y = 150;
            this.helpGroup.y += 145;
            this.helpGroup.x -= 35;
            this.objectivesGroup.y += 145;
            this.objectivesGroup.x -= 35;
            this.helpGroup.scale.set(0.5, 0.5);
            this.objectivesGroup.scale.set(0.5, 0.5);
        },
        /**
         * Create the main screen, including all of the buttons.
         */
        initHomeScreenGroup: function() {
            this.phoneGroup = this.game.add.group();
            this.phoneGroup.x = this.game.world.centerX;
            var buttonY = 365;

            this.phoneBg = new Phaser.Sprite(this.game, 0, 0, this.theme.textureKey, this.theme.phone.background);
            this.phoneBg.anchor.setTo(0.5, 0.0);
            this.phoneGroup.add(this.phoneBg);
            
            this.muteOnButton = this.createPhoneButton('muteOn', this.onClickMute, this, 2);
            this.phoneGroup.add(this.muteOnButton);
            this.muteOnButton.x = -100;
            this.muteOnButton.y = buttonY;
            this.muteOnButton.anchor.setTo(0.5, 0);
            this.muteOnButton.bringToTop();
            
            this.muteOffButton = this.createPhoneButton('muteOff', this.onClickMute, this, 2);
            this.phoneGroup.add(this.muteOffButton);
            this.muteOffButton.x = -100;
            this.muteOffButton.y = buttonY;
            this.muteOffButton.anchor.setTo(0.5, 0);
            this.muteOffButton.bringToTop();

            this.muteIcon = new Phaser.Sprite(this.game, 0, SCREEN_Y + 2, this.theme.textureKey, this.theme.phone.ringMode.muteOff);
            this.phoneGroup.add(this.muteIcon);
            this.muteIcon.animations.add('vibrate', this.theme.phone.ringMode.muteOn );
            this.muteIcon.x = 220;
            this.muteIcon.bringToTop();

            this.helpButton = this.createPhoneButton('help', this.onClickHelp, this, 2);
            this.phoneGroup.add(this.helpButton);
            this.helpButton.x = 10;
            this.helpButton.y = buttonY;
            this.helpButton.anchor.setTo(0.5, 0);
            this.helpButton.bringToTop();
            
            this.objectivesButton = this.createPhoneButton('objectives', this.onClickObjectives, this, 2);
            this.phoneGroup.add(this.objectivesButton);
            this.objectivesButton.x = 150;
            this.objectivesButton.y = buttonY;
            this.objectivesButton.anchor.setTo(0.5, 0);
            this.objectivesButton.bringToTop();
            
            this.closeButton = this.createPhoneButton('power', this.onClickClose, this, 2);
            this.phoneGroup.add(this.closeButton);
            this.closeButton.x = 280;
            this.closeButton.y = buttonY;
            this.closeButton.anchor.setTo(0.5, 0);
            this.closeButton.bringToTop();
            this.phoneGroup.visible = false;
        },
        initBlockingGroup: function() {
            this.blockingSprite = this.createBlockingSprite();
            this.game.add.existing(this.blockingSprite);
            this.blockingSprite.visible = false;
        },
        initHelpWindowGroup: function () {
            var width = SCREEN_END_X - SCREEN_X;
            var marginX = 5;

            this.helpGroup = this.game.add.group();
            this.helpGroup.x = SCREEN_X;
            this.helpGroup.y = SCREEN_Y;

            var headingText = new Phaser.Text(this.game, marginX, 10, "Help", this.fontHeader);
            this.fontBody.wordWrap = true;
            this.fontBody.wordWrapWidth = width * 0.95;
            this.helpText = new Phaser.Text(this.game, marginX, headingText.height + 15, "BODY TEST", this.fontBody);

            this.helpGroup.add(headingText);
            this.helpGroup.add(this.helpText);

            this.hideHelp();
        },
        showHelp: function ( body) {
            this.helpGroup.visible = true;
            this.helpText.inputEnabled = false;
            this.helpText.setText( body );
            var eventData = {"text": "", "audio" : this.data.helpAudio };
            this.playAudio( eventData);
        },
        hideHelp: function () {
            this.helpGroup.visible = false;
        },
        initObjectivesWindowGroup: function () {
            var width = SCREEN_END_X - SCREEN_X;
            var marginX = 5, marginY = 10;

            this.objectivesGroup = this.game.add.group();
            this.objectivesGroup.x = SCREEN_X;
            this.objectivesGroup.y = SCREEN_Y;

            var headingText = new Phaser.Text(this.game, marginX, marginY, "Objectives", this.fontHeader);
            this.objectivesGroup.add(headingText);

            // list out the objectives, with icons.
            // update the icons when the phone is shown
            // in the onGameChoice, watch for objectives.
            var eachTextItem;
            var eachCheckBox;
            var currentY = headingText.y + headingText.height + marginY;

            _.each( this.data.objectives, function( objective, objectiveKey) {
                eachCheckBox = new Phaser.Sprite(this.game, 0, currentY - 2, this.theme.textureKey, this.theme.phone.checkBoxes[0]);
                eachTextItem = new Phaser.Text(this.game, eachCheckBox.width + marginX, currentY, this.modelInterface.getValue(objective), this.fontBody);
                currentY += eachTextItem.height + marginY;
                this.objectivesGroup.add(eachCheckBox);
                this.objectivesGroup.add(eachTextItem);
                this.objectiveMarkers[objectiveKey] = eachCheckBox;
            }, this);
        },
        showObjectives: function ( objectives ) {
            this.objectivesGroup.visible = true;
            var eventData = {"text": "", "audio" : this.data.objectiveAudio };
            this.playAudio( eventData);
        },
        hideObjectives: function () {
            this.objectivesGroup.visible = false;
        },
        destroy: function () {
            this.fontHeader = null;
            this.fontBody = null;
            if ( this.phoneGroup ) {
                this.phoneGroup.destroy();
            }
            if ( this.helpGroup ) {
                this.helpGroup.destroy(true);
            }
            if ( this.objectivesGroup ) {
                this.objectivesGroup.destroy(true);
            }
            if ( this.blockingSprite ) {
                this.blockingSprite.destroy(true);
            }

            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePhone;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js","moment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\moment\\moment.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-popup.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The IUC popup actor. Pops up an alert, that does not block the screen. Alert can be closed.
 *
 * Creating a phone button actor:
 * {
 *     "name": "popup11", // a unique identifier
 *     "type": "iucpopup", // the required type.*
 *     "heading": "This area is closed.",
 *     "text": "We're busy booking someone. Come back another day.",
 *     "background": "myimage",
 *     "variable": "x"
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var winX = 200, winY = 250;
    var closeX = 550, closeY = 300;

    var ItsUrChoicePopupActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "heading", "text", "variable" ];
        },
        enterScene: function() {
            this.buildActor();
        },
        buildActor: function() {
            this.popupGroup = this.game.add.group();
            this.popupGroup.x = winX;
            this.popupGroup.y = winY;

            var bgFrame = this.theme.popup.background;
            if( this.data.background ) {
                bgFrame = this.getImage(this.data.background, this.data.key);
            }
            this.bg = this.game.add.sprite( 0, 0, this.theme.textureKey, bgFrame );
            this.popupGroup.add(this.bg);

            this.button = this.game.add.button( 0, 9 , this.theme.textureKey,
                this.onPointerUp, this,
                this.theme.popup.closeButton[0], this.theme.popup.closeButton[1],
                this.theme.popup.closeButton[2], this.theme.popup.closeButton[3] );
            this.popupGroup.add(this.button);
            this.button.x = this.bg.width - this.button.width - 8;


            var headingStyle = this.getFont( "popupHeading");
            var bodyStyle = this.getFont( "popupBody");

            if( this.data.fontBody ) {
                bodyStyle = this.getFont(this.data.fontBody);
            }

            if( this.data.fontHeading ) {
                headingStyle = this.getFont(this.data.fontHeading);
            }

            var contentBodyY = 50;
            if( this.data.heading ) {
                this.heading = this.game.add.text(10, 12, this.data.heading, headingStyle);
                this.popupGroup.add(this.heading);
                contentBodyY = 65;
            }
            this.body = this.game.add.text( 15, contentBodyY, this.data.text, bodyStyle);
            this.popupGroup.add(this.body);

            this.button.inputEnabled = true;
        },
        /**
         * Any game choice during an alert will cause the phone to 'vibrate' on screen.
         * @param choice
         */
        onGameChoice: function( choice ) { },
        onPointerUp: function( event ) {
                     var varSet = {};
            varSet[this.data.variable] = this.data.name;
            this.events.onGameChoice.dispatch( this.data.name, varSet );
        },
        destroy: function() {
            this.popupGroup.destroy(true);
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoicePopupActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-window.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The IUC popup actor. Pops up an alert, that does not block the screen. Alert can be closed.
 *
 * Creating a phone button actor:
 * {
 *     "name": "window1", // a unique identifier
 *     "type": "iucwindow", // the required type.*
 *     "heading": "Day 3 Complete",
 *     "audio": "audiokey", // Play when window is initiall opened, or maximimized from min.
 *     "text": "We're busy booking someone. Come back another day.",
 *     "variable": "x",
 *     "showClose": false|true, // optional, defaults to false.
 * }
 *
 */
(function () {

    var Actor = require('../actor');

    var MAXIMIZE = "MAX";
    var MINIMIZE = "MIN";
    var CLOSE = "CLOSE";

    var ItsUrChoiceWindowActor = Actor.extend( {
        // constructor in parent.
        getRequiredFields: function() {
            return [ "heading", "text" ];
        },
        enterScene: function() {
            this.buildActor();
            this.minimize();
        },
        buildActor: function() {
            this.windowGroup = this.game.add.group();
            this.windowGroup.x = 0;
            this.windowGroup.y = 0;

            this.blockerSprite = new Phaser.Sprite(this.game, 0, 0);
            var graphics = new Phaser.Graphics(this.game, 0, 0);
            this.blockerSprite.addChild(graphics);
            graphics.beginFill( 0xEFEFEF, 0.75 );
            graphics.drawRect( 0, 0, this.game.world.width, this.game.world.height );
            graphics.endFill();
            this.blockerSprite.inputEnabled = true;
            this.blockerSprite.bringToTop();
            this.windowGroup.add(this.blockerSprite);

            var bgFrame = this.theme.window.background;
            if( this.data.background ) {
                bgFrame = this.getImage(this.data.background, this.data.key);
            }
            this.bg = this.game.add.sprite( 0, 0, this.theme.textureKey, bgFrame );
            this.windowGroup.add(this.bg);

            this.logo = this.game.add.sprite( this.game.world.width - 25, this.game.world.height - 25,
                this.theme.textureKey, this.theme.window.logo );
            this.logo.anchor.setTo( 1.0, 1.0);
            this.windowGroup.add(this.logo);

            var minButtonY = 20;
            if( this.data.showClose ) {
                this.closeButton = this.game.add.button(this.game.world.width - 25, 20, this.theme.textureKey,
                    this.onCloseButton, this,
                    this.theme.window.closeButton[0], this.theme.window.closeButton[1],
                    this.theme.window.closeButton[2], this.theme.window.closeButton[3]);
                this.windowGroup.add(this.closeButton);
                this.closeButton.anchor.setTo( 1.0, 0);
                this.closeButton.inputEnabled = true;
                minButtonY += this.closeButton.y + this.closeButton.height;
            }

            this.minimizeButton = this.game.add.button( this.game.world.width - 25,
                minButtonY, this.theme.textureKey,
                this.onMinimizeButton, this,
                this.theme.window.minimizeButton[0], this.theme.window.minimizeButton[1],
                this.theme.window.minimizeButton[2], this.theme.window.minimizeButton[3] );
            this.windowGroup.add(this.minimizeButton);
            this.minimizeButton.anchor.setTo( 1.0, 0);

            this.maximizeButton = this.game.add.button( this.game.world.width,
                0, this.theme.textureKey, this.onMaximizeButton, this,
                this.theme.window.maximizeButton[0], this.theme.window.maximizeButton[1],
                this.theme.window.maximizeButton[2], this.theme.window.maximizeButton[3] );
            this.windowGroup.add(this.maximizeButton);
            this.maximizeButton.anchor.setTo( 1.0, 0);
            this.maximizeButton.visible = false;

            var headingStyle = this.getFont( "windowHeading");
            var bodyStyle = this.getFont( "windowBody");

            this.heading = this.game.add.text( this.game.world.width / 2, 120, this.data.heading, headingStyle);
            this.heading.anchor.setTo( 0.5, 0.5);
            this.windowGroup.add(this.heading);

            this.body = this.game.add.text( this.game.world.width / 2, 160, this.data.text, bodyStyle);
            this.body.anchor.setTo( 0.5, 0 );
            this.windowGroup.add(this.body);

            this.minimizeButton.inputEnabled = true;

        },
        onGameChoice: function( choice ) { },
        onCloseButton: function () {
            this.dispatch(CLOSE);
        },
        onMinimizeButton: function () {
            this.dispatch(MINIMIZE);
            this.minimize();
        },
        onMaximizeButton: function () {
            this.dispatch(MAXIMIZE);
            this.maximize();
        },
        minimize: function() {
            this.toggleContent(false);
            this.onMinTweenComplete();
        },
        onMinTweenComplete: function() {
            this.bg.visible = false;
            this.maximizeButton.visible = true;
            if( this.data.audio ) {
                this.playAudio({ audio: this.data.audio, key: null, "priority": "stop"});
            }
        },
        maximize: function() {
            this.maximizeButton.visible = false;
            this.game.world.bringToTop(this.windowGroup);
            this.bg.visible = true;
            this.onMaxTweenComplete();
        },
        onMaxTweenComplete: function() {
            this.toggleContent(true);
            if( this.data.audio ) {
                this.playAudio(  { audio: this.data.audio, key: null});
            }
        },
        toggleContent: function( visible ) {
            this.heading.visible = visible;
            this.body.visible = visible;
            this.logo.visible = visible;
            if( this.data.closeButton ) {
                this.closeButton.visible = visible;
            }
            this.minimizeButton.visible = visible;
            this.blockerSprite.visible = visible;
        },
        dispatch: function (value) {
            var varSet = {};
            varSet[this.data.variable] = value;
            this.events.onGameChoice.dispatch(this.data.name, varSet);
        },
        destroy: function () {
            if( this.windowGroup ) {
                this.windowGroup.destroy(true);
            }
            this.freeBaseActor();
        }
    });

    module.exports = ItsUrChoiceWindowActor;
}());

},{"../actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-large.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var LargeBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.startLoc = [ -150, 100];
            this.endLoc = [ 850, 235];
            this.isPlaying = false;

            this.sprite = this.game.add.sprite( this.startLoc[0], this.startLoc[1] , this.theme.textureKey, this.theme.mapInfo.largeBirdFrames[0]);
            this.sprite.animations.add('fly', this.theme.mapInfo.largeBirdFrames );
            this.sprite.scale.setTo(0.3,0.3);
            this.tween1 = this.game.add.tween(this.sprite).to( { x: this.endLoc[0] }, 4000, 'Linear', false);
            this.tween2 = this.game.add.tween(this.sprite).to( { y: this.endLoc[1] }, 3500, Phaser.Easing.Cubic.In, false);
            this.tween1.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            var crowSound = this.game.rnd.integerInRange(1, 100);
            var whichSound = 'crow';
            if( crowSound > 30 ) {
                whichSound += this.game.rnd.integerInRange(1, 2);
                this.events.playAudio.dispatch("LargeBird", {text:"", audio: whichSound, key: null, priority: 'low'});
            }
            this.sprite.x = this.startLoc[0];
            this.sprite.y = this.startLoc[1];
            this.sprite.animations.play('fly', 14, true);
            this.tween1.start();
            this.tween2.start();
        },
        destroy: function() {
            this.sprite.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = LargeBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-bird-small.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var SmallBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.startLoc = [ 805, 25];
            this.endLoc = [ -100, 75];

            this.sprite = this.game.add.sprite( this.startLoc[0], this.startLoc[1] , this.theme.textureKey, this.theme.mapInfo.smallBirdFrames[0]);
            this.sprite.animations.add('fly', this.theme.mapInfo.smallBirdFrames );

            this.tween1 = this.game.add.tween(this.sprite).to( { x: this.endLoc[0] }, 3000, 'Linear', false);
            this.tween2 = this.game.add.tween(this.sprite).to( { y: this.endLoc[1] }, 3000, Phaser.Easing.Cubic.InOut, false);
            this.tween1.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.sprite.animations.play('fly', 14, true);
            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            var birdSound = this.game.rnd.integerInRange(1, 100);
            var whichSound = 'birdChirp';
            if( birdSound > 30 ) {
                whichSound += this.game.rnd.integerInRange(1, 4);
                this.events.playAudio.dispatch("smallBird", {text:"", audio: whichSound, key: null, priority: 'low'});
            }
            this.sprite.x = this.startLoc[0];
            this.sprite.y = this.startLoc[1];
            this.tween1.start();
            this.tween2.start();

        },
        destroy: function() {
            this.sprite.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = SmallBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-basic.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    var RANDOM_CAR_Y = [ 239, 236, 221, 210 ];
    var RANDOM_CAR_X = [ 801, 660, 277, -50 ];

    var LargeBird = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.randomCar = this.game.add.sprite( 801, 70, this.theme.textureKey, this.theme.mapInfo.vehicles[0]);
            this.randomCar.scale.setTo(0.8, 0.8);
            this.randomCar.anchor.setTo( 0, 1.0);
            this.randomCar.visible = false;

            this.randomCarTween1  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[1], x: RANDOM_CAR_X[1] }, 5500,  Phaser.Easing.Quintic.Out, false);

            this.randomCarTween2  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[2], x: RANDOM_CAR_X[2] }, 7000,  Phaser.Easing.Quintic.InOut, false, 2000);
            this.randomCarTween1.chain(this.randomCarTween2);

            this.randomCarTween3  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[3], x: RANDOM_CAR_X[3] }, 4000,  "Linear", false, 2000);
            this.randomCarTween2.chain(this.randomCarTween3);
            this.randomCarTween3.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.randomCarTween1b  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[1], x: RANDOM_CAR_X[1] }, 6000,  Phaser.Easing.Quintic.Out, false);
            this.randomCarTween2b  = this.game.add.tween(this.randomCar).to( { y: RANDOM_CAR_Y[3], x: RANDOM_CAR_X[3] }, 9000,  "Linear", false, 2000);
            this.randomCarTween1b.chain(this.randomCarTween2b);
            this.randomCarTween2b.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            this.randomCar.y = RANDOM_CAR_Y[0];
            this.randomCar.x = RANDOM_CAR_X[0];
            this.randomCar.frameName = this.theme.mapInfo.vehicles[this.game.rnd.integerInRange(0, 7)];
            this.randomCar.visible = true;

            if( this.game.rnd.integerInRange(1, 3) === 2 ) {
                this.randomCarTween1b.start();
            } else {
                this.randomCarTween1.start();
            }
        },
        destroy: function() {
            this.randomCar.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = LargeBird;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\map\\actor-car-yellow.js":[function(require,module,exports){
/**
 * @author George Frick
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel');
    var Base = require('basejs');

    // This defines the starting point and then 4 stopping points for the yellow car.
    var YELLOW_CAR_Y = [ 650, 264, 245, 237, 255 ];
    var YELLOW_CAR_X = [ 5, 569, 592, 607, 850 ];

    var YellowCar = Base.extend({
        constructor: function(game, theme) {
            this.game = game;
            this.theme = theme;
            this.isPlaying = false;

            this.yellowCar = this.game.add.sprite( 180, 70, this.theme.textureKey, this.theme.mapInfo.yellowCarFrames[0]);
            this.yellowCar.visible = false;
            this.yellowCar.anchor.setTo(0.5, 0.5);

            this.tweenScale = this.game.add.tween(this.yellowCar.scale).to( {x: 0.746, y: 0.73} , 9000, Phaser.Easing.Quintic.Out, false);
            this.yellowCarTween1 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[1], x: YELLOW_CAR_X[1] }, 9000,  Phaser.Easing.Quintic.Out, false);

            this.yellowCarTween2 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[2], x: YELLOW_CAR_X[2] }, 750,  "Linear", false, 1000);
            this.yellowCarTween2.onComplete.add(
                function() {
                    this.yellowCar.scale.setTo( 1.0, 1.0);
                    this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[1];
                }, this);
            this.yellowCarTween1.chain(this.yellowCarTween2);

            this.yellowCarTween3 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[3], x: YELLOW_CAR_X[3] }, 500,  "Linear", false);
            this.yellowCarTween3.onComplete.add(
                function() {
                    this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[2];
                }, this);
            this.yellowCarTween2.chain(this.yellowCarTween3);

            this.yellowCarTween4 = this.game.add.tween(this.yellowCar).to( { y: YELLOW_CAR_Y[4], x: YELLOW_CAR_X[4] }, 3000,  "Linear", false);
            this.yellowCarTween3.chain(this.yellowCarTween4);
            this.yellowCarTween4.onComplete.add(function() {
                this.isPlaying = false;
            }, this);

            this.events = {
                playAudio: new Phaser.Signal()
            };
        },
        play: function() {
            if( this.isPlaying ) {
                return;
            }
            this.isPlaying = true;
            this.yellowCar.frameName = this.theme.mapInfo.yellowCarFrames[0];
            this.yellowCar.y = YELLOW_CAR_Y[0];
            this.yellowCar.x = YELLOW_CAR_X[0];
            this.yellowCar.visible = true;
            this.yellowCarTween1.start();
            this.tweenScale.start();
        },
        destroy: function() {
            this.yellowCar.destroy();
            if (this.events.playAudio) {
                this.events.playAudio.removeAll();
                this.events.playAudio.dispose();
            }
        }
    });

    module.exports = YellowCar;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\rounded-chat-rect.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/21/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This class will create a text bubble with a gradient back fill. It reproduces a series of text bubble images
 * from Flash that were nine-sliced. In this case, the nine-slice is no longer needed and we just render a
 * rounded rectangle as a mask.
 *
 * The rectangle will be padded around the font.
 *
 */
(function () {
    'use strict';
    var log = require('loglevel'),
        _ = require('lodash'),
        Base = require("basejs");

    var RoundedChatRect = Base.extend({
        constructor: function (game, theme) {
            this.game = game;
            this.theme = theme;

            var roundness = 28;
            var width = 440, height = 200;
            var x = 15, y = 10;
            var paddingX = 60, paddingY = 20;

            var bubbleGroup = this.game.add.group();
            this.bubble = bubbleGroup;

            // Create the text, which is wrapped according to the font.
            var fontHeading = _.cloneDeep(this.theme.fonts.chatText);
            fontHeading.wordWrapWidth = 460;
            var bubbleText = game.add.text((width/2) + paddingX , y + paddingY , "No text yet.", fontHeading );
            bubbleText.anchor.setTo(0.5, 0);
            this.bubbleText = bubbleText;
            this.bubbleText.lineSpacing = -4;
            this.gradients = ['#ffffff', '#ffffff'];

            // var bubbleBorderThin = this.game.add.graphics(0, 0);
            // bubbleBorderThin.lineStyle(2, 0x000000, 1);
            // bubbleBorderThin.drawRoundedRect(x+1, y+1, width, height, roundness);
            // bubbleBorderThin.endFill();
            // bubbleGroup.add(bubbleBorderThin);

            // draw the shape that contains the gradient
            // var gradientBmp = this.game.add.bitmapData(width, height);
            //
            // var gradientFill = gradientBmp.context.createLinearGradient(0, 0, width, 0);
            // gradientFill.addColorStop(0, this.gradients[0]);
            // gradientFill.addColorStop(1, this.gradients[1]);
            // gradientBmp.context.fillStyle = gradientFill;
            // gradientBmp.context.fillRect(0, 0, width, height);
            // var gradientSprite = this.game.add.sprite(x, y, gradientBmp);
            // bubbleGroup.add(gradientSprite);

            // var gradientMask = this.game.add.graphics(0, 0);
            // gradientMask.beginFill(0x000000);
            // gradientMask.drawRoundedRect(x, y, width, height, roundness); // draw a rounded rect mask
            // gradientMask.endFill();
            // bubbleGroup.add(gradientMask);

            // gradientSprite.mask = gradientMask; // apply the mask
            //
            // this.carrot = this.game.add.sprite( 454, 150, this.theme.textureKey,"speech_arrow.png");

            bubbleGroup.add(bubbleText);
            bubbleGroup.bringToTop(bubbleText);
            // bubbleGroup.add(this.carrot);

        },
        showResponse: function( response ) {
            this.bubbleText.setText( response.text.text );
        },
        show: function () {
            this.bubble.visible = true;
        },
        hide: function () {
            this.bubble.visible = false;
        },
        destroy: function () {
            this.bubble.destroy(true);
        }
    });

    module.exports = RoundedChatRect;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\tween-helper.js":[function(require,module,exports){
/**
 * @author Paul Knell
 * @version 1.0.0
 * @creation 10/23/2018
 * Copyright 2018 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * A helper class that supports setting up Tween.  Intended to be used by Actors.
 *
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs');

    var TweenHelper = Base.extend({
        constructor: function(game, actor) {
            if( !game ) {
                throw "TweenHelper requires game constructor argument.";
            }
            if( !actor ) {
                throw "TweenHelper requires actor constructor argument.";
            }
            this.game = game;
            this.actor = actor;
        },
        addTweens: function(tweenDataArray, sprite) {
            if (_.isArray(tweenDataArray)) {
                _.each(tweenDataArray, function(tweenData) { this.addTween(tweenData, sprite); }, this);
            } else {
                this.addTween(tweenDataArray, sprite);
            }
        },
        addTween: function(tweenData, sprite) {

            var tweens = {};

            var configureTweens = function(tweenData) {
                var delay = tweenData.delay ? tweenData.delay : 0;
                var easing = tweenData.easing || "Linear";
                if (tweens.spriteTween) {
                    var newValues = {};
                    if (tweenData.location) {
                        newValues.x = tweenData.location[0];
                        newValues.y = tweenData.location[1];
                    }
                    // Support for tweenData.location is here for backwards compatibility, but
                    // separate tweenData.x and tweenData.y has been added so that each dimension can be
                    // independently "tweened" if desired.
                    if (tweenData.x) {
                        newValues.x = tweenData.x;
                    }
                    if (tweenData.y) {
                        newValues.y = tweenData.y;
                    }
                    if (!_.isUndefined(tweenData.alpha)) {
                        newValues.alpha = tweenData.alpha;
                    }
                    if (!_.isUndefined(tweenData.angle)) {
                        newValues.angle = tweenData.angle;
                    }
                    if (!_.isUndefined(tweenData.rotation)) {
                        newValues.rotation = tweenData.rotation;
                    }
                    tweens.spriteTween.to(newValues, tweenData.time, easing, false, delay);
                }
                if (tweens.scaleTween) {
                    var newValues = {};
                    if (tweenData.scale) {
                        newValues.x = tweenData.scale[0];
                        newValues.y = tweenData.scale[1];
                    }
                    tweens.scaleTween.to( newValues, tweenData.time, easing, false, delay);
                }
            };

            if (tweenData.location || !_.isUndefined(tweenData.alpha)
                || !_.isUndefined(tweenData.rotation) || !_.isUndefined(tweenData.angle)
                || !_.isUndefined(tweenData.x) || !_.isUndefined(tweenData.y)) {

                tweens.spriteTween = this.game.add.tween(sprite);
            }
            if (tweenData.scale && sprite.scale) {
                tweens.scaleTween = this.game.add.tween(sprite.scale);
            }

            configureTweens(tweenData);

            if (tweenData.chainedTweens) {
                if (_.isArray(tweenData.chainedTweens)) {
                    _.each(tweenData.chainedTweens, configureTweens, this);
                } else {
                    this.configureTweens(tweenData.chainedTweens);
                }
            }

            if (tweenData.loop === true) {
                _.each(tweens, function(tween) { tween.loop(); });
            }

            if (!_.isUndefined(tweenData.yoyo)) {
                _.each(tweens, function(tween) {
                    var millis = Number(tweenData.yoyo);
                    if (!isNaN(millis)) {
                        tween.yoyo(true, millis);
                    } else if (tweenData.yoyo) {
                        tween.yoyo(true, 1000);
                    }
                });
            }

            if (!_.isUndefined(tweenData.variable)) {
                var tween = tweens.spriteTween || tweens.scaleTween;
                tween.onComplete.add(function() {
                    var varSet = {};
                    varSet[tweenData.variable] = 'complete';
                    this.actor.dispatchGameChoice(varSet);
                }, this);
            }

            _.each(tweens, function(tween) { tween.start(); });
        },
        removeTweens: function(sprite) {
            this.game.tweens.removeFrom(sprite);
            if (!_.isUndefined(sprite.scale)) {
                this.game.tweens.removeFrom(sprite.scale);
            }
        }
    });

    module.exports = TweenHelper;
}());

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-action.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * For now, just serve as a registry for actions
 */
(function () {
    'use strict';
    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs'),
        ChoiceAction = require('./actions/game-choice'),
        RemoveActorAction = require('./actions/remove-actor'),
        AddActorAction = require('./actions/add-actor'),
        CheckOutcomeAction = require('./actions/check-outcomes'),
        ChangeObjectiveAction = require('./actions/change-objective'),
        MarkCompleteAction = require('./actions/mark-complete'),
        VariableIncrementAction = require('./actions/variable-increment'),
        MhSceneAction = require('./actions/mh/mh-change-scene'),
        SceneAction = require('./actions/change-scene');

    var PlayAction = Base.extend( {
        constructor: function() {
            this.actions = {};
        },
        registerAction: function( type, action ) {
            this.actions[type] = action;
        },
        getAction: function( data ) {
            if( !data || !data.type || !this.actions[data.type] ) {
                throw "Cannot retrieve an action without an action type. { type: '..', args: [...]} ";
            }
            var clazz = this.actions[data.type];
            return new clazz( data.args );
        }
    });

    var ActionFactory = new PlayAction();
    ActionFactory.registerAction("add-actor", AddActorAction);
    ActionFactory.registerAction("check-outcomes", CheckOutcomeAction);
    ActionFactory.registerAction("choice", ChoiceAction);
    ActionFactory.registerAction("mark-complete", MarkCompleteAction);
    ActionFactory.registerAction("objective", ChangeObjectiveAction);
    ActionFactory.registerAction("remove-actor", RemoveActorAction);
    ActionFactory.registerAction("scene", SceneAction);
    ActionFactory.registerAction("variable", ChoiceAction);
    ActionFactory.registerAction("variable-increment", VariableIncrementAction);

    // Mission-Health specific actions:
    ActionFactory.registerAction("mh-scene", MhSceneAction);

    module.exports = ActionFactory;
}());

},{"./actions/add-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\add-actor.js","./actions/change-objective":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-objective.js","./actions/change-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\change-scene.js","./actions/check-outcomes":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\check-outcomes.js","./actions/game-choice":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\game-choice.js","./actions/mark-complete":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mark-complete.js","./actions/mh/mh-change-scene":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\mh\\mh-change-scene.js","./actions/remove-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\remove-actor.js","./actions/variable-increment":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actions\\variable-increment.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-actor.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0
 * @creation 07/01/2015, 09/07/2017
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is a registry and construction factory for Actors; which should not be instantiated on their own, only
 * from this creation point. This creation point also works for validation purposes.
 */
(function () {
    'use strict';
    var _ = require('lodash');
    var log = require('loglevel');
    var Base = require('basejs');

    /* General Actors, or reusable across courses */
    var Animation = require('./actors/actor-animation');
    var Audio = require('./actors/actor-audio');
    var Blocker = require('./actors/actor-blocker');
    var Button = require('./actors/actor-button');
    var ButtonCharacter = require('./actors/actor-button-character');
    var Character = require('./actors/actor-character');
    var ClickAnimation = require('./actors/actor-click-animation');
    var Decoration = require('./actors/actor-decoration');
    var Drag = require('./actors/actor-drag');
    var Draw = require('./actors/actor-draw');
    var Drop = require('./actors/actor-drop');
    var Fadeout = require('./actors/actor-fadeout');
    var InputField = require('./actors/actor-input-field');
    var Instructions = require('./actors/actor-instruction-bubble');
    var Line = require('./actors/actor-line');
    var NoInputCharacter = require('./actors/actor-no-input-character');
    var Question = require('./actors/actor-question');
    var Rectangle = require('./actors/actor-rectangle');
    var SpeechBubble = require('./actors/actor-speech-bubble');
    var Text = require('./actors/actor-text');
    var TextBubble = require('./actors/actor-text-bubble');
    var Timeline = require('./actors/actor-timeline');
    var ToggleButton = require('./actors/actor-toggle-button');
    var UrlButtonInvisible = require('./actors/actor-url-button-invisible');
    var UrlButton = require('./actors/actor-url-button');
    var Wistia = require('./actors/actor-wistia');

    /* Actors specifically for It's UR Choice usage */
    var Chat = require('./actors/iuc/actor-chat');
    var ItsUrChoiceBook = require('./actors/iuc/actor-book');
    var ItsUrChoiceDrag = require('./actors/iuc/actor-file-drag');
    var ItsUrChoicePhone = require('./actors/iuc/actor-phone');
    var ItsUrChoicePhoneButton = require('./actors/iuc/actor-phone-button');
    var MapActor = require('./actors/iuc/actor-map');
    var PopupActor = require('./actors/iuc/actor-popup');
    var WindowActor = require('./actors/iuc/actor-window');

    /* Actors specifically for Act Now! usage */
    var Announcer = require('./actors/actnow/actor-announcer');
    var Choice = require('./actors/actnow/actor-choice');
    var ActNowPhone = require('./actors/actnow/actor-phone');
    var PhoneButton = require('./actors/actnow/actor-phone-button');
    var Spinner = require('./actors/actnow/actor-spinner');
    var Chooser = require('./actors/actnow/actor-chooser');
    var ZinkComputer = require('./actors/actnow/actor-zink-computer');
    var ZinkPoster = require('./actors/actnow/actor-zink-poster');

    var PlayActor = Base.extend( {
        constructor: function() {
            this.actors = {};
            this.actorTypes = [];
        },
        registerActor: function( type, actor ) {
            _.each( this.actorTypes, function(knownType) {
               if( knownType === type ) {
                   throw "You are registering an actor type that already exists: " + type;
               }
            });
            this.actorTypes.push(type);
            this.actors[type] = actor;
        },
        getActor: function( type ) {
            return this.actors[type];
        },
        isAvailableType: function(type) {
            var found = false;
            _.each( this.actorTypes, function(knownType) {
                if( knownType === type ) {
                    found = true;
                }
            });
            return found;
        },
        getAvailableTypes: function() {
            // Return a clone, to make it read only.
            return _.clone(this.actorTypes);
        }
    });

    var ActorFactory = new PlayActor();

    /* General Actors, or reusable across courses */
    ActorFactory.registerActor("animation", Animation );
    ActorFactory.registerActor("audio", Audio );
    ActorFactory.registerActor("blocker", Blocker );
    ActorFactory.registerActor("button", Button );
    ActorFactory.registerActor("button-character", ButtonCharacter );
    ActorFactory.registerActor("character", Character);
    ActorFactory.registerActor("click-animation", ClickAnimation);
    ActorFactory.registerActor("decoration", Decoration );
    ActorFactory.registerActor("drag", Drag );
    ActorFactory.registerActor("draw", Draw );
    ActorFactory.registerActor("drop", Drop );
    ActorFactory.registerActor("fadeout", Fadeout );
    ActorFactory.registerActor("input-field", InputField );
    ActorFactory.registerActor("instructions", Instructions );
    ActorFactory.registerActor("line", Line );
    ActorFactory.registerActor("no-input-character", NoInputCharacter );
    ActorFactory.registerActor("rectangle", Rectangle);
    ActorFactory.registerActor("speech-bubble", SpeechBubble);
    ActorFactory.registerActor("text", Text);
    ActorFactory.registerActor("text-bubble", TextBubble);
    ActorFactory.registerActor("timeline", Timeline);
    ActorFactory.registerActor("toggle-button", ToggleButton );
    ActorFactory.registerActor("url-button", UrlButton );
    ActorFactory.registerActor("url-button-invisible", UrlButtonInvisible );
    ActorFactory.registerActor("question", Question);
    ActorFactory.registerActor("video", Wistia );
    ActorFactory.registerActor("wistia", Wistia );

    /* Actors specifically for It's UR Choice usage */
    ActorFactory.registerActor("chat", Chat);
    ActorFactory.registerActor("iucbook", ItsUrChoiceBook );
    ActorFactory.registerActor("iucdrag", ItsUrChoiceDrag );
    ActorFactory.registerActor("iucphone", ItsUrChoicePhone );
    ActorFactory.registerActor("iucphone-button", ItsUrChoicePhoneButton );
    ActorFactory.registerActor("iucmap", MapActor);
    ActorFactory.registerActor("iucpopup", PopupActor);
    ActorFactory.registerActor("iucwindow", WindowActor);

    /* Actors for Act Now! usage */
    ActorFactory.registerActor("announcer", Announcer);
    ActorFactory.registerActor("choice", Choice);
    ActorFactory.registerActor("phone-button", PhoneButton );
    ActorFactory.registerActor("phone", ActNowPhone );
    ActorFactory.registerActor("spinner", Spinner);
    ActorFactory.registerActor("chooser", Chooser);
    ActorFactory.registerActor("zink-computer", ZinkComputer );
    ActorFactory.registerActor("zink-poster", ZinkPoster);

    module.exports = ActorFactory;
}());

},{"./actors/actnow/actor-announcer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-announcer.js","./actors/actnow/actor-choice":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-choice.js","./actors/actnow/actor-chooser":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-chooser.js","./actors/actnow/actor-phone":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone.js","./actors/actnow/actor-phone-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-phone-button.js","./actors/actnow/actor-spinner":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-spinner.js","./actors/actnow/actor-zink-computer":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-computer.js","./actors/actnow/actor-zink-poster":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-zink-poster.js","./actors/actor-animation":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-animation.js","./actors/actor-audio":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-audio.js","./actors/actor-blocker":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-blocker.js","./actors/actor-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button.js","./actors/actor-button-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-button-character.js","./actors/actor-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-character.js","./actors/actor-click-animation":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-click-animation.js","./actors/actor-decoration":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-decoration.js","./actors/actor-drag":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drag.js","./actors/actor-draw":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-draw.js","./actors/actor-drop":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-drop.js","./actors/actor-fadeout":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-fadeout.js","./actors/actor-input-field":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-input-field.js","./actors/actor-instruction-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-instruction-bubble.js","./actors/actor-line":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-line.js","./actors/actor-no-input-character":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-no-input-character.js","./actors/actor-question":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-question.js","./actors/actor-rectangle":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-rectangle.js","./actors/actor-speech-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-speech-bubble.js","./actors/actor-text":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text.js","./actors/actor-text-bubble":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-text-bubble.js","./actors/actor-timeline":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-timeline.js","./actors/actor-toggle-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-toggle-button.js","./actors/actor-url-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button.js","./actors/actor-url-button-invisible":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-url-button-invisible.js","./actors/actor-wistia":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actor-wistia.js","./actors/iuc/actor-book":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-book.js","./actors/iuc/actor-chat":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-chat.js","./actors/iuc/actor-file-drag":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-file-drag.js","./actors/iuc/actor-map":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-map.js","./actors/iuc/actor-phone":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone.js","./actors/iuc/actor-phone-button":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-phone-button.js","./actors/iuc/actor-popup":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-popup.js","./actors/iuc/actor-window":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\iuc\\actor-window.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-scene.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * Represent a "Scene" as part of an "Act". The scene contains an array of actors and deals with brokering events.
 */
(function () {

    var _ = require('lodash'),
        log = require('loglevel'),
        Base = require('basejs'),
        PlayActor = require('./play-actor'),
        PlayThroughActor = require('./actors/actnow/actor-playthrough');

    var PlayScene = Base.extend( {
        constructor: function(game, data, modelInterface, theme) {
            if( !game ) {
                throw "PlayScene requires game constructor argument.";
            }
            if( !data ) {
                throw "PlayScene requires data constructor argument.";
            }
            this.initScene(game);
            this.events = {
                onGameChoice: new Phaser.Signal(),
                onGameSpeech: new Phaser.Signal(),
                onGameMusic: new Phaser.Signal()
            };
            this.data = data;
            this.modelInterface = modelInterface;
            this.theme = theme;
            this.actors = [];
            this.delayedActors = [];
            this.isShowPlayThrough = false;
            this.playthroughActor = null;
        },
        initScene: function(game) {
            this.game = game;
            this.bgColor = this.game.add.graphics(0,0);
            this.bgColor.beginFill("0xFFFFFF");
            this.bgColor.drawRect(0,0, this.game.world.width, this.game.world.height);
            this.bgColor.endFill();
            this.bgColor._chw_name = "SceneBackgroundGraphics";
        },
        showNewSceneData: function( newData ) {
            this.data = newData;
            this.bgColor.visible = false;
            if( this.playthroughActor ) {
                this.playthroughActor.hide();
            }
            this.sceneId = newData.id;
        },
        /**
         * Show the scene to the player by setting the background and having all actors enter the scene.
         */
        showScene: function() {

            if( this.data.background !== "none") {
                if( this.background ) {
                    this.background.frameName = this.theme.sceneImages[this.data.background];
                    this.background.visible = true;
                } else {
                    this.background = this.game.add.sprite(0, 0, this.theme.textureKey, this.theme.sceneImages[this.data.background] );
                    this.background.inputEnabled = true;
                    this.game.input.disabled = true;
                }
            } else if( this.background ) {
                this.background.visible = false;
            }
            this.bgColor.visible = true;
            _.each( this.data.actors, this.addActor, this);

            /**
             * The constant 'play-through' actor.
             */
            if( this.isShowPlayThrough ) {
                this.playthroughActor.show();
            }

            if( this.data.backgroundMusic ) {
                this.events.onGameMusic.dispatch( this.data.backgroundMusic );
            }

        },
        showPlayThrough: function() {
            if( !this.playthroughActor  ) {
                this.playthroughActor  = new PlayThroughActor(this.game, this.theme);
                this.playthroughActor.setModelInterface(this.modelInterface);
                this.playthroughActor.enterScene();
            }
            this.isShowPlayThrough = true;
        },
        /**
         * Add an individual actor to the scene. The ordering is important, the actor is created, then event listeners
         * are added, and then the actor is allowed to enter the scene. We don't want an actor that immediately acts
         * to have its events ignored because the listeners weren't yet in place.
         * @param actorData
         */
        addActor: function(actorData) {
            var actorClass, actor, newActorData = actorData;
            // Actors can also be of type reference, meaning they load an actor from the set of actors outside scenes.
            if( actorData.type === "reference" ) {
                newActorData = this.modelInterface.getActorByRef( actorData.name );
            }

            actorClass = PlayActor.getActor(newActorData.type);
            actor = new actorClass(this.game, newActorData, this.theme);
            actor.setModelInterface(this.modelInterface);
            actor.clearVariables();
            // Any given actor may or may not publish these events.
            if (actor.events) {
                if (actor.events.onGameChoice) {
                    actor.events.onGameChoice.add(this.onGameChoice, this);
                }
                if (actor.events.onGameSpeech) {
                    actor.events.onGameSpeech.add(this.onGameSpeech, this);
                }
            }

            if (typeof newActorData.startDelay === "undefined") {
                this.actors.push(actor);
                actor.enterScene();
            } else {
                var delayActor = [];
                delayActor[0] = -1; // start time in ticks, to be set in tickUpdate()
                delayActor[1] = newActorData.startDelay; // in ticks (a tick is defined in main)
                delayActor[2] = actor;
                this.delayedActors.push(delayActor);
            }
        },
        /**
         * An actor has made a choice, bubble this event up to the 'act', and inform all other
         * actors of the choice so that they can adjust any internal state.
         * @param name
         * @param choice
         */
        onGameChoice: function( name, choice ) {
            this.events.onGameChoice.dispatch(  choice );

            var tempVars = _.pairs(choice)[0];
            choice.consumed = this.sceneCommand(name, tempVars[0], tempVars[1]);

            if( !choice.consumed ) {
             this.sendGameChoiceToActors(name, choice);
            }
        },
        sendGameChoiceToActors: function(name, choice) {
            // Tell any actors with a method to handle choices.
            _.each(this.actors, function (actor) {
                if (actor.getName() !== name && actor.onGameChoice) {
                    actor.onGameChoice(choice);
                }
            }, this);
        },
        /**
         * Run an Scene level command. Return true if a command happened, otherwise false.
         * @param command
         * @param arg
         * @returns {boolean} true if the command was consumed.
         */
        sceneCommand: function( actorName, command, arg) {
            log.warn("Scene command: " + command + " / " + arg);
            if( command === "dropped" ) {
                _.each( this.actors, function(actor1) {
                    if( actor1 && actor1.getType() === "drop" ) {
                        _.each( this.actors, function(actor2) {
                            if( actor2.getType() === "drag" || actor2.getType() === "iucdrag" ) {
                                if( this.game.physics.arcade.overlap( actor1.getPrimarySprite(), actor2.getPrimarySprite()) ) {
                                    actor1.onReceiveDrop(actor2.getName());
                                    return false; // exit loop.
                                }
                            }
                        }, this);
                    }
                }, this);

                return true;
            } else if( command === "mute_game") {
                _.each(this.actors, function (actor) {
                    if ( actor.data.name !== actorName && actor.data.type === "wistia" ) {
                        actor.onWistiaMute(this.game.sound.mute);
                    }
                }, this);
            }
            return false;
        },
        /**
         * An actor is showing new text (and possibly playing new audio). some actors animate others speaking, or
         * show the text/audio that an actor is speaking. So bubble the event and also tell the other actors.
         * @param name
         * @param speech
         */
        onGameSpeech: function( name, speech, sourceActor ) {
            this.events.onGameSpeech.dispatch( speech );
            if( sourceActor && sourceActor.isSoundEventInverse()  ) {
                if( sourceActor.onGameSpeech) {
                    sourceActor.onGameSpeech(speech);
                }
            } else {
                // Tell any actors with a method to handle speech changes.
                _.each(this.actors, function (actor) {
                    if (actor.data.name !== name && actor.onGameSpeech) {
                        actor.onGameSpeech(speech);
                    }
                    if ( actor.data.type === "wistia" ) {
                        actor.onGameSpeech(speech);
                    }
                }, this);
            }
        },
        /**
         * A speech stop action has occured from further up the chain, continue passing it down to each actor.
         * @param speech
         */
        onGameSpeechStop: function( speech ) {
            _.each( this.actors, function( actor ) {
                if( actor && actor.onGameSpeechStop ) {
                    actor.onGameSpeechStop( speech );
                }
            }, this);
        },
        removeActorByName: function( name ) {
            var index,
                actor = null;
            for( index = 0; index < this.actors.length; index++ ) {
                if( this.actors[index].data.name === name ) {
                    actor = this.actors[index];
                    break;
                } else {
                    log.warn(this.actors[index].data.name );
                }
            }
            if( actor ) {
                this.actors.splice(index, 1);
                this.destroyActor(actor);
            } else {
                // check for a delayed actor that hasn't been triggered yet
                for( index = 0; index < this.delayedActors.length; index++ ) {
                    var delayedActor = this.delayedActors[index][2];
                    if( delayedActor.data.name === name ) {
                        actor = delayedActor;
                        break;
                    } else {
                        log.warn(delayedActor.data.name );
                    }
                }
                if( actor ) {
                    this.delayedActors.splice(index, 1);
                    actor.destroy();
                }
            }
        },
        /**
         * Check for delayed actors. If a delayed actor's start time  in ticks has arrived, add it to the scene and
         * remove it from the delayed actors list.
         *
         * STRONG WARNING: Don't do much here - it's called from the main update loop. Any extensive operations will
         * cause the user interface to lag.
         */
        tickUpdate: function (tick) {
            for (var i = this.delayedActors.length - 1; i >= 0; i--) {
                if (this.delayedActors[i][0] < 0) {
                    // This actor's start time hasn't been set yet. Set its start time to current tick plus its delay.
                    this.delayedActors[i][0] = tick + this.delayedActors[i][1];
                }
                if (tick >= this.delayedActors[i][0] ) {
                    var actor = this.delayedActors[i][2];
                    var delay = this.delayedActors[i][1];
                    this.delayedActors.splice(i, 1); // remove it
                    //log.warn("delayed actor"
                    //    + (((typeof actor.data != "undefined") && (typeof actor.data.name != "undefined")) ? (" named \"" + actor.data.name + "\"") : "")
                    //    + (((typeof actor.data != "undefined") && (typeof actor.data.type != "undefined")) ? (" of type \"" + actor.data.type + "\"") : "")
                    //    + " entering scene after " + delay + " ticks");
                    this.actors.push(actor);
                    actor.enterScene();
                }
            }
            _.each( this.actors, function(actor1) {
                if( actor1.getType() === "drop"  ) {
                    _.each( this.actors, function(actor2) {
                        if( actor2.getType() === "drag" || actor2.getType() === "iucdrag" ) {
                            if( this.game.physics.arcade.overlap( actor1.getPrimarySprite(), actor2.getPrimarySprite()) ) {
                                actor1.onOverlapping(actor2.getName());
                                return false;
                            } else {
                                actor1.onOverlapping(null);
                            }
                        }
                    }, this);
                }
            }, this);
        },
        getActions: function() {
            return this.data.actions;
        },
        /**
         * Retrieve the keys of any additional audio this scene wants.
         * @returns {Array}
         */
        getAdditionalAudio: function() {
            var additionalAudio = [];
            _.each( this.data.actors, function( actor ) {
                if( actor.audioKey ) {
                    additionalAudio.push( actor.audioKey );
                }
            }, this);
            return additionalAudio;
        },
        destroyActor: function( actor ) {
            actor.destroy();
        },
        clearForReuse: function() {
            var actor;
            while( actor = this.actors.pop() ) {
                this.destroyActor(actor);
                actor = null;
            }
            this.actors = [];
            var delayedActorData;
            while( delayedActorData = this.delayedActors.pop() ) {
                actor = delayedActorData[2];
                actor.destroy();
                actor = null;
            }
            this.delayedActors = [];
            this.events.onGameChoice.removeAll();
            this.events.onGameSpeech.removeAll();
            this.events.onGameMusic.removeAll();
        },
        destroy: function() {
            this.clearForReuse();
            this.bgColor.destroy();
            this.background.inputEnabled = false;
            this.background.destroy();
            this.events.onGameChoice.dispose();
            this.events.onGameSpeech.dispose();
            this.events.onGameMusic.dispose();
            this.events = null;
        }
    });

    module.exports = PlayScene;
}());

},{"./actors/actnow/actor-playthrough":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\actors\\actnow\\actor-playthrough.js","./play-actor":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene\\play-actor.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scorm.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/10/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This module is an interface to the SCORM API provided via /main/scorm/APIWrapper.js
 * Users of this module are expected to call initialize with a settings object of at least:
 * {
 *     scormEnabled: true|false
 * }
 * You do not have to enable Scorm to use this class, it will hold an internal representation for debugging
 * purposes.
 *
 */
(function () {

    var Base = require('basejs'),
        log = require('loglevel'),
        _ = require('lodash');

    // @TODO, inject scorm interface instead of assuming window.
    var Scorm = Base.extend({
        constructor: function (scormInterface) {
            this.scormInterface = scormInterface || window;
            this.sessionStartTime = new Date();
            this.interval = 0;
            this.scormAvailable = false;
            this.initSuccess = "";
            this.constants = {
                incomplete: "incomplete",
                notAttempted: "not attempted",
                complete: "completed"
            };
            /**
             * @See Scorm Runtime ENV PDF Section 3.4
             */
            this.LMSKeys = {
                lessonStatus: "cmi.core.lesson_status",
                interactionCount: "cmi.interactions._count",
                suspendData: "cmi.suspend_data",
                interactionId: "cmi.interactions.#.id",
                interactionType: "cmi.interactions.#.type", // @SEE LMSInteractionTypes below.
                interactionCorrectPattern: "cmi.interactions.#.correct_responses.0.pattern",
                interactionActualPattern: "cmi.interactions.#.student_response",
                interactionResult: "cmi.interactions.#.result", // @SEE LMSResultTypes below
                rawScore: "cmi.core.score.raw",
                sessionTime: "cmi.core.session_time",
                objectiveId: "cmi.objectives.#.id",
                objectiveStatus: "cmi.objectives.#.status" // @SEE LMSObjectiveStatusValues below
            };
            /**
             * The valid "status" field when working with cmi objectives
             * @type {Array}
             */
            this.LMSObjectiveStatusValues = [
                "passed", "completed", "failed", "incomplete", "browsed", "not attempted"
            ];
            /**
             * The valid "type" field when creating an interaction.
             * @See Scorm Runtime Env PDF Section 3.4.4
             */
            this.LMSInteractionTypes = [
                "true-false", "choice", "fill-in", "matching", "performance", "sequencing", "likert", "numeric"
            ];
            /**
             * The valid "result" field when creating an interaction.
             * @See Scorm Runtime Env PDF Section 3.4.4
             */
            this.LMSResultTypes = [
                "correct", "wrong", "unanticipated", "neutral" // and x.x
            ];
            this.LMSResultTypeNumber = /[0-9]+\.[0-9]+/; // Regular expression for #.#
            this.lessonData = {};
        },
        initialize: function (settings) {
            log.debug("Initializing SCORM CH API");
            if (settings && settings.scormEnabled) {
                log.debug("scormEnabled === true, initializing SCORM");
                if (!doLMSInitialize) {
                    log.error("The LMS Wrapper appears to be missing. Skipping SCORM Initialization.");
                    return;
                }
                this.initSuccess = doLMSInitialize();
                // error in early IE. GJF console.log("initialize success?: " + success);
                if (this.initSuccess === "true") {
                    this.scormAvailable = true;
                    log.debug("SCORM initialized from SCORM CH API successfully.");
                    // Create a "that" closure for the window function. GJF.
                    var that = this;
                    window.onbeforeunload = function () {
                        window.clearInterval(that.interval);
                        doLMSFinish();
                    };

                    this.sessionStartTime = new Date();
                } else {
                    log.error("SCORM initialize from SCORM CH API, FAILED!");
                    alert("Could not initialize SCORM API.");
                }
            } else {
                log.warn("scormEnabled === false, skipping SCORM");
            }
        },
        initializeStatus: function () {
            if (this.scormAvailable) {
                var status = doLMSGetValue(this.LMSKeys.lessonStatus);
                if (!status || status === this.constants.notAttempted) {
                    this.setLessonStatus(this.constants.incomplete);
                }
            } else {
                this.setLessonStatus(this.constants.incomplete);
            }
        },
        setLessonStatus: function (status) {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.lessonStatus, status);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.lessonStatus] = status;
            }
        },
        getLessonStatus: function () {
            var status = "";
            if (this.scormAvailable) {
                status = doLMSGetValue(this.LMSKeys.lessonStatus);
            } else {
                status = this.lessonData[this.LMSKeys.lessonStatus];
            }
            return status;
        },
        isLessonComplete: function () {
            return this.getLessonStatus() === this.constants.complete;
        },
        getObjective: function( index ) {
            var id, status;
            if (this.scormAvailable) {
                id = doLMSGetValue((this.LMSKeys.objectiveId).replace("#", index));
                status = doLMSGetValue((this.LMSKeys.objectiveStatus).replace("#", index));
            } else {
                id = this.lessonData[(this.LMSKeys.objectiveId).replace("#", index)];
                status = this.lessonData[(this.LMSKeys.objectiveStatus).replace("#", index)];
            }
            var temp = {
                index: index,
                id: id,
                status: status
            };
            log.debug(temp);
            return temp;
        },
        setObjective: function( index, id, status) {
            log.debug("Set objective " + index + " " + id + " " + status );
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue((this.LMSKeys.objectiveId).replace("#", index), id);
                doLMSSetValue((this.LMSKeys.objectiveStatus).replace("#", index), status);
                doLMSCommit();
            } else {
                 this.lessonData[(this.LMSKeys.objectiveId).replace("#", index)] = id;
                 this.lessonData[(this.LMSKeys.objectiveStatus).replace("#", index)] = status;
            }
        },
        getInteractionCount: function () {
            var count = 0;
            if (this.scormAvailable) {
                count = doLMSGetValue(this.LMSKeys.interactionCount);
            } else {
                count = this.lessonData[this.LMSKeys.interactionCount] || 0; // default to 0.
            }
            return Number(count);
        },
        createInteraction: function (index, id, type, correctResponse, studentResponse, result) {
            // Allow the user to pass in an object with these values instead of all of the values directly.
            log.debug(index);
            if (typeof index === "object") {
                id = index.id;
                type = index.type;
                correctResponse = index.correctResponse;
                studentResponse = index.studentResponse;
                result = index.result;
                index = index.index;
            }
            if (type && !(_.contains(this.LMSInteractionTypes, type))) {
                throw "Invalid LMSInteractionType: " + type;
            }
            if (result && !( _.contains(this.LMSResultTypes,result)) && !result.match(this.LMSResultTypeNumber)) {
                throw "Invalid LMSResultType: " + result;
            }
            id = this.trimString(id, 255);
            id = this.replaceSpaces(id, "_");
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue((this.LMSKeys.interactionId).replace("#", index), id);
                doLMSSetValue((this.LMSKeys.interactionType).replace("#", index), type);
                doLMSSetValue((this.LMSKeys.interactionCorrectPattern).replace("#", index), correctResponse);
                doLMSSetValue((this.LMSKeys.interactionActualPattern).replace("#", index), studentResponse);
                doLMSSetValue((this.LMSKeys.interactionResult).replace("#", index), result);
                doLMSCommit();
            } else {
                this.lessonData[(this.LMSKeys.interactionId).replace("#", index)] = id;
                this.lessonData[(this.LMSKeys.interactionType).replace("#", index)] = type;
                this.lessonData[(this.LMSKeys.interactionCorrectPattern).replace("#", index)] = correctResponse;
                this.lessonData[(this.LMSKeys.interactionActualPattern).replace("#", index)] = studentResponse;
                this.lessonData[(this.LMSKeys.interactionResult).replace("#", index)] = result;
            }
        },
        setSuspendData: function (data) {
            if (this.scormAvailable) {
                log.debug("Setting suspend data");
                log.debug(data);
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.suspendData, data);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.suspendData] = data;
            }
        },
        getSuspendData: function () {
            var data = "";
            if (this.scormAvailable) {
                data = doLMSGetValue(this.LMSKeys.suspendData);
            } else {
                data = this.lessonData[this.LMSKeys.suspendData];
            }
            return data;
        },
        markComplete: function () {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.lessonStatus, this.constants.complete);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.lessonStatus] = this.constants.complete;
            }
        },
        setRawScore: function (score) {
            if (this.scormAvailable) {
                var formattedTime = this.computeSessionTime();
                doLMSSetValue(this.LMSKeys.sessionTime, formattedTime);
                doLMSSetValue(this.LMSKeys.rawScore, score);
                doLMSCommit();
            } else {
                this.lessonData[this.LMSKeys.rawScore] = score;
            }
        },
        getRawScore: function () {
            var score = 0;
            if (this.scormAvailable) {
                score = doLMSGetValue(this.LMSKeys.rawScore);
            } else {
                score = this.lessonData[this.LMSKeys.rawScore];
            }
            return score;
        },
        computeSessionTime: function () {
            var timeNow = new Date();
            var timeDifference = timeNow.getTime() - this.sessionStartTime.getTime();
            var dateDifference = new Date(timeDifference);
            //console.log("session time set to: " + formattedTime)
            return this.formatDateForSCORM(dateDifference);
        },
        formatDateForSCORM: function (date) {
            var totalTime = "";
            var hr = date.getUTCHours();
            var min = date.getUTCMinutes();
            var sec = date.getUTCSeconds();

            if (hr < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + hr + ":";
            if (min < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + min + ":";
            if (sec < 10) {
                totalTime = totalTime + "0";
            }
            totalTime = totalTime + sec;

            return totalTime;
        },
        trimString: function (str, toLength) {
            if (str.length > toLength) {
                str = str.substr(0, toLength);
            }
            return str;
        },
        replaceSpaces: function (str, replacement) {
            return str.replace(/\s/g, replacement);
        },
        getLessonData: function () {
            return this.lessonData;
        }
    });

    module.exports = Scorm;
}());
},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\boot.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/21/15
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The boot state configures the game based on the device loading it. The basic game data is loaded so
 * that the preload state has all prerequisites. The settings
 */
(function () {
	"use strict";
	var Base = require("basejs");

	var BootState = Base.extend({
		constructor: function (settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.loading_image_url ||
				!settings.play_json_key ||
				!settings.play_json_url ||
				!settings.preload_state_name
			) {
				throw "Boot State is missing a required configuration field.";
			}

			this.settings = settings;
			this.ready = false;
		},
		/**
		 * called first before preload.
		 */
		init: function () {
			this.ready = false;
			this.game.input.maxPointers = 1;
			// Don't pause the game when the mouse leaves.
			this.game.stage.disableVisibilityChange = true;
			//this.game.scale.pageAlignHorizontally = true;
			this.game.scale.refresh();

			if (typeof PhaserInput !== "undefined") {
				this.game.plugins.add(PhaserInput.Plugin);
			}
		},
		/**
		 * In order to show the loading image while all of the resources load, it gets loaded during the
		 * boot state, so that it is available during preload of the preload state.
		 */
		preload: function () {
			this.game.load.image(
				this.settings.loading_image_key,
				this.settings.loading_image_url
			);
			this.game.load.text(
				this.settings.play_json_key,
				this.settings.play_json_url
			);
			this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
		},
		loadComplete: function () {
			var playJsonData = this.game.cache.getText(this.settings.play_json_key);
			var config = JSON.parse(playJsonData);
			/*if(config.autoScale){
                window.addEventListener("resize", this.onResize.bind(this));
                this.onResize();
            }*/
			this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
			this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;

			this.game.state.start(this.settings.preload_state_name);
		},
		/**
		 * Scales the gameContainer so that it does not exceed the inner browser width or height
		 */
		/*onResize: function(){
            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;
            var windowRatio = windowWidth / windowHeight;
            var gameContainer = document.querySelector("#gameContainer");
            var boxRatio = this.game.world.width / this.game.world.height;
            if(windowRatio < boxRatio){
                gameContainer.style.width = windowWidth + "px";
                gameContainer.style.height = (windowWidth / boxRatio) + "px";
            }else{
                gameContainer.style.width = (windowHeight * boxRatio) + "px";
                gameContainer.style.height = windowHeight + "px";
            }
        }*/
	});

	module.exports = BootState;
})();

},{"basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\main.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/22/15
 * @creation 07/01/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This is the main state. It will be restarted every time an Act changes. The responsibility of this state is to
 * allow the current Act to load media before starting. Everything is done via the Play, no act should be
 * referenced or instantiated here.
 */
(function () {
    'use strict';
    var log = require('loglevel'),
        LoadingScreen = require('../loading-screen'),
        Base = require('basejs');

    var MainState = Base.extend({
        constructor: function (settings) {
            if (!settings
                || !settings.loading_image_key ) {
                throw "Main state is missing a required configuration field.";
            }

            this.settings = settings;
        },
        /**
         * Called before preload, during each restart.
         * @param isRestart true if being called as part of a restart.
         */
        init: function (isRestart) {
            log.info("Main state created");
            if( !this.game.loadingScreen ) {
                this.game.loadingScreen = new LoadingScreen(this.game, this.settings);
            }
            this.ready = false;
            this.isRestart = isRestart; // we are restarting this state due to act change.
        },
        /**
         * Called after init. This is where media can be downloaded.
         */
        preload: function () {
            this.game.loadingScreen.show();
            this.game.play.preloadAct();
            this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
        },
        loadComplete: function() {
            this.game.loadingScreen.showComplete();
        },
        /**
         * Called when preload is complete, all media is downloaded. (But we'll check ourselves anyways)
         */
        create: function () {
        },
        /**
         * Render is called each game tick to allow the application to render anything 'on top' such as a HUD.
         * Used here for debugging.
         */
        render: function () {
            this.game.play.renderDebug();
        },
        /**
         * Called each game tick, used to manually check the media state and then start. Otherwise it passes the
         * update along to the Play.
         */
        update: function () {
            if (this.ready === true) {
                this.game.play.tickUpdate(this.game.time.now);
            } else if (this.game.play.isPreloadActComplete() === true) {
                this.ready = true;
                this.game.play.showNextAct(this.isRestart);
                this.game.play.sendCrossActVariables();
                this.game.loadingScreen.destroy();
            }
        }
    });

    module.exports = MainState;
}());
},{"../loading-screen":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\states\\preload.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.1.0 @ 09/21/15
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * The preload state shows the loading screen while it processes all of the themes and scene data for each
 * act entry in the play.
 */
(function () {
	"use strict";
	var log = require("loglevel"),
		Base = require("basejs"),
		Play = require("../play/play"),
		LoadingScreen = require("../loading-screen"),
		_ = require("lodash");

	var PreloadState = Base.extend({
		constructor: function (settings) {
			if (
				!settings ||
				!settings.loading_image_key ||
				!settings.play_json_key ||
				!settings.main_state_name
			) {
				throw "Preload state is missing a required configuration field.";
			}

			this.settings = settings;
		},
		/**
		 * This is called before preload. Just record that things aren't complete yet.
		 */
		init: function () {
			this.loadingScreen = new LoadingScreen(this.game, this.settings);
			this.ready = false;

			var playJsonData = this.game.cache.getText(this.settings.play_json_key);
			if (!playJsonData) {
				throw "Error in Preload: Did not find play json data in cache.";
			}
			this.game.play = new Play(
				this.game,
				JSON.parse(playJsonData),
				this.settings
			);
		},
		/**
		 * Show the preload image, allow the Play to load data.
		 */
		preload: function () {
			if (this.game.play.isLogging() === true) {
				log.enableAll();
				log.warn("Logging Enabled");
			} else {
				log.disableAll();
			}
			this.loadingScreen.show();
			var preloadSet = this.game.play.getRequiredResourceList();
			_.each(
				preloadSet,
				function (preloadItem) {
					this.game.load.text(preloadItem.key, preloadItem.file);
				},
				this
			);
			this.game.load.audio("audioFix", [
				this.game.config.assetPath + "engine/silence-m4a.m4a",
				this.game.config.assetPath + "engine/silence-ogg.ogg",
			]);
			this.game.load.onLoadComplete.addOnce(this.loadComplete, this);
		},
		/**
		 * Called when preload is complete, all media is downloaded. (But we'll check ourselves anyways)
		 */
		create: function () {
			this.loadingScreen.showClickthrough();
			// this.loadingScreen.showComplete();
			//this.loadingScreen.destroy();
		},
		loadComplete: function () {
			this.game.scorm.initialize({
				scormEnabled: _environmentSettings.scormEnabled,
				//scormEnabled: this.game.play.isScormEnabled(),
			});
			this.game.scorm.initializeStatus();
			this.game.play.loadScormData();
			this.game.play.selectDefaultAct();
			var audioFix = this.game.add.audio("audioFix");
			this.game.input.onTap.add(function () {
				audioFix.play();
				this.state.start(this.settings.main_state_name);
			}, this);
			//this.state.start(this.settings.main_state_name); // The "Play" can also do this.
		},
	});

	module.exports = PreloadState;
})();

},{"../loading-screen":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\loading-screen.js","../play/play":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\play\\play.js","basejs":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\basejs\\Base.js","lodash":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\lodash\\index.js","loglevel":"C:\\CHW\\Code Repositories\\Scene Engine 2\\node_modules\\loglevel\\lib\\loglevel.js"}],"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js":[function(require,module,exports){
/**
 * @author George Frick
 * @version 1.0.0
 * @creation 06/04/2015
 * Copyright 2015 Children's Hospital
 * This software is the property of Children's Hospital.
 *
 * This file exists so that startup of an engine can be controlled. This file is simply a stub that works to
 * build the engine and then start it. This means that the engine can be loaded without it starting for
 * purposes of testing, debugging, and adding any code that comes up that happens before/after the engine is
 * done.
 */
(function () {
    module.exports = require('./engine/scene-engine');

    if (!String.prototype.startsWith) {
        (function() {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function() {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                } catch(error) {}
                return result;
            }());
            var toString = {}.toString;
            var startsWith = function(search) {
                if (this === null) {
                    throw TypeError();
                }
                var string = String(this);
                if (search && toString.call(search) === '[object RegExp]') {
                    throw TypeError();
                }
                var stringLength = string.length;
                var searchString = String(search);
                var searchLength = searchString.length;
                var position = arguments.length > 1 ? arguments[1] : undefined;
                // `ToInteger`
                var pos = position ? Number(position) : 0;
                if (pos !== pos) { // better `isNaN`
                    pos = 0;
                }
                var start = Math.min(Math.max(pos, 0), stringLength);
                // Avoid the `indexOf` call if no match is possible
                if (searchLength + start > stringLength) {
                    return false;
                }
                var index = -1;
                while (++index < searchLength) {
                    if (string.charCodeAt(start + index) !== searchString.charCodeAt(index)) {
                        return false;
                    }
                }
                return true;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'startsWith', {
                    'value': startsWith,
                    'configurable': true,
                    'writable': true
                });
            } else {
                String.prototype.startsWith = startsWith;
            }
        }());
    }
}());

},{"./engine/scene-engine":"C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\engine\\scene-engine.js"}]},{},["C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js"])("C:\\CHW\\Code Repositories\\Scene Engine 2\\src\\main\\main.js")
});

//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZWpzL0Jhc2UuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvYXVkaW8tY2hhbm5lbC5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvYXVkaW8tc2VydmljZS5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvcGxheS1hY3QtbWFuYWdlci5qcyIsInNyYy9tYWluL2VuZ2luZS9hY3QvcGxheS1hY3QuanMiLCJzcmMvbWFpbi9lbmdpbmUvYWN0L3ZhbGlkYXRvci5qcyIsInNyYy9tYWluL2VuZ2luZS9sb2FkaW5nLXNjcmVlbi5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVsLmpzIiwic3JjL21haW4vZW5naW5lL3BsYXkvbW9kZWxzL2FjdG5vdy5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVscy9iYXNpYy5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L21vZGVscy9tb2RlbC1yZWdpc3RyeS5qcyIsInNyYy9tYWluL2VuZ2luZS9wbGF5L3BsYXkuanMiLCJzcmMvbWFpbi9lbmdpbmUvcGxheS9zY29ybS1zZXJ2aWNlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lLWVuZ2luZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2FkZC1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2NoYW5nZS1vYmplY3RpdmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0aW9ucy9jaGFuZ2Utc2NlbmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0aW9ucy9jaGVjay1vdXRjb21lcy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL2dhbWUtY2hvaWNlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdGlvbnMvbWFyay1jb21wbGV0ZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL21oL21oLWNoYW5nZS1zY2VuZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL3JlbW92ZS1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3Rpb25zL3ZhcmlhYmxlLWluY3JlbWVudC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWFubm91bmNlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWNob2ljZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLWNob29zZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLXBsYXl0aHJvdWdoLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rub3cvYWN0b3Itc3Bpbm5lci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0bm93L2FjdG9yLXppbmstY29tcHV0ZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG5vdy9hY3Rvci16aW5rLXBvc3Rlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYW5pbWF0aW9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1hdWRpby5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYmxvY2tlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYnV0dG9uLWNoYXJhY3Rlci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItYnV0dG9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1jaGFyYWN0ZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLWNsaWNrLWFuaW1hdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZGVjb3JhdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJhZy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJhdy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZHJvcC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItZmFkZW91dC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItaW5wdXQtZmllbGQuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLWluc3RydWN0aW9uLWJ1YmJsZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItbGluZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3Itbm8taW5wdXQtY2hhcmFjdGVyLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1xdWVzdGlvbi5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItcmVjdGFuZ2xlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci1zcGVlY2gtYnViYmxlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci10ZXh0LWJ1YmJsZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItdGV4dC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvYWN0b3ItdGltZWxpbmUuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLXRvZ2dsZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLXVybC1idXR0b24taW52aXNpYmxlLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci11cmwtYnV0dG9uLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9hY3Rvci13aXN0aWEuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2FjdG9yLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvYWN0b3ItYm9vay5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL2FjdG9yLWNoYXQuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1maWxlLWRyYWcuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1tYXAuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1waG9uZS1idXR0b24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9hY3Rvci1waG9uZS5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL2FjdG9yLXBvcHVwLmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvYWN0b3Itd2luZG93LmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy9pdWMvbWFwL2FjdG9yLWJpcmQtbGFyZ2UuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9tYXAvYWN0b3ItYmlyZC1zbWFsbC5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL21hcC9hY3Rvci1jYXItYmFzaWMuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvYWN0b3JzL2l1Yy9tYXAvYWN0b3ItY2FyLXllbGxvdy5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9hY3RvcnMvaXVjL3JvdW5kZWQtY2hhdC1yZWN0LmpzIiwic3JjL21haW4vZW5naW5lL3NjZW5lL2FjdG9ycy90d2Vlbi1oZWxwZXIuanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvcGxheS1hY3Rpb24uanMiLCJzcmMvbWFpbi9lbmdpbmUvc2NlbmUvcGxheS1hY3Rvci5qcyIsInNyYy9tYWluL2VuZ2luZS9zY2VuZS9wbGF5LXNjZW5lLmpzIiwic3JjL21haW4vZW5naW5lL3Njb3JtLmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9ib290LmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9tYWluLmpzIiwic3JjL21haW4vZW5naW5lL3N0YXRlcy9wcmVsb2FkLmpzIiwic3JjL21haW4vbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzEvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICBCYXNlZCBvbiBCYXNlLmpzIDEuMWEgKGMpIDIwMDYtMjAxMCwgRGVhbiBFZHdhcmRzXG4gIFVwZGF0ZWQgdG8gcGFzcyBKU0hpbnQgYW5kIGNvbnZlcnRlZCBpbnRvIGEgbW9kdWxlIGJ5IEtlbm5ldGggUG93ZXJzXG4gIExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qL1xuLypnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUqL1xuLypqc2hpbnQgZXFlcWVxOnRydWUqL1xuKGZ1bmN0aW9uIChuYW1lLCBnbG9iYWwsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnKSB7XG4gICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFtuYW1lXSA9IGRlZmluaXRpb24oKTtcbiAgfVxufSkoJ0Jhc2UnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIC8vIEJhc2UgT2JqZWN0XG4gIHZhciBCYXNlID0gZnVuY3Rpb24gKCkge307XG5cbiAgLy8gSW1wbGVtZW50YXRpb25cbiAgQmFzZS5leHRlbmQgPSBmdW5jdGlvbiAoX2luc3RhbmNlLCBfc3RhdGljKSB7IC8vIHN1YmNsYXNzXG4gICAgdmFyIGV4dGVuZCA9IEJhc2UucHJvdG90eXBlLmV4dGVuZDtcbiAgICAvLyBidWlsZCB0aGUgcHJvdG90eXBlXG4gICAgQmFzZS5fcHJvdG90eXBpbmcgPSB0cnVlO1xuICAgIHZhciBwcm90byA9IG5ldyB0aGlzKCk7XG4gICAgZXh0ZW5kLmNhbGwocHJvdG8sIF9pbnN0YW5jZSk7XG4gICAgcHJvdG8uYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBhbnkgb3RoZXIgbWV0aG9kIHRvIGludm9rZSB0aGF0IG1ldGhvZCdzIGFuY2VzdG9yXG4gICAgfTtcbiAgICBkZWxldGUgQmFzZS5fcHJvdG90eXBpbmc7XG4gICAgLy8gY3JlYXRlIHRoZSB3cmFwcGVyIGZvciB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAvL3ZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yLnZhbHVlT2YoKTsgLy8tZGVhblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuICAgIHZhciBrbGFzcyA9IHByb3RvLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUJhc2UuX3Byb3RvdHlwaW5nKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGluZyB8fCB0aGlzLmNvbnN0cnVjdG9yID09PSBrbGFzcykgeyAvLyBpbnN0YW50aWF0aW9uXG4gICAgICAgICAgICB0aGlzLl9jb25zdHJ1Y3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb25zdHJ1Y3Rpbmc7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gIT09IG51bGwpIHsgLy8gY2FzdGluZ1xuICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHNbMF0uZXh0ZW5kIHx8IGV4dGVuZCkuY2FsbChhcmd1bWVudHNbMF0sIHByb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgLy8gYnVpbGQgdGhlIGNsYXNzIGludGVyZmFjZVxuICAgIGtsYXNzLmFuY2VzdG9yID0gdGhpcztcbiAgICBrbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICBrbGFzcy5mb3JFYWNoID0gdGhpcy5mb3JFYWNoO1xuICAgIGtsYXNzLmltcGxlbWVudCA9IHRoaXMuaW1wbGVtZW50O1xuICAgIGtsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xuICAgIGtsYXNzLnRvU3RyaW5nID0gdGhpcy50b1N0cmluZztcbiAgICBrbGFzcy52YWx1ZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiAodHlwZSA9PT0gJ29iamVjdCcpID8ga2xhc3MgOiBjb25zdHJ1Y3Rvci52YWx1ZU9mKCk7XG4gICAgfTtcbiAgICBleHRlbmQuY2FsbChrbGFzcywgX3N0YXRpYyk7XG4gICAgLy8gY2xhc3MgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAodHlwZW9mIGtsYXNzLmluaXQgPT09ICdmdW5jdGlvbicpIGtsYXNzLmluaXQoKTtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgQmFzZS5wcm90b3R5cGUgPSB7XG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAoc291cmNlLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IC8vIGV4dGVuZGluZyB3aXRoIGEgbmFtZS92YWx1ZSBwYWlyXG4gICAgICAgIHZhciBhbmNlc3RvciA9IHRoaXNbc291cmNlXTtcbiAgICAgICAgaWYgKGFuY2VzdG9yICYmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIC8vIG92ZXJyaWRpbmcgYSBtZXRob2Q/XG4gICAgICAgIC8vIHRoZSB2YWx1ZU9mKCkgY29tcGFyaXNvbiBpcyB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICghYW5jZXN0b3IudmFsdWVPZiB8fCBhbmNlc3Rvci52YWx1ZU9mKCkgIT09IHZhbHVlLnZhbHVlT2YoKSkgJiYgL1xcYmJhc2VcXGIvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuICAgICAgICAgIHZhciBtZXRob2QgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgICB2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuYmFzZSB8fCBCYXNlLnByb3RvdHlwZS5iYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHByZXZpb3VzO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gcG9pbnQgdG8gdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gICAgICAgICAgdmFsdWUudmFsdWVPZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgPT09ICdvYmplY3QnKSA/IHZhbHVlIDogbWV0aG9kO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFsdWUudG9TdHJpbmcgPSBCYXNlLnRvU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbc291cmNlXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UpIHsgLy8gZXh0ZW5kaW5nIHdpdGggYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgdmFyIGV4dGVuZCA9IEJhc2UucHJvdG90eXBlLmV4dGVuZDtcbiAgICAgICAgLy8gaWYgdGhpcyBvYmplY3QgaGFzIGEgY3VzdG9taXplZCBleHRlbmQgbWV0aG9kIHRoZW4gdXNlIGl0XG4gICAgICAgIGlmICghQmFzZS5fcHJvdG90eXBpbmcgJiYgdHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBleHRlbmQgPSB0aGlzLmV4dGVuZCB8fCBleHRlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3RvID0ge1xuICAgICAgICAgIHRvU291cmNlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGRvIHRoZSBcInRvU3RyaW5nXCIgYW5kIG90aGVyIG1ldGhvZHMgbWFudWFsbHlcbiAgICAgICAgdmFyIGhpZGRlbiA9IFsnY29uc3RydWN0b3InLCAndG9TdHJpbmcnLCAndmFsdWVPZiddO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgcHJvdG90eXBpbmcgdGhlbiBpbmNsdWRlIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBmb3IgKHZhciBpID0gQmFzZS5fcHJvdG90eXBpbmcgPyAwIDogMTsgaSA8IGhpZGRlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBoID0gaGlkZGVuW2ldO1xuICAgICAgICAgIGlmIChzb3VyY2VbaF0gIT09IHByb3RvW2hdKVxuICAgICAgICAgICAgZXh0ZW5kLmNhbGwodGhpcywgaCwgc291cmNlW2hdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IGVhY2ggb2YgdGhlIHNvdXJjZSBvYmplY3QncyBwcm9wZXJ0aWVzIHRvIHRoaXMgb2JqZWN0XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoIXByb3RvW2tleV0pIGV4dGVuZC5jYWxsKHRoaXMsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZVxuICBCYXNlID0gQmFzZS5leHRlbmQoe1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmV4dGVuZChhcmd1bWVudHNbMF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGFuY2VzdG9yOiBPYmplY3QsXG4gICAgdmVyc2lvbjogJzEuMScsXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gKG9iamVjdCwgYmxvY2ssIGNvbnRleHQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJsb2NrLmNhbGwoY29udGV4dCwgb2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW1wbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiwgY2FsbCBpdFxuICAgICAgICAgIGFyZ3VtZW50c1tpXSh0aGlzLnByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIHRoZSBpbnRlcmZhY2UgdXNpbmcgdGhlIGV4dGVuZCBtZXRob2RcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS5leHRlbmQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZXR1cm4gQmFzZSBpbXBsZW1lbnRhdGlvblxuICByZXR1cm4gQmFzZTtcbn0pO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMS40XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0wNC0yOFQxNjowMVpcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1xuXG52YXIgYXJyID0gW107XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cblx0dmVyc2lvbiA9IFwiMi4xLjRcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuXHQvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICsgMSkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZihcInVzZSBzdHJpY3RcIikgPT09IDEgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuXHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0pO1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FycmF5bGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4wLXByZVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTEyLTE2XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG5cdFx0Ly8gUVNBIHZhcnNcblx0XHRpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcblxuXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZTtcblxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggIXNlZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIHdoZW4gcG9zc2libGUgKGUuZy4sIG5vdCB1bmRlciBEb2N1bWVudEZyYWdtZW50KVxuXHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuXHRcdFx0XHRcdGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIi5DTEFTU1wiKVxuXHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgIT09IDEgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFNldCBvdXIgZG9jdW1lbnRcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0Ly8gU3VwcG9ydDogSUU+OFxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXG5cdC8vIElFIHdpbGwgdGhyb3cgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcblx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XG5cdFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTdXBwb3J0IHRlc3RzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcZl0nIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjIrLCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuNytcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGRpciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmIHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlKFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG5cdFx0KTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoIChjdXIgPSBjdXJbZGlyXSkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59KTtcbnZhciBybm90d2hpdGUgPSAoL1xcUysvZyk7XG5cblxuXG4vLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXG52YXIgb3B0aW9uc0NhY2hlID0ge307XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHQoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblx0XHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcblx0XHRmaXJpbmdTdGFydCxcblx0XHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcblx0XHRmaXJpbmdMZW5ndGgsXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCxcblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0bWVtb3J5ID0gb3B0aW9ucy5tZW1vcnkgJiYgZGF0YTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIHN0YWNrICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdC8vIERvIHdlIG5lZWQgdG8gYWRkIHRoZSBjYWxsYmFja3MgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRmaXJlKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6ICEhKCBsaXN0ICYmIGxpc3QubGVuZ3RoICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdGZpcmluZ0xlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGxvY2tlZD9cblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgJiYgKCAhZmlyZWQgfHwgc3RhY2sgKSApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBhcmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcywgZm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0pLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsxXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gV2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHRzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cbi8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxualF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5qUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NCxcblx0Ly8gT2xkIFdlYktpdCBkb2VzIG5vdCBoYXZlIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucy9mcmVlemUgbWV0aG9kLFxuXHQvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY2FjaGUgPSB7fSwgMCwge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcbkRhdGEuYWNjZXB0cyA9IGpRdWVyeS5hY2NlcHREYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblx0a2V5OiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIHRoZSBrZXkgZm9yIGEgZnJvemVuIG9iamVjdC5cblx0XHRpZiAoICFEYXRhLmFjY2VwdHMoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IHt9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlIGtleVxuXHRcdFx0dW5sb2NrID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdW5sb2NrICkge1xuXHRcdFx0dW5sb2NrID0gRGF0YS51aWQrKztcblxuXHRcdFx0Ly8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB7IHZhbHVlOiB1bmxvY2sgfTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB1bmxvY2s7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRpZiAoICF0aGlzLmNhY2hlWyB1bmxvY2sgXSApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVubG9jaztcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Ly8gVGhlcmUgbWF5IGJlIGFuIHVubG9jayBhc3NpZ25lZCB0byB0aGlzIG5vZGUsXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcIm93bmVyXCIsIGNyZWF0ZSBvbmUgaW5saW5lXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXG5cdFx0Ly8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxuXHRcdC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XG5cdFx0fVxuXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxuXHRcdFx0dGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF0gfHwge31cblx0XHQpO1xuXHR9LFxuXHRkaXNjYXJkOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0aWYgKCBvd25lclsgdGhpcy5leHBhbmRvIF0gKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59O1xudmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFfcHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YV91c2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKFwiLVwiKSAhPT0gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YV91c2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YV9wcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSk7XG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxudmFyIHJjaGVja2FibGVUeXBlID0gKC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pKTtcblxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59KSgpO1xudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKFwiLlwiKSA+PSAwICkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+PSAwIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlLCBmYWxzZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94LCBDaHJvbWUsIFNhZmFyaVxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbmlmICggIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG5cdGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcblxuXHQvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuXHR3cmFwTWFwID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0XHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG5cdH07XG5cbi8vIFN1cHBvcnQ6IElFOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFfcHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFfcHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YV91c2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0YnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7XG5cdFx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0XHRub2RlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcblx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1sgaSBdKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XG5cblx0XHRcdFx0aWYgKCBrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkYXRhX3ByaXYuY2FjaGVbIGtleSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YV9wcml2LmNhY2hlWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNldCA9IHRoaXMsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpc1sgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge307XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBzdHlsZSxcblx0XHRlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHQvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxuXHRcdGRpc3BsYXkgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgJiYgKCBzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSggZWxlbVsgMCBdICkgKSA/XG5cblx0XHRcdC8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRpbWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHRzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0aWYgKCBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXHR9XG5cblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDwgNlxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBpT1MgPCA2IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG5cdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtcIiArXG5cdFx0XCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcIiArXG5cdFx0XHRcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IG5vZGUuanMganNkb21cblx0Ly8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XG5cdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXG5cdFx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHRcdC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG5cdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0XHR9LFxuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHRcdH0sXG5cdFx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF07XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcblx0XHRvcmlnTmFtZSA9IG5hbWUsXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9yaWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggcmV0WzFdICsgMSApICogcmV0WzJdICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIsIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdGlmICggdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiZcblx0XHRcdFx0KCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fVxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRyZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLyxcblx0YW5pbWF0aW9uUHJlZmlsdGVycyA9IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXHR0d2VlbmVycyA9IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0cGFydHMgPSByZnhudW0uZXhlYyggdmFsdWUgKSxcblx0XHRcdFx0dW5pdCA9IHBhcnRzICYmIHBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHRcdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRcdFx0c3RhcnQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK3RhcmdldCApICYmXG5cdFx0XHRcdFx0cmZ4bnVtLmV4ZWMoIGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AgKSApLFxuXHRcdFx0XHRzY2FsZSA9IDEsXG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAyMDtcblxuXHRcdFx0aWYgKCBzdGFydCAmJiBzdGFydFsgMyBdICE9PSB1bml0ICkge1xuXHRcdFx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0XHRcdHVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdFx0XHRwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuXG5cdFx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRcdHN0YXJ0ID0gK3RhcmdldCB8fCAxO1xuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpLFxuXHRcdFx0XHQvLyBicmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAodHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XG5cdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcblx0XHRjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG5cdFx0XHRkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93IGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkpID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0pO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgeyBzcGVjaWFsRWFzaW5nOiB7fSB9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSlcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIgXCIpO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdID0gdHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHQuZHVyYXRpb24gOlxuXHRcdG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3ByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcblx0Ly8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSkoKTtcblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0KCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHRlbGVtWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5oYXNBdHRyaWJ1dGUoIFwidGFiaW5kZXhcIiApIHx8IHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0ZWxlbS50YWJJbmRleCA6XG5cdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTYtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggKG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBvcHRpb24udmFsdWUsIHZhbHVlcyApID49IDApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59KTtcblxuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoL1xcPy8pO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgdG1wO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLmhyZWYsXG5cblx0Ly8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5cdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWzBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHNbIFwidGhyb3dzXCIgXSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblx0XHRcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT09IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT09IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9O1xufSk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHR1cmw6IHVybCxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMDtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9KTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn07XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdWNjZXNzU3RhdHVzID0ge1xuXHRcdC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXG4vLyBTZWUgaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NiBmb3IgbW9yZSBpbmZvXG5pZiAoIHdpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSgpO1xuXHRcdH1cblx0fSk7XG59XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCksXG5cdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogeGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0fSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0pLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSkubGVuZ3RoO1xufTtcblxuXG5cblxudmFyIGRvY0VsZW0gPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8NyssIENocm9tZTwzNytcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0pO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0pO1xufVxuXG5cblxuXG52YXJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBsb2Rhc2ggMy4xMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1kIC1vIC4vaW5kZXguanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICczLjEwLjEnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHdyYXBwZXIgbWV0YWRhdGEuICovXG4gIHZhciBCSU5EX0ZMQUcgPSAxLFxuICAgICAgQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBDVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIENVUlJZX0ZMQUcgPSA4LFxuICAgICAgQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBQQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIEFSWV9GTEFHID0gMTI4LFxuICAgICAgUkVBUkdfRkxBRyA9IDI1NjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHdoZW4gYSBmdW5jdGlvbiBiZWNvbWVzIGhvdC4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDE1MCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMjtcblxuICAvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xuICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzl8Izk2KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxuXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxuXFxcXF18XFxcXC4pKj8pXFwyKVxcXS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpXG4gICAqIGFuZCB0aG9zZSBvdXRsaW5lZCBieSBbYEVzY2FwZVJlZ0V4cFBhdHRlcm5gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lc2NhcGVyZWdleHBwYXR0ZXJuKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXJzID0gL15bOiEsXXxbXFxcXF4kLiorPygpW1xcXXt9fFxcL118KF5bMC05YS1mQS1GbnJ0dXZ4XSl8KFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0pL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXJzID0gUmVnRXhwKHJlUmVnRXhwQ2hhcnMuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLiAqL1xuICB2YXIgcmVDb21ib01hcmsgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyM10vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSGFzSGV4UHJlZml4ID0gL14wW3hYXS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbjEgPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZGVcXHhkZi1cXHhmNlxceGY4LVxceGZmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyB0byBjcmVhdGUgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVdvcmRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cHBlciA9ICdbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXScsXG4gICAgICAgIGxvd2VyID0gJ1thLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZdKyc7XG5cbiAgICByZXR1cm4gUmVnRXhwKHVwcGVyICsgJysoPz0nICsgdXBwZXIgKyBsb3dlciArICcpfCcgKyB1cHBlciArICc/JyArIGxvd2VyICsgJ3wnICsgdXBwZXIgKyAnK3xbMC05XSsnLCAnZycpO1xuICB9KCkpO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQXJyYXlCdWZmZXInLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXRoJywgJ051bWJlcicsXG4gICAgJ09iamVjdCcsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsXG4gICAgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1ttYXBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjQyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVDJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnYCc6ICcmIzk2OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCIsXG4gICAgJyYjOTY7JzogJ2AnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCByZWdleGVzLiAqL1xuICB2YXIgcmVnZXhwRXNjYXBlcyA9IHtcbiAgICAnMCc6ICd4MzAnLCAnMSc6ICd4MzEnLCAnMic6ICd4MzInLCAnMyc6ICd4MzMnLCAnNCc6ICd4MzQnLFxuICAgICc1JzogJ3gzNScsICc2JzogJ3gzNicsICc3JzogJ3gzNycsICc4JzogJ3gzOCcsICc5JzogJ3gzOScsXG4gICAgJ0EnOiAneDQxJywgJ0InOiAneDQyJywgJ0MnOiAneDQzJywgJ0QnOiAneDQ0JywgJ0UnOiAneDQ1JywgJ0YnOiAneDQ2JyxcbiAgICAnYSc6ICd4NjEnLCAnYic6ICd4NjInLCAnYyc6ICd4NjMnLCAnZCc6ICd4NjQnLCAnZSc6ICd4NjUnLCAnZic6ICd4NjYnLFxuICAgICduJzogJ3g2ZScsICdyJzogJ3g3MicsICd0JzogJ3g3NCcsICd1JzogJ3g3NScsICd2JzogJ3g3NicsICd4JzogJ3g3OCdcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSBvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZiAmJiBzZWxmLk9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgd2luZG93YC4gKi9cbiAgdmFyIGZyZWVXaW5kb3cgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgJiYgd2luZG93Lk9iamVjdCAmJiB3aW5kb3c7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBgdGhpc2AgdmFsdWUgaXMgdXNlZCBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gICAqIHJlc3RyaWN0ZWQgYHdpbmRvd2Agb2JqZWN0LCBvdGhlcndpc2UgdGhlIGB3aW5kb3dgIG9iamVjdCBpcyB1c2VkLlxuICAgKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXMgJiYgdGhpcy53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY29tcGFyZUFzY2VuZGluZ2Agd2hpY2ggY29tcGFyZXMgdmFsdWVzIGFuZFxuICAgKiBzb3J0cyB0aGVtIGluIGFzY2VuZGluZyBvcmRlciB3aXRob3V0IGd1YXJhbnRlZWluZyBhIHN0YWJsZSBzb3J0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgIHZhciB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1VuZGVmID0gdmFsdWUgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZTtcblxuICAgICAgdmFyIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgIG90aElzVW5kZWYgPSBvdGhlciA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyO1xuXG4gICAgICBpZiAoKHZhbHVlID4gb3RoZXIgJiYgIW90aElzTnVsbCkgfHwgIXZhbElzUmVmbGV4aXZlIHx8XG4gICAgICAgICAgKHZhbElzTnVsbCAmJiAhb3RoSXNVbmRlZiAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAodmFsSXNVbmRlZiAmJiBvdGhJc1JlZmxleGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoKHZhbHVlIDwgb3RoZXIgJiYgIXZhbElzTnVsbCkgfHwgIW90aElzUmVmbGV4aXZlIHx8XG4gICAgICAgICAgKG90aElzTnVsbCAmJiAhdmFsSXNVbmRlZiAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAob3RoSXNVbmRlZiAmJiB2YWxJc1JlZmxleGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRnVuY3Rpb25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZW52aXJvbm1lbnRzXG4gICAqIHdpdGggaW5jb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBBdm9pZCBhIENoYWtyYSBKSVQgYnVnIGluIGNvbXBhdGliaWxpdHkgbW9kZXMgb2YgSUUgMTEuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9pc3N1ZXMvMTYyMSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gICAqIGZvciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogKHZhbHVlICsgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICogb2YgYHN0cmluZ2AgdGhhdCBpcyBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyBUaGUgY2hhcmFjdGVycyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGNoYXJzLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpbmRleCkpID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlXG4gICAqIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gYmFzZUNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LmNyaXRlcmlhLCBvdGhlci5jcml0ZXJpYSkgfHwgKG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnNvcnRCeU9yZGVyYCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgKlxuICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc3MgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICogYSB2YWx1ZSBpcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGlmIGl0cyBjb3JyZXNwb25kaW5nIG9yZGVyIGlzIFwiYXNjXCIsIGFuZFxuICAgKiBkZXNjZW5kaW5nIGlmIFwiZGVzY1wiLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgIHJldHVybiByZXN1bHQgKiAoKG9yZGVyID09PSAnYXNjJyB8fCBvcmRlciA9PT0gdHJ1ZSkgPyAxIDogLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVidXJyTGV0dGVyKGxldHRlcikge1xuICAgIHJldHVybiBkZWJ1cnJlZExldHRlcnNbbGV0dGVyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gaHRtbEVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZVJlZ0V4cGAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCByZWdleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWFkaW5nQ2hhciBUaGUgY2FwdHVyZSBncm91cCBmb3IgYSBsZWFkaW5nIGNoYXJhY3Rlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHdoaXRlc3BhY2VDaGFyIFRoZSBjYXB0dXJlIGdyb3VwIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXIoY2hyLCBsZWFkaW5nQ2hhciwgd2hpdGVzcGFjZUNoYXIpIHtcbiAgICBpZiAobGVhZGluZ0NoYXIpIHtcbiAgICAgIGNociA9IHJlZ2V4cEVzY2FwZXNbY2hyXTtcbiAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VDaGFyKSB7XG4gICAgICBjaHIgPSBzdHJpbmdFc2NhcGVzW2Nocl07XG4gICAgfVxuICAgIHJldHVybiAnXFxcXCcgKyBjaHI7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYE5hTmAgaXMgZm91bmQgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCBgTmFOYCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAwIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChvdGhlciAhPT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRyaW1tZWRMZWZ0SW5kZXhgIGFuZCBgdHJpbW1lZFJpZ2h0SW5kZXhgIHRvIGRldGVybWluZSBpZiBhXG4gICAqIGNoYXJhY3RlciBjb2RlIGlzIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyQ29kZSBUaGUgY2hhcmFjdGVyIGNvZGUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBjaGFyQ29kZWAgaXMgd2hpdGVzcGFjZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNTcGFjZShjaGFyQ29kZSkge1xuICAgIHJldHVybiAoKGNoYXJDb2RlIDw9IDE2MCAmJiAoY2hhckNvZGUgPj0gOSAmJiBjaGFyQ29kZSA8PSAxMykgfHwgY2hhckNvZGUgPT0gMzIgfHwgY2hhckNvZGUgPT0gMTYwKSB8fCBjaGFyQ29kZSA9PSA1NzYwIHx8IGNoYXJDb2RlID09IDYxNTggfHxcbiAgICAgIChjaGFyQ29kZSA+PSA4MTkyICYmIChjaGFyQ29kZSA8PSA4MjAyIHx8IGNoYXJDb2RlID09IDgyMzIgfHwgY2hhckNvZGUgPT0gODIzMyB8fCBjaGFyQ29kZSA9PSA4MjM5IHx8IGNoYXJDb2RlID09IDgyODcgfHwgY2hhckNvZGUgPT0gMTIyODggfHwgY2hhckNvZGUgPT0gNjUyNzkpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgb3B0aW1pemVkIGZvciBzb3J0ZWQgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgc2VlbixcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgIGlmICghaW5kZXggfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltTGVmdGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1SaWdodGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgaXNTcGFjZShzdHJpbmcuY2hhckNvZGVBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sVW5lc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyB1c2luZyBgY29udGV4dGAgdG8gbW9jayBgRGF0ZSNnZXRUaW1lYCB1c2UgaW4gYF8ubm93YFxuICAgKiB2YXIgbW9jayA9IF8ucnVuSW5Db250ZXh0KHtcbiAgICogICAnRGF0ZSc6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHsgJ2dldFRpbWUnOiBnZXRUaW1lTW9jayB9O1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIG9yIGNyZWF0aW5nIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41IGZvciBtb3JlIGRldGFpbHMuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgc3RyaW5nUHJvdG8gPSBTdHJpbmcucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXlCdWZmZXIgPSBjb250ZXh0LkFycmF5QnVmZmVyLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgcGFyc2VGbG9hdCA9IGNvbnRleHQucGFyc2VGbG9hdCxcbiAgICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyksXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBnZXROYXRpdmUoRGF0ZSwgJ25vdycpLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgYC1JbmZpbml0eWAgYW5kIGBJbmZpbml0eWAuICovXG4gICAgdmFyIE5FR0FUSVZFX0lORklOSVRZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gICAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gICAgICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IGNoYWluaW5nLlxuICAgICAqIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucywgYW5kIGZ1bmN0aW9ucyBjYW5cbiAgICAgKiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWUgb3IgbWF5IHJldHVybiBhXG4gICAgICogcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHJldHVybmluZyB0aGUgdW53cmFwcGVkXG4gICAgICogdmFsdWUuIEV4cGxpY2l0IGNoYWluaW5nIG1heSBiZSBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC4gVGhlIGV4ZWN1dGlvbiBvZlxuICAgICAqIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBleGVjdXRpb24gaXMgZGVmZXJyZWQgdW50aWwgYF8jdmFsdWVgXG4gICAgICogaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLiBTaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gc3RyYXRlZ3kgd2hpY2ggbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgY2FuIGhlbHBcbiAgICAgKiB0byBhdm9pZCB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlcyBhbmQgZ3JlYXRseSByZWR1Y2UgdGhlXG4gICAgICogbnVtYmVyIG9mIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLFxuICAgICAqIGBmaXJzdGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHBsdWNrYCwgYHJlamVjdGAsIGByZXN0YCwgYHJldmVyc2VgLFxuICAgICAqIGBzbGljZWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdG9BcnJheWAsXG4gICAgICogYW5kIGB3aGVyZWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhdGAsIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLFxuICAgICAqIGBjYWxsYmFja2AsIGBjaGFpbmAsIGBjaHVua2AsIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uc3RhbnRgLFxuICAgICAqIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLFxuICAgICAqIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BSaWdodFdoaWxlYCxcbiAgICAgKiBgZHJvcFdoaWxlYCwgYGZpbGxgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCxcbiAgICAgKiBgbWF0Y2hlc1Byb3BlcnR5YCwgYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCxcbiAgICAgKiBgbW9kQXJnc2AsIGBuZWdhdGVgLCBgb21pdGAsIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCxcbiAgICAgKiBgcGFydGl0aW9uYCwgYHBpY2tgLCBgcGxhbnRgLCBgcGx1Y2tgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCxcbiAgICAgKiBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmVhcmdgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJlc3RQYXJhbWAsXG4gICAgICogYHJldmVyc2VgLCBgc2V0YCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc29ydEJ5QWxsYCxcbiAgICAgKiBgc29ydEJ5T3JkZXJgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsXG4gICAgICogYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRvUGxhaW5PYmplY3RgLFxuICAgICAqIGB0cmFuc2Zvcm1gLCBgdW5pb25gLCBgdW5pcWAsIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHppcGAsIGB6aXBPYmplY3RgLCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xvbmVgLCBgY2xvbmVEZWVwYCxcbiAgICAgKiBgZGVidXJyYCwgYGVuZHNXaXRoYCwgYGVzY2FwZWAsIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmluZFdoZXJlYCwgYGZpcnN0YCxcbiAgICAgKiBgZmxvb3JgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsXG4gICAgICogYGluUmFuZ2VgLCBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsXG4gICAgICogYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCBgaXNGdW5jdGlvbmAsIGBpc01hdGNoYCxcbiAgICAgKiBgaXNOYXRpdmVgLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLFxuICAgICAqIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLCBgam9pbmAsIGBrZWJhYkNhc2VgLFxuICAgICAqIGBsYXN0YCwgYGxhc3RJbmRleE9mYCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWluYCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsXG4gICAgICogYG5vd2AsIGBwYWRgLCBgcGFkTGVmdGAsIGBwYWRSaWdodGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRMYXN0SW5kZXhgLCBgc3RhcnRDYXNlYCxcbiAgICAgKiBgc3RhcnRzV2l0aGAsIGBzdW1gLCBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltTGVmdGAsIGB0cmltUmlnaHRgLCBgdHJ1bmNgLFxuICAgICAqIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2QgYHNhbXBsZWAgd2lsbCByZXR1cm4gYSB3cmFwcGVkIHZhbHVlIHdoZW4gYG5gIGlzIHByb3ZpZGVkLFxuICAgICAqIG90aGVyd2lzZSBhbiB1bndyYXBwZWQgdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIG4pIHtcbiAgICAgKiAgIHJldHVybiB0b3RhbCArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fY2hhaW5fXycpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBhbGwgY2hhaW5pbmcgd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgY2hhaW5pbmcgZm9yIGFsbCB3cmFwcGVyIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FjdGlvbnM9W11dIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCwgYWN0aW9ucykge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IGFjdGlvbnMgfHwgW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGVudmlyb25tZW50IGZlYXR1cmUgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZVxuICAgICAqIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IFBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBhcnJheUNvcHkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gYXJyYXlDb3B5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBhcnJheUNvcHkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgYXJyTGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSB8fCAoYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSgoaXNSaWdodCAmJiBpc0FycikgPyBhcnJheS5yZXZlcnNlKCkgOiBhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5L3ZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG5hbWUgQ2FjaGVcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCBzdWNjZXNzZnVsbHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBEZWxldGUoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2FjaGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEdldChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXycgPyB1bmRlZmluZWQgOiB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgY2FjaGVkIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGtleSAhPSAnX19wcm90b19fJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX19kYXRhX18sIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgdmFsdWVgIHRvIGBrZXlgIG9mIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ICE9ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHRoaXMuX19kYXRhX19ba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIHRoaXMuZGF0YSA9IHsgJ2hhc2gnOiBuYXRpdmVDcmVhdGUobnVsbCksICdzZXQnOiBuZXcgU2V0IH07XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdGhpcy5wdXNoKHZhbHVlc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY2FjaGVgIG1pbWlja2luZyB0aGUgcmV0dXJuIHNpZ25hdHVyZSBvZlxuICAgICAqIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gY2FjaGUuZGF0YSxcbiAgICAgICAgICByZXN1bHQgPSAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkgPyBkYXRhLnNldC5oYXModmFsdWUpIDogZGF0YS5oYXNoW3ZhbHVlXTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA/IDAgOiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBwdXNoXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGRhdGEuc2V0LmFkZCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmhhc2hbdmFsdWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGpvaW5pbmcgYGFycmF5YCB3aXRoIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBqb2luLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBqb2luLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvbmNhdChhcnJheSwgb3RoZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IC0xLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggKyBvdGhMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBvdGhMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4KytdID0gb3RoZXJbb3RoSW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlDb3B5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VFeHRyZW11bWAgZm9yIGFycmF5cyB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWBcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGNvbXB1dGVkID0gZXhWYWx1ZSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9ICtpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zdW1gIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdCArPSAraXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSkgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdFZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2VWYWx1ZSA6IG9iamVjdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25EZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgaWdub3Jlc1xuICAgICAqIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBjaGVja2luZyBpZiBhIHByb3BlcnR5IGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBvYmplY3QgYW5kIHNvdXJjZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25Pd25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gKG9iamVjdFZhbHVlID09PSB1bmRlZmluZWQgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKVxuICAgICAgICA/IHNvdXJjZVZhbHVlXG4gICAgICAgIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmFzc2lnbmAgZm9yIGN1c3RvbWl6aW5nIGFzc2lnbmVkIHZhbHVlcyB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmBcbiAgICAgKiBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcih2YWx1ZSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuXG4gICAgICAgIGlmICgocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkgfHxcbiAgICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICAgICAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VDb3B5KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZyBjb2xsZWN0aW9uc1xuICAgICAqIGFuZCBpbmRpdmlkdWFsIGtleSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQoY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzTmlsID0gY29sbGVjdGlvbiA9PSBudWxsLFxuICAgICAgICAgIGlzQXJyID0gIWlzTmlsICYmIGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pLFxuICAgICAgICAgIGxlbmd0aCA9IGlzQXJyID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHByb3BzTGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc0luZGV4KGtleSwgbGVuZ3RoKSA/IGNvbGxlY3Rpb25ba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXNOaWwgPyB1bmRlZmluZWQgOiBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNhbGxiYWNrYCB3aGljaCBzdXBwb3J0cyBzcGVjaWZ5aW5nIHRoZVxuICAgICAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpc0FyZyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBmdW5jXG4gICAgICAgICAgOiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGNoZXMoZnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc0FyZyA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gcHJvcGVydHkoZnVuYylcbiAgICAgICAgOiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCBgdmFsdWVgIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QpIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZztcblxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lT2JqZWN0KGlzRnVuYyA/IHt9IDogdmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICAgICAgPyBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApXG4gICAgICAgICAgICA6IChvYmplY3QgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB7fTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYW4gaW5kZXhcbiAgICAgKiBvZiB3aGVyZSB0byBzbGljZSB0aGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBhcmd1bWVudHMgcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHdoaWNoIGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGNhY2hlID0gKGlzQ29tbW9uICYmIHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkgPyBjcmVhdGVDYWNoZSh2YWx1ZXMpIDogbnVsbCxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gY2FjaGU7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoaXNDb21tb24gJiYgdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleE9mKHZhbHVlcywgdmFsdWUsIDApIDwgMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGV4dHJlbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIHZhbHVlXG4gICAgICogaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gZXhWYWx1ZSBUaGUgaW5pdGlhbCBleHRyZW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBleFZhbHVlLFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAraXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpIHx8IChjdXJyZW50ID09PSBleFZhbHVlICYmIGN1cnJlbnQgPT09IHJlc3VsdCkpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoZW5kID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgd2hpbGUgKHN0YXJ0IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kYCwgYF8uZmluZExhc3RgLCBgXy5maW5kS2V5YCwgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEtleV0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudFxuICAgICAqICBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMsIHJldEtleSkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJldEtleSA/IGtleSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggYWRkZWQgc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmdcbiAgICAgKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cy1saWtlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgICAgKGlzU3RyaWN0IHx8IGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGlzRGVlcCwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gICAgICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gICAgICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckluYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gdGhvc2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIHBhdGhzXG4gICAgICogYW5kIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aEtleV0gVGhlIGtleSByZXByZXNlbnRhdGlvbiBvZiBwYXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoS2V5ICE9PSB1bmRlZmluZWQgJiYgcGF0aEtleSBpbiB0b09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHBhdGggPSBbcGF0aEtleV07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3BhdGhbaW5kZXgrK11dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gICAgICBpZiAoIW9iaklzQXJyKSB7XG4gICAgICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICAgICAgaWYgKG9ialRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgICAgICB9IGVsc2UgaWYgKG9ialRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgICBvYmpJc0FyciA9IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW90aElzQXJyKSB7XG4gICAgICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgICAgICBpZiAob3RoVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvdGhUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG90aElzQXJyID0gaXNUeXBlZEFycmF5KG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhKG9iaklzQXJyIHx8IG9iaklzT2JqKSkge1xuICAgICAgICByZXR1cm4gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xvb3NlKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXRlY3RpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBzZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNKTy5cbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCBgb2JqZWN0YCBhbmQgYG90aGVyYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICBzdGFja0EucHVzaChvYmplY3QpO1xuICAgICAgc3RhY2tCLnB1c2gob3RoZXIpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXG4gICAgICBzdGFja0EucG9wKCk7XG4gICAgICBzdGFja0IucG9wKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgdHJ1ZSkgOiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXMgbm90IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgdmFyIGtleSA9IG1hdGNoRGF0YVswXVswXSxcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hEYXRhWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIHRvT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShwYXRoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSksXG4gICAgICAgICAgcGF0aEtleSA9IChwYXRoICsgJycpO1xuXG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHBhdGhLZXk7XG4gICAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIGlmICgoaXNBcnIgfHwgIWlzQ29tbW9uKSAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5ID0gbGFzdChwYXRoKTtcbiAgICAgICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWVcbiAgICAgICAgICA/IChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gb2JqZWN0KSlcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmplY3Rba2V5XSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NyY0FyciA9IGlzQXJyYXlMaWtlKHNvdXJjZSkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSksXG4gICAgICAgICAgcHJvcHMgPSBpc1NyY0FyciA/IHVuZGVmaW5lZCA6IGtleXMoc291cmNlKTtcblxuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzcmNWYWx1ZTtcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdExpa2Uoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgocmVzdWx0ICE9PSB1bmRlZmluZWQgfHwgKGlzU3JjQXJyICYmICEoa2V5IGluIG9iamVjdCkpKSAmJlxuICAgICAgICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aCxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHNyY1ZhbHVlKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnJheUxpa2Uoc3JjVmFsdWUpICYmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IChpc0FycmF5TGlrZSh2YWx1ZSkgPyBhcnJheUNvcHkodmFsdWUpIDogW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGlzQXJndW1lbnRzKHZhbHVlKVxuICAgICAgICAgICAgPyB0b1BsYWluT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZVxuICAgICAgLy8gaXQgd2l0aCBpdHMgbWVyZ2VkIHZhbHVlLlxuICAgICAgc3RhY2tBLnB1c2goc3JjVmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBvYmplY3Rba2V5XSA9IG1lcmdlRnVuYyhyZXN1bHQsIHNyY1ZhbHVlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICB2YXIgcGF0aEtleSA9IChwYXRoICsgJycpO1xuICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleCBhcmd1bWVudHMgYW5kIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDA7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAoaW5kZXggIT0gcHJldmlvdXMgJiYgaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gICAgICogYW5kIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAgICogdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEZyb21Db2xsZWN0aW9uIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudFxuICAgICAqICBvZiBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUNvbGxlY3Rpb24sIGVhY2hGdW5jKSB7XG4gICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0RnJvbUNvbGxlY3Rpb25cbiAgICAgICAgICA/IChpbml0RnJvbUNvbGxlY3Rpb24gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmVcbiAgICAgKiB0aGUgc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlPcmRlcmAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKCksXG4gICAgICAgICAgaW5kZXggPSAtMTtcblxuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkgeyByZXR1cm4gY2FsbGJhY2soaXRlcmF0ZWUpOyB9KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkgeyByZXR1cm4gaXRlcmF0ZWUodmFsdWUpOyB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCArPSAraXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB8fCAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGlzTGFyZ2UgPSBpc0NvbW1vbiAmJiBsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSxcbiAgICAgICAgICBzZWVuID0gaXNMYXJnZSA/IGNyZWF0ZUNhY2hlKCkgOiBudWxsLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCAwKSA8IDApIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogb2YgYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kcm9wUmlnaHRXaGlsZWAsIGBfLmRyb3BXaGlsZWAsIGBfLnRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBhbmQgYF8udGFrZVdoaWxlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhY3Rpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNbaW5kZXhdO1xuICAgICAgICByZXN1bHQgPSBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSAmJiBjb21wdXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJpbmFyeUluZGV4YCBleGNlcHQgdGhhdCBpdCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1VuZGVmID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIGlzRGVmID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSBpc1JlZmxleGl2ZSB8fCByZXRIaWdoZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIGlzRGVmICYmIChyZXRIaWdoZXN0IHx8IGNvbXB1dGVkICE9IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWYpIHtcbiAgICAgICAgICBzZXRMb3cgPSBpc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBpc0RlZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcHV0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICAgICAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodGhpc0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcblxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuICAgICAgdmFyIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoYXJnc0xlbmd0aCArIHJpZ2h0TGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5jb3VudEJ5YCwgYF8uZ3JvdXBCeWAsIGBfLmluZGV4QnlgLCBvciBgXy5wYXJ0aXRpb25gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBmdW5jdGlvbiB0byBpbml0aWFsaXplIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5hc3NpZ25gLCBgXy5kZWZhdWx0c2AsIG9yIGBfLm1lcmdlYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCA1KTtcbiAgICAgICAgICBsZW5ndGggLT0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIHRoaXNBcmcgPT0gJ2Z1bmN0aW9uJyA/IHRoaXNBcmcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcbiAgICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgYF8uZm9ySW5gIG9yIGBfLmZvckluUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kV3JhcHBlcihmdW5jLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIG5ldyBjYWNoZSBvYmplY3QgaWYgYFNldGAgaXMgc3VwcG9ydGVkLCBlbHNlIGBudWxsYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAobmF0aXZlQ3JlYXRlICYmIFNldCkgPyBuZXcgU2V0Q2FjaGUodmFsdWVzKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgY29tcG91bmQgd29yZHMgb3V0IG9mIHRoZSB3b3JkcyBpbiBhXG4gICAgICogZ2l2ZW4gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJyYXkgPSB3b3JkcyhkZWJ1cnIoc3RyaW5nKSksXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHJlc3VsdCwgYXJyYXlbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcldyYXBwZXIoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcgVGhlIGN1cnJ5IGJpdCBmbGFnLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJ5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZsYWcpIHtcbiAgICAgIGZ1bmN0aW9uIGN1cnJ5RnVuYyhmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIGFyaXR5LCBndWFyZCkpIHtcbiAgICAgICAgICBhcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcHBlcihmdW5jLCBmbGFnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeUZ1bmMucGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycnlGdW5jO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5kZWZhdWx0c2Agb3IgYF8uZGVmYXVsdHNEZWVwYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWZhdWx0cyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0cyhhc3NpZ25lciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChjdXN0b21pemVyKTtcbiAgICAgICAgcmV0dXJuIGFzc2lnbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ubWF4YCBvciBgXy5taW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gZXhWYWx1ZSBUaGUgaW5pdGlhbCBleHRyZW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBleHRyZW11bSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHRyZW11bShjb21wYXJhdG9yLCBleFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpdGVyYXRlZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFycmF5RXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpO1xuICAgICAgICAgIGlmICghKGNvbGxlY3Rpb24ubGVuZ3RoICYmIHJlc3VsdCA9PT0gZXhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VGaW5kSW5kZXgoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tUmlnaHQpO1xuICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gY29sbGVjdGlvbltpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEluZGV4YCBvciBgXy5maW5kTGFzdEluZGV4YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kSW5kZXgoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kS2V5YCBvciBgXy5maW5kTGFzdEtleWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kS2V5KG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICByZXR1cm4gYmFzZUZpbmQob2JqZWN0LCBwcmVkaWNhdGUsIG9iamVjdEZ1bmMsIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd3JhcHBlcixcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gMCxcbiAgICAgICAgICAgIGZ1bmNzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXdyYXBwZXIgJiYgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydSAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IC0xIDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmIGRhdGFbMV0gPT0gKEFSWV9GTEFHIHwgQ1VSUllfRkxBRyB8IFBBUlRJQUxfRkxBRyB8IFJFQVJHX0ZMQUcpICYmICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDEpIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpID8gd3JhcHBlcltmdW5jTmFtZV0oKSA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JFYWNoYCBvciBgXy5mb3JFYWNoUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG4gICAgICAgICAgOiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JJbihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yT3duYCBvciBgXy5mb3JPd25SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JPd24ob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0RnVuYyhvYmplY3QsIGl0ZXJhdGVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5tYXBLZXlzYCBvciBgXy5tYXBWYWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01hcEtleXNdIFNwZWNpZnkgbWFwcGluZyBrZXlzIGluc3RlYWQgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hcCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3RNYXBwZXIoaXNNYXBLZXlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICB2YXIgbWFwcGVkID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgICAgICBrZXkgPSBpc01hcEtleXMgPyBtYXBwZWQgOiBrZXk7XG4gICAgICAgICAgdmFsdWUgPSBpc01hcEtleXMgPyB2YWx1ZSA6IG1hcHBlZDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5wYWRMZWZ0YCBvciBgXy5wYWRSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBwYWRkaW5nIGZyb20gdGhlIHJpZ2h0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWREaXIoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgICByZXR1cm4gKGZyb21SaWdodCA/IHN0cmluZyA6ICcnKSArIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSArIChmcm9tUmlnaHQgPyAnJyA6IHN0cmluZyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5wYXJ0aWFsYCBvciBgXy5wYXJ0aWFsUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcgVGhlIHBhcnRpYWwgYml0IGZsYWcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZsYWcpIHtcbiAgICAgIHZhciBwYXJ0aWFsRnVuYyA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBwYXJ0aWFsRnVuYy5wbGFjZWhvbGRlcik7XG4gICAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFydGlhbEZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5yZWR1Y2VgIG9yIGBfLnJlZHVjZVJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgICB2YXIgaW5pdEZyb21BcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSlcbiAgICAgICAgICA6IGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSwgZWFjaEZ1bmMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIENVUlJZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIENVUlJZX0JPVU5EX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeVJpZ2h0ID0gYml0bWFzayAmIENVUlJZX1JJR0hUX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgdG8gb3RoZXIgZnVuY3Rpb25zLlxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycnkgfHwgaXNDdXJyeVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgYXJnc0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBsZW5ndGggLT0gYXJnc0hvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgICAgdmFyIG5ld0FyZ1BvcyA9IGFyZ1BvcyA/IGFycmF5Q29weShhcmdQb3MpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld0FyaXR5ID0gbmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSxcbiAgICAgICAgICAgICAgICBuZXdzSG9sZGVycyA9IGlzQ3VycnkgPyBhcmdzSG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogYXJnc0hvbGRlcnMsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gYXJncyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGFyZ3M7XG5cbiAgICAgICAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBQQVJUSUFMX0ZMQUcgOiBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBQQVJUSUFMX1JJR0hUX0ZMQUcgOiBQQVJUSUFMX0ZMQUcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzQ3VycnlCb3VuZCkge1xuICAgICAgICAgICAgICBiaXRtYXNrICY9IH4oQklORF9GTEFHIHwgQklORF9LRVlfRkxBRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3c0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsIG5ld0hvbGRlcnNSaWdodCwgbmV3QXJnUG9zLCBhcnksIG5ld0FyaXR5XSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWRXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIHJlcXVpcmVkIGZvciBgc3RyaW5nYCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYGxlbmd0aGAuXG4gICAgICogVGhlIGBjaGFyc2Agc3RyaW5nIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBwYWRkaW5nIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZCBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gK2xlbmd0aDtcblxuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIHN0ckxlbmd0aDtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT0gbnVsbCA/ICcgJyA6IChjaGFycyArICcnKTtcbiAgICAgIHJldHVybiByZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwocGFkTGVuZ3RoIC8gY2hhcnMubGVuZ3RoKSkuc2xpY2UoMCwgcGFkTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqIHRoZSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgLy8gQXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IHVzZSBkaXNxdWFsaWZ5aW5nIG9wdGltaXphdGlvbnMgYnlcbiAgICAgICAgLy8gY29udmVydGluZyBpdCB0byBhbiBhcnJheSBiZWZvcmUgcHJvdmlkaW5nIGl0IGBmdW5jYC5cbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5jZWlsYCwgYF8uZmxvb3JgLCBvciBgXy5yb3VuZGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDAgOiAoK3ByZWNpc2lvbiB8fCAwKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgIHByZWNpc2lvbiA9IHBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5zb3J0ZWRJbmRleGAgb3IgYF8uc29ydGVkTGFzdEluZGV4YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGluZGV4IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNvcnRlZEluZGV4KHJldEhpZ2hlc3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIChpdGVyYXRlZSA9PSBudWxsICYmIGNhbGxiYWNrID09PSBiYXNlQ2FsbGJhY2spXG4gICAgICAgICAgPyBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpXG4gICAgICAgICAgOiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLCByZXRIaWdoZXN0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAgMjU2IC0gYF8uYXJ5YFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFBBUlRJQUxfRkxBRyB8IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCAtPSAoaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMCk7XG4gICAgICBpZiAoYml0bWFzayAmIFBBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyksXG4gICAgICAgICAgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHldO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgICBhcml0eSA9IG5ld0RhdGFbOV07XG4gICAgICB9XG4gICAgICBuZXdEYXRhWzldID0gYXJpdHkgPT0gbnVsbFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogKG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCkgfHwgMCk7XG5cbiAgICAgIGlmIChiaXRtYXNrID09IEJJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZFdyYXBwZXIobmV3RGF0YVswXSwgbmV3RGF0YVsyXSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFBBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChCSU5EX0ZMQUcgfCBQQVJUSUFMX0ZMQUcpKSAmJiAhbmV3RGF0YVs0XS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldHRlcihyZXN1bHQsIG5ld0RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgYXJyYXlzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzTG9vc2UgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKGlzTG9vc2UgPyBvdGhWYWx1ZSA6IGFyclZhbHVlLCBpc0xvb3NlID8gYXJyVmFsdWUgOiBvdGhWYWx1ZSwgaW5kZXgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKGlzTG9vc2UpIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcbiAgICAgICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWwuXG4gICAgICAgICAgcmV0dXJuICtvYmplY3QgPT0gK290aGVyO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBUcmVhdCBgTmFOYCB2cy4gYE5hTmAgYXMgZXF1YWwuXG4gICAgICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdClcbiAgICAgICAgICAgID8gb3RoZXIgIT0gK290aGVyXG4gICAgICAgICAgICA6IG9iamVjdCA9PSArb3RoZXI7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MgcHJpbWl0aXZlcyBhbmQgc3RyaW5nXG4gICAgICAgICAgLy8gb2JqZWN0cyBhcyBlcXVhbC4gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzTG9vc2U7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogb2JqVmFsdWUsIGlzTG9vc2U/IG9ialZhbHVlIDogb3RoVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIDogcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJjYWxsYmFja1wiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uY2FsbGJhY2tgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUNhbGxiYWNrYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guY2FsbGJhY2sgfHwgY2FsbGJhY2s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGNhbGxiYWNrID8gYmFzZUNhbGxiYWNrIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ0NvdW50ID8gcmVzdWx0KGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5uYW1lLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258bnVtYmVyfSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmluZGV4T2YgfHwgaW5kZXhPZjtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyByZXN1bHQoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gICAgICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFpcnMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF1bMl0gPSBpc1N0cmljdENvbXBhcmFibGUocmVzdWx0W2xlbmd0aF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKCEodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IE9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBidWZmZXJDbG9uZShvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcihpc0RlZXAgPyBidWZmZXJDbG9uZShidWZmZXIpIDogYnVmZmVyLCBvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0Lmxlbmd0aCk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IG9iamVjdC5sYXN0SW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2VQYXRoKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmICFpc0tleShwYXRoLCBvYmplY3QpKSB7XG4gICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgIHBhdGggPSBsYXN0KHBhdGgpO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFtwYXRoXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKCh0eXBlID09ICdzdHJpbmcnICYmIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkpIHx8IHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiB0b09iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyk7XG4gICAgICBpZiAoIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHJlcXVpcmVkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZCBgXy5yZWFyZ2BcbiAgICAgKiBhdWdtZW50IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZSBleGVjdXRlZCBpbXBvcnRhbnQsXG4gICAgICogcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZSBhbiBleGNlcHRpb24gZm9yIGEgc2FmZVxuICAgICAqIGNvbW1vbiBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YCBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IEFSWV9GTEFHO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgIChzcmNCaXRtYXNrID09IEFSWV9GTEFHICYmIGJpdG1hc2sgPT0gQ1VSUllfRkxBRykgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBSRUFSR19GTEFHICYmIGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gKEFSWV9GTEFHIHwgUkVBUkdfRkxBRykgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gKGJpdG1hc2sgJiBCSU5EX0ZMQUcpID8gMCA6IENVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNF0pO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzZdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdFZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2VWYWx1ZSA6IG1lcmdlKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwgbWVyZ2VEZWZhdWx0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgc3BlY2lmaWVkXG4gICAgICogYnkgYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeUFycmF5KG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB3aGljaCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgXG4gICAgICogcmV0dXJucyB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGJhc2VGb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGFycmF5Q29weShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHkgZnVuY3Rpb25cbiAgICAgKiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWUgW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VTZXREYXRhKGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICAgICAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aDtcblxuICAgICAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0l0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIHByb3BlcnR5IHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlVG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXJcbiAgICAgICAgPyB3cmFwcGVyLmNsb25lKClcbiAgICAgICAgOiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXywgYXJyYXlDb3B5KHdyYXBwZXIuX19hY3Rpb25zX18pKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBjb2xsZWN0aW9uYCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgY29udGFpbmluZyBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heChuYXRpdmVGbG9vcihzaXplKSB8fCAxLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyXG4gICAgICogcHJvdmlkZWQgYXJyYXlzIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgM10sIFs0LCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UoYXJyYXkpICYmIGlzQXJyYXlMaWtlKGFycmF5KSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCBmYWxzZSwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDhdLCAnKicsIDEsIDIpO1xuICAgICAqIC8vID0+IFs0LCAnKicsIDhdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci51c2VyID09ICdiYXJuZXknO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIGZpbmRJbmRleCA9IGNyZWF0ZUZpbmRJbmRleCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci51c2VyID09ICdwZWJibGVzJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RJbmRleCA9IGNyZWF0ZUZpbmRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCB0aGUgYXJyYXkgaXMgcmVjdXJzaXZlbHlcbiAgICAgKiBmbGF0dGVuZWQsIG90aGVyd2lzZSBpdCBpcyBvbmx5IGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGlzRGVlcGBcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCAzLCBbNF1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNEZWVwLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNEZWVwLCBndWFyZCkpIHtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBhIG5lc3RlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZWN1cnNpdmVseSBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIDMsIFs0XV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldFxuICAgICAqIGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIHNvcnRlZCBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YFxuICAgICAqIHBlcmZvcm1zIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDJdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IGZyb21JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gYXJyYXlbaW5kZXhdKSA6IChhcnJheVtpbmRleF0gIT09IGFycmF5W2luZGV4XSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3BSaWdodChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBvZiB0aGUgcHJvdmlkZWRcbiAgICAgKiBhcnJheXMgdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyXSwgWzQsIDJdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheXNbb3RoSW5kZXhdID0gaXNBcnJheUxpa2UodmFsdWUgPSBhcnJheXNbb3RoSW5kZXhdKSA/IHZhbHVlIDogW107XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAoaXNDb21tb24gJiYgdmFsdWUubGVuZ3RoID49IDEyMCkgPyBjcmVhdGVDYWNoZShvdGhJbmRleCAmJiB2YWx1ZSkgOiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gYXJyYXlzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICgoc2VlbiA/IGNhY2hlSW5kZXhPZihzZWVuLCB2YWx1ZSkgOiBpbmRleE9mKHJlc3VsdCwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICB2YXIgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFycmF5c1tvdGhJbmRleF0sIHZhbHVlLCAwKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb21cbiAgICAgKiAgb3IgYHRydWVgIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgZnJvbUluZGV4YFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDEsIDIsIDJdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4IHx8IDAsIGxlbmd0aCAtIDEpKSArIDE7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGluZGV4LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJyYXkgPSBhcmdzWzBdO1xuXG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkpID4gLTEpIHtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZGV4ZXMgYW5kIHJldHVybnNcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mXG4gICAgICogaW5kZXhlcyBvciBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzUsIDEwLCAxNSwgMjBdO1xuICAgICAqIHZhciBldmVucyA9IF8ucHVsbEF0KGFycmF5LCAxLCAzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbNSwgMTVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzEwLCAyMF1cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICBpbmRleGVzID0gYmFzZUZsYXR0ZW4oaW5kZXhlcyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcy5zb3J0KGJhc2VDb21wYXJlQXNjZW5kaW5nKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3AoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZVxuICAgICAqIGxpc3RzIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZFxuICAgICAqIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci4gSWYgYW4gaXRlcmF0ZWVcbiAgICAgKiBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7ICdkYXRhJzogeyAndGhpcnR5JzogMzAsICdmb3J0eSc6IDQwLCAnZmlmdHknOiA1MCB9IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0aGlydHknLCAnZmlmdHknXSwgJ2ZvcnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZGF0YVt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICB2YXIgc29ydGVkSW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNCwgNSwgNV0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICB2YXIgc29ydGVkTGFzdEluZGV4ID0gY3JlYXRlU29ydGVkSW5kZXgodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICBuID0gbGVuZ3RoIC0gKCtuIHx8IDApO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgb2YgdGhlIHByb3ZpZGVkIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgNF1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBQcm92aWRpbmcgYHRydWVgIGZvciBgaXNTb3J0ZWRgIHBlcmZvcm1zIGEgZmFzdGVyIHNlYXJjaCBhbGdvcml0aG1cbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3JcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkXSBTcGVjaWZ5IHRoZSBhcnJheSBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGlzU29ydGVkYFxuICAgICAqIF8udW5pcShbMSwgMSwgMl0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYW4gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBfLnVuaXEoWzEsIDIuNSwgMS41LCAyXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzEsIDIuNV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNTb3J0ZWQgIT0gbnVsbCAmJiB0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXNBcmcgPSBpdGVyYXRlZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNTb3J0ZWQsIHRoaXNBcmcpID8gdW5kZWZpbmVkIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbGJhY2sgPSBnZXRDYWxsYmFjaygpO1xuICAgICAgaWYgKCEoaXRlcmF0ZWUgPT0gbnVsbCAmJiBjYWxsYmFjayA9PT0gYmFzZUNhbGxiYWNrKSkge1xuICAgICAgICBpdGVyYXRlZSA9IGNhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaXNTb3J0ZWQgJiYgZ2V0SW5kZXhPZigpID09IGJhc2VJbmRleE9mKVxuICAgICAgICA/IHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKVxuICAgICAgICA6IGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGl0ZXJhdGVlIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCk7XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoZ3JvdXAsIGl0ZXJhdGVlLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoYXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgPyBhcnJheVB1c2goYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSksIGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCA/IGJhc2VVbmlxKHJlc3VsdCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmQgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSByZXN0UGFyYW0odW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8ucGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5c1xuICAgICAqIG9mIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuIFByb3ZpZGUgZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSxcbiAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAgb3IgdHdvIGFycmF5cywgb25lIG9mIHByb3BlcnR5IG5hbWVzXG4gICAgICogYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDQwXV0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMgPyBwcm9wcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAobGVuZ3RoICYmICF2YWx1ZXMgJiYgIWlzQXJyYXkocHJvcHNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBpdGVyYXRlZSB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAyID8gYXJyYXlzW2xlbmd0aCAtIDJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZW5ndGggLT0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVlID0gKGxlbmd0aCA+IDEgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ2Z1bmN0aW9uJykgPyAoLS1sZW5ndGgsIHRoaXNBcmcpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSwgdGhpc0FyZyk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluaW5nIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICAgIHJldHVybiBjaHIudXNlciArICcgaXMgJyArIGNoci5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3IgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mXG4gICAgICogdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9uc1xuICAgICAqIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyh1c2VycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyh1c2VycykuY2hhaW4oKVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbmVkIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGpvaW5pbmcgYSB3cmFwcGVkIGFycmF5IHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbmNhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkuY29uY2F0KDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cod3JhcHBlZC52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQ29uY2F0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgdmFsdWVzID0gYmFzZUZsYXR0ZW4odmFsdWVzKTtcbiAgICAgIHJldHVybiB0aGlzLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29uY2F0KGlzQXJyYXkoYXJyYXkpID8gYXJyYXkgOiBbdG9PYmplY3QoYXJyYXkpXSwgdmFsdWVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbmVkIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIE1hdGgucG93KHZhbHVlLCAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IFszLCA0XTtcbiAgICAgKiB2YXIgb3RoZXJXcmFwcGVkID0gd3JhcHBlZC5wbGFudChvdGhlcik7XG4gICAgICpcbiAgICAgKiBvdGhlcldyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIHdyYXBwZWQgYXJyYXkgc28gdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuXG4gICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwZWQgJiYgd3JhcHBlZC5fX2Rpcl9fIDwgMCkgPyB2YWx1ZSA6IHZhbHVlLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIHJlc3VsdCBvZiBjb2VyY2luZyB0aGUgdW53cmFwcGVkIHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvZXJjZWQgc3RyaW5nIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKCkgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgdG8gZXh0cmFjdCB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBydW4sIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4ga2V5cywgb3IgaW5kZXhlcyxcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAuIEtleXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBrZXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbcHJvcHNdIFRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqICBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2ssIHNwZWNpZmllZCBpbmRpdmlkdWFsbHkgb3IgaW4gYXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJ10sIFswLCAyXSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAncGViYmxlcyddXG4gICAgICovXG4gICAgdmFyIGF0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByb3BzKSB7XG4gICAgICByZXR1cm4gYmFzZUF0KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/ICsrcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbNCwgNSwgNl0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFs0LCA2XVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGJhc2VFYWNoUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIGFuZCB0aGVcbiAgICAgKiBzb3VyY2Ugb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBoYXMgZXF1aXZhbGVudCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbmQoY29sbGVjdGlvbiwgYmFzZU1hdGNoZXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHlcbiAgICAgKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCIgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMl0pLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAqICAgY29uc29sZS5sb2cobik7XG4gICAgICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obiwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuLCBrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZS1rZXkgcGFpciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckVhY2ggPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaCwgYmFzZUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaFJpZ2h0KGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4pO1xuICAgICAqIH0pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaFJpZ2h0ID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2hSaWdodCwgYmFzZUVhY2hSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3Iobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldFxuICAgICAqIGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29udGFpbnMsIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkpKSB7XG4gICAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiAoZnJvbUluZGV4IHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0eXBlb2YgY29sbGVjdGlvbiA9PSAnc3RyaW5nJyB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgZnVuY3Rpb24gaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlEYXRhID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9iamVjdC5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdCBpc1xuICAgICAqIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBpc1Byb3AgPSBpc0tleShwYXRoKSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IHBhdGggOiAoKGlzUHJvcCAmJiB2YWx1ZSAhPSBudWxsKSA/IHZhbHVlW3BhdGhdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gZnVuYyA/IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpIDogaW52b2tlUGF0aCh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaFxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2FsbGJhY2tgLCBgY2h1bmtgLCBgY2xvbmVgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLFxuICAgICAqIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsIGBmaWxsYCwgYGZsYXR0ZW5gLCBgaW52ZXJ0YCwgYG1heGAsIGBtaW5gLFxuICAgICAqIGBwYXJzZUludGAsIGBzbGljZWAsIGBzb3J0QnlgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGVtcGxhdGVgLCBgdHJpbWAsXG4gICAgICogYHRyaW1MZWZ0YCwgYHRyaW1SaWdodGAsIGB0cnVuY2AsIGByYW5kb21gLCBgcmFuZ2VgLCBgc2FtcGxlYCwgYHNvbWVgLFxuICAgICAqIGBzdW1gLCBgdW5pcWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdGltZXNUaHJlZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDJdLCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiAxLCAnYic6IDIgfSwgdGltZXNUaHJlZSk7XG4gICAgICogLy8gPT4gWzMsIDZdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgd2hpbGUgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDI7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gW1sxLCAzXSwgWzJdXVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEuMiwgMi4zLCAzLjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKSAlIDI7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gW1sxLjIsIDMuNF0sIFsyLjNdXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIG1hcHBlciA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICByZXR1cm4gXy5wbHVjayhhcnJheSwgJ3VzZXInKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgZnJvbSBhbGwgZWxlbWVudHMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIHZhciB1c2VySW5kZXggPSBfLmluZGV4QnkodXNlcnMsICd1c2VyJyk7XG4gICAgICogXy5wbHVjayh1c2VySW5kZXgsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiBbMzYsIDQwXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHBhdGgpIHtcbiAgICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgcHJvcGVydHkocGF0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBzb3J0QnlBbGxgLFxuICAgICAqIGFuZCBgc29ydEJ5T3JkZXJgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHRvdGFsLCBuKSB7XG4gICAgICogICByZXR1cm4gdG90YWwgKyBuO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlID0gY3JlYXRlUmVkdWNlKGFycmF5UmVkdWNlLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlUmlnaHQgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2VSaWdodCwgYmFzZUVhY2hSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlamVjdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPiAwID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRvQXJyYXkoY29sbGVjdGlvbiksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBuID0gbmF0aXZlTWluKG4gPCAwID8gMCA6ICgrbiB8fCAwKSwgbGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFtyYW5kXTtcblxuICAgICAgICByZXN1bHRbcmFuZF0gPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNhbXBsZShjb2xsZWN0aW9uLCBQT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgcmV0dXJuIGlzTGVuZ3RoKGxlbmd0aCkgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcbiAgICAgKiBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhpcyBtZXRob2QgcGVyZm9ybXNcbiAgICAgKiBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2YgZXF1YWwgZWxlbWVudHMuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5zaW4obik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLnNpbihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnNvcnRCeSh1c2VycywgJ3VzZXInKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBjYW4gc29ydCBieSBtdWx0aXBsZSBpdGVyYXRlZXNcbiAgICAgKiBvciBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdfE9iamVjdHxPYmplY3RbXXxzdHJpbmd8c3RyaW5nW10pfSBpdGVyYXRlZXNcbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCB2YWx1ZXMgb3IgYXJyYXlzIG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDIgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsIFsndXNlcicsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0Ml0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5QWxsKHVzZXJzLCAndXNlcicsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3IoY2hyLmFnZSAvIDEwKTtcbiAgICAgKiB9KSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDJdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnlBbGwgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBndWFyZCA9IGl0ZXJhdGVlc1syXTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGl0ZXJhdGVlcy5sZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeUFsbGAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogc29ydCBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsXG4gICAgICogdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIGEgdmFsdWUgaXMgc29ydGVkIGluXG4gICAgICogYXNjZW5kaW5nIG9yZGVyIGlmIGl0cyBjb3JyZXNwb25kaW5nIG9yZGVyIGlzIFwiYXNjXCIsIGFuZCBkZXNjZW5kaW5nIGlmIFwiZGVzY1wiLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBzb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBfLm1hcChfLnNvcnRCeU9yZGVyKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkpIHtcbiAgICAgICAgb3JkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIGFuZCB0aGVcbiAgICAgKiBzb3VyY2Ugb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuICAgICAqIG93biBvciBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWUgc2VlIGBfLm1hdGNoZXNQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogXy5wbHVjayhfLndoZXJlKHVzZXJzLCB7ICdwZXRzJzogWydkaW5vJ10gfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aGVyZShjb2xsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgYmFzZU1hdGNoZXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBpbnZva2VkXG4gICAgICovXG4gICAgdmFyIG5vdyA9IG5hdGl2ZU5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCBpcyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IG47XG4gICAgICAgICAgbiA9IGZ1bmM7XG4gICAgICAgICAgZnVuYyA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuID0gbmF0aXZlSXNGaW5pdGUobiA9ICtuKSA/IG4gOiAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBgbmAgYXJndW1lbnRzIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCBuLCBndWFyZCkpIHtcbiAgICAgICAgbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuYXRpdmVNYXgoK24gfHwgMCwgMCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBBUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCBpcyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KCcjYWRkJykub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IGFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IG47XG4gICAgICAgICAgbiA9IGZ1bmM7XG4gICAgICAgICAgZnVuYyA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgXy5iaW5kYCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAgdGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBCSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmQucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgZW51bWVyYWJsZSBmdW5jdGlvblxuICAgICAqIHByb3BlcnRpZXMsIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCBhcmUgYm91bmQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW21ldGhvZE5hbWVzXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGxvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiB0aGUgZWxlbWVudCBpcyBjbGlja2VkXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgbWV0aG9kTmFtZXMgPSBtZXRob2ROYW1lcy5sZW5ndGggPyBiYXNlRmxhdHRlbihtZXRob2ROYW1lcykgOiBmdW5jdGlvbnMob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kTmFtZXNbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIEJJTkRfRkxBRywgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCBhbmQgcHJlcGVuZHNcbiAgICAgKiBhbnkgYWRkaXRpb25hbCBgXy5iaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kS2V5LnBsYWNlaG9sZGVyKTtcbiAgICAgICAgYml0bWFzayB8PSBQQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGNhbGxlZCBlaXRoZXIgaW52b2tlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgY3VycnkgPSBjcmVhdGVDdXJyeShDVVJSWV9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgY3VycnlSaWdodCA9IGNyZWF0ZUN1cnJ5KENVUlJZX1JJR0hUX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0XG4gICAgICogYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlXG4gICAgICogIGRlbGF5ZWQgYmVmb3JlIGl0IGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBpbnZva2UgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAgICogICAnbWF4V2FpdCc6IDEwMDBcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSBkZWJvdW5jZWQgY2FsbFxuICAgICAqIHZhciB0b2RvQ2hhbmdlcyA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDEwMDApO1xuICAgICAqIE9iamVjdC5vYnNlcnZlKG1vZGVscy50b2RvLCB0b2RvQ2hhbmdlcyk7XG4gICAgICpcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMsIGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgKiAgIGlmIChfLmZpbmQoY2hhbmdlcywgeyAndXNlcic6ICd0b2RvJywgJ3R5cGUnOiAnZGVsZXRlJ30pKSB7XG4gICAgICogICAgIHRvZG9DaGFuZ2VzLmNhbmNlbCgpO1xuICAgICAqICAgfVxuICAgICAqIH0sIFsnZGVsZXRlJ10pO1xuICAgICAqXG4gICAgICogLy8gLi4uYXQgc29tZSBwb2ludCBgbW9kZWxzLnRvZG9gIGlzIGNoYW5nZWRcbiAgICAgKiBtb2RlbHMudG9kby5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAqXG4gICAgICogLy8gLi4uYmVmb3JlIDEgc2Vjb25kIGhhcyBwYXNzZWQgYG1vZGVscy50b2RvYCBpcyBkZWxldGVkXG4gICAgICogLy8gd2hpY2ggY2FuY2VscyB0aGUgZGVib3VuY2VkIGB0b2RvQ2hhbmdlc2AgY2FsbFxuICAgICAqIGRlbGV0ZSBtb2RlbHMudG9kbztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gd2FpdCA8IDAgPyAwIDogKCt3YWl0IHx8IDApO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiBuYXRpdmVNYXgoK29wdGlvbnMubWF4V2FpdCB8fCAwLCB3YWl0KTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlKGlzQ2FsbGVkLCBpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgIGNvbXBsZXRlKHRyYWlsaW5nQ2FsbCwgbWF4VGltZW91dElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF4RGVsYXllZCgpIHtcbiAgICAgICAgY29tcGxldGUodHJhaWxpbmcsIHRpbWVvdXRJZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IG1heFdhaXQ7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgcHJvdmlkZWRcbiAgICAgKiBmdW5jdGlvbnMgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY3NdIEZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhfLmFkZCwgc3F1YXJlKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYmFja2Zsb3csIGNvbXBvc2VcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY3NdIEZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KHNxdWFyZSwgXy5hZGQpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nIGFuZCB1c2VkIGFzIHRoZVxuICAgICAqIGNhY2hlIGtleS4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXBwZXJDYXNlID0gXy5tZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHVwcGVyQ2FzZS5jYWNoZS5zZXQoJ2ZyZWQnLCAnQkFSTkVZJyk7XG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0JBUk5FWSdcbiAgICAgKlxuICAgICAqIC8vIHJlcGxhY2luZyBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdiYXJuZXknIH07XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcbiAgICAgKlxuICAgICAqIGlkZW50aXR5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogaWRlbnRpdHkob3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgbWVtb2l6ZS5DYWNoZTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBydW5zIGVhY2ggYXJndW1lbnQgdGhyb3VnaCBhIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtc10gVGhlIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm1cbiAgICAgKiBhcmd1bWVudHMsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGZ1bmN0aW9ucyBvciBhcnJheXMgb2YgZnVuY3Rpb25zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBtb2RkZWQgPSBfLm1vZEFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBzcXVhcmUsIGRvdWJsZWQpO1xuICAgICAqXG4gICAgICogbW9kZGVkKDEsIDIpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqXG4gICAgICogbW9kZGVkKDUsIDEwKTtcbiAgICAgKiAvLyA9PiBbMjUsIDIwXVxuICAgICAqL1xuICAgIHZhciBtb2RBcmdzID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSBiYXNlRmxhdHRlbih0cmFuc2Zvcm1zKTtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8ICFhcnJheUV2ZXJ5KHRyYW5zZm9ybXMsIGJhc2VJc0Z1bmN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0oYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBpbnZva2VzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHRcbiAgICAgKiBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBjcmVhdGVQYXJ0aWFsKFBBUlRJQUxfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9SSUdIVF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIDIsIDAsIDEpO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogdmFyIG1hcCA9IF8ucmVhcmcoXy5tYXAsIFsxLCAwXSk7XG4gICAgICogbWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9LCBbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBSRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlRmxhdHRlbihpbmRleGVzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgcmVzdCk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSByZXN0O1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuMykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9TcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhIFByb21pc2VcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFycmF5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlXG4gICAgICogdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlXG4gICAgICogYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmdcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBpbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlc1xuICAgICAqIGpRdWVyeSgnLmludGVyYWN0aXZlJykub24oJ2NsaWNrJywgXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHtcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgdHJhaWxpbmcgdGhyb3R0bGVkIGNhbGxcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgeyAnbGVhZGluZyc6IGxlYWRpbmcsICdtYXhXYWl0JzogK3dhaXQsICd0cmFpbGluZyc6IHRyYWlsaW5nIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHdyYXBwZXIgPSB3cmFwcGVyID09IG51bGwgPyBpZGVudGl0eSA6IHdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCBQQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgW3ZhbHVlXSwgW10pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAgICAgKiBvdGhlcndpc2UgdGhleSBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUodXNlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZSh1c2VycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChpc0RlZXAgJiYgdHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcikpIHtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaXNEZWVwID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGN1c3RvbWl6ZXI7XG4gICAgICAgIGN1c3RvbWl6ZXIgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpKVxuICAgICAgICA6IGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmdcbiAgICAgKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAodXNlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcChkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpKVxuICAgICAgICA6IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBndCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBndGUodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gISF2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGVtcHR5IHVubGVzcyBpdCBpcyBhblxuICAgICAqIGBhcmd1bWVudHNgIG9iamVjdCwgYXJyYXksIHN0cmluZywgb3IgalF1ZXJ5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGEgbGVuZ3RoXG4gICAgICogZ3JlYXRlciB0aGFuIGAwYCBvciBhbiBvYmplY3Qgd2l0aCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAha2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kXG4gICAgICogaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciBbLCBpbmRleHxrZXldKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICogYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmQgc3VwcG9ydFxuICAgICAqIGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVxXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKGFycmF5LCBvdGhlciwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICBpZiAoXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMykgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAgcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZXJyb3JUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc2Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDEwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE9iamVjdCgxMCkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAgICAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG8gZGV0ZXJtaW5lIGlmXG4gICAgICogYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZFxuICAgICAqIGl0IGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIG90aGVyLCBpbmRleHxrZXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBwcm9wZXJ0aWVzIG9mIGFycmF5cywgYm9vbGVhbnMsXG4gICAgICogYERhdGVgIG9iamVjdHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC4gUHJvdmlkZSBhIGN1c3RvbWl6ZXIgZnVuY3Rpb24gdG8gZXh0ZW5kXG4gICAgICogc3VwcG9ydCBmb3IgY29tcGFyaW5nIG90aGVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgc291cmNlLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykgfHwgdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub3QgdGhlIHNhbWUgYXMgW2Bpc05hTmBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40KVxuICAgICAqIHdoaWNoIHJldHVybnMgYHRydWVgIGZvciBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlIGNsYXNzaWZpZWRcbiAgICAgKiBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignOC40Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYXNzdW1lcyBvYmplY3RzIGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yXG4gICAgICogaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3I7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIG5vbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcgJiYgIWlzQXJndW1lbnRzKHZhbHVlKSkgfHxcbiAgICAgICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgICAgIC8vIGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWRcbiAgICAgIC8vIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGJhc2VGb3JJbih2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsdGUodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpO1xuICAgICAqIH0oMSwgMiwgMykpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZSA/IGdldExlbmd0aCh2YWx1ZSkgOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyBpcyBoYW5kbGVkXG4gICAgICogYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAndXNlcic6ICdmcmVkJyB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ2FnZSc6IDM2IH0sIHsgJ2FnZSc6IDQwIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UodXNlcnMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkoYSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihiYXNlTWVyZ2UpO1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6XG4gICAgICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QuYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBvdGhlciA6IHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGN1c3RvbWl6ZXJcbiAgICAgICAgPyBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKVxuICAgICAgICA6IGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSkge1xuICAgICAgICBwcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gY3JlYXRlRGVmYXVsdHMoYXNzaWduLCBhc3NpZ25EZWZhdWx0cyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ3VzZXInOiB7ICduYW1lJzogJ2Jhcm5leScgfSB9LCB7ICd1c2VyJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDM2IH0gfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0gfVxuICAgICAqXG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGNyZWF0ZURlZmF1bHRzKG1lcmdlLCBtZXJnZURlZmF1bHRzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZEtleSA9IGNyZWF0ZUZpbmRLZXkoYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zIGBiYXJuZXlgXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0S2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nXG4gICAgICogYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYScsICdiJywgYW5kICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGNyZWF0ZUZvckluKGJhc2VGb3IpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2MnLCAnYicsIGFuZCAnYScgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICdhJywgJ2InLCBhbmQgJ2MnXG4gICAgICovXG4gICAgdmFyIGZvckluUmlnaHQgPSBjcmVhdGVGb3JJbihiYXNlRm9yUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZyBgaXRlcmF0ZWVgXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJyBhbmQgJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGNyZWF0ZUZvck93bihiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2InIGFuZCAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyBhbmQgJ2InXG4gICAgICovXG4gICAgdmFyIGZvck93blJpZ2h0ID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyxcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAgICogLy8gPT4gWydhZnRlcicsICdhcnknLCAnYXNzaWduJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHVzZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCB0b1BhdGgocGF0aCksIHBhdGggKyAnJyk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiB7ICdjJzogMyB9IH0gfTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcGF0aCk7XG4gICAgICBpZiAoIXJlc3VsdCAmJiAhaXNLZXkocGF0aCkpIHtcbiAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBsYXN0KHBhdGgpO1xuICAgICAgICByZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IChpc0xlbmd0aChvYmplY3QubGVuZ3RoKSAmJiBpc0luZGV4KHBhdGgsIG9iamVjdC5sZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlIHByb3BlcnR5XG4gICAgICogYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzIHVubGVzcyBgbXVsdGlWYWx1ZWAgaXMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlWYWx1ZV0gQWxsb3cgbXVsdGlwbGUgdmFsdWVzIHBlciBrZXkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGBtdWx0aVZhbHVlYFxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCwgdHJ1ZSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggYGl0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIHZhciBtYXBLZXlzID0gY3JlYXRlT2JqZWN0TWFwcGVyKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgZnVuY3Rpb24gaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIG1hcFZhbHVlcyA9IGNyZWF0ZU9iamVjdE1hcHBlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIG9taXQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbMF0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChiYXNlRmxhdHRlbihwcm9wcyksIFN0cmluZyk7XG4gICAgICAgIHJldHVybiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VEaWZmZXJlbmNlKGtleXNJbihvYmplY3QpLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgdmFyIHByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhwcm9wc1swXSwgcHJvcHNbMV0sIDMpO1xuICAgICAgcmV0dXJuIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAsXG4gICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFpcnMoeyAnYmFybmV5JzogMzYsICdmcmVkJzogNDAgfSk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLiBQcm9wZXJ0eVxuICAgICAqIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mIHByb3BlcnR5XG4gICAgICogbmFtZXMuIElmIGBwcmVkaWNhdGVgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGVhY2ggcHJvcGVydHkgb2YgYG9iamVjdGBcbiAgICAgKiBwaWNraW5nIHRoZSBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIF8uaXNTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHByb3BzWzBdID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGJpbmRDYWxsYmFjayhwcm9wc1swXSwgcHJvcHNbMV0sIDMpKVxuICAgICAgICA6IHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kIGl0cyByZXN1bHRcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhLmIuYycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbcGF0aF07XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmICFpc0tleShwYXRoLCBvYmplY3QpKSB7XG4gICAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICAgIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2xhc3QocGF0aCldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdC5jYWxsKG9iamVjdCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIG9uIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgXG4gICAgICogZG9lcyBub3QgZXhpc3QgaXQgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYXVnbWVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ3hbMF0ueS56JywgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHBhdGhLZXkgPSAocGF0aCArICcnKTtcbiAgICAgIHBhdGggPSAob2JqZWN0W3BhdGhLZXldICE9IG51bGwgfHwgaXNLZXkocGF0aCwgb2JqZWN0KSkgPyBbcGF0aEtleV0gOiB0b1BhdGgocGF0aCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgICAgIGlmIChpc09iamVjdChuZXN0ZWQpKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lc3RlZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5lc3RlZFtrZXldID0gaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb24gcG90ZW50aWFsbHkgbXV0YXRpbmdcbiAgICAgKiB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zXG4gICAgICogbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbiwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG4gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCk7XG5cbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBDdG9yIDogW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShpc0Z1bmN0aW9uKEN0b3IpID8gQ3Rvci5wcm90b3R5cGUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG5gIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICtlbmQgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgdmFsdWUgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIGlzIHJldHVybmVkLlxuICAgICAqIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludFxuICAgICAqIG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIGlzSXRlcmF0ZWVDYWxsKG1pbiwgbWF4LCBmbG9hdGluZykpIHtcbiAgICAgICAgbWF4ID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9NYXggJiYgdHlwZW9mIG1pbiA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgbm9NYXggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gKHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2FwaXRhbGl6ZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiAoc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmcgW2xhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZyBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbjEsIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSAodGFyZ2V0ICsgJycpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgbGVuZ3RoKTtcblxuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5pbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIFwiJ1wiLCBhbmQgXCJcXGBcIiwgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWwgY2hhcmFjdGVyc1xuICAgICAqIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIFNlZSBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBCYWNrdGlja3MgYXJlIGVzY2FwZWQgYmVjYXVzZSBpbiBJbnRlcm5ldCBFeHBsb3JlciA8IDksIHRoZXkgY2FuIGJyZWFrIG91dFxuICAgICAqIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy4gU2VlIFsjNTldKGh0dHBzOi8vaHRtbDVzZWMub3JnLyM1OSksXG4gICAgICogWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLCBbIzEwOF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwOCksIGFuZFxuICAgICAqIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZiB0aGUgW0hUTUw1IFNlY3VyaXR5IENoZWF0c2hlZXRdKGh0dHBzOi8vaHRtbDVzZWMub3JnLylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5cyBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpXG4gICAgICogdG8gcmVkdWNlIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAvLyBSZXNldCBgbGFzdEluZGV4YCBiZWNhdXNlIGluIElFIDwgOSBgU3RyaW5nI3JlcGxhY2VgIGRvZXMgbm90LlxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiL1wiLCBcIl5cIiwgXCIkXCIsIFwiLlwiLCBcInxcIiwgXCI/XCIsXG4gICAgICogXCIqXCIsIFwiK1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIgYW5kIFwifVwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOlxcL1xcL2xvZGFzaFxcLmNvbVxcL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhcnMudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhcnMsIGVzY2FwZVJlZ0V4cENoYXIpXG4gICAgICAgIDogKHN0cmluZyB8fCAnKD86KScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBuYXRpdmVGbG9vcihtaWQpLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gbmF0aXZlQ2VpbChtaWQpO1xuXG4gICAgICBjaGFycyA9IGNyZWF0ZVBhZGRpbmcoJycsIHJpZ2h0TGVuZ3RoLCBjaGFycyk7XG4gICAgICByZXR1cm4gY2hhcnMuc2xpY2UoMCwgbGVmdExlbmd0aCkgKyBzdHJpbmcgKyBjaGFycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRMZWZ0ID0gY3JlYXRlUGFkRGlyKCk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICB2YXIgcGFkUmlnaHQgPSBjcmVhdGVQYWREaXIodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCxcbiAgICAgKiBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jRSlcbiAgICAgKiBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IEVTMyBmb3IgYHBhcnNlSW50YC5cbiAgICAgIC8vIENocm9tZSBmYWlscyB0byB0cmltIGxlYWRpbmcgPEJPTT4gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTA5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHJhZGl4LCBndWFyZCkgOiByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0cmltKHN0cmluZyk7XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoc3RyaW5nLCByYWRpeCB8fCAocmVIYXNIZXhQcmVmaXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG4gPSArbjtcbiAgICAgIGlmIChuIDwgMSB8fCAhc3RyaW5nIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMXSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW290aGVyT3B0aW9uc10gRW5hYmxlcyB0aGUgbGVnYWN5IGBvcHRpb25zYCBwYXJhbSBzaWduYXR1cmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVyc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTIGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWBcbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgb3RoZXJPcHRpb25zKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChvdGhlck9wdGlvbnMgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvdGhlck9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25XaXRoKGJhc2VBc3NpZ24oe30sIG90aGVyT3B0aW9ucyB8fCBvcHRpb25zKSwgc2V0dGluZ3MsIGFzc2lnbk93bkRlZmF1bHRzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25XaXRoKGJhc2VBc3NpZ24oe30sIG9wdGlvbnMuaW1wb3J0cyksIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbk93bkRlZmF1bHRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG4gICAgICAgICAgPyBvcHRpb25zLnNvdXJjZVVSTFxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZyksIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzID0gKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbUxlZnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUxlZnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltUmlnaHQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJpZ2h0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0IG9yIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCAyNCk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbi4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyAoK29wdGlvbnMubGVuZ3RoIHx8IDApIDogbGVuZ3RoO1xuICAgICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gK29wdGlvbnMgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAobGVuZ3RoID49IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBvbWlzc2lvbi5sZW5ndGg7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBuZXdFbmQsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpIHx8ICcnKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT0gbnVsbCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbCBIVE1MXG4gICAgICogZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkpIHtcbiAgICAgICAgcGF0dGVybiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuIHx8IHJlV29yZHMpIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSB0aGVcbiAgICAgKiBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYFxuICAgICAqIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluXG4gICAgICogdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaXRlcmF0ZWVcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jYWxsYmFjayA9IF8ud3JhcChfLmNhbGxiYWNrLCBmdW5jdGlvbihjYWxsYmFjaywgZnVuYywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGZ1bmMpO1xuICAgICAqICAgaWYgKCFtYXRjaCkge1xuICAgICAqICAgICByZXR1cm4gY2FsbGJhY2soZnVuYywgdGhpc0FyZyk7XG4gICAgICogICB9XG4gICAgICogICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnXG4gICAgICogICAgICAgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM11cbiAgICAgKiAgICAgICA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FnZV9fZ3QzNicpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSkge1xuICAgICAgICB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZShmdW5jKVxuICAgICAgICA/IG1hdGNoZXMoZnVuYylcbiAgICAgICAgOiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICpcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuIG9iamVjdFxuICAgICAqIGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ubWF0Y2hlcyh7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIG9uIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgXy5tYXRjaGVzUHJvcGVydHkoJ3VzZXInLCAnZnJlZCcpKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb24gYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiBfLmNvbnN0YW50KDIpIH0gfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogXy5jb25zdGFudCgxKSB9IH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iLmMnKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLmludm9rZShfLnNvcnRCeShvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYicsICdjJ10pKSwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IHJlc3RQYXJhbShmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpbnZva2VQYXRoKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvbiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VQYXRoKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIHRoZW4gbWV0aG9kcyBhcmUgYWRkZWQgdG9cbiAgICAgKiBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkXG4gICAgICogIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgdmFyIGlzT2JqID0gaXNPYmplY3Qoc291cmNlKSxcbiAgICAgICAgICAgIHByb3BzID0gaXNPYmogPyBrZXlzKHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpID8gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIShtZXRob2ROYW1lcyA/IG1ldGhvZE5hbWVzLmxlbmd0aCA6IGlzT2JqKSkge1xuICAgICAgICAgIG1ldGhvZE5hbWVzID0gZmFsc2U7XG4gICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lc1tpbmRleF0sXG4gICAgICAgICAgICBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuXG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBhcnJheUNvcHkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oZnVuYykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdW5kZWZpbmVkYCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhdCBgcGF0aGAgb24gYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAyIH0gfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogMSB9IH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmIuYycpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYicsICdjJ10pKSwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHBhdGgpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHByb3BlcnR5IHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgdG9QYXRoKHBhdGgpLCBwYXRoICsgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCBpdCBpc1xuICAgICAqIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuIElmIGBlbmRgIGlzIGxlc3MgdGhhbiBgc3RhcnRgXG4gICAgICogYSB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBudW1iZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmIChzdGVwICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiAoK3N0ZXAgfHwgMCk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgLy8gVXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1cyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggaW52b2NhdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYsIGZhbHNlKSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIG1hZ2UuY2FzdFNwZWxsKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcyB3aXRoIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYFxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7XG4gICAgICogICB0aGlzLmNhc3Qobik7XG4gICAgICogfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgbiA9IG5hdGl2ZUZsb29yKG4pO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IHRvIGF2b2lkIGEgSlNDIEpJVCBidWcgaW4gU2FmYXJpIDhcbiAgICAgIC8vIHdoZXJlIGBBcnJheSgwKWAgaXMgdHJlYXRlZCBhcyBgQXJyYXkoMSlgLlxuICAgICAgaWYgKG4gPCAxIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCkpO1xuXG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaWYgKGluZGV4IDwgTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBiYXNlVG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciB0byBhZGQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuICgrYXVnZW5kIHx8IDApICsgKCthZGRlbmQgfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBgbmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBgbmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG4gICAgICogYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gLUluZmluaXR5XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heCh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICovXG4gICAgdmFyIG1heCA9IGNyZWF0ZUV4dHJlbXVtKGd0LCBORUdBVElWRV9JTkZJTklUWSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGVtcHR5IG9yIGZhbHNleVxuICAgICAqIGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4odXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIG1pbiA9IGNyZWF0ZUV4dHJlbXVtKGx0LCBQT1NJVElWRV9JTkZJTklUWSk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCA2XSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIF8uc3VtKHsgJ2EnOiA0LCAnYic6IDYgfSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnbic6IDQgfSxcbiAgICAgKiAgIHsgJ24nOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zdW0ob2JqZWN0cywgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICByZXR1cm4gb2JqZWN0Lm47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zdW0ob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUubGVuZ3RoID09IDFcbiAgICAgICAgPyBhcnJheVN1bShpc0FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHRvSXRlcmFibGUoY29sbGVjdGlvbiksIGl0ZXJhdGVlKVxuICAgICAgICA6IGJhc2VTdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYE1hcGAgY2FjaGUuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcERlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcFNldDtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBTZXRgIGNhY2hlLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbmRleEJ5ID0gaW5kZXhCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubW9kQXJncyA9IG1vZEFyZ3M7XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXN0UGFyYW0gPSByZXN0UGFyYW07XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydEJ5QWxsID0gc29ydEJ5QWxsO1xuICAgIGxvZGFzaC5zb3J0QnlPcmRlciA9IHNvcnRCeU9yZGVyO1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5iYWNrZmxvdyA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kV2hlcmU7XG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRMZWZ0ID0gcGFkTGVmdDtcbiAgICBsb2Rhc2gucGFkUmlnaHQgPSBwYWRSaWdodDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG4gICAgbG9kYXNoLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbiAgICBsb2Rhc2gudHJ1bmMgPSB0cnVuYztcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guZXEgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICAgIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgICBsb2Rhc2guZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgY2FwYWJsZSBvZiByZXR1cm5pbmcgd3JhcHBlZCBhbmQgdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgICBsb2Rhc2gucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmICghdGhpcy5fX2NoYWluX18gJiYgbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh2YWx1ZSwgbik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICAgIGlmIChmaWx0ZXJlZCAmJiAhaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuID09IG51bGwgPyAxIDogbmF0aXZlTWF4KG5hdGl2ZUZsb29yKG4pIHx8IDAsIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGlmIChmaWx0ZXJlZCkge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKHJlc3VsdC5fX3Rha2VDb3VudF9fLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goeyAnc2l6ZSc6IG4sICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlICE9IExBWllfTUFQX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goeyAnaXRlcmF0ZWUnOiBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSksICd0eXBlJzogdHlwZSB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZmlyc3RgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydmaXJzdCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnJlc3RgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAncmVzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLnBsdWNrYCBhbmQgYF8ud2hlcmVgLlxuICAgIGFycmF5RWFjaChbJ3BsdWNrJywgJ3doZXJlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IGluZGV4ID8gJ2ZpbHRlcicgOiAnbWFwJyxcbiAgICAgICAgICBjcmVhdGVDYWxsYmFjayA9IGluZGV4ID8gYmFzZU1hdGNoZXMgOiBwcm9wZXJ0eTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbb3BlcmF0aW9uTmFtZV0oY3JlYXRlQ2FsbGJhY2sodmFsdWUpKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9ICgrZW5kIHx8IDApO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUsIHRoaXNBcmcpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpmaXJzdHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtyZXRVbndyYXBwZWQgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByZXRVbndyYXBwZWQgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAocmV0VW53cmFwcGVkICYmIGNoYWluQWxsKVxuICAgICAgICAgICAgPyBsb2Rhc2hGdW5jKHZhbHVlLCAxKVswXVxuICAgICAgICAgICAgOiBsb2Rhc2hGdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWN0aW9uID0geyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCkge1xuICAgICAgICAgIGlmIChvbmx5TGF6eSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2Rhc2hGdW5jLmNhbGwodW5kZWZpbmVkLCB0aGlzLnZhbHVlKCkpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydqb2luJywgJ3BvcCcsICdwdXNoJywgJ3JlcGxhY2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAnc3BsaXQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9ICgvXig/OnJlcGxhY2V8c3BsaXQpJC8udGVzdChtZXRob2ROYW1lKSA/IHN0cmluZ1Byb3RvIDogYXJyYXlQcm90bylbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpqb2lufHBvcHxyZXBsYWNlfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcy52YWx1ZSgpLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgZnVuY3Rpb24gbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lLFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XG5cbiAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZFdyYXBwZXIodW5kZWZpbmVkLCBCSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7ICduYW1lJzogJ3dyYXBwZXInLCAnZnVuYyc6IHVuZGVmaW5lZCB9XTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGxhenkgd3JhcHBlci5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW5pbmcgZnVuY3Rpb25zIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uY2F0ID0gd3JhcHBlckNvbmNhdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5ydW4gPSBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb24gYWxpYXNlcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbGxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLm1hcDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmhlYWQgPSBsb2Rhc2gucHJvdG90eXBlLmZpcnN0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuc2VsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5maWx0ZXI7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50YWlsID0gbG9kYXNoLnByb3RvdHlwZS5yZXN0O1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBsb2Rhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgdG8gYXZvaWRcbiAgICAvLyBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgbG9kYXNoIGlzIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgYW5kIG5vdCBpbnRlbmRlZFxuICAgIC8vIGFzIGFuIEFNRCBtb2R1bGUuIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvclxuICAgIC8vIG1vcmUgZGV0YWlscy5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcyBvciBSaW5nb0pTLlxuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIEV4cG9ydCBmb3IgUmhpbm8gd2l0aCBDb21tb25KUyBzdXBwb3J0LlxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3IgYSBicm93c2VyIG9yIFJoaW5vLlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKlxyXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXHJcbipcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB7fTtcclxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBXZSBjYW4ndCBidWlsZCBhIHJlYWwgbWV0aG9kIHdpdGhvdXQgYSBjb25zb2xlIHRvIGxvZyB0b1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2dNZXRob2RzID0gW1xyXG4gICAgICAgIFwidHJhY2VcIixcclxuICAgICAgICBcImRlYnVnXCIsXHJcbiAgICAgICAgXCJpbmZvXCIsXHJcbiAgICAgICAgXCJ3YXJuXCIsXHJcbiAgICAgICAgXCJlcnJvclwiXHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XHJcbiAgICAgICAgICAgIHNlbGZbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/IG5vb3AgOiBzZWxmLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XHJcbiAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddID0gbGV2ZWxOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gXCJsb2dsZXZlbD1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkUGVyc2lzdGVkTGV2ZWwoKSB7XHJcbiAgICAgICAgdmFyIHN0b3JlZExldmVsO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbJ2xvZ2xldmVsJ107XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9sb2dsZXZlbD0oW147XSspLy5leGVjKHdpbmRvdy5kb2N1bWVudC5jb29raWUpWzFdO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IFwiV0FSTlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFB1YmxpYyBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xyXG5cclxuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcclxuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBzZWxmLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKTtcclxuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjEwLjZcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc0FNb21lbnRPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fc3RyaWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3R6bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc1VUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3BmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbG9jYWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKCkge1xuICAgIH1cblxuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdIHx8IG5ldyBMb2NhbGUoKTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3VuaXRzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbiAoc3RoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMzI1XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RoID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RoKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICB2YXIgZnJvbV9zdHJpbmdfX2lzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC8oVHwgKVxcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZnJvbV9zdHJpbmdfX2lzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gKG1hdGNoWzZdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaChtYXRjaE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gJ1onO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IGxvY2FsX19jcmVhdGVMb2NhbChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIHdlZWsxSmFuID0gNiArIGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3REYXlPZldlZWtPZlllYXIsIGphblggPSBjcmVhdGVVVENEYXRlKHllYXIsIDAsIDEgKyB3ZWVrMUphbiksIGQgPSBqYW5YLmdldFVUQ0RheSgpLCBkYXlPZlllYXI7XG4gICAgICAgIGlmIChkIDwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgICAgIGQgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHdlZWtkYXkgPSB3ZWVrZGF5ICE9IG51bGwgPyAxICogd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyB3ZWVrMUphbiArIDcgKiAod2VlayAtIDEpIC0gZCArIHdlZWtkYXk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCBkb3csIGRveSkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoT2Zmc2V0KSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2lzRFNUU2hpZnRlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBjcmVhdGVfX2lzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGNyZWF0ZV9faXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChmb3JtYXRzICYmIGZvcm1hdHNbZm9ybWF0XSB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpICYmIHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyksXG4gICAgICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0LFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkX19pc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgMCwgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gdGhpcy5fd2Vla2RheXNQYXJzZSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgID0gY2xvbmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgPSBmb3JtYXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICA9IHRvO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICA9IHRvT2JqZWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICA9IHRvU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG5cbiAgICAvLyBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgLy8gV2VlayBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgIC8vIFF1YXJ0ZXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgIC8vIE1vbnRoXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgIC8vIFdlZWtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgIC8vIERheVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgLy8gSG91clxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgLy8gTWludXRlXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAvLyBTZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAvLyBPZmZzZXRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLl9jYWxlbmRhciAgICAgICA9IGRlZmF1bHRDYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWwgICAgICAgID0gZGVmYXVsdE9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgIC8vIE1vbnRoXG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRocyAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1BhcnNlICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcblxuICAgIC8vIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzICAgICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgY291bnQsIHNldHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzJywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0JywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3QgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgID09PSAxICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA9PT0gMSAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPT09IDEgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgID09PSAxICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTAuNic7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIFJlcHJlc2VudCBhIHBsYXlhYmxlIHNldCBvZiBzb3VuZHMgaW5jbHVkaW5nIGEgZGVzY3JpcHRpdmUga2V5LCBhbiBhdWRpbyBzcHJpdGUsIGFuZCB0aGUgc2V0IG9mIHNvdW5kIGtleXMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoa2V5LCBzcHJpdGUsIHNvdW5kcykge1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgICAgIHRoaXMuc291bmRzID0gc291bmRzOyAvLyBqc29uIHNldCBvZiBzb3VuZHMuXHJcblxyXG4gICAgICAgICAgICBfLmVhY2goc291bmRzLCBmdW5jdGlvbiAodGltaW5nLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFkZE1hcmtlcihrZXksIHRpbWluZ1swXSwgdGltaW5nWzFdLCAxLCB0aW1pbmdbMl0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgb25TdG9wOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLm9uU3RvcC5hZGQodGhpcy5vblNvdW5kRmluaXNoZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWxsb3dNdWx0aXBsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFsbG93TXVsdGlwbGUgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNDdXJyZW50TWFya2VyOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlLmN1cnJlbnRNYXJrZXIgPT09IGtleTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUGxheWluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZS5pc1BsYXlpbmc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRDaGFubmVsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzS2V5OiBmdW5jdGlvbigga2V5ICkge1xyXG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5zb3VuZHNba2V5XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigga2V5ICkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5wbGF5KGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc3RvcCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcE5vRXZlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5vblN0b3AucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUub25TdG9wLmFkZCh0aGlzLm9uU291bmRGaW5pc2hlZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblNvdW5kRmluaXNoZWQ6IGZ1bmN0aW9uIChzdG9wcGVkU291bmQsIG1hcmtlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vblN0b3AuZGlzcGF0Y2goc3RvcHBlZFNvdW5kLCBtYXJrZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLm9uU3RvcC5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc3RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogaHR0cHM6Ly9waGFzZXJnYW1lcy5jb20vcGhhc2VyLWF1ZGlvLWRlbGF5L1xyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG4gICAgdmFyIEF1ZGlvQ2hhbm5lbCA9IHJlcXVpcmUoJy4vYXVkaW8tY2hhbm5lbCcpO1xyXG4gICAgdmFyIENIQU5ORUxfUFJJTUFSWSA9IFwicHJpbWFyeVwiO1xyXG4gICAgdmFyIENIQU5ORUxfTVVTSUMgPSBcInNlY29uZGFyeVwiO1xyXG4gICAgdmFyIENIQU5ORUxfU0ZYID0gXCJzZnhcIjtcclxuICAgIC8vdmFyIGJ1aWxkQXVkaW9MaXBTeW5jQXJyYXkgPSByZXF1aXJlKCcuLi90b29scy9hdWRpby1saXAtc3luYycpOyAvL2NvbW1lbnQgb3V0IHdoZW4gZG9uZVxyXG5cclxuICAgIHZhciBBdWRpb1NlcnZpY2UgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChnYW1lLCB0aGVtZURhdGEpIHtcclxuICAgICAgICAgICAgaWYgKCFnYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkF1ZGlvU2VydmljZSByZXF1aXJlcyBnYW1lIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhlbWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkF1ZGlvU2VydmljZSByZXF1aXJlcyB0aGVtZURhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb1F1ZXVlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgc291bmRGaW5pc2hlZDogbmV3IFBoYXNlci5TaWduYWwoKSxcclxuICAgICAgICAgICAgICAgIG9uU2NlbmVBdWRpb1JlYWR5OiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBhIHNjZW5lIHNob3dpbmcsIGVuZCBpdC5cclxuICAgICAgICAgKiBAVE9ETyBhbGxvdyB0aGlzIHRvIHJlbW92ZSBmcm9tIGNhY2hlP1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0b3BBbmRVbmxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHRoaXMuY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBTdG9wIHRoZSBjdXJyZW50IHNjZW5lIGFuZCBjbGVhbiBpdCB1cC5cclxuICAgICAgICBzdG9wU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tDSEFOTkVMX1BSSU1BUlldLnN0b3BOb0V2ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9NVVNJQ10pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9NVVNJQ10uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW0NIQU5ORUxfU0ZYXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tDSEFOTkVMX1NGWF0uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzb21ldGhpbmcgc3RhcnRzIHRvIHBsYXkgYXVkaW8sIGl0IGRvZXMgaXQgdmlhIGFuIGV2ZW50LCB0aGlzIGFsbG93cyBmb3IgdGVsbGluZyB0aGUgb3RoZXIgYWN0b3JzLCB0aGVcclxuICAgICAgICAgKiBzY2VuZSwgYWN0IGFuZCB0aGUgcGxheS4gSW4gdGhpcyBjYXNlLCB3ZSBhbHNvIHdhbnQgdG8gc3RvcCBhbnkgcHJldmlvdXNseSBwbGF5aW5nIHNvdW5kLlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHNwZWVjaCBpcyBhbHdheXMgdHJhY2tlZCBzbyB3ZSBjYW4gaGF2ZSBldmVudGluZyBvbiB3aGVuIGl0IHN0b3BzLlxyXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHtcclxuICAgICAgICAgKiAgdGV4dDogXCJcIixcclxuICAgICAgICAgKiAgXCJhdWRpb1wiOiBcIlwiLFxyXG4gICAgICAgICAqICBcImtleVwiOiBcIlwiLFxyXG4gICAgICAgICAqICBcImNoYW5uZWxcIjogb3B0aW9uYWwgY2hhbm5lbCwgZGVmYXVsdHMgdG8gcHJpbWFyeSwgc3dpdGNoZWQgdG8gc2Z4IGZvciBzZnhcclxuICAgICAgICAgKiAgXCJwcmlvcml0eVwiOiBzdG9wIHwgcmVzdGFydCB8IHF1ZXVlIHwgbG93IHwgd2l0aCB8IHN0b3BhbGxcclxuICAgICAgICAgKiAgXCJzdG9wXCI6ICA9PiBzdG9wIGF1ZGlvIGlmIHBsYXlpbmcgdGhlIHNhbWUgc291bmQuXHJcbiAgICAgICAgICogIFwicmVzdGFydFwiOiAgUmVzdGFydCBhdWRpbyBpZiBwbGF5aW5nIHRoZSBzYW1lIHNvdW5kLlxyXG4gICAgICAgICAqICBcInF1ZXVlXCI6IFF1ZXVlIHRoZSBhdWRpbyB0byBwbGF5IG5leHQsIHdpbGwgcGxheSBub3cgaWYgbm8gcXVldWUuXHJcbiAgICAgICAgICogIFwibG93XCI6IElnbm9yZSByZXF1ZXN0IGlmIHNvdW5kIGlzIHBsYXlpbmdcclxuICAgICAgICAgKiAgXCJzdG9wYWxsXCIgOiBzdG9wYWxsIHNvdW5kLCBpZ25vcmUgYXVkaW8ga2V5LlxyXG4gICAgICAgICAqICBkZWZhdWx0L2ludGVycnVwdDogSW50ZXJydXB0IHRoZSBjdXJyZW50IHNvdW5kIGFuZCBwbGF5IHRoZSBuZXcgb25lLCBlbXB0eWluZyB0aGUgcXVldWUuXHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBsYXlBdWRpbzogZnVuY3Rpb24gKGF1ZGlvLCBkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNhbGxpbmcgcGxheUF1ZGlvXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZGF0YS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wcmlvcml0eSA9IFwiaW50ZXJydXB0XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZGF0YS5jaGFubmVsKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmNoYW5uZWwgPSBDSEFOTkVMX1BSSU1BUlk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFubmVsc1tDSEFOTkVMX1BSSU1BUlldKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkF0dGVtcHRpbmcgdG8gcGxheSBhdWRpbyBiZWZvcmUgZ2FtZSBzb3VuZHMgYXJlIGluaXRpYWxpemVkLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuZmluZENoYW5uZWxGb3JLZXkoYXVkaW8sIGRhdGEuY2hhbm5lbCk7XHJcbiAgICAgICAgICAgIGlmICghY2hhbm5lbCApIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgYWN0aXZpdGllcyBwbGF5IFwic2lsZW5jZVwiLCByYXRoZXIgdGhhbiBhZGp1c3RpbmcgdGhlIGNvbnZlcnRlZCBYTUwsIHdlIHN1cHBvcnQgaXQuXHJcbiAgICAgICAgICAgICAgICBpZiggYXVkaW8gPT09IFwic2lsZW5jZVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcmlvcml0eSA9IFwic3RvcGFsbFwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlJlcXVlc3QgdG8gcGxheSB1bmtub3duIGtleTogXCIgKyBhdWRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdhbWVTb3VuZHMgPSB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RvcGFsbCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdG9wJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3RvcCBpcyBhbHdheXMgYSBzdG9wLCBzbyBlaXRoZXIgc3RvcCBvciBkbyBub3RoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmlzUGxheWluZyAmJiBjaGFubmVsLmlzQ3VycmVudE1hcmtlcihhdWRpbykgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZXN0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmlzUGxheWluZyAmJiBjaGFubmVsLmlzQ3VycmVudE1hcmtlcihhdWRpbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAncXVldWUnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuaXNQbGF5aW5nKCkgJiYgIWNoYW5uZWwuaXNDdXJyZW50TWFya2VyKGF1ZGlvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvUXVldWUucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaWxsIGZhbGwgdGhyb3VnaCBhbmQgcGxheSB0aGUgc291bmQuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb3cnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NmeCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gdGhpcy5maW5kQ2hhbm5lbEZvcktleShhdWRpbywgJ3NmeCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hhbm5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlJlcXVlc3QgdG8gcGxheSB1bmtub3duIHNmeCBrZXk6IFwiICsgYXVkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwucGxheShhdWRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ludGVycnVwdCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbC5pc1BsYXlpbmcoKSAmJiBjaGFubmVsLmlzQ3VycmVudE1hcmtlcihhdWRpbykgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcGxheWluZywganVzdCBrZWVwIHBsYXlpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiUGxheWluZyBhdWRpbyBcIiArIGF1ZGlvKTtcclxuICAgICAgICAgICAgY2hhbm5lbC5wbGF5KGF1ZGlvKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXJ0IGJ5IHRyeWluZyB0byBnZXQgdGhlIHByZWZlcnJlZCBjaGFubmVsLCBidXQgb3RoZXJ3aXNlIHNlYXJjaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5kQ2hhbm5lbEZvcktleTogZnVuY3Rpb24gKGtleSwgcHJlZmVycmVkQ2hhbm5lbCkge1xyXG4gICAgICAgICAgICB2YXIgcHJlZmVycmVkID0gdGhpcy5jaGFubmVsc1twcmVmZXJyZWRDaGFubmVsXTtcclxuICAgICAgICAgICAgaWYgKHByZWZlcnJlZCAmJiBwcmVmZXJyZWQuaGFzS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmZXJyZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uZmluZCh0aGlzLmNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWwuaGFzS2V5KGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lTXVzaWM6IGZ1bmN0aW9uIChhdWRpbykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfTVVTSUNdLnBsYXkoYXVkaW8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiBhdWRpbyBmaW5pc2hlcyBwbGF5aW5nLCBhY3RvcnMgbmVlZCB0byBrbm93LCBpbiBjYXNlIHRoZXkgYXJlIGFuaW1hdGluZyBzcGVlY2gvZXRjLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uU291bmRGaW5pc2hlZDogZnVuY3Rpb24gKHN0b3BwZWRTb3VuZCwgbWFya2VyKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiT24gc291bmQgRmluaXNoZWQgY2FsbGVkIGZvcjogXCIgKyBtYXJrZXIpO1xyXG4gICAgICAgICAgICBsb2cud2FybihzdG9wcGVkU291bmQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuc291bmRGaW5pc2hlZC5kaXNwYXRjaChzdG9wcGVkU291bmQsIG1hcmtlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb1F1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5hdWRpb1F1ZXVlLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oZGF0YS5hdWRpbywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRTb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gVW5jb21tZW50IHRoaXMgbGluZSBhbmQgeW91IHdpbGwgcHJvZHVjZSBsaXAgc3luYyBkYXRhLlxyXG4gICAgICAgICAgICAvL2J1aWxkQXVkaW9MaXBTeW5jQXJyYXkodGhpcy50aGVtZS5zb3VuZEZpbGVbMF0sIHRoaXMudGhlbWUuc291bmRzLCB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGEpOyAvL2NvbW1lbnQgb3V0IHdoZW4gZG9uZVxyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV0gPSBuZXcgQXVkaW9DaGFubmVsKHRoaXMudGhlbWUuc291bmRLZXksIHRoaXMuZ2FtZS5hZGQuYXVkaW8odGhpcy50aGVtZS5zb3VuZEtleSksIHRoaXMudGhlbWUuc291bmRzKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tDSEFOTkVMX01VU0lDXSA9IG5ldyBBdWRpb0NoYW5uZWwodGhpcy50aGVtZS5zb3VuZEtleSwgdGhpcy5nYW1lLmFkZC5hdWRpbyh0aGlzLnRoZW1lLnNvdW5kS2V5KSwgdGhpcy50aGVtZS5zb3VuZHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfU0ZYXSA9IG5ldyBBdWRpb0NoYW5uZWwodGhpcy50aGVtZS5zb3VuZEtleSwgdGhpcy5nYW1lLmFkZC5hdWRpbyh0aGlzLnRoZW1lLnNvdW5kS2V5KSwgdGhpcy50aGVtZS5zb3VuZHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfUFJJTUFSWV0uYWxsb3dNdWx0aXBsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW0NIQU5ORUxfTVVTSUNdLmFsbG93TXVsdGlwbGUoKTtcclxuICAgICAgICAgICAgLy90aGlzLmdhbWVTb3VuZHMub25NYXJrZXJDb21wbGV0ZS5hZGQodGhpcy5vblNvdW5kRmluaXNoZWQsIHRoaXMpOyBUaGlzIGV2ZW50IGRvZXNuJ3QgZG8gd2hhdCB5b3UgdGhpbmsuXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbQ0hBTk5FTF9QUklNQVJZXS5ldmVudHMub25TdG9wLmFkZCh0aGlzLm9uU291bmRGaW5pc2hlZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHRoZSBvbGQgbG9hZGluZyBmdW5jdGlvbnMgdXNlZCBieSBwbGF5LWFjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRBdWRpbzogZnVuY3Rpb24gKHNvdW5kS2V5LCBzb3VuZEZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWQuYXVkaW8oc291bmRLZXksIHNvdW5kRmlsZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmxvYWRBdWRpbzogZnVuY3Rpb24gKHNvdW5kS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5jYWNoZS5yZW1vdmVTb3VuZChzb3VuZEtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1JlYWR5OiBmdW5jdGlvbiAoc291bmRLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZS5jYWNoZS5pc1NvdW5kRGVjb2RlZChzb3VuZEtleSlcclxuICAgICAgICAgICAgICAgICYmIHRoaXMuZ2FtZS5jYWNoZS5pc1NvdW5kUmVhZHkoc291bmRLZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlc2UgYXJlIHRoZSBuZXdlciBmdW5jdGlvbnMgd2hpY2ggc2hvdyB0aGUgbG9hZGluZyBzY3JlZW4gZHVyaW5nIGR5bmFtaWMgbG9hZGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLnNob3coKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWRBZGRpdGlvbmFsQXVkaW86IGZ1bmN0aW9uIChhdWRpb0xpc3QpIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvTGlzdCAmJiBhdWRpb0xpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIF8uZWFjaChhdWRpb0xpc3QsIGZ1bmN0aW9uIChhdWRpb0tleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvclNvdW5kRGF0YSA9IHRoaXMudGhlbWUuYWN0b3JTb3VuZHNbYXVkaW9LZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWN0b3JTb3VuZERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJObyBhdWRpbyBlbnRyeSBmb3IgYXVkaW8ga2V5OiBcIiArIGF1ZGlvS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETyBqdXN0IGdvIGFoZWFkIGFuZCBsb2FkIHRoZSBqc29uIGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvIGJlIGNvcGllZCBpbiFcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5hdWRpbyhhdWRpb0tleSwgYWN0b3JTb3VuZERhdGEuc291bmRGaWxlKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9MaXN0ID0gYXVkaW9MaXN0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWQub25Mb2FkQ29tcGxldGUuYWRkT25jZSh0aGlzLndhaXRGb3JBdWRpb0RlY29kZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5zdGFydCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z091dHB1dCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25TY2VuZUF1ZGlvUmVhZHkuZGlzcGF0Y2godHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubG9hZEFkZGl0aW9uYWxBdWRpbzogZnVuY3Rpb24gKGF1ZGlvTGlzdCkge1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9MaXN0ICYmIGF1ZGlvTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGF1ZGlvTGlzdCwgZnVuY3Rpb24gKGF1ZGlvS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5jaGFubmVsc1thdWRpb0tleV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1thdWRpb0tleV0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWxzW2F1ZGlvS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWUuY2FjaGUucmVtb3ZlU291bmQoYXVkaW9LZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhaXRGb3JBdWRpb0RlY29kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYWxsUmVhZHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWRpbmdTY3JlZW4uc2hvd0RlY29kaW5nKCk7XHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmF1ZGlvTGlzdCwgZnVuY3Rpb24gKGF1ZGlvS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nYW1lLmNhY2hlLmNoZWNrU291bmRLZXkoYXVkaW9LZXkpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNjZW5lIHdhcyBzb21laG93IGRlc3Ryb3llZCBiZWZvcmUgaXQgZmluaXNoZWQgbG9hZGluZyBpdCdzIGF1ZGlvLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nYW1lLmNhY2hlLmlzU291bmREZWNvZGVkKGF1ZGlvS2V5KSB8fCAhdGhpcy5nYW1lLmNhY2hlLmlzU291bmRSZWFkeShhdWRpb0tleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxSZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbGxSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDaGFubmVscyh0aGlzLmF1ZGlvTGlzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvTGlzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZGluZ1NjcmVlbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnT3V0cHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vblNjZW5lQXVkaW9SZWFkeS5kaXNwYXRjaCh0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoXy5iaW5kKHRoaXMud2FpdEZvckF1ZGlvRGVjb2RlLCB0aGlzKSwgNTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVidWdPdXRwdXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyB2YXIgY2hhbm5lbE5hbWVzID0gW107XHJcbiAgICAgICAgICAgIC8vIHZhciBjYWNoZU5hbWVzID0gW107XHJcbiAgICAgICAgICAgIC8vIF8uZWFjaCggdGhpcy5jaGFubmVscywgZnVuY3Rpb24oY2hhbm5lbCwga2V5KSB7XHJcbiAgICAgICAgICAgIC8vICAgICBjaGFubmVsTmFtZXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAvLyB9LCB0aGlzKTtcclxuICAgICAgICAgICAgLy8gXy5lYWNoKCB0aGlzLmdhbWUuY2FjaGUuZ2V0S2V5cyhQaGFzZXIuQ2FjaGUuU09VTkQpLCBmdW5jdGlvbigga2V5KSB7XHJcbiAgICAgICAgICAgIC8vICAgICBjYWNoZU5hbWVzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgLy8gfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIkF2YWlsYWJsZSBDaGFubmVscyBmb3Igc2NlbmU6IFwiICsgY2hhbm5lbE5hbWVzLmpvaW4oXCIsIFwiKSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIkF2YWlsYWJsZSBDaGFubmVscyBpbiBjYWNoZTogXCIgKyBjaGFubmVsTmFtZXMuam9pbihcIiwgXCIpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUNoYW5uZWxzOiBmdW5jdGlvbiggYXVkaW9MaXN0ICkge1xyXG4gICAgICAgICAgICBfLmVhY2goYXVkaW9MaXN0LCBmdW5jdGlvbiAoYXVkaW9LZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RvclNvdW5kRGF0YSA9IHRoaXMudGhlbWUuYWN0b3JTb3VuZHNbYXVkaW9LZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RvclNvdW5kRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm8gYXVkaW8gZW50cnkgZm9yIExPQURFRCBhdWRpbyBrZXk6IFwiICsgYXVkaW9LZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2F1ZGlvS2V5XSA9IG5ldyBBdWRpb0NoYW5uZWwoYXVkaW9LZXksIHRoaXMuZ2FtZS5hZGQuYXVkaW8oYXVkaW9LZXkpLCBhY3RvclNvdW5kRGF0YS5zb3VuZHMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF1ZGlvU2VydmljZTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8yMi8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogUmV0dXJuIGFuIGFjdCBpbnN0YW5jZSBnaXZlbiBhIHR5cGUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgIFBsYXlBY3QgPSByZXF1aXJlKCcuL3BsYXktYWN0Jyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgZ2V0QWN0SW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBnYW1lLCB0aGVtZURhdGEsIGFjdE5hbWUpIHtcclxuICAgICAgICAgICAgaWYoIHR5cGUgJiYgdHlwZSAhPT0gXCJQbGF5QWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhenogPSB3aW5kb3dbdHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiggY2xhenogKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdEluc3RhbmNlID0gbmV3IGNsYXp6KGdhbWUsICB0aGVtZURhdGEsIGFjdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdEluc3RhbmNlLmFjdE5hbWUgPSBhY3ROYW1lOyAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gZnVubnkgYnVzaW5lc3MuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdEluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJVbmFibGUgdG8gbG9hZCBhY3Rpdml0eTogXCIgKyB0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGxheUFjdChnYW1lLCB0aGVtZURhdGEsIGFjdE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogUmVwcmVzZW50IGFuIGVudGlyZSBBQ1QuIEFuIGFjdCBjb29yZGluYXRlcyBhIHNldCBvZiBzY2VuZXMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdHZhciBfID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuXHRcdGxvZyA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKSxcclxuXHRcdEJhc2UgPSByZXF1aXJlKFwiYmFzZWpzXCIpLFxyXG5cdFx0UGxheVNjZW5lID0gcmVxdWlyZShcIi4uL3NjZW5lL3BsYXktc2NlbmVcIiksXHJcblx0XHRQbGF5QWN0aW9uID0gcmVxdWlyZShcIi4uL3NjZW5lL3BsYXktYWN0aW9uXCIpLFxyXG5cdFx0UGxheU1vZGVsID0gcmVxdWlyZShcIi4uL3BsYXkvbW9kZWxcIiksXHJcblx0XHRBY3RWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JcIik7XHJcblx0dmFyIEF1ZGlvU2VydmljZSA9IHJlcXVpcmUoXCIuL2F1ZGlvLXNlcnZpY2VcIik7XHJcblxyXG5cdHZhciBQbGF5QWN0ID0gQmFzZS5leHRlbmQoe1xyXG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChnYW1lLCB0aGVtZURhdGEsIGFjdE5hbWUpIHtcclxuXHRcdFx0aWYgKCFnYW1lKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJQbGF5QWN0IHJlcXVpcmVzIGdhbWUgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCF0aGVtZURhdGEpIHtcclxuXHRcdFx0XHR0aHJvdyBcIlBsYXlBY3QgcmVxdWlyZXMgdGhlbWVEYXRhIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2FtZSA9IGdhbWU7XHJcblx0XHRcdHRoaXMudGhlbWUgPSB0aGVtZURhdGE7XHJcblx0XHRcdHRoaXMuYWN0TmFtZSA9IGFjdE5hbWU7XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlID0gbmV3IEF1ZGlvU2VydmljZSh0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG5cclxuXHRcdFx0dGhpcy5ldmVudHMgPSB7XHJcblx0XHRcdFx0b25HYW1lQ2hvaWNlOiBuZXcgUGhhc2VyLlNpZ25hbCgpLFxyXG5cdFx0XHRcdG9uQWN0U3RhdHVzOiBuZXcgUGhhc2VyLlNpZ25hbCgpLFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5pc1ByZWxvYWRlZCA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdHNldFNjb3JtU3RyaW5nOiBmdW5jdGlvbiAoc3VzcGVuZERhdGEpIHtcclxuXHRcdFx0dGhpcy5zdXNwZW5kRGF0YSA9IHN1c3BlbmREYXRhO1xyXG5cdFx0fSxcclxuXHRcdGdldFNjb3JtU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLm1vZGVsLmdldFN1c3BlbmREYXRhKCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTaG93IHRoZSBjdXJyZW50IHNjZW5lLCBjbGVhcmluZyBvdXQgYW55IG9sZCBzY2VuZS4gSWYgdGhlcmUgaXMgYSBzb3VuZCBwbGF5aW5nLCBzdG9wIGl0LiBUaGlzIGZyZWVzIHVwXHJcblx0XHQgKiBtZW1vcnksIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNvdWxkIHBvc3NpYmx5IHJlY3ljbGUgYWN0b3JzLlxyXG5cdFx0ICovXHJcblx0XHRzdGFydDogZnVuY3Rpb24gKGlzUmVzdGFydCkge1xyXG5cdFx0XHRsb2cud2FybihcInNob3dDdXJyZW50U2NlbmUgY2FsbGVkLlwiKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLnN1c3BlbmREYXRhKSB7XHJcblx0XHRcdFx0dGhpcy5tb2RlbC5yZXN0b3JlRGF0YSh0aGlzLnN1c3BlbmREYXRhKTtcclxuXHRcdFx0XHR0aGlzLnN1c3BlbmREYXRhID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm1vZGVsLmV2ZW50cy5vbkdhbWVPdXRjb21lLmFkZCh0aGlzLm9uR2FtZU91dGNvbWUsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5pbml0U291bmRzKCk7XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLmV2ZW50cy5vblNjZW5lQXVkaW9SZWFkeS5hZGQoXHJcblx0XHRcdFx0dGhpcy5vblNjZW5lU3RhcnRBdWRpb1JlYWR5LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2UuZXZlbnRzLnNvdW5kRmluaXNoZWQuYWRkKHRoaXMub25Tb3VuZEZpbmlzaGVkLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmIChpc1Jlc3RhcnQpIHtcclxuXHRcdFx0XHRsb2cud2FybihcIlRyeWluZyB0byByZXN0YXJ0Li4uXCIgKyB0aGlzLm1vZGVsLmdldEN1cnJlbnRTY2VuZU5hbWUoKSk7XHJcblx0XHRcdFx0dGhpcy5tb2RlbC50cnlSZXN1bWUoKTtcclxuXHRcdFx0XHRsb2cud2FybihcIi4uLi4uXCIgKyB0aGlzLm1vZGVsLmdldEN1cnJlbnRTY2VuZU5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zdGFydFNjZW5lKCk7XHJcblx0XHR9LFxyXG5cdFx0c3RhcnRTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgbmV3U2NlbmVEYXRhID0gdGhpcy5tb2RlbC5nZXRDdXJyZW50U2NlbmUoKTtcclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc2hvd05ld1NjZW5lRGF0YShuZXdTY2VuZURhdGEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lID0gbmV3IFBsYXlTY2VuZShcclxuXHRcdFx0XHRcdHRoaXMuZ2FtZSxcclxuXHRcdFx0XHRcdG5ld1NjZW5lRGF0YSxcclxuXHRcdFx0XHRcdHRoaXMubW9kZWwuZ2V0VmFySW50ZXJmYWNlKCksXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5sb2FkQWRkaXRpb25hbEF1ZGlvKFxyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmdldEFkZGl0aW9uYWxBdWRpbygpXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGlzIHRoZSBvdGhlciBoYWxmIG9mIFwic3RhcnRTY2VuZVwiLCB3aGljaCBub3cgd2FpdHMgZm9yIGF1ZGlvLi4uXHJcblx0XHQgKi9cclxuXHRcdG9uU2NlbmVTdGFydEF1ZGlvUmVhZHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMubW9kZWwuaXNTaG93UGxheVRocm91Z2goKSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnNob3dQbGF5VGhyb3VnaCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5ldmVudHMub25HYW1lQ2hvaWNlLmFkZCh0aGlzLm9uR2FtZUNob2ljZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmV2ZW50cy5vbkdhbWVTcGVlY2guYWRkKHRoaXMub25HYW1lU3BlZWNoLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZXZlbnRzLm9uR2FtZU11c2ljLmFkZCh0aGlzLm9uR2FtZU11c2ljLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc2hvd1NjZW5lKCk7XHJcblx0XHRcdHRoaXMucnVuU2NlbmVTdGFydEFjdGlvbnMoKTtcclxuXHRcdFx0dGhpcy5ldmVudHMub25BY3RTdGF0dXMuZGlzcGF0Y2goXCJzYXZlXCIpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogV2hlbiBhIHNjZW5lIHN0YXJ0cywgcnVuIGFueSBzdGFydGluZyBhY3Rpb25zLlxyXG5cdFx0ICovXHJcblx0XHRydW5TY2VuZVN0YXJ0QWN0aW9uczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuY3VycmVudFNjZW5lLmdldEFjdGlvbnMoKTtcclxuXHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdGFjdGlvbnMsXHJcblx0XHRcdFx0ZnVuY3Rpb24gKHNpbmdsZUFjdGlvbikge1xyXG5cdFx0XHRcdFx0bG9nLndhcm4oXCJleGVjdXRpbmcgc3RhcnRpbmcgYWN0aW9uOlwiKTtcclxuXHRcdFx0XHRcdGxvZy53YXJuKHNpbmdsZUFjdGlvbik7XHJcblx0XHRcdFx0XHRQbGF5QWN0aW9uLmdldEFjdGlvbihzaW5nbGVBY3Rpb24pLmV4ZWN1dGUodGhpcyk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdCk7XHJcblx0XHRcdGFjdGlvbnMgPSB0aGlzLm1vZGVsLmdldEdsb2JhbEFjdGlvbnMoKTtcclxuXHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdGFjdGlvbnMsXHJcblx0XHRcdFx0ZnVuY3Rpb24gKHNpbmdsZUFjdGlvbikge1xyXG5cdFx0XHRcdFx0bG9nLndhcm4oXCJleGVjdXRpbmcgc3RhcnRpbmcgZ2xvYmFsIGFjdGlvbjpcIik7XHJcblx0XHRcdFx0XHRsb2cud2FybihzaW5nbGVBY3Rpb24pO1xyXG5cdFx0XHRcdFx0UGxheUFjdGlvbi5nZXRBY3Rpb24oc2luZ2xlQWN0aW9uKS5leGVjdXRlKHRoaXMpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHQpO1xyXG5cdFx0XHQvLyBUaGUgc2NlbmUgaXMgZG9uZSBzdGFydGluZyB1cCwgYWxsb3cgaW5wdXQuXHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgdGhlcmUgaXMgYSBzY2VuZSBzaG93aW5nLCBlbmQgaXQuXHJcblx0XHQgKi9cclxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2Uuc3RvcEFuZFVubG9hZCgpO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2UncmUgbm90IGluIGEgc2NlbmUsIHRoZW4gbm8gaW5wdXQhXHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5kaXNhYmxlZCA9IHRydWU7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTY2VuZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmRlc3Ryb3koKTtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTY2VuZSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy51bmxvYWQoKTsgLy8gcmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgcHJlbG9hZGVkLlxyXG5cdFx0fSxcclxuXHRcdC8vIFN0b3AgdGhlIGN1cnJlbnQgc2NlbmUgYW5kIGNsZWFuIGl0IHVwLlxyXG5cdFx0c3RvcFNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLnN0b3BTY2VuZSgpO1xyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS51bmxvYWRBZGRpdGlvbmFsQXVkaW8oXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZ2V0QWRkaXRpb25hbEF1ZGlvKClcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFNjZW5lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuY2xlYXJGb3JSZXVzZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBbiBvdXRjb21lIG9yIHN0YXJ0aW5nIGFjdGlvbiBoYXMgc2V0IGEgdmFyaWFibGUgKGdhbWUgY2hvaWNlKS4gT3RoZXIgYWN0b3JzIGluIHRoZSBzY2VuZSBuZWVkIHRvXHJcblx0XHQgKiBrbm93IGFib3V0IGl0LlxyXG5cdFx0ICogQHBhcmFtIGRhdGFcclxuXHRcdCAqL1xyXG5cdFx0b25HYW1lQ2hvaWNlQWN0aW9uOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHR0aGlzLm9uR2FtZUNob2ljZShkYXRhKTtcclxuXHRcdFx0aWYgKCFkYXRhLmNvbnN1bWVkKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc2VuZEdhbWVDaG9pY2VUb0FjdG9ycyhcIiFBQ1RJT04hXCIsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTb21ldGhpbmcgaW4gdGhlIGdhbWUgaGFzIG1hZGUgYSBjaG9pY2UuIFRoaXMgY2hvaWNlIGlzIHJlY29yZGVkIGFzIHRoZSBzZXR0aW5nIG9mIGEgdmFyaWFibGUsIHdlIHRoZW5cclxuXHRcdCAqIHJ1biBhbiB1cGRhdGUgaW4gY2FzZSB0aGF0IGNob2ljZSBsZWQgdG8gYW4gYWN0aW9uLCAoZXZlbnRzIGJ1YmJsZSB1cCwgYWN0aW9ucyBoYXBwZW4gZG93bilcclxuXHRcdCAqIEBwYXJhbSBkYXRhXHJcblx0XHQgKi9cclxuXHRcdG9uR2FtZUNob2ljZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0bG9nLndhcm4oXCJnYW1lIGNob2ljZVwiKTtcclxuXHRcdFx0bG9nLndhcm4oZGF0YSk7XHJcblxyXG5cdFx0XHR0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goZGF0YSk7XHJcblx0XHRcdGlmIChkYXRhLmNvbnN1bWVkKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdGVtcFZhcnMgPSBfLnBhaXJzKGRhdGEpWzBdO1xyXG5cdFx0XHRsb2cud2Fybih0ZW1wVmFycyk7XHJcblx0XHRcdGRhdGEuY29uc3VtZWQgPSB0aGlzLmFjdENvbW1hbmQodGVtcFZhcnNbMF0sIHRlbXBWYXJzWzFdKTtcclxuXHJcblx0XHRcdC8vIE9ubHkgcmVjb3JkIHRoZSB2YXJpYWJsZSBpZiBpdCB3YXNuJ3QgYSBjb21tYW5kLCB3aGljaCBkb2VzIE5PVCBjb25zdW1lIGl0LiBJdCBtYXkgcmVzdWx0IGluIGFuIGV2ZW50LFxyXG5cdFx0XHQvLyBvdGhlcndpc2UsIGNoZWNrIGZvciBjb21wbGV0ZWQgb3V0Y29tZXMuXHJcblx0XHRcdGlmICghZGF0YS5jb25zdW1lZCkge1xyXG5cdFx0XHRcdHZhciBldmVudCA9IHRoaXMubW9kZWwuaGFuZGxlU3BlY2lhbFZhcih0ZW1wVmFyc1swXSwgdGVtcFZhcnNbMV0pO1xyXG5cdFx0XHRcdC8vIHZhciBldmVudCA9IHRoaXMubW9kZWwuc2V0VmFyKHRlbXBWYXJzWzBdLCB0ZW1wVmFyc1sxXSk7XHJcblx0XHRcdFx0aWYgKGV2ZW50KSB7XHJcblx0XHRcdFx0XHR0aGlzLmV2ZW50cy5vbkFjdFN0YXR1cy5kaXNwYXRjaChldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLm1vZGVsLnNldFZhcih0ZW1wVmFyc1swXSwgdGVtcFZhcnNbMV0pKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNoZWNrQ3VycmVudFNjZW5lT3V0Y29tZXModGVtcFZhcnNbMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGNoZWNrQ3VycmVudFNjZW5lT3V0Y29tZXM6IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xyXG5cdFx0XHR0aGlzLm1vZGVsLmNoZWNrRm9yQ29tcGxldGVkT3V0Y29tZXModmFyaWFibGUpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogdGhpcyBmdW5jdGlvbiBjbGVhcnMgYSB2YXJpYWJsZSBvdXQgb2YgdGhlIG1vZGVsIG1hbnVhbGx5LiBJdCBzaG91bGQgYWxtb3N0IG5ldmVyIGJlIHVzZWQuXHJcblx0XHQgKiBAcGFyYW0gbmFtZVxyXG5cdFx0ICovXHJcblx0XHRjbGVhclZhcmlhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLm1vZGVsLnZhcmlhYmxlc1tuYW1lXSA9IHVuZGVmaW5lZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFJ1biBhbiBBY3QgbGV2ZWwgY29tbWFuZC4gUmV0dXJuIHRydWUgaWYgYSBjb21tYW5kIGhhcHBlbmVkLCBvdGhlcndpc2UgZmFsc2UuXHJcblx0XHQgKiBAcGFyYW0gY29tbWFuZFxyXG5cdFx0ICogQHBhcmFtIGFyZ1xyXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIGNvbnN1bWVkLlxyXG5cdFx0ICovXHJcblx0XHRhY3RDb21tYW5kOiBmdW5jdGlvbiAoY29tbWFuZCwgYXJnKSB7XHJcblx0XHRcdGxvZy53YXJuKFwiQWN0IGNvbW1hbmQ6IFwiICsgY29tbWFuZCArIFwiIC8gXCIgKyBhcmcpO1xyXG5cdFx0XHRpZiAoY29tbWFuZCA9PT0gXCJyZW1vdmUtYWN0b3JcIiAmJiB0aGlzLmN1cnJlbnRTY2VuZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZUFjdG9yQnlOYW1lKGFyZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJhZGQtYWN0b3JcIiAmJiB0aGlzLmN1cnJlbnRTY2VuZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmFkZEFjdG9yKGFyZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0Y29tbWFuZCA9PT0gXCJvYmplY3RpdmVfY29tcGxldGVcIiB8fFxyXG5cdFx0XHRcdGNvbW1hbmQgPT09IFwiYWN0aXZpdHlfY29tcGxldGVcIlxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyBvYmplY3RpdmVfY29tcGxldGUgPT4gXCJmaW5pc2hlZCB0aGlzIGFjdFwiLCBub3QgYSBzY29ybSBvYmplY3RpdmUuXHJcblx0XHRcdFx0dGhpcy5ldmVudHMub25BY3RTdGF0dXMuZGlzcGF0Y2goXCJjb21wbGV0ZVwiKTtcclxuXHRcdFx0XHQvLyBvYmplY3RpdmUgPT4gXCJmaW5pc2ggYSBzY29ybSBvYmplY3RpdmVcIlxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwib2JqZWN0aXZlXCIpIHtcclxuXHRcdFx0XHR0aGlzLmV2ZW50cy5vbkFjdFN0YXR1cy5kaXNwYXRjaChcIm9iamVjdGl2ZVwiLCBhcmcpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIElmIHNvbWV0aGluZyBzdGFydHMgdG8gcGxheSBhdWRpbywgaXQgZG9lcyBpdCB2aWEgYW4gZXZlbnQsIHRoaXMgYWxsb3dzIGZvciB0ZWxsaW5nIHRoZSBvdGhlciBhY3RvcnMsIHRoZVxyXG5cdFx0ICogc2NlbmUsIGFjdCBhbmQgdGhlIHBsYXkuIEluIHRoaXMgY2FzZSwgd2UgYWxzbyB3YW50IHRvIHN0b3AgYW55IHByZXZpb3VzbHkgcGxheWluZyBzb3VuZC5cclxuXHRcdCAqIFRoZSBjdXJyZW50IHNwZWVjaCBpcyBhbHdheXMgdHJhY2tlZCBzbyB3ZSBjYW4gaGF2ZSBldmVudGluZyBvbiB3aGVuIGl0IHN0b3BzLlxyXG5cdFx0ICogQHBhcmFtIGRhdGFcclxuXHRcdCAqL1xyXG5cdFx0b25HYW1lU3BlZWNoOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHRsb2cud2FybihcIm9uIGdhbWUgc3BlZWNoXCIpO1xyXG5cdFx0XHRsb2cud2FybihkYXRhKTtcclxuXHJcblx0XHRcdHZhciBhdWRpbyA9IHRoaXMubW9kZWwuZ2V0VmFsdWUoZGF0YS5hdWRpbyk7XHJcblx0XHRcdGlmIChkYXRhLmtleSkge1xyXG5cdFx0XHRcdGF1ZGlvID0gdGhpcy5tb2RlbC5nZXRWYWx1ZShkYXRhLmtleSkgKyBcIl9cIiArIGF1ZGlvO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmF1ZGlvU2VydmljZS5wbGF5QXVkaW8oYXVkaW8sIGRhdGEpO1xyXG5cdFx0fSxcclxuXHRcdG9uR2FtZU11c2ljOiBmdW5jdGlvbiAoYXVkaW8pIHtcclxuXHRcdFx0dGhpcy5hdWRpb1NlcnZpY2Uub25HYW1lTXVzaWMoYXVkaW8pO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogV2hlbiBhdWRpbyBmaW5pc2hlcyBwbGF5aW5nLCBhY3RvcnMgbmVlZCB0byBrbm93LCBpbiBjYXNlIHRoZXkgYXJlIGFuaW1hdGluZyBzcGVlY2gvZXRjLlxyXG5cdFx0ICovXHJcblx0XHRvblNvdW5kRmluaXNoZWQ6IGZ1bmN0aW9uIChzdG9wcGVkU291bmQsIG1hcmtlcikge1xyXG5cdFx0XHQvLyBfdGVtcE1hcmtlciBiZWNhdXNlIGN1cnJlbnRNYXJrZXIgaXMgbm93IGJsYW5rLi4uXHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTY2VuZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLm9uR2FtZVNwZWVjaFN0b3AobWFya2VyKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG1vZGVsIGhhcyBzaWduYWxlZCB0aGF0IG91dGNvbWVzIG5lZWQgdG8gZXhlY3V0ZSBhY3Rpb25zLiBFeGVjdXRlIHRob3NlIGFjdGlvbnMuXHJcblx0XHQgKiBAcGFyYW0gcGVuZGluZ0FjdGlvbnNcclxuXHRcdCAqIFdpbGwgbG9vayBsaWtlOlxyXG5cdFx0ICogW1xyXG5cdFx0ICogIFsgXCJvdXRjb21lXzFcIjogWyB7IEFDVElPTiB9ICwgeyBBQ1RJT04gfSBdLFxyXG5cdFx0ICogICAgXCJvdXRjb21lXzJcIjogWyB7IEFDVElPTiB9ICwgeyBBQ1RJT04gfSBdLCAuLi4gXVxyXG5cdFx0ICovXHJcblx0XHRvbkdhbWVPdXRjb21lOiBmdW5jdGlvbiAocGVuZGluZ0FjdGlvbnMpIHtcclxuXHRcdFx0Xy5lYWNoKFxyXG5cdFx0XHRcdHBlbmRpbmdBY3Rpb25zLFxyXG5cdFx0XHRcdGZ1bmN0aW9uIChhY3Rpb25EYXRhKSB7XHJcblx0XHRcdFx0XHRsb2cud2FybihcImV4ZWN1dGluZyBhY3Rpb25zIGZvciBcIiArIGFjdGlvbkRhdGEubmFtZSk7XHJcblx0XHRcdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0XHRcdGFjdGlvbkRhdGEuYWN0aW9ucyxcclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKHNpbmdsZUFjdGlvbikge1xyXG5cdFx0XHRcdFx0XHRcdGxvZy53YXJuKFwiZXhlY3V0aW5nIGFjdGlvbjpcIik7XHJcblx0XHRcdFx0XHRcdFx0bG9nLndhcm4oYWN0aW9uRGF0YSk7XHJcblx0XHRcdFx0XHRcdFx0UGxheUFjdGlvbi5nZXRBY3Rpb24oc2luZ2xlQWN0aW9uKS5leGVjdXRlKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHQpO1xyXG5cdFx0fSxcclxuXHRcdHNob3dOZXdTY2VuZTogZnVuY3Rpb24gKHNjZW5lKSB7XHJcblx0XHRcdGlmICh0aGlzLm1vZGVsLnNldEN1cnJlbnRTY2VuZShzY2VuZSkpIHtcclxuXHRcdFx0XHR0aGlzLnN0b3BTY2VuZSgpO1xyXG5cdFx0XHRcdHRoaXMuc3RhcnRTY2VuZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHJldHVybnMgdGhlIHBhdGhzIHRvIGV2ZXJ5dGhpbmcsIGJhc2VkIG9uIHRoZSB0aGVtZS9cclxuXHRcdCAqIEByZXR1cm5zIHt7dGV4dHVyZUtleTogc3RyaW5nLCB0ZXh0dXJlOiBzdHJpbmcsIHRleHR1cmVNYXA6IHN0cmluZywgc291bmRLZXk6IHN0cmluZywgc291bmRGaWxlOiBzdHJpbmd9fVxyXG5cdFx0ICovXHJcblx0XHRnZXRNZWRpYURhdGE6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIHNvdW5kRmlsZXMgPSBudWxsO1xyXG5cdFx0XHRpZiAodGhpcy50aGVtZS5oYXNPd25Qcm9wZXJ0eShcInNvdW5kRmlsZVwiKSkge1xyXG5cdFx0XHRcdHNvdW5kRmlsZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGhlbWUuc291bmRGaWxlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRzb3VuZEZpbGVzW2ldID0gdGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyB0aGlzLnRoZW1lLnNvdW5kRmlsZVtpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dGV4dHVyZUtleTogdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdHRleHR1cmU6IHRoaXMuZ2FtZS5jb25maWcuYXNzZXRQYXRoICsgdGhpcy50aGVtZS50ZXh0dXJlLFxyXG5cdFx0XHRcdHRleHR1cmVNYXA6IHRoaXMuZ2FtZS5jb25maWcuYXNzZXRQYXRoICsgdGhpcy50aGVtZS50ZXh0dXJlTWFwLFxyXG5cdFx0XHRcdHNvdW5kS2V5OiB0aGlzLnRoZW1lLnNvdW5kS2V5LFxyXG5cdFx0XHRcdHNvdW5kRmlsZTogc291bmRGaWxlcyxcclxuXHRcdFx0XHRkYXRhRmlsZTogdGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyB0aGlzLnRoZW1lLmRhdGEsXHJcblx0XHRcdFx0YW5pbWF0aW9uczogdGhpcy50aGVtZS5hbmltYXRpb25zLFxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogQWxsb3cgdGhlIGN1cnJlbnQgc2NlbmUgdG8gcGVyZm9ybSB0aW1lZCBvcGVyYXRpb25zLiBUaGUgc2l6ZSBvZiBhIFwidGlja1wiIGlzIGRlZmluZWQgaW4gbWFpbi5qcywgYnV0IHRoaW5rIG9mXHJcblx0XHQgKiBpdCBhcyBhIG1pbGxpc2Vjb25kLlxyXG5cdFx0ICpcclxuXHRcdCAqIFNUUk9ORyBXQVJOSU5HOiBEb24ndCBkbyBtdWNoIGhlcmUgLSBpdCdzIGNhbGxlZCBmcm9tIHRoZSBtYWluIHVwZGF0ZSBsb29wLiBBbnkgZXh0ZW5zaXZlIG9wZXJhdGlvbnMgd2lsbFxyXG5cdFx0ICogY2F1c2UgdGhlIHVzZXIgaW50ZXJmYWNlIHRvIGxhZy5cclxuXHRcdCAqL1xyXG5cdFx0dGlja1VwZGF0ZTogZnVuY3Rpb24gKHRpY2spIHtcclxuXHRcdFx0aWYgKCEodHlwZW9mIHRoaXMuY3VycmVudFNjZW5lID09PSBcInVuZGVmaW5lZFwiKSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnRpY2tVcGRhdGUodGljayk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRyZW5kZXJEZWJ1ZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvL2lmKCB0aGlzLmdhbWVTb3VuZHMgICkge1xyXG5cdFx0XHQvLyAgICB0aGlzLmdhbWUuZGVidWcuc291bmRJbmZvKHRoaXMuZ2FtZVNvdW5kcywgMTAsIDIwKTtcclxuXHRcdFx0Ly99XHJcblx0XHR9LFxyXG5cdFx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNQcmVsb2FkZWQpIHtcclxuXHRcdFx0XHRsb2cud2FybihcIiEhISBDYWxsZWQgUHJlbG9hZCBpbiBBY3QgXCIgKyB0aGlzLmFjdE5hbWUpO1xyXG5cdFx0XHRcdHRoaXMubWVkaWFEYXRhID0gdGhpcy5nZXRNZWRpYURhdGEoKTtcclxuXHRcdFx0XHR0aGlzLmdhbWUubG9hZC50ZXh0KFxyXG5cdFx0XHRcdFx0dGhpcy5hY3ROYW1lICsgXCJfc2NlbmVfZGF0YVwiLFxyXG5cdFx0XHRcdFx0dGhpcy5tZWRpYURhdGEuZGF0YUZpbGVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5sb2FkLmF0bGFzSlNPTkhhc2goXHJcblx0XHRcdFx0XHR0aGlzLm1lZGlhRGF0YS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdFx0dGhpcy5tZWRpYURhdGEudGV4dHVyZSxcclxuXHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLnRleHR1cmVNYXBcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGlmICh0aGlzLm1lZGlhRGF0YS5zb3VuZEZpbGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLmxvYWRBdWRpbyhcclxuXHRcdFx0XHRcdFx0dGhpcy5tZWRpYURhdGEuc291bmRLZXksXHJcblx0XHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLnNvdW5kRmlsZVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMubWVkaWFEYXRhLmFuaW1hdGlvbnMpIHtcclxuXHRcdFx0XHRcdF8uZWFjaChcclxuXHRcdFx0XHRcdFx0dGhpcy5tZWRpYURhdGEuYW5pbWF0aW9ucyxcclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKGFuaW1hdGlvblNldCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZ2FtZS5sb2FkLmF0bGFzSlNPTkhhc2goXHJcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb25TZXQudGV4dHVyZUtleSxcclxuXHRcdFx0XHRcdFx0XHRcdGFuaW1hdGlvblNldC50ZXh0dXJlLFxyXG5cdFx0XHRcdFx0XHRcdFx0YW5pbWF0aW9uU2V0LnRleHR1cmVNYXBcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmlzUHJlbG9hZGVkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uUHJlbG9hZEZpbmlzaGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMubW9kZWwgPSBuZXcgUGxheU1vZGVsKFxyXG5cdFx0XHRcdEpTT04ucGFyc2UodGhpcy5nYW1lLmNhY2hlLmdldFRleHQodGhpcy5hY3ROYW1lICsgXCJfc2NlbmVfZGF0YVwiKSlcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy52YWxpZGF0b3IgPSBuZXcgQWN0VmFsaWRhdG9yKHRoaXMubW9kZWwuZ2V0UmF3RGF0YSgpKTtcclxuXHRcdFx0dGhpcy52YWxpZGF0b3IudmFsaWRhdGUoKTtcclxuXHRcdH0sXHJcblx0XHR1bmxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNQcmVsb2FkZWQpIHtcclxuXHRcdFx0XHR0aGlzLm1lZGlhRGF0YSA9IHRoaXMuZ2V0TWVkaWFEYXRhKCk7XHJcblx0XHRcdFx0dGhpcy5nYW1lLmNhY2hlLnJlbW92ZUltYWdlKHRoaXMubWVkaWFEYXRhLnRleHR1cmVLZXkpO1xyXG5cdFx0XHRcdGlmICh0aGlzLm1lZGlhRGF0YS5hbmltYXRpb25zKSB7XHJcblx0XHRcdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0XHRcdHRoaXMubWVkaWFEYXRhLmFuaW1hdGlvbnMsXHJcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChhbmltYXRpb25TZXQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmdhbWUuY2FjaGUucmVtb3ZlSW1hZ2UoYW5pbWF0aW9uU2V0LnRleHR1cmVLZXkpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmdhbWUuY2FjaGUucmVtb3ZlVGV4dCh0aGlzLm1lZGlhRGF0YS50ZXh0dXJlTWFwKTtcclxuXHRcdFx0XHR0aGlzLmdhbWUuY2FjaGUucmVtb3ZlVGV4dCh0aGlzLmFjdE5hbWUgKyBcIl9zY2VuZV9kYXRhXCIpO1xyXG5cdFx0XHRcdGlmICh0aGlzLm1lZGlhRGF0YS5zb3VuZEZpbGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLnVubG9hZEF1ZGlvKHRoaXMubWVkaWFEYXRhLnNvdW5kS2V5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5pc1ByZWxvYWRlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDaGVjayB0aGF0IHNvdW5kIGhhcyBkZWNvZGVkLlxyXG5cdFx0ICovXHJcblx0XHRpc1ByZWxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5pc1ByZWxvYWRlZCAhPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogQFRPRE8gR0pGIHRoaXMgd2FzIGluY29ycmVjdCBiZWZvcmUsIChhY3QgKyBcIl8uLi5cIiksIFdhcyBpdCBiZWluZyByZWFjaGVkIG9yIGp1c3QgZmFpbGluZz9cclxuXHRcdFx0ICogU2hvdWxkIHRoZSBhYm92ZSBsaW5lIGJlIHJlbW92ZWQvY2hhbmdlZD8gKHByb2JhYmx5KVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0aWYgKCF0aGlzLmdhbWUuY2FjaGUuZ2V0VGV4dCh0aGlzLmFjdE5hbWUgKyBcIl9zY2VuZV9kYXRhXCIpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0IXRoaXMubWVkaWFEYXRhLnNvdW5kRmlsZSB8fFxyXG5cdFx0XHRcdHRoaXMuYXVkaW9TZXJ2aWNlLmlzUmVhZHkodGhpcy5tZWRpYURhdGEuc291bmRLZXkpXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0c2V0U3RhbmRBbG9uZTogZnVuY3Rpb24gKGlzU3RhbmRBbG9uZSkge30sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gUGxheUFjdDtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQSB2YWxpZGF0b3IgZm9yIHRoZSBzY2VuZURhdGEuanNvbiAoYWN0KSBmaWxlIHRvIG1ha2Ugc3VyZSB0aGUgYmFzaWNcclxuICogZmllbGRzIGFyZSB0aGVyZSBmb3IgZWFjaCBvYmplY3QuXHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgLy8gQSBzbWFsbCB2YWxpZGF0aW9uIG1vZGVsIGZvciBhIHNldCBvZiBzY2VuZURhdGEuXHJcbiAgICB2YXIgYWN0VmFsaWRhdGlvbk1vZGVsID1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwicGxheVwiOiB7XHJcbiAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVG9wIGxldmVsIGNvbnRhaW5lciBmb3IgYWxsIHNjZW5lIGRhdGFcIixcclxuICAgICAgICAgICAgICAgIFwidmFsaWRhdGlvbk1vZGVsXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0YXJ0XCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcImFjdC5wbGF5LnN0YXJ0IHNwZWNpZmllcyB0aGUgc3RhcnRpbmcgc2NlbmUuXCJ9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2NlbmVzXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcImFjdC5wbGF5LnNjZW5lcyBzcGVjaWZpZWQgYWxsIHNjZW5lcy5cIiB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgIHZhciBzY2VuZVZhbGlkYXRpb25Nb2RlbCA9IHtcclxuICAgICAgICBcImlkXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIHNjZW5lLlwiIH0sXHJcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIlJlZmVyZW5jZSBiYWNrZ3JvdW5kIGltYWdlIGZvciBhIHNjZW5lLlwiIH0sXHJcbiAgICAgICAgXCJhY3RvcnNcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IG9mIGFjdG9ycyB0byBhZGQgdG8gYSBzY2VuZS5cIiB9LFxyXG4gICAgICAgIFwib3V0Y29tZXNcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IG9mIHBvc3NpYmxlIG91dGNvbWVzIGZyb20gYSBzY2VuZS5cIiB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBhY3RvclZhbGlkYXRpb25Nb2RlbCA9IHtcclxuICAgICAgICBcIm5hbWVcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiSWRlbnRpZmllciBmb3IgYWN0b3IuXCIgfSxcclxuICAgICAgICBcInR5cGVcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiVHlwZSBvZiBhY3RvciB0byBiZSBjcmVhdGVkLlwiIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIG91dGNvbWVWYWxpZGF0aW9uTW9kZWwgPSB7XHJcbiAgICAgICAgXCJldmVudHNcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IG9mIHZhcmlhYmxlcy92YWx1ZSBwYWlycyB0aGF0IHRyaWdnZXIgdGhlIG91dGNvbWUuXCIgfSxcclxuICAgICAgICBcImFjdGlvbnNcIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiQXJyYXkgb2YgYWN0aW9ucyB0byB0YWtlIHdoZW4gb3V0Y29tZSBpcyB0cmlnZ2VyZWQuXCIgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgQWN0VmFsaWRhdG9yID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGpzb25EYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmF3RGF0YSA9IGpzb25EYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcnVuIHNvbWUgYmFzaWMgdmFsaWRhdGlvbiBvbiB0aGUgYXZhaWxhYmxlIGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggISB0aGlzLnJhd0RhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlBsYXlNb2RlbCByZXF1aXJlcyBnYW1lIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yYXdEYXRhO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bkFjdFZhbGlkYXRvciggZGF0YSwgYWN0VmFsaWRhdGlvbk1vZGVsKTtcclxuICAgICAgICAgICAgXy5lYWNoKCBkYXRhLnBsYXkuc2NlbmVzLCBmdW5jdGlvbihzY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5TY2VuZVZhbGlkYXRvcihzY2VuZSwgc2NlbmVWYWxpZGF0aW9uTW9kZWwpO1xyXG4gICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICBsb2cud2FybihcIlZhbGlkYXRpb24gY29tcGxldGUuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuQWN0VmFsaWRhdG9yOiBmdW5jdGlvbiggZW50cnlQb2ludCwgdmFsaWRhdGlvbk1vZGVsICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHZhbGlkYXRpb25Nb2RlbCwgZnVuY3Rpb24oIHRvVmFsaWRhdGUsIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgaWYoICFlbnRyeVBvaW50W2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiTWlzc2luZzogXCIgKyB0b1ZhbGlkYXRlLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCB0b1ZhbGlkYXRlLnZhbGlkYXRpb25Nb2RlbCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkFjdFZhbGlkYXRvciggZW50cnlQb2ludFtpbmRleF0sIHRvVmFsaWRhdGUudmFsaWRhdGlvbk1vZGVsICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuU2NlbmVWYWxpZGF0b3I6IGZ1bmN0aW9uKCBlbnRyeVBvaW50LCB2YWxpZGF0aW9uTW9kZWwgKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdmFsaWRhdGlvbk1vZGVsLCBmdW5jdGlvbiggdG9WYWxpZGF0ZSwgaW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggIWVudHJ5UG9pbnRbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJNaXNzaW5nOiBcIiArIHRvVmFsaWRhdGUuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICBfLmVhY2goIGVudHJ5UG9pbnQuYWN0b3JzLCBmdW5jdGlvbiAoYWN0b3IsIGFjdG9ySW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCggYWN0b3JWYWxpZGF0aW9uTW9kZWwsIGZ1bmN0aW9uKCB0b1ZhbGlkYXRlLCBpbmRleCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggIWFjdG9yW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk1pc3Npbmc6IFwiICsgdG9WYWxpZGF0ZS5kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIF8uZWFjaCggZW50cnlQb2ludC5vdXRjb21lcywgZnVuY3Rpb24gKG91dGNvbWUsIG91dGNvbWVJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKCBvdXRjb21lVmFsaWRhdGlvbk1vZGVsLCBmdW5jdGlvbiggdG9WYWxpZGF0ZSwgaW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoICFvdXRjb21lW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk1pc3Npbmc6IFwiICsgdG9WYWxpZGF0ZS5kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBY3RWYWxpZGF0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDkvMjEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqICBEcmF3IGEgbG9hZGluZyBzY3JlZW4gaW4gUGhhc2VyLiBFeHBlY3RzIHJlc291cmNlcyB0byBhbHJlYWR5IGJlIGxvYWRlZC5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0dmFyIEJhc2UgPSByZXF1aXJlKFwiYmFzZWpzXCIpO1xyXG5cclxuXHR2YXIgTG9hZGluZ1NjcmVlbiA9IEJhc2UuZXh0ZW5kKHtcclxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZ2FtZSwgc2V0dGluZ3MpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdCFzZXR0aW5ncyB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX2ltYWdlX2tleSB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX2JnX2NvbG9yIHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLmxvYWRpbmdfdGV4dCB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX2ZvbnRcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhyb3cgXCJMb2FkaW5nIHNjcmVlbiBpcyBtaXNzaW5nIGEgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBmaWVsZC5cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmdhbWUgPSBnYW1lO1xyXG5cdFx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG5cdFx0XHR0aGlzLnNwaW5uZXIgPSBbXCIuXCIsIFwiLi5cIiwgXCIuLi5cIiwgXCIuLi4uXCJdO1xyXG5cdFx0fSxcclxuXHRcdHNob3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gMS4gQ3JlYXRlIHNvbGlkIGJhY2tncm91bmQuXHJcblx0XHRcdHRoaXMuYmdDb2xvciA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoMCwgMCk7XHJcblx0XHRcdHRoaXMuYmdDb2xvci5iZWdpbkZpbGwodGhpcy5zZXR0aW5ncy5sb2FkaW5nX2JnX2NvbG9yKTtcclxuXHRcdFx0dGhpcy5iZ0NvbG9yLmRyYXdSZWN0KFxyXG5cdFx0XHRcdDAsXHJcblx0XHRcdFx0MCxcclxuXHRcdFx0XHR0aGlzLmdhbWUud29ybGQud2lkdGgsXHJcblx0XHRcdFx0dGhpcy5nYW1lLndvcmxkLmhlaWdodFxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLmJnQ29sb3IuZW5kRmlsbCgpO1xyXG5cdFx0XHR0aGlzLmJnQ29sb3IuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIDIuIENyZWF0ZSBhIGxvYWRpbmcgaW1hZ2UvaWNvbi9zcGxhc2hcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZLFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubG9hZGluZ19pbWFnZV9rZXlcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZS5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuXHRcdFx0Ly8gdGhpcy5zcGxhc2hJbWFnZS5hbHBoYSA9IDA7XHJcblx0XHRcdC8vIHRoaXMudHdlZW4gPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3BsYXNoSW1hZ2UpLnRvKHthbHBoYTogMX0sIDIwMDAsIFwiTGluZWFyXCIsIHRydWUsIDAsIC0xKTtcclxuXHJcblx0XHRcdC8vICBBbmQgdGhpcyB0ZWxscyBpdCB0byByZXBlYXQsIGkuZS4gZmFkZSBpbiBhZ2FpbiAxMCB0aW1lcy5cclxuXHRcdFx0Ly8gIFRoZSAxMDAwIHRlbGxzIGl0IHRvIHdhaXQgZm9yIDEgc2Vjb25kIGJlZm9yZSByZXN0YXJ0aW5nIHRoZSBmYWRlLlxyXG5cdFx0XHQvLyB0aGlzLnR3ZWVuLnlveW8odHJ1ZSwgMTAwMCk7XHJcblxyXG5cdFx0XHQvLyAzLiBBZGQgYSBwcm9ncmVzcyBpbmRpY2F0b3JcclxuXHRcdFx0dGhpcy5wcm9ncmVzc1RleHQgPSB0aGlzLmdhbWUuYWRkLnRleHQoXHJcblx0XHRcdFx0dGhpcy5nYW1lLndvcmxkLmNlbnRlclgsXHJcblx0XHRcdFx0dGhpcy5nYW1lLndvcmxkLmNlbnRlclksXHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sb2FkaW5nX3RleHQsXHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sb2FkaW5nX2ZvbnRcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5wcm9ncmVzc1RleHQuYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgam9pbnRIZWlnaHQgPSB0aGlzLnNwbGFzaEltYWdlLmhlaWdodCArIHRoaXMucHJvZ3Jlc3NUZXh0LmhlaWdodDtcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZS55ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgLSBqb2ludEhlaWdodCAvIDI7XHJcblx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0LnkgPSB0aGlzLnNwbGFzaEltYWdlLnkgKyB0aGlzLnNwbGFzaEltYWdlLmhlaWdodCArIDI1O1xyXG5cdFx0XHR0aGlzLmdhbWUubG9hZC5vbkZpbGVDb21wbGV0ZS5hZGQodGhpcy5maWxlQ29tcGxldGUsIHRoaXMpO1xyXG5cdFx0fSxcclxuXHRcdHNob3dDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9waGFzZXIuaW8vZG9jcy8yLjQuNC9QaGFzZXIuQ2FjaGUuaHRtbCNvblNvdW5kVW5sb2NrXHJcblx0XHRcdC8vIGJ1dCBjYW4ndCB1c2UgOi0oXHJcblx0XHRcdGlmICh0aGlzLmdhbWUuZGV2aWNlLmRlc2t0b3ApIHtcclxuXHRcdFx0XHR0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0LnNldFRleHQoXCJcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gdGhpcy5wcm9ncmVzc1RleHQuc2V0VGV4dChcIlwiKTtcclxuXHRcdH0sXHJcblx0XHRzaG93Q2xpY2t0aHJvdWdoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHQvLyBodHRwczovL3BoYXNlci5pby9kb2NzLzIuNC40L1BoYXNlci5DYWNoZS5odG1sI29uU291bmRVbmxvY2tcclxuXHRcdFx0Ly8gYnV0IGNhbid0IHVzZSA6LShcclxuXHRcdFx0aWYgKHRoaXMuZ2FtZS5kZXZpY2UuZGVza3RvcCkge1xyXG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0LnNldFRleHQoXCJDbGljayBoZXJlIHRvIGJlZ2luLlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiVG91Y2ggc2NyZWVuIHRvIGJlZ2luLlwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB0aGlzLnByb2dyZXNzVGV4dC5zZXRUZXh0KFwiXCIpO1xyXG5cdFx0fSxcclxuXHRcdHNob3dEZWNvZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvL3RoaXMucHJvZ3Jlc3NUZXh0LnNldFRleHQoXCJQcmVwYXJpbmcgQXVkaW86IFwiICsgdGhpcy5nZXRGYWtlUHJvZ3Jlc3MoKSk7XHJcblx0XHR9LFxyXG5cdFx0Z2V0RmFrZVByb2dyZXNzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vcmV0dXJuIHRoaXMuc3Bpbm5lclt0aGlzLnByb2dyZXNzKysgJSA0XTtcclxuXHRcdH0sXHJcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHQvLyB0aGlzLnR3ZWVuLnN0b3AoKTtcclxuXHRcdFx0Ly8gdGhpcy50d2Vlbi50YXJnZXQgPSBudWxsOyAvLyBkaXNjb25uZWN0IGZyb20gc3BsYXNoIGltYWdlLlxyXG5cdFx0XHQvLyB0aGlzLnR3ZWVuID0gbnVsbDtcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZS5jcm9wRW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnNwbGFzaEltYWdlLmRlc3Ryb3koKTtcclxuXHRcdFx0dGhpcy5zcGxhc2hJbWFnZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuYmdDb2xvci5kZXN0cm95KCk7XHJcblx0XHRcdHRoaXMuYmdDb2xvciA9IG51bGw7XHJcblx0XHRcdHRoaXMucHJvZ3Jlc3NUZXh0LmRlc3Ryb3koKTtcclxuXHRcdFx0dGhpcy5wcm9ncmVzc1RleHQgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmdhbWUubG9hZC5vbkZpbGVDb21wbGV0ZS5yZW1vdmVBbGwoKTtcclxuXHRcdH0sXHJcblx0XHRmaWxlQ29tcGxldGU6IGZ1bmN0aW9uIChcclxuXHRcdFx0cHJvZ3Jlc3MsXHJcblx0XHRcdGNhY2hlS2V5LFxyXG5cdFx0XHRzdWNjZXNzLFxyXG5cdFx0XHR0b3RhbExvYWRlZCxcclxuXHRcdFx0dG90YWxGaWxlc1xyXG5cdFx0KSB7XHJcblx0XHRcdC8vIHRoaXMucHJvZ3Jlc3NUZXh0LnNldFRleHQodGhpcy5zZXR0aW5ncy5sb2FkaW5nX3RleHQgKyBwcm9ncmVzcyArIFwiJVwiKTtcclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gTG9hZGluZ1NjcmVlbjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogUmVwcmVzZW50IGEgUGxheSBhcyBhIG1vZGVsLCB0aGlzIGlzIHRoZSBjb2xsZWN0aW9uIG9mIHNjZW5lIGRhdGEsIGV0Yy5cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIE1vZGVsUmVnaXN0cnkgPSByZXF1aXJlKCcuL21vZGVscy9tb2RlbC1yZWdpc3RyeScpLFxyXG4gICAgICAgIE5PX0NIQVIgPSBcIm5vbmVcIjtcclxuXHJcbiAgICB2YXIgUGxheU1vZGVsID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGpzb25EYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmF3RGF0YSA9IGpzb25EYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYoICFqc29uRGF0YSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiUGxheU1vZGVsIHJlcXVpcmVzIGdhbWUgZGF0YSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoICFqc29uRGF0YS5wbGF5ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJQbGF5TW9kZWwgaGFzIG5vIHBsYXkgZGF0YS5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkdhbWVPdXRjb21lOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBtb2RlbENsYXNzID0gTW9kZWxSZWdpc3RyeS5nZXRNb2RlbCh0aGlzLmdldE1vZGVsVHlwZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwgPSBuZXcgbW9kZWxDbGFzcygpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRWYXIoXCJzdGFydF9zY2VuZVwiLCB0aGlzLmdldERlZmF1bHRTY2VuZU5hbWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJldmlvdXNTY2VuZU5hbWUoIFwiIU5PTkUhXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRTY2VuZU5hbWUoIHRoaXMuZ2V0RGVmYXVsdFNjZW5lTmFtZSgpICk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFZhcihcImRlZmF1bHRfc2NlbmVfbmFtZVwiLCB0aGlzLmdldERlZmF1bHRTY2VuZU5hbWUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSYXdEYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE1vZGVsVHlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gXCJhY3Rub3dcIiwgc2luY2UgdGhhdCB3YXMgdGhlIG9yaWdpbmFsIGFuZCBtYWtlcyBhbGwgcGxheSBmaWxlcyBiYWNrd2FyZHMgY29tcGF0aWJsZS5cclxuICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGEucGxheS5tb2RlbFR5cGUgfHwgXCJhY3Rub3dcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHNjZW5lIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEN1cnJlbnRTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2VuZSA9IHRoaXMuZ2V0U2NlbmVCeU5hbWUodGhpcy5nZXRDdXJyZW50U2NlbmVOYW1lKCkpO1xyXG4gICAgICAgICAgICBpZiggIXNjZW5lICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiZ2V0Q3VycmVudFNjZW5lIGZhaWxlZCB0byByZXR1cm4gYSBzY2VuZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNjZW5lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2NlbmVCeU5hbWU6IGZ1bmN0aW9uKCBzY2VuZU5hbWUgKSB7XHJcbiAgICAgICAgICAgIGlmKCAhc2NlbmVOYW1lICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdEYXRhLnBsYXkuc2NlbmVzW3NjZW5lTmFtZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRHbG9iYWxBY3Rpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYoIHRoaXMucmF3RGF0YS5wbGF5Lmdsb2JhbCApIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSB0aGlzLnJhd0RhdGEucGxheS5nbG9iYWwuYWN0aW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiBhY3Rpb25zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0R2xvYmFsT3V0Y29tZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5yYXdEYXRhLnBsYXkgJiYgdGhpcy5yYXdEYXRhLnBsYXkuZ2xvYmFsICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YS5wbGF5Lmdsb2JhbC5vdXRjb21lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3ZpZGUgYSBhbiBpbnRlcmZhY2UgdG8gdGhlIG1vZGVsIHRoYXQgZG9lc24ndCBhbGxvdyBmb3IgYW55dGhpbmcgYnV0XHJcbiAgICAgICAgICogcmVhZC1vbmx5IGFjY2Vzcy4gVGhpcyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIHJlZmVyZW5jaW5nIG9iamVjdFxyXG4gICAgICAgICAqIHRvIHVzZSBnZXRWYWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7Z2V0VmFyOiBGdW5jdGlvbn19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VmFySW50ZXJmYWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZ2V0QWN0b3JCeVJlZjogZnVuY3Rpb24oIGFjdG9yTmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5yYXdEYXRhLnBsYXkuZ2xvYmFsLmFjdG9yc1thY3Rvck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiggdmFyTmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5nZXRWYWx1ZSh2YXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjbGVhclZhbHVlOiBmdW5jdGlvbiggdmFyTmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFZhcih2YXJOYW1lLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgdHJ1ZSB2YWx1ZSBmb3IgYSBmaWVsZCB0aGF0IG1heSBiZSBhIHZhcmlhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiggdmFyTmFtZSApIHtcclxuICAgICAgICAgICAgaWYoIHZhck5hbWUgJiYgdHlwZW9mIHZhck5hbWUgPT09ICdzdHJpbmcnICYmIHZhck5hbWUuaW5kZXhPZignJCcpID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyKHZhck5hbWUuc3Vic3RyKDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFyTmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhIG5ldyBzY2VuZSBpbiB0aGUgbW9kZWwuIFRoaXMgb25seSBhZmZlY3RzIHRyYWNraW5nIHVudGlsIGdldEN1cnJlbnRTY2VuZSBpcyBjYWxsZWQuXHJcbiAgICAgICAgICogQXR0ZW1wdGluZyB0byBzd2l0Y2ggdG8gdGhlIHNhbWUgc2NlbmUgaXMgaWdub3JlZC5cclxuICAgICAgICAgKiBAcGFyYW0gbmV3U2NlbmVJZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnkgaXMgc2NlbmUgY2hhbmdlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRDdXJyZW50U2NlbmU6IGZ1bmN0aW9uKCBuZXdTY2VuZUlkICkge1xyXG4gICAgICAgICAgICBpZiggbmV3U2NlbmVJZCApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdTY2VuZU5hbWUgPSB0aGlzLmdldFZhbHVlKG5ld1NjZW5lSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBuZXdTY2VuZU5hbWUgIT09IHRoaXMuZ2V0Q3VycmVudFNjZW5lTmFtZSgpICYmIHRoaXMuZ2V0U2NlbmVCeU5hbWUobmV3U2NlbmVOYW1lKSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNjZW5lTmFtZSA9IHRoaXMuZ2V0Q3VycmVudFNjZW5lTmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFNjZW5lTmFtZShuZXdTY2VuZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJldmlvdXNTY2VuZU5hbWUoY3VycmVudFNjZW5lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJzZXRDdXJyZW50U2NlbmUgY2FsbGVkIHdpdGhvdXQgbmV3U2NlbmVJZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVTcGVjaWFsVmFyOiBmdW5jdGlvbiggdmFyaWFibGUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuaGFuZGxlU3BlY2lhbFZhcih2YXJpYWJsZSwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29tZXRoaW5nIGhhcyBjaGFuZ2VkIGluIHRoZSBtb2RlbC4gSWYgYSB2YXJpYWJsZSBjaGFuZ2VzLCB0aGUgc3RhdGVcclxuICAgICAgICAgKiBvZiB0aGUgYWN0IG1pZ2h0IGNoYW5nZSwgc28gaWdub3JlIGEgdmFsdWUgc3RheWluZyB0aGUgc2FtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zZXRWYXIodmFyaWFibGUsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhcjogZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmFyKHZhcmlhYmxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGZvciBvdXRjb21lcyB0aGF0IHdlcmUgY29tcGxldGVkIGJ5IGNoYW5naW5nIGEgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIHZhcmlhYmxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hlY2tGb3JDb21wbGV0ZWRPdXRjb21lczogZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcImNoZWNraW5nIGZvciBjb21wbGV0ZWQgb3V0Y29tZTogXCIgKyB2YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIHZhciBzY2VuZSA9IHRoaXMuZ2V0Q3VycmVudFNjZW5lKCksXHJcbiAgICAgICAgICAgICAgICBnT3V0Y29tZXMgPSB0aGlzLmdldEdsb2JhbE91dGNvbWVzKCksXHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nQWN0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYoICFzY2VuZS5vdXRjb21lcyAmJiAhZ091dGNvbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJTY2VuZSB3aXRoIG5vIG91dGNvbWVzIGluIGNoZWNrRm9yQ29tcGxldGVkT3V0Y29tZXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIGdPdXRjb21lcyAgKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goZ091dGNvbWVzLCBmdW5jdGlvbiAob3V0Y29tZSwgb3V0Y29tZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkNoZWNraW5nIGdsb2JhbCBvdXRjb21lOiBcIiArIG91dGNvbWVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja091dGNvbWUob3V0Y29tZSwgdmFyaWFibGUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiUGVuZGluZyBhY3Rpb24gb24gb3V0Y29tZTogXCIgKyBvdXRjb21lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2goe1wibmFtZVwiOiBvdXRjb21lTmFtZSwgXCJhY3Rpb25zXCI6IG91dGNvbWUuYWN0aW9uc30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goIHNjZW5lLm91dGNvbWVzLCBmdW5jdGlvbihvdXRjb21lLCBvdXRjb21lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiQ2hlY2tpbmcgb3V0Y29tZTogXCIgKyBvdXRjb21lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5jaGVja091dGNvbWUob3V0Y29tZSwgdmFyaWFibGUpID09PSB0cnVlICApIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIlBlbmRpbmcgYWN0aW9uIG9uIG91dGNvbWU6IFwiICsgb3V0Y29tZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2goIHsgXCJuYW1lXCI6IG91dGNvbWVOYW1lLCBcImFjdGlvbnNcIjogb3V0Y29tZS5hY3Rpb25zIH0gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCBwZW5kaW5nQWN0aW9ucy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lT3V0Y29tZS5kaXNwYXRjaCggcGVuZGluZ0FjdGlvbnMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgYWxsIG9mIHRoZSB2YXJpYWJsZXMgaW4gYW4gb3V0Y29tZSBhZ2FpbnN0IHRoZSB2YXJpYWJsZXMgaW4gdGhlIG1vZGVsLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG91dGNvbWUgb2JqZWN0IHRoYXQgc2hvdWxkIGhhdmUgJ2V2ZW50cycgb2JqZWN0IG9uIGl0LlxyXG4gICAgICAgICAqIEB2YXJpYWJsZSBUaGlzIGlzIHRoZSB2YXJpYWJsZSB0aGF0IGNoYW5nZWQsIGEgdmFyaWFibGUgaW52b2x2ZWQgaW4gdGhlIG91dGNvbWUgaGFzIHRvIGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb3V0Y29tZSBpcyBjdXJyZW50bHkgbWF0Y2hlcyB0aGUgbW9kZWwncyBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjaGVja091dGNvbWU6IGZ1bmN0aW9uKCBvdXRjb21lICwgdmFyaWFibGUgKSB7XHJcbiAgICAgICAgICAgIGlmKCAhb3V0Y29tZS5ldmVudHMgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFycmF5cyA9IF8ucGFpcnMoIG91dGNvbWUuZXZlbnRzKSxcclxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYW5zd2VyLFxyXG4gICAgICAgICAgICAgICAgZm91bmRWYXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgXy5lYWNoKCBhcnJheXMsIGZ1bmN0aW9uKCBzaW5nbGVWYXIgKSB7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXIgPSB0aGlzLmdldFZhcihzaW5nbGVWYXJbMF0pO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG91dGNvbWUgY2FuIG9ubHkgbWF0Y2ggaWYgb25lIG9mIHRoZSB2YXJpYWJsZXMgaW52b2x2ZWQgaXMgdGhlIG9uZSBjaGF0IGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICBpZiggc2luZ2xlVmFyWzBdID09PSB2YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZFZhciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2hlZCAmJiB0aGlzLm1hdGNoU2luZ2xlT3V0Y29tZSggYW5zd2VyLCBzaW5nbGVWYXJbMV0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzICk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkICYmIGZvdW5kVmFyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2hTaW5nbGVPdXRjb21lOiBmdW5jdGlvbiggbGVmdFNpZGUsIHJpZ2h0U2lkZSApIHtcclxuICAgICAgICAgICAgLy8gbG9nLndhcm4oXCJtYXRjaFNpbmdsZU91dGNvbWU6IFwiICsgbGVmdFNpZGUgKyBcIiAvIFwiICsgcmlnaHRTaWRlKTtcclxuICAgICAgICAgICAgaWYoIGxlZnRTaWRlID09PSBudWxsIHx8IGxlZnRTaWRlID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiByaWdodFNpZGUgPT09IFwic3RyaW5nXCIgJiYgKHJpZ2h0U2lkZVswXSA9PT0gJyEnIHx8IHJpZ2h0U2lkZSA9PT0gJ3VuZGVmaW5lZCcpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHR5cGVvZiByaWdodFNpZGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmKCBsZWZ0U2lkZSA9PT0gcmlnaHRTaWRlIHx8IHJpZ2h0U2lkZSA9PT0gJyonIHx8IChyaWdodFNpZGVbMF0gPT09ICchJyAmJiBsZWZ0U2lkZSAhPT0gXy50cmltKHJpZ2h0U2lkZSxcIiFcIikgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdHlwZW9mIHJpZ2h0U2lkZSA9PT0gXCJudW1iZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIGlmKCBwYXJzZUludChsZWZ0U2lkZSwxMCkgPT09IHBhcnNlSW50KHJpZ2h0U2lkZSwxMCkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihfLmlzQXJyYXkoIHJpZ2h0U2lkZSApICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlubmVyTWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCggcmlnaHRTaWRlICwgZnVuY3Rpb24oIHNpbmdsZVJpZ2h0U2lkZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaCB8fCB0aGlzLm1hdGNoU2luZ2xlT3V0Y29tZShsZWZ0U2lkZSwgc2luZ2xlUmlnaHRTaWRlKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyTWF0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZSBkYXRhIHRoYXQgYWxyZWFkeSBleGlzdGVkIGluIFNDT1JNLlxyXG4gICAgICAgICAqIERhdGEgbG9va3MgbGlrZTogU0NFTkUsWy4uLiBkZXBlbmRzIG9uIGRhdGEgbW9kZWxdXHJcbiAgICAgICAgICogU0NFTkUgPSBjdXJyZW50IHNjZW5lLiBIYW5kbGUgdGhlIHNjZW5lIGF0IHRoZSBiYXNlIG1vZGVsIGxldmVsIGJlY2F1c2Ugd2UgYWx3YXlzIHN0b3JlIHNjZW5lLCByZWdhcmRsZXNzXHJcbiAgICAgICAgICogb2YgY3VycmVudCBhY3Rpdml0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKHN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKHN1c3BlbmREYXRhKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZXN0b3JlRGF0YSggc3VzcGVuZERhdGEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY2FsbGluZyB0aGlzIHdpbGwgYXR0ZW1wdCB0byBkaXZlcnQgdGhlIG1vZGVsIHRvIHNldHRpbmcgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlXHJcbiAgICAgICAgICogc3BlY2lhbCByZXN1bWUgc2NlbmUuIFRoZSBjdXJyZW50IHNjZW5lIHdpbGwgYmUgc2F2ZWQgYXMgdGhlICdyZXN0b3JlJyBzY2VuZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0cnlSZXN1bWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZ2V0Q3VycmVudFNjZW5lTmFtZSgpICE9PSB0aGlzLmdldERlZmF1bHRTY2VuZU5hbWUoKSAmJiB0aGlzLmdldFJlc3VtZVNjZW5lKCkgKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2Fybih0aGlzLmdldEN1cnJlbnRTY2VuZU5hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRTY2VuZU5hbWUoIHRoaXMuZ2V0UmVzdW1lU2NlbmUoKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSZXN1bWVTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0RhdGEucGxheS5yZXN1bWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTdXNwZW5kRGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0U3VzcGVuZERhdGEodGhpcy5nZXRQZXJzaXN0TGlzdCgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFyIG91dCBhbnkgc2F2ZWQgY2hvaWNlcyB0byB1bmRlZmluZWQuIGN1cnJlbnRseSB0aGlzIGludm9sdmVzIHdoaWNoIGNoYXJhY3RlcnMgdGhlXHJcbiAgICAgICAgICogcGxheWVyIHNlbGVjdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyU2F2ZWRDaG9pY2VzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwuY2xlYXJTYXZlZENob2ljZXMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU2hvd1BsYXlUaHJvdWdoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YSAmJiB0aGlzLnJhd0RhdGEucGxheSAmJiB0aGlzLnJhd0RhdGEucGxheS5zaG93UGxheVRocm91Z2g7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXREZWZhdWx0U2NlbmVOYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3RGF0YS5wbGF5LnN0YXJ0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UGVyc2lzdExpc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdEYXRhLnBsYXkucGVyc2lzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEN1cnJlbnRTY2VuZU5hbWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmFyKFwiY3VycmVudF9zY2VuZV9uYW1lXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Q3VycmVudFNjZW5lTmFtZTogZnVuY3Rpb24oIHNjZW5lTmFtZSApIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VmFyKFwiY3VycmVudF9zY2VuZV9uYW1lXCIsIHNjZW5lTmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRQcmV2aW91c1NjZW5lTmFtZTogZnVuY3Rpb24oIHNjZW5lTmFtZSApIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VmFyKFwicHJldmlvdXNfc2NlbmVfbmFtZVwiLCBzY2VuZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGxheU1vZGVsO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXByZXNlbnQgYSBzcGVjaWZpYyBQbGF5IE1vZGVsIHN0cmF0ZWd5IGZvciBhIHNldCBvZiBjb3Vyc2VzL2FjdGl2aXRpZXMuXHJcbiAqXHJcbiAqIFBBID0gUGFydGljaXBhdGVcclxuICogREkgPSBEaXNjb3VyYWdlXHJcbiAqIEFMID0gQWxsb3dcclxuICogRU4gPSBFbmNvdXJhZ2VcclxuICogUFIgPSBQcmV2ZW50XHJcbiAqIFhYID0gVW5hbnN3ZXJlZFxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyksXHJcbiAgICAgICAgTk9fQ0hBUiA9IFwibm9uZVwiO1xyXG5cclxuICAgIHZhciBBY3ROb3dEYXRhID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHtcclxuICAgICAgICAgICAgICAgIFwic2NvcmVcIjogMCxcclxuICAgICAgICAgICAgICAgIFwicGxheVRocm91Z2hcIjogMSxcclxuICAgICAgICAgICAgICAgIFwiZGVjaXNpb25zQ3VycmVudFwiOiBbXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIl0sXHJcbiAgICAgICAgICAgICAgICBcImRlY2lzaW9uc1ByZXZpb3VzXCI6IFtcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiXSxcclxuICAgICAgICAgICAgICAgIFwicGhvbmVSaW5nZXJJbmRleFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJwaG9uZUJnSW5kZXhcIjogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zY29yZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBcIlBBXCI6IC0yLFxyXG4gICAgICAgICAgICAgICAgXCJESVwiOiAxLFxyXG4gICAgICAgICAgICAgICAgXCJBTFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJFTlwiOiAtMSxcclxuICAgICAgICAgICAgICAgIFwiUFJcIjogMixcclxuICAgICAgICAgICAgICAgIFwiWFhcIjogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHNwZWNpYWwgYmVoYXZpb3IgZm9yIGFjdG5vdyBiYXNlZCBhY3RzIHdoaWNoIGV4cGVjdCBkZWNpc2lvbiBwb2ludHNcclxuICAgICAgICAgKiBhbmQgc3BlY2lhbCBhY3RfY29tcGxldGUgLyBjb21wbGV0ZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHZhcmlhYmxlXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaGFuZGxlU3BlY2lhbFZhcjogZnVuY3Rpb24oIHZhcmlhYmxlLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYoIHZhcmlhYmxlLnN1YnN0cigwLDIpID09PSBcImRwXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZERlY2lzaW9uKHZhcmlhYmxlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwic2F2ZVwiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHZhcmlhYmxlID09PSBcImFjdF9jb21wbGV0ZVwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNhdmVkQ2hvaWNlcygpO1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuaW5jcmVtZW50UGxheXRocm91Z2godmFsdWUpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJjb21wbGV0ZVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbWV0aGluZyBoYXMgY2hhbmdlZCBpbiB0aGUgbW9kZWwuIElmIGEgdmFyaWFibGUgY2hhbmdlcywgdGhlIHN0YXRlXHJcbiAgICAgICAgICogb2YgdGhlIGFjdCBtaWdodCBjaGFuZ2UsIHNvIGlnbm9yZSBhIHZhbHVlIHN0YXlpbmcgdGhlIHNhbWUuXHJcbiAgICAgICAgICogUmV0dXJucyBUUlVFIGlmIHRoZSB2YXJpYWJsZSB3YXMgY2hhbmdlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIC8vbG9nLndhcm4oXCJTZXQgVmFyaWFibGU6IFwiICsgdmFyaWFibGUgKyBcIiA9IFwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICBpZiggdmFyaWFibGUgPT09IFwic2NvcmVcIiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW1wic2NvcmVcIl0gKz0gcGFyc2VJbnQodmFsdWUsMTApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdICE9PSB2YWx1ZSApICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWN0IG9uIGEgdmFsdWUgc3RheWluZyB0aGUgc2FtZS5cclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW3ZhcmlhYmxlXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VmFyOiBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgZGF0YSB0aGF0IGFscmVhZHkgZXhpc3RlZCBpbiBTQ09STS5cclxuICAgICAgICAgKiBEYXRhIGxvb2tzIGxpa2U6IFtwbGF5VGhyb3VnaCxjaGFyMSxjaGFyMixjaGFyMywxfDJ8M3w0fDV8Nnw3fDh8OSwxfDJ8M3w0fDV8Nnw3fDh8OSwxfDJ8M3w0fDV8Nnw3fDh8OV1cclxuICAgICAgICAgKiAxfDJ8M3w0fDV8Nnw3fDh8OSA9IGFuc3dlcnMgcGVyIHBsYXkgdGhyb3VnaC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKHVucGFyc2VkU3VzcGVuZERhdGEpIHtcclxuICAgICAgICAgICAgbG9nLndhcm4odW5wYXJzZWRTdXNwZW5kRGF0YSk7XHJcbiAgICAgICAgICAgIHZhciAgc3BsaXREYXRhID0gdW5wYXJzZWRTdXNwZW5kRGF0YS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzWydjdXJyZW50X3NjZW5lX25hbWUnXSA9IHNwbGl0RGF0YVswXTtcclxuICAgICAgICAgICAgdmFyIHN1c3BlbmREYXRhID0gXy5kcm9wKHNwbGl0RGF0YSwxKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5wbGF5VGhyb3VnaCA9IHBhcnNlSW50KHN1c3BlbmREYXRhWzBdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzEnXSA9IHRoaXMucmVzb2x2ZUNoYXJhY3RlcihzdXNwZW5kRGF0YVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzInXSA9IHRoaXMucmVzb2x2ZUNoYXJhY3RlcihzdXNwZW5kRGF0YVsyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzMnXSA9IHRoaXMucmVzb2x2ZUNoYXJhY3RlcihzdXNwZW5kRGF0YVszXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNQcmV2aW91cyA9IHN1c3BlbmREYXRhWzRdLnNwbGl0KFwifFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLmRlY2lzaW9uc0N1cnJlbnQgPSBzdXNwZW5kRGF0YVs1XS5zcGxpdChcInxcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5zY29yZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMudmFyaWFibGVzLmRlY2lzaW9uc0N1cnJlbnQgLCBmdW5jdGlvbihzY29yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnNjb3JlICs9IHRoaXMuY29udmVydFRvUG9pbnRzKHNjb3JlKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbmNob3NlbiBjaGFyYWN0ZXJzIGFyZSBzYXZlZCBhcyBOT19DSEFSLCByZXNvbHZlIHRoZW0gYmFjayB0byAndW5kZWZpbmVkJyBvciB0aGVpclxyXG4gICAgICAgICAqIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNvbHZlQ2hhcmFjdGVyOiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIGlmKCB2YWx1ZSA9PT0gTk9fQ0hBUiApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnZlcnRUb1BvaW50czogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnNjb3Jlc1tzdHJdICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY29yZXNbc3RyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTdXNwZW5kRGF0YTogZnVuY3Rpb24gKHBlcnNpc3RMaXN0KSB7XHJcbiAgICAgICAgICAgIC8vIHBlcnNpc3RMaXN0IGlzIG5vdCB1c2VkIGluIEFjdE5vdyEsIHdoaWNoIGhhcyBhIGZpeGVkIHNldCBvZiBzYXZlcy5cclxuICAgICAgICAgICAgdmFyIGNoYXJhY3RlcjEgPSB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzEnXSB8fCBOT19DSEFSLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyMiA9IHRoaXMudmFyaWFibGVzWydjaGFyYWN0ZXJfMiddIHx8IE5PX0NIQVIsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIzID0gdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8zJ10gfHwgTk9fQ0hBUjtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdXNwZW5kRGF0YSA9IHRoaXMudmFyaWFibGVzWydjdXJyZW50X3NjZW5lX25hbWUnXVxyXG4gICAgICAgICAgICAgICAgKyBcIixcIiArIHRoaXMudmFyaWFibGVzLnBsYXlUaHJvdWdoXHJcbiAgICAgICAgICAgICAgICArIFwiLFwiICsgY2hhcmFjdGVyMVxyXG4gICAgICAgICAgICAgICAgKyBcIixcIiArIGNoYXJhY3RlcjJcclxuICAgICAgICAgICAgICAgICsgXCIsXCIgKyBjaGFyYWN0ZXIzXHJcbiAgICAgICAgICAgICAgICArIFwiLFwiICsgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zUHJldmlvdXMuam9pbihcInxcIilcclxuICAgICAgICAgICAgICAgICsgXCIsXCIgKyB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNDdXJyZW50LmpvaW4oXCJ8XCIpO1xyXG4gICAgICAgICAgICBsb2cud2FybihzdXNwZW5kRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5kRGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlY29yZERlY2lzaW9uOiBmdW5jdGlvbiAoZHAsIGFuc3dlcikge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIlJlY29yZGluZyBkZWNpc2lvbiBcIiArIGRwICsgXCIgLyBcIiArIGFuc3dlcik7XHJcbiAgICAgICAgICAgIHZhciBkSW5kZXggPSBwYXJzZUludChkcC5zdWJzdHIoMiksIDEwKTtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zQ3VycmVudFtkSW5kZXgtMV0gPSBhbnN3ZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnNjb3JlICs9IHRoaXMuc2NvcmVzW2Fuc3dlcl07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmNyZWFzZSB0aGUgcGxheXRocm91Z2ggY291bnQsIG9wdGlvbmFsbHkgbWFya2luZyB0aGlzIGFjdCBjb21wbGV0ZS5cclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIG51bWJlcnMgbWF5IGJlIHN0cmluZ3MsIGFuZCBmb3JjZXMgdGhlbSB0byBudW1iZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb21wbGV0ZUNvdW50IG9wdGlvbmFsIHZhbHVlIGF0IHdoaWNoIHRvIG1hcmsgdGhlIGFjdCBjb21wbGV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbmNyZW1lbnRQbGF5dGhyb3VnaDogZnVuY3Rpb24oIGNvbXBsZXRlQ291bnQgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiaW5jcmVhc2luZyBwbGF5IHRocm91Z2hcIik7XHJcbiAgICAgICAgICAgIGlmKCAhY29tcGxldGVDb3VudCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiWW91IG11c3QgcHJvdmlkZSBhIGNvbXBsZXRlIGNvdW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMucGxheVRocm91Z2ggPSBwYXJzZUludCh0aGlzLnZhcmlhYmxlcy5wbGF5VGhyb3VnaCwgMTApO1xyXG5cclxuICAgICAgICAgICAgY29tcGxldGVDb3VudCA9IHBhcnNlSW50KGNvbXBsZXRlQ291bnQsMTApO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2UndmUgY29tcGxldGVkIHRoZSBkZXNpcmVkIG51bWJlciBvZiBwbGF5IHRocm91Z2hzLCBtYXJrIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICBpZiggdGhpcy52YXJpYWJsZXMucGxheVRocm91Z2ggPT09IGNvbXBsZXRlQ291bnQgKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIlRhcmdldCBwbGF5dGhyb3VnaHMgcmVhY2hlZFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnBsYXlUaHJvdWdoID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBnbyB0byB0aGUgbmV4dCBwbGF5VGhyb3VnaC5cclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMucGxheVRocm91Z2grKztcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2N1cnJlbnRfc2NlbmVfbmFtZSddID0gdGhpcy52YXJpYWJsZXNbJ2RlZmF1bHRfc2NlbmVfbmFtZSddO1xyXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBkZWNpc2lvbiBwb2ludHMgYW5kIHN0YXJ0IGEgbmV3IHNldC5cclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMuZGVjaXNpb25zUHJldmlvdXMgPSB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNDdXJyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5kZWNpc2lvbnNDdXJyZW50ID0gIFtcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiLCBcIlhYXCIsIFwiWFhcIiwgXCJYWFwiXTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFyIG91dCBhbnkgc2F2ZWQgY2hvaWNlcyB0byB1bmRlZmluZWQuIGN1cnJlbnRseSB0aGlzIGludm9sdmVzIHdoaWNoIGNoYXJhY3RlcnMgdGhlXHJcbiAgICAgICAgICogcGxheWVyIHNlbGVjdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyU2F2ZWRDaG9pY2VzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbJ2NoYXJhY3Rlcl8xJ10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzWydjaGFyYWN0ZXJfMiddID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1snY2hhcmFjdGVyXzMnXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFjdE5vd0RhdGE7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMTAvMzAvMjAxN1xyXG4gKiBDb3B5cmlnaHQgMjAxNyBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFJlcHJlc2VudCBhIHNwZWNpZmljIFBsYXkgTW9kZWwgc3RyYXRlZ3kgZm9yIGEgc2V0IG9mIGNvdXJzZXMvYWN0aXZpdGllcy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgQmFzaWNEYXRhID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzID0ge1xyXG4gICAgICAgICAgICAgICAgc2NvcmU6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgd2hlcmUgeW91IHdvdWxkIGltcGxlbWVudCBzcGVjaWFsIGJlaGF2aW9yIGZvciBhIGN1c3RvbWUgbW9kZWwgc3RyYXRlZ3kuXHJcbiAgICAgICAgICogWW91IGNhbiByZXR1cm4gYW4gZXZlbnQgc3RyaW5nIGZyb20gdGhpcyBhbmQgaXQgd2lsbCBiZSBkaXNwYXRjaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhhbmRsZVNwZWNpYWxWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb21ldGhpbmcgaGFzIGNoYW5nZWQgaW4gdGhlIG1vZGVsLiBJZiBhIHZhcmlhYmxlIGNoYW5nZXMsIHRoZSBzdGF0ZVxyXG4gICAgICAgICAqIG9mIHRoZSBhY3QgbWlnaHQgY2hhbmdlLCBzbyBpZ25vcmUgYSB2YWx1ZSBzdGF5aW5nIHRoZSBzYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFZhcjogZnVuY3Rpb24oIHZhcmlhYmxlLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgLy9sb2cud2FybihcIlNldCBWYXJpYWJsZTogXCIgKyB2YXJpYWJsZSArIFwiID0gXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmKCB2YXJpYWJsZSA9PT0gXCJzY29yZVwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbXCJzY29yZVwiXSArPSBwYXJzZUludCh2YWx1ZSwxMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0gIT09IHZhbHVlICkgIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhY3Qgb24gYSB2YWx1ZSBzdGF5aW5nIHRoZSBzYW1lLlxyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRWYXI6IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV07XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGRhdGEgdGhhdCBhbHJlYWR5IGV4aXN0ZWQgaW4gU0NPUk0uXHJcbiAgICAgICAgICogRGF0YSBsb29rcyBsaWtlOiBbVkFSOlZBTFVFfFZBUjpWQUxVRV1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKHN1c3BlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmKCBzdXNwZW5kRGF0YSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kU2V0ID0gc3VzcGVuZERhdGEuc3BsaXQoXCJ8XCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXI7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goc3VzcGVuZFNldCwgZnVuY3Rpb24gKHZhbHVlUGFpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSB2YWx1ZVBhaXIuc3BsaXQoXCI6XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PT0gMiAmJiBwYWlyWzFdICE9PSAndW5kZWZpbmVkJyAmJiBwYWlyWzFdICE9PSBcIm51bGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1twYWlyWzBdXSA9IHBhaXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihzdXNwZW5kRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5zY29yZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvciB0aGUgYmFzaWMgbW9kZWwsIHNhdmUgZXZlcnl0aGluZyB0aGF0IGl0J3MgdG9sZCB0byBzYXZlLlxyXG4gICAgICAgICAqIEBwYXJhbSBwZXJzaXN0TGlzdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U3VzcGVuZERhdGE6IGZ1bmN0aW9uIChwZXJzaXN0TGlzdCkge1xyXG4gICAgICAgICAgICB2YXIgc3VzcGVuZERhdGEgPSBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgc3VzcGVuZEVudHJpZXMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKCBwZXJzaXN0TGlzdCwgZnVuY3Rpb24oIGtleVZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBzYXZlIGRlZmluZWQgdmFyaWFibGVzLlxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMudmFyaWFibGVzW2tleVZhbHVlXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5kRW50cmllcy5wdXNoKGtleVZhbHVlICsgXCI6XCIgKyB0aGlzLnZhcmlhYmxlc1trZXlWYWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgaWYoIHN1c3BlbmRFbnRyaWVzLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5kRGF0YSA9IHN1c3BlbmRFbnRyaWVzLmpvaW4oXCJ8XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5kRGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJhc2ljRGF0YTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8xMS8yMDE3XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBpcyBhIHJlZ2lzdHJ5IGFuZCBjb25zdHJ1Y3Rpb24gZmFjdG9yeSBmb3IgTW9kZWwgU3RyYXRlZ2llczsgd2hpY2ggc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgb24gdGhlaXIgb3duLCBvbmx5XHJcbiAqIGZyb20gdGhpcyBjcmVhdGlvbiBwb2ludC5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBBY3ROb3cgPSByZXF1aXJlKCcuL2FjdG5vdycpO1xyXG4gICAgdmFyIEJhc2ljID0gcmVxdWlyZSgnLi9iYXNpYycpO1xyXG5cclxuICAgIHZhciBNb2RlbFJlZ2lzdHJ5ID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxUeXBlcyA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJNb2RlbDogZnVuY3Rpb24oIHR5cGUsIG1vZGVsICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMubW9kZWxUeXBlcywgZnVuY3Rpb24oa25vd25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZigga25vd25UeXBlID09PSB0eXBlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiWW91IGFyZSByZWdpc3RlcmluZyBhIG1vZGVsIHR5cGUgdGhhdCBhbHJlYWR5IGV4aXN0czogXCIgKyB0eXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbFR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxzW3R5cGVdID0gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24oIHR5cGUgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiUmV0dXJuaW5nIG1vZGVsIG9mIHR5cGU6IFwiICsgdHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsc1t0eXBlXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQXZhaWxhYmxlVHlwZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLm1vZGVsVHlwZXMsIGZ1bmN0aW9uKGtub3duVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIGtub3duVHlwZSA9PT0gdHlwZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRBdmFpbGFibGVUeXBlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhIGNsb25lLCB0byBtYWtlIGl0IHJlYWQgb25seS5cclxuICAgICAgICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5tb2RlbFR5cGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgTW9kZWxGYWN0b3J5ID0gbmV3IE1vZGVsUmVnaXN0cnkoKTtcclxuXHJcbiAgICAvKiBHZW5lcmFsIEFjdG9ycywgb3IgcmV1c2FibGUgYWNyb3NzIGNvdXJzZXMgKi9cclxuICAgIE1vZGVsRmFjdG9yeS5yZWdpc3Rlck1vZGVsKFwiYWN0bm93XCIsIEFjdE5vdyApO1xyXG4gICAgTW9kZWxGYWN0b3J5LnJlZ2lzdGVyTW9kZWwoXCJiYXNpY1wiLCBCYXNpYyApO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWxGYWN0b3J5O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMi4wLjBcclxuICogQGNyZWF0aW9uIDEwLzI3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSB0b3AgbGV2ZWwgY29udHJvbGxlciBmb3IgdGhlIHNjZW5lIGVuZ2luZSwgUGxheS0+QWN0KHMpLT5TY2VuZShzKS0+QWN0b3JzXHJcbiAqIFRoZSBQbGF5IG9iamVjdCBtYW5hZ2VzIGFsbCBvZiB0aGUgQWN0cyBpbiBhIFBsYXksIHNob3dpbmcgb25lIGFjdCBhdCBhIHRpbWUgYW5kIGFjY2VwdGluZyBldmVudHMgZnJvbSBBY3Qgb2JqZWN0cy5cclxuICpcclxuICogVGhlIGdlbmVyYWwgaWRlYSBpcyB0aGF0IGFuIEFjdCBpcyBhbGxvd2VkIHRvIHVzZSB0aGUgZ2FtZSBvYmplY3QgZm9yIGRyYXdpbmcgdG8gdGhlIHNjcmVlbiwgc291bmQsIGFuZCBJL08uIFRoZXJlXHJcbiAqIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFjdCBpbnN0YW50aWF0ZWQsIGFuZCB0aGV5IGFyZSBzdGFja2VkIG9uIHRvcCBvZiBlYWNoIG90aGVyICh6LWluZGV4KS4gRWFjaCBBY3QgaXMgcmVzcG9uc2libGVcclxuICogZm9yIGNsZWFuaW5nIGl0c2VsZiB1cCBhbmQgcmVtb3ZpbmcgZnJvbSB0aGUgZ2FtZSBhbnl0aGluZyBpdCBhZGRlZC4gQW4gQWN0IG11c3Qgb25seSBjb25mb3JtIHRvIHRoZSBhY3QgaW50ZXJmYWNlLFxyXG4gKiBpdCBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgcGxheS1zY2VuZS5cclxuICpcclxuICogSWYgYW55IG9mIHRoZSBhY3RzIGhhdmUgb2JqZWN0aXZlcywgdGhlbiB0aGUgZW50aXJlIHBsYXkgKHNjb3JtIGFjdGl2aXR5KSB3aWxsIG5vdCBiZSBtYXJrZWQgY29tcGxldGUgdW50aWwgYWxsXHJcbiAqIG9iamVjdGl2ZSBhY3RzIGhhdmUgcmVwb3J0ZWQgYXMgY29tcGxldGVkLiBJZiBubyBhY3RzIGhhdmUgb2JqZWN0aXZlcywgdGhlbiB0aGUgZW50aXJlIHBsYXkgd2lsbCBiZSBtYXJrZWQgY29tcGxldGVcclxuICogd2hlbiB0aGUgZGVmYXVsdCBhY3QgcmVwb3J0cyBjb21wbGV0ZS5cclxuICpcclxuICogVGhpcyB3aGF0IHRoZSBjb25maWd1cmF0aW9uIHNob3VsZCBsb29rIGxpa2UuIEluIHRoZSBnZW5lcmFsIGNhc2UsIHRoaXMgd2lsbCBjb21lIGZyb20gcGhhc2VyLiBCdXQgeW91IGNvdWxkIGp1c3RcclxuICogcGFzcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluLlxyXG4gKiB7XHJcbiAqICAgXCJuYW1lXCI6IFwiTmFtZSBvZiB0aGUgcGxheVwiLFxyXG4gKiAgIFwiZGVzY3JpcHRpb25cIjogXCJZb3UgbWF5IHVzZSB0aGlzIGxpbmUgYXMgaW4tZGF0YSBkb2N1bWVudGF0aW9uLlwiLFxyXG4gKiAgIFwic2Nvcm1cIjogdHJ1ZXxmYWxzZSxcclxuICogICBcImxvZ2dpbmdcIjogdHJ1ZXxmYWxzZSxcclxuICogICBcImFjdHNcIjoge1xyXG4gKiAgICAgXCJkZWZhdWx0XCI6IHsgLy8gWW91IE1VU1QgaGF2ZSBhbiBhY3QgY2FsbGVkICdkZWZhdWx0JyAhXHJcbiAqICAgICAgIFwiaWRcIjogXCJkZWZhdWx0XCIsIC8vIHRoaXMgaXMgYW4gaW50ZXJuYWwgSUQgdXNlZCB0byBzdG9yZSB0aGluZ3MgaW4gdGhlIHBoYXNlciBjYWNoZS4gSXQgc2hvdWxkIGJlIHVuaXF1ZSBhbW9uZyBhY3RzLlxyXG4gKiAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRXZlcnkgc2V0IG9mIGFjdHMgaGFzIGEgZGVmYXVsdCwgd2hpY2ggaXMgdGhlIGFjdCB0aGF0IGlzIHN0YXJ0ZWQgYnkgZGVmYXVsdC5cIixcclxuICogICAgICAgXCJuYW1lXCI6IFwiR3JhZGUgNiBBY3QgTm93IVwiLFxyXG4gKiAgICAgICBcImRhdGFcIjogXCJtZWRpYS9zY2VuZURhdGEuanNvblwiLFxyXG4gKiAgICAgICBcInRoZW1lXCI6IFwibWVkaWEvdGhlbWUuanNvblwiLFxyXG4gKiAgICAgICBcIm9iamVjdGl2ZVwiOiBcInhcIiwgLy8gT3B0aW9uYWwsIG9iamVjdCB0byBjb21wbGV0ZSB3aGVuIGFjdCBpcyBjb21wbGV0ZVxyXG4gKiAgICAgICBcIm9iamVjdGl2ZXNcIjogWyBcImFcIiwgXCJiXCIsIGNcIl0gLy8gb3B0aW9uYWwsIG1heSBzdGlsbCBoYXZlIFwib2JqZWN0aXZlXCIgYXMgd2VsbC5cclxuICogICAgICAgXCJ0eXBlXCI6IFwic2NlbmVcIiAvLyBvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJzY2VuZVwiLCBzcGVjaWZpZXMgd2hhdCB0eXBlIG9mIEFjdCB0byBpbnN0YW50aWF0ZS5cclxuICogICAgIH0sXHJcbiAqICAgICBcImFjdDJcIjoge1xyXG4gKiAgICAgICBcImlkXCI6IFwiYWN0MlwiLFxyXG4gKiAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwidGhpcyBpcyB0aGUgZXhjaXRpbmcgc2Vjb25kIGFjdCFcIixcclxuICogICAgICAgXCJuYW1lXCI6IFwiQWN0IFR3byFcIixcclxuICogICAgICAgXCJkYXRhXCI6IFwibWVkaWEvc2NlbmVEYXRhLmpzb25cIixcclxuICogICAgICAgXCJ0aGVtZVwiOiBcIm1lZGlhL3RoZW1lLmpzb25cIlxyXG4gKiAgICAgfSxcclxuICogICAgIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgbG9nID0gcmVxdWlyZShcImxvZ2xldmVsXCIpLFxyXG5cdFx0XyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRCYXNlID0gcmVxdWlyZShcImJhc2Vqc1wiKSxcclxuXHRcdEFjdE1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWN0L3BsYXktYWN0LW1hbmFnZXJcIiksXHJcblx0XHRTY29ybVNlcnZpY2UgPSByZXF1aXJlKFwiLi9zY29ybS1zZXJ2aWNlXCIpO1xyXG5cclxuXHR2YXIgT0JKRUNUSVZFX1BSRUZJWCA9IFwib2JqZWN0aXZlX1wiO1xyXG5cclxuXHR2YXIgUGxheSA9IEJhc2UuZXh0ZW5kKHtcclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRpb25zIG9mIHRoZSBQbGF5IG9iamVjdCwgcmVxdWlyaW5nIGJvdGggYSBQaGFzZXIgZ2FtZSBhbmQgYSBjb25maWd1cmF0aW9uIG9iamVjdCAoSlNPTilcclxuXHRcdCAqIHRoZSBjb25maWd1cmF0aW9uIHNob3VsZCBpbmNsdWRlIGEgbmFtZSwgZGVzY3JpcHRpb24gYW5kIGEgc2V0IG9mIGFjdHMuIFRoZSBhY3RzIE1VU1QgaW5jbHVkZVxyXG5cdFx0ICogYW4gYWN0IGxhYmVsbGVkICdkZWZhdWx0Jy5cclxuXHRcdCAqL1xyXG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChnYW1lLCBjb25maWcsIHNldHRpbmdzKSB7XHJcblx0XHRcdGlmICghZ2FtZSB8fCAhY29uZmlnIHx8ICFzZXR0aW5ncykge1xyXG5cdFx0XHRcdHRocm93IFwiQ3JlYXRpbmcgYSBQbGF5IHJlcXVpcmVzIGEgUGhhc2VyIGdhbWUgaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCBzZXR0aW5ncy5cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5hY3RzKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJUaGVyZSBpcyBubyAnYWN0cycgZmllbGQgaW4gdGhlIHBsYXkuanNvblwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2FtZSA9IGdhbWU7XHJcblx0XHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0XHR0aGlzLnBsYXlBY3RTZXQgPSBjb25maWcuYWN0cztcclxuXHRcdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG5cdFx0XHR0aGlzLmFjdEluc3RhbmNlcyA9IHt9O1xyXG5cdFx0XHR0aGlzLnByZXZpb3VzQWN0ID0gbnVsbDtcclxuXHRcdFx0dGhpcy53YWl0aW5nT24gPSBbXTtcclxuXHRcdFx0dGhpcy5zY29ybVNlcnZpY2UgPSBuZXcgU2Nvcm1TZXJ2aWNlKFxyXG5cdFx0XHRcdHRoaXMuZ2FtZS5zY29ybSxcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLFxyXG5cdFx0XHRcdHRoaXMucGxheUFjdFNldFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy5jb21tYW5kcyA9IHtcclxuXHRcdFx0XHRjaGFuZ2VfYWN0OiBcImNoYW5nZV9hY3RcIixcclxuXHRcdFx0XHRtdXRlX2dhbWU6IFwibXV0ZV9nYW1lXCIsXHJcblx0XHRcdFx0bXV0ZV9nYW1lX29uOiBcIm11dGVfb25cIixcclxuXHRcdFx0XHRzYXZlOiBcInNhdmVcIixcclxuXHRcdFx0XHRjb21wbGV0ZTogXCJjb21wbGV0ZVwiLFxyXG5cdFx0XHRcdG9iamVjdGl2ZTogXCJvYmplY3RpdmVcIixcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICghdGhpcy5wbGF5QWN0U2V0W3RoaXMuc2V0dGluZ3MuZGVmYXVsdF9hY3RfbmFtZV0pIHtcclxuXHRcdFx0XHR0aHJvdyBcIlBsYXkgY291bGQgbm90IHN0YXJ0LiBZb3UgZG8gbm90IGhhdmUgYSBkZWZhdWx0IEFDVC4gU2VlIHBsYXkuanMgaGVhZGVyLlwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmF1dG9TY2FsZSkge1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5zY2FsZS5zY2FsZU1vZGUgPSBQaGFzZXIuU2NhbGVNYW5hZ2VyLlNIT1dfQUxMO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXQgdGhlIERlZmF1bHQgQWN0IGFzIHRoZSBuZXh0IEFjdC5cclxuXHRcdCAqL1xyXG5cdFx0c2VsZWN0RGVmYXVsdEFjdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLnNlbGVjdE5leHRBY3QodGhpcy5zZXR0aW5ncy5kZWZhdWx0X2FjdF9uYW1lKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0ZXMgb3IgbG9va3MgdXAgYW4gZXhpc3RpbmcgQWN0LiBBbnkgY3VycmVudGx5IHJ1bm5pbmcgQWN0IHdpbGxcclxuXHRcdCAqIGJlIHN0b3BwZWQuIFdoZW4gYSBuZXcgQWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhY2hlZC5cclxuXHRcdCAqIFRoaXMgZG9lcyBOT1Qgc3RhcnQgdGhlIEFjdCwgYWZ0ZXIgc2VsZWN0TmV4dEFjdCgpLCBzdGFydE5leHRBY3QoKSBtdXN0IGJlIGNhbGxlZC5cclxuXHRcdCAqIEBwYXJhbSBhY3ROYW1lIE5hbWUgb2YgQWN0IGZyb20gUGxheS5qc29uIHRvIHN0YXJ0LlxyXG5cdFx0ICovXHJcblx0XHRzZWxlY3ROZXh0QWN0OiBmdW5jdGlvbiAoYWN0TmFtZSkge1xyXG5cdFx0XHQvLyBFeGl0IGFueSBjdXJyZW50IGFjdC5cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudEFjdCkge1xyXG5cdFx0XHRcdC8vIHRoZSBkZWZhdWx0IGFjdCBzaG91bGQgbm90IGJlIHN0b3BwZWQuXHJcblx0XHRcdFx0aWYgKHRoaXMuY3VycmVudEFjdC5hY3ROYW1lICE9PSB0aGlzLnNldHRpbmdzLmRlZmF1bHRfYWN0X25hbWUpIHtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudEFjdC5zdG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMucHJldmlvdXNBY3QgPSB0aGlzLmN1cnJlbnRBY3Q7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERvbid0IGNyZWF0ZSBhbiBhY3QgdGhhdCBhbHJlYWR5IGV4aXN0cy5cclxuXHRcdFx0aWYgKHRoaXMuYWN0SW5zdGFuY2VzW2FjdE5hbWVdKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0ID0gdGhpcy5hY3RJbnN0YW5jZXNbYWN0TmFtZV07XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LnNldFNjb3JtU3RyaW5nKHRoaXMucGxheUFjdFNldFthY3ROYW1lXS5zdXNwZW5kRGF0YSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBMb29rIHVwIGFuZCBjcmVhdGUgYW4gQWN0IHRoYXQgZG9lc24ndCBleGlzdC5cclxuXHRcdFx0dmFyIG5leHRBY3REYXRhID0gdGhpcy5wbGF5QWN0U2V0W2FjdE5hbWVdO1xyXG5cdFx0XHR2YXIgbmV4dEFjdFRoZW1lID0gSlNPTi5wYXJzZShcclxuXHRcdFx0XHR0aGlzLmdhbWUuY2FjaGUuZ2V0VGV4dCh0aGlzLnNldHRpbmdzLnRoZW1lX3ByZWZpeCArIG5leHRBY3REYXRhLmlkKVxyXG5cdFx0XHQpO1xyXG5cdFx0XHRpZiAodGhpcy5jb25maWcuYXV0b1NjYWxlKSB7XHJcblx0XHRcdFx0Ly8gSWYgYXV0b1NjYWxlIGlzIHNldCB0byB0cnVlIGluIHRoZSBwbGF5Lmpzb24gZmlsZSBhZGQgYSBwcm9wZXJ0eSB0byB0aGUgdGhlbWUgdG8gc211Z2dsZSBpdCBpbnRvIHRoZSBhY3QgZm9yIHVzZSBieSBhY3RvcnMsIHdobyBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIHBsYXkuanNvbiBzZXR0aW5ncy4gRm9yIGV4YW1wbGUsIHRoZSBXSVNUSUEgYWN0b3Igc2l6ZXMgdGhlIHZpZGVvIGRpdiBkaWZmZXJlbnRseSBhY2NvcmRpbmcgdG8gdGhlIGF1dG9TY2FsZSBzZXR0aW5nLlxyXG5cdFx0XHRcdG5leHRBY3RUaGVtZS5pbnRlcm5hbF9hdXRvU2NhbGUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRBY3QgPSBBY3RNYW5hZ2VyLmdldEFjdEluc3RhbmNlKFxyXG5cdFx0XHRcdG5leHRBY3REYXRhLnR5cGUsXHJcblx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdG5leHRBY3RUaGVtZSxcclxuXHRcdFx0XHRhY3ROYW1lXHJcblx0XHRcdCk7XHJcblx0XHRcdC8vIE9ubHkgdGhlIGRlZmF1bHQgQWN0IGNvdW50cyBhcyBzdGFuZCBhbG9uZS5cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudEFjdC5zZXRTdGFuZEFsb25lKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LnNldFN0YW5kQWxvbmUoXHJcblx0XHRcdFx0XHRhY3ROYW1lID09PSB0aGlzLnNldHRpbmdzLmRlZmF1bHRfYWN0X25hbWVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFN1YnNjcmliZSB0byBhbGwgZXZlbnRzLlxyXG5cdFx0XHR0aGlzLmN1cnJlbnRBY3QuZXZlbnRzLm9uR2FtZUNob2ljZS5hZGQodGhpcy5vbkdhbWVDaG9pY2VFdmVudCwgdGhpcyk7XHJcblx0XHRcdHRoaXMuY3VycmVudEFjdC5ldmVudHMub25BY3RTdGF0dXMuYWRkKHRoaXMub25BY3RTdGF0dXNFdmVudCwgdGhpcyk7XHJcblx0XHRcdC8vIFJlc3RvcmUgdGhlIEFjdCBmcm9tIHRoZSBcIlNhdmVcIiBwb2ludC5cclxuXHRcdFx0dGhpcy5jdXJyZW50QWN0LnNldFNjb3JtU3RyaW5nKG5leHRBY3REYXRhLnN1c3BlbmREYXRhKTtcclxuXHRcdFx0dGhpcy5hY3RJbnN0YW5jZXNbYWN0TmFtZV0gPSB0aGlzLmN1cnJlbnRBY3Q7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiAgVGhpcyBpcyB0aGUgaG9vayBpbnRvIHJlc3RhcnRpbmcgdGhlIG1haW4gUGhhc2VyIHN0YXRlIGFuZCBsYXVuY2hpbmcgYSBuZXcgQWN0LlxyXG5cdFx0ICogIFRoZSBuZXcgQWN0IHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiBzZWxlY3RlZCB1c2luZyBzZWxlY3ROZXh0QWN0KCkuXHJcblx0XHQgKiAgVGhpcyB3aWxsIGxlYWQgdG8gc2hvd0FjdCgpIGJlaW5nIGNhbGxlZCBmcm9tIHRoZSBtYWluIHN0YXRlLlxyXG5cdFx0ICovXHJcblx0XHRzdGFydE5leHRBY3Q6IGZ1bmN0aW9uIChpc1Jlc3RhcnQpIHtcclxuXHRcdFx0dGhpcy5nYW1lLnN0YXRlLnJlc3RhcnQoZmFsc2UsIGZhbHNlLCBpc1Jlc3RhcnQpOyAvLyB0cnVlLCBmYWxzZSBtZWFucyBcImNsZWFyIHdvcmxkLCBrZWVwIGNhY2hlXCJcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZnVuY3Rpb25hbCB3aWxsIGFjdHVhbGx5IHN0YXJ0IGFuIGFjdCB1cCwgYW5kIHRoZW4gcHJvdmlkZSBpdCB3aXRoIGluZm9ybWF0aW9uIG9uIHRoZSBvdGhlciBhY3RzLlxyXG5cdFx0ICogSXQgd2lsbCB0ZWxsIGFuIGFjdCB3aGljaCBwcmV2aW91cyBhY3QgZXhpdGVkLCBhbGxvd2luZyBhbiBhY3QgdG8ga25vdyBib3RoIHdoaWNoIGFjdCBjYW1lIGJlZm9yZSBhbmRcclxuXHRcdCAqIHRoYXQgaXQgaXNuJ3QgZmlyc3QuXHJcblx0XHQgKiBTZWNvbmQsIGl0IHdpbGwgaW5mb3JtIGEgbm9uLWZpcnN0IGFjdCBpZiB0aGUgcHJldmlvdXMgYWN0cyBvYmplY3RpdmUgc3RhdHVzIChhY3RfZXhpdGVkICsgb2JqZWN0aXZlIHN0YXR1cylcclxuXHRcdCAqIEZvciBhIGZpcnN0IChEZWZhdWx0KSBhY3QsIHRoZSBzdGF0dXMgb2YgZXZlcnkgb3RoZXIgYWN0IG9iamVjdGl2ZSB3aWxsIGJlIHBhc3NlZCBpbiwgYnV0IG9ubHkgaWYgdGhhdFxyXG5cdFx0ICogYWN0IGlzIHRyYWNraW5nIGJ5IG9iamVjdGl2ZS5cclxuXHRcdCAqIEBwYXJhbSBpc1Jlc3RhcnRcclxuXHRcdCAqL1xyXG5cdFx0c2hvd05leHRBY3Q6IGZ1bmN0aW9uIChpc1Jlc3RhcnQpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRBY3QpIHtcclxuXHRcdFx0XHR0aHJvdyBcIk5vIGN1cnJlbnQgQWN0IHRvIHN0YXJ0IVwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2luZ2xlQWN0RGF0YSA9IHRoaXMucGxheUFjdFNldFt0aGlzLmN1cnJlbnRBY3QuYWN0TmFtZV07XHJcblxyXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIG9iamVjdGl2ZSwgaXQgbWF5IG5lZWQgdG8gYmUgbWFya2VkIGFzIHN0YXJ0ZWQuXHJcblx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLm1hcmtBY3RTdGFydGVkKHNpbmdsZUFjdERhdGEuaWQpO1xyXG5cclxuXHRcdFx0Ly8gVGhlcmUgaXMgbm8gbmVlZCB0byBzdGFydCB0aGUgZGVmYXVsdCBhY3QsIGl0J3Mgbm90IHN0b3BwZWQuIEJ1dCB0aGlzIG1heSBiZSB0aGUgZmlyc3QgY2FsbC5cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdCF0aGlzLnByZXZpb3VzQWN0IHx8XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LmFjdE5hbWUgIT09IHRoaXMuc2V0dGluZ3MuZGVmYXVsdF9hY3RfbmFtZVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5jdXJyZW50QWN0Lm9uUHJlbG9hZEZpbmlzaGVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRBY3Qub25QcmVsb2FkRmluaXNoZWQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0LnN0YXJ0KGlzUmVzdGFydCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgd2lsbCBzZW5kIHZhcmlhYmxlcyB0byB0aGUgY3VycmVudCBhY3QgZnJvbSB0aGUgcHJldmlvdXMgb3IgYWxsIGFjdHMsIHNvIHdoZW4gdGhlIGRlZmF1bHRcclxuXHRcdCAqIGFjdCBzdGFydHMsIGl0IHdpbGwga25vdyBhYm91dCBhbGwgdHJhY2tlZCBvYmplY3RpdmUgdmFyaWFibGVzIGluIG90aGVyIGFjdHMuXHJcblx0XHQgKi9cclxuXHRcdHNlbmRDcm9zc0FjdFZhcmlhYmxlczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgb2JqZWN0aXZlU2V0ID0gW107XHJcblx0XHRcdHZhciB0ZW1wO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMucHJldmlvdXNBY3QpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRBY3Qub25HYW1lQ2hvaWNlKHsgYWN0X2V4aXRlZDogdGhpcy5wcmV2aW91c0FjdC5hY3ROYW1lIH0pO1xyXG5cdFx0XHRcdHZhciBwcmV2aW91c0FjdERhdGEgPSB0aGlzLnBsYXlBY3RTZXRbdGhpcy5wcmV2aW91c0FjdC5hY3ROYW1lXTtcclxuXHRcdFx0XHRvYmplY3RpdmVTZXQgPSB0aGlzLnNjb3JtU2VydmljZS5nZXRBY3RPYmplY3RpdmVTdGF0dXNTZXQoXHJcblx0XHRcdFx0XHRwcmV2aW91c0FjdERhdGEuaWRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9IC8qIGRlZmF1bHQgYWN0ICovIGVsc2Uge1xyXG5cdFx0XHRcdG9iamVjdGl2ZVNldCA9IHRoaXMuc2Nvcm1TZXJ2aWNlLmdldFBsYXlPYmplY3RpdmVTdGF0dXNTZXQoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0b2JqZWN0aXZlU2V0LFxyXG5cdFx0XHRcdGZ1bmN0aW9uIChlYWNoT2JqZWN0aXZlKSB7XHJcblx0XHRcdFx0XHR0ZW1wID0ge307XHJcblx0XHRcdFx0XHR0ZW1wW09CSkVDVElWRV9QUkVGSVggKyBlYWNoT2JqZWN0aXZlLmdldElkKCldID1cclxuXHRcdFx0XHRcdFx0ZWFjaE9iamVjdGl2ZS5nZXRTdGF0dXMoKTtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudEFjdC5vbkdhbWVDaG9pY2UodGVtcCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGxheWVyIG1hZGUgYSBnYW1lIGNob2ljZS4gVGhpcyBtYXkgYmUgYSBzcGVjaWFsIGNvbW1hbmQgZm9yIHRoZSBQbGF5LlxyXG5cdFx0ICogQXR0ZW1wdCB0byBleGVjdXRlIGl0LCBhbmQgYWxsb3cgdGhlIGV4ZWN1dGlvbiB0byBkZXRlcm1pbmUgaWYgdGhlIGV2ZW50IHdhc1xyXG5cdFx0ICogY29uc3VtZWQuXHJcblx0XHQgKiBAcGFyYW0gZXZlbnRQYWlyXHJcblx0XHQgKi9cclxuXHRcdG9uR2FtZUNob2ljZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnRQYWlyKSB7XHJcblx0XHRcdHZhciB0ZW1wVmFycyA9IF8ucGFpcnMoZXZlbnRQYWlyKVswXTtcclxuXHRcdFx0ZXZlbnRQYWlyLmNvbnN1bWVkID0gdGhpcy5wbGF5Q29tbWFuZCh0ZW1wVmFyc1swXSwgdGVtcFZhcnNbMV0pO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHBsYXllciBjYXVzZWQgYSBzdGF0dXMgZXZlbnQ7IHVzdWFsbHkgZWl0aGVyIGEgc2F2ZSBvciBhIGNvbXBsZXRpb24gb2YgYW4gYWN0aXZpdHkuIFRoZXNlIGFyZW4ndFxyXG5cdFx0ICogY2F1ZWQgYnkgcGxheWVyJ3MgZGlyZWN0bHksIGJ1dCBieSB0aGUgU2NlbmVzL0FjdHMuXHJcblx0XHQgKiBcImFjdF9jb21wbGV0ZVwiIC0+IGluY3JlbWVudCBwbGF5dGhyb3VnaCAtPiBcImNvbXBsZXRlXCIgc3RhdHVzIGV2ZW50LlxyXG5cdFx0ICogQHBhcmFtIGV2ZW50Q29tbWFuZFxyXG5cdFx0ICovXHJcblx0XHRvbkFjdFN0YXR1c0V2ZW50OiBmdW5jdGlvbiAoZXZlbnRDb21tYW5kLCBldmVudEFyZykge1xyXG5cdFx0XHRpZiAoZXZlbnRDb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLnNhdmUpIHtcclxuXHRcdFx0XHR0aGlzLnNhdmVTY29ybURhdGEoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChldmVudENvbW1hbmQgPT09IHRoaXMuY29tbWFuZHMuY29tcGxldGUpIHtcclxuXHRcdFx0XHR0aGlzLnNjb3JtU2VydmljZS5oYW5kbGVBY3RDb21wbGV0ZSh0aGlzLmN1cnJlbnRBY3QuYWN0TmFtZSk7IC8vIGFjdE5hbWUgPT09IGFjdElkXHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRDb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLm9iamVjdGl2ZSkge1xyXG5cdFx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLm1hcmtPYmplY3RpdmVDb21wbGV0ZShldmVudEFyZyk7XHJcblx0XHRcdFx0dGhpcy5zYXZlU2Nvcm1EYXRhKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIEV4ZWN1dGUgYSBQbGF5IGxldmVsIGNvbW1hbmQsIHN1Y2ggYXMgc2F2aW5nIG9yIGNoYW5naW5nIGFjdHMuXHJcblx0XHQgKiBSZXR1cm5zIHRydWUgaWYgaXQgY29uc3VtZXMgdGhlIGNvbW1hbmQvY2hvaWNlLlxyXG5cdFx0ICovXHJcblx0XHRwbGF5Q29tbWFuZDogZnVuY3Rpb24gKGNvbW1hbmQsIGFyZykge1xyXG5cdFx0XHRsb2cud2FybihcInBsYXkgY29tbWFuZDogXCIgKyBjb21tYW5kICsgXCIgLyBcIiArIGFyZyk7XHJcblx0XHRcdGlmIChjb21tYW5kID09PSB0aGlzLmNvbW1hbmRzLmNoYW5nZV9hY3QpIHtcclxuXHRcdFx0XHRsb2cud2FybihcIkNoYW5naW5nIGFjdCB0byBcIiArIGFyZyk7XHJcblx0XHRcdFx0aWYgKHRoaXMucGxheUFjdFNldFthcmddKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNlbGVjdE5leHRBY3QoYXJnKTtcclxuXHRcdFx0XHRcdHRoaXMuc3RhcnROZXh0QWN0KHRydWUpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsb2cuZXJyb3IoXCJSZXF1ZXN0IHRvIGNoYW5nZSB0byBub24tZXhpc3RhbnQgYWN0OiBcIiArIGFyZyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IHRoaXMuY29tbWFuZHMuc2F2ZSkge1xyXG5cdFx0XHRcdHRoaXMuc2F2ZVNjb3JtRGF0YSgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IHRoaXMuY29tbWFuZHMubXV0ZV9nYW1lKSB7XHJcblx0XHRcdFx0Ly8gR0pGIC0gMDkvMjAvMTcgLSBJIG1heSBoYXZlIGp1c3QgYnJva2UgbXV0ZSBmb3IgYWxsIHBhc3QgYWN0aXZpdGllcyBieSBmaXhpbmcgdGhpcyBsaW5lLlxyXG5cdFx0XHRcdHRoaXMuZ2FtZS5zb3VuZC5tdXRlID1cclxuXHRcdFx0XHRcdGFyZyA9PT0gdGhpcy5jb21tYW5kcy5tdXRlX2dhbWVfb24gPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBSZXR1cm4gZmFsc2UgYmVjYXVzZSB0aGlzIGlzbid0ICdjb25zdW1pbmcnLCBpdCdzIGEgc2lkZSBlZmZlY3Qgc3BlY2lhbCBjYXNlLlxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIExvYWQgdGhlIHRoZW1lIGFuZCBkYXRhIGZpbGVzIGZvciBlYWNoIGFjdCBpbiBwbGF5Lmpzb25cclxuXHRcdCAqIFRoaXMgdXNlZCB0byBcInByZWxvYWRcIiwgYnV0IG5vdyBpdCByZXR1cm5zIGEgc2V0LCB0aGUgcGxheSBpcyBubyBsb25nZXIgcmVzcG9uc2libGUgZm9yIGxvYWRpbmdcclxuXHRcdCAqIHJlc291cmNlcy5cclxuXHRcdCAqIFRoaXMgY2FuJ3QgYmUgZG9uZSBmb3IgdGhlIGFjdCBiZWNhdXNlIGl0IHdvdWxkIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IDotKFxyXG5cdFx0ICovXHJcblx0XHRnZXRSZXF1aXJlZFJlc291cmNlTGlzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgcHJlbG9hZFNldCA9IFtdO1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0dGhpcy5nZXRBY3RzTGlzdCgpLFxyXG5cdFx0XHRcdGZ1bmN0aW9uIChhY3QpIHtcclxuXHRcdFx0XHRcdGxvZy53YXJuKFxyXG5cdFx0XHRcdFx0XHRcImxvYWRpbmcgdGV4dCBcIiArXHJcblx0XHRcdFx0XHRcdFx0YWN0LnRoZW1lICtcclxuXHRcdFx0XHRcdFx0XHRcIiBhcyBcIiArXHJcblx0XHRcdFx0XHRcdFx0KHRoaXMuc2V0dGluZ3MudGhlbWVfcHJlZml4ICsgYWN0LmlkKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHByZWxvYWRTZXQucHVzaCh7XHJcblx0XHRcdFx0XHRcdGtleTogdGhpcy5zZXR0aW5ncy50aGVtZV9wcmVmaXggKyBhY3QuaWQsXHJcblx0XHRcdFx0XHRcdGZpbGU6IHRoaXMuZ2FtZS5jb25maWcuYXNzZXRQYXRoICsgYWN0LnRoZW1lLFxyXG5cdFx0XHRcdFx0XHR0eXBlOiBcImpzb25cIixcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHQpO1xyXG5cdFx0XHRyZXR1cm4gcHJlbG9hZFNldDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZW4gdGhlIG1haW4gUGhhc2VyIHN0YXRlIGlzIHJlc3RhcnRlZCwgZHVyaW5nIHRoZSBQaGFzZXIgcHJlbG9hZCBmdW5jdGlvbiwgdGhpcyBwcmVsb2FkIHdpbGwgYmUgY2FsbGVkXHJcblx0XHQgKiBzbyB0aGF0IHRoZSBuZXcgQWN0IGhhcyBhIHZhbGlkIGVudHJ5IHBvaW50IHRvIGxvYWRpbmcgYXNzZXRzLiBUaGUgQWN0IGNhbiBsb2FkIGFueSByZXNvdXJjZXMgbmVjZXNzYXJ5LlxyXG5cdFx0ICovXHJcblx0XHRwcmVsb2FkQWN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3QpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRBY3QucHJlbG9hZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYWN0IGRldGVybWluZXMgd2hlbiBpdCBpcyBkb25lIGxvYWRpbmcsIHNvIHdoZW4gYXNrZWQsIGRlbGVnYXRlIHRvIHRoZSBBY3QuXHJcblx0XHQgKi9cclxuXHRcdGlzUHJlbG9hZEFjdENvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRBY3QgJiYgdGhpcy5jdXJyZW50QWN0LmlzUHJlbG9hZENvbXBsZXRlKCk7XHJcblx0XHR9LFxyXG5cdFx0aXNMb2dnaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5sb2dnaW5nID09PSB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdGdldEFjdHNMaXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnBsYXlBY3RTZXQ7XHJcblx0XHR9LFxyXG5cdFx0aXNTY29ybUVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLnNjb3JtID09PSB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdHJlbmRlckRlYnVnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRBY3QgJiYgdGhpcy5zZXR0aW5ncy5kZWJ1ZyA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC5yZW5kZXJEZWJ1ZygpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0aGlzIGlzIHRoZSBnYW1lIGxvb3AuIElmIHRoZSBhY3QgaXMgYSBnYW1lLCBvciBoYXMgYSBkZWxheSwgb3IgbmVlZHMgdG8gZG8gdGltaW5nLCBpdCBTSE9VTEQgTk9UXHJcblx0XHQgKiB1c2UgaXRzIG93biB1cGRhdGUgZnVuY3Rpb24sIGJ1dCBzaG91bGQgaW5zdGVhZCBwcm92aWRlIGEgdGlja1VwZGF0ZS4gVGhpcyB3aWxsIGJlIGNhbGxlZCBoZXJlIHNvXHJcblx0XHQgKiB0aGF0IHRoZSB1cGRhdGUoKSBjYWxscyBhcmUgY29udHJvbGxlZCBmcm9tIHRoZSBwbGF5LlxyXG5cdFx0ICogQHBhcmFtIHRpbWVcclxuXHRcdCAqL1xyXG5cdFx0dGlja1VwZGF0ZTogZnVuY3Rpb24gKHRpbWUpIHtcclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudEFjdCkge1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEFjdC50aWNrVXBkYXRlKHRoaXMuZ2FtZS50aW1lLm5vdyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRsb2FkU2Nvcm1EYXRhOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLmxvYWRTY29ybU9iamVjdGl2ZURhdGEoKTtcclxuXHRcdFx0dGhpcy5zY29ybVNlcnZpY2UubG9hZFNjb3JtU3VzcGVuZERhdGEoKTtcclxuXHRcdH0sXHJcblx0XHRzYXZlU2Nvcm1EYXRhOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuc2Nvcm1TZXJ2aWNlLnNhdmVTY29ybU9iamVjdGl2ZURhdGEoKTtcclxuXHRcdFx0dmFyIHNjb3JtU3RyaW5nID0gdGhpcy5jdXJyZW50QWN0LmdldFNjb3JtU3RyaW5nKCk7XHJcblx0XHRcdGlmIChzY29ybVN0cmluZyAmJiBzY29ybVN0cmluZy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dGhpcy5zY29ybVNlcnZpY2Uuc2F2ZVNjb3JtU3VzcGVuZERhdGEoXHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRBY3QuYWN0TmFtZSxcclxuXHRcdFx0XHRcdHNjb3JtU3RyaW5nXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBQbGF5O1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogUmVwcmVzZW50IHRoZSBzZXQgb2Ygc2Nvcm0gb3BlcmF0aW9ucyB0aGF0IGFyZSByZXF1aXJlZCBieSBhIFBsYXkuIFRoaXMgaW52b2x2ZXMgdGhlIHNhdmluZywgbG9hZGluZyBhbmQgdXBkYXRpbmdcclxuICogb2YgYWxsIG9iamVjdGl2ZXMgYW5kIHN1c3BlbmQgZGF0YS5cclxuICpcclxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90IGhhbmRsZSBnYW1lIGV2ZW50cyBvciBzZW5kIGdhbWUgbm90aWZpY2F0aW9ucyB0byBhY3RzL3NjZW5lcy9ldGMuIEl0IG9ubHkgbWFuYWdlcyBzY29ybVxyXG4gKiByZWxhdGVkIGRhdGEgYXMgcmVxdWlyZWQuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKFwiYmFzZWpzXCIpO1xyXG5cclxuICAgIHZhciBTVEFUVVNfTk9UX0FUVEVNUFRFRCA9IFwibm90IGF0dGVtcHRlZFwiO1xyXG4gICAgdmFyIFNUQVRVU19BVFRFTVBURUQgPSBcImluY29tcGxldGVcIjtcclxuICAgIHZhciBTVEFUVVNfQ09NUExFVEVEID0gXCJjb21wbGV0ZWRcIjtcclxuXHJcbiAgICB2YXIgU2Nvcm1PYmplY3RpdmUgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBhY3RJZCwgaW5kZXgsIGlkLCBzdGF0dXMgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0SWQgPSBhY3RJZDtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0U3RhdHVzOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTdGF0dXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRJZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEFjdElkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIFNjb3JtU2VydmljZSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHNjb3JtLCBzZXR0aW5ncywgcGxheUFjdFNldCkge1xyXG4gICAgICAgICAgICBpZiAoIXNjb3JtIHx8ICFzZXR0aW5ncyB8fCAhcGxheUFjdFNldCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJZb3UgbXVzdCBwcm92aWRlIGFuIGludGVyZmFjZSB0byBzY29ybSBhbmQgc2V0dGluZ3MuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zY29ybSA9IHNjb3JtO1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUFjdFNldCA9IHBsYXlBY3RTZXQ7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlU2V0ID0gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXJrQWN0U3RhcnRlZDogZnVuY3Rpb24gKGFjdElkKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5nZXRBY3RPYmplY3RpdmVTdGF0dXNTZXQoYWN0SWQpLCBmdW5jdGlvbihvYmplY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RpdmUuZ2V0U3RhdHVzKCkgIT09IFNUQVRVU19DT01QTEVURUQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3RpdmUuc2V0U3RhdHVzKFNUQVRVU19BVFRFTVBURUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZU9iamVjdGl2ZShvYmplY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcmtPYmplY3RpdmVDb21wbGV0ZTogZnVuY3Rpb24oIG9iamVjdGl2ZUlkICkge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0aXZlID0gXy5maW5kV2hlcmUoIHRoaXMub2JqZWN0aXZlU2V0LCB7IGlkOiBvYmplY3RpdmVJZH0pO1xyXG4gICAgICAgICAgICBpZiggb2JqZWN0aXZlICkge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0aXZlLnNldFN0YXR1cyhTVEFUVVNfQ09NUExFVEVEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZU9iamVjdGl2ZShvYmplY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BsYXlDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRBY3RPYmplY3RpdmVTdGF0dXNTZXQ6IGZ1bmN0aW9uIChhY3RJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy53aGVyZSh0aGlzLm9iamVjdGl2ZVNldCwge2FjdElkOiBhY3RJZH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UGxheU9iamVjdGl2ZVN0YXR1c1NldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdGl2ZVNldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXlIYXNPYmplY3RpdmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gKHRoaXMub2JqZWN0aXZlU2V0Lmxlbmd0aCA+IDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgaXQncyBwYXJ0IG9mIHRoZSBzdGFydHVwIG9mIHRoaXMgc2VydmljZSBhbmQgb3V0c2lkZSBzb3VyY2VzIHNob3VsZCBub3QgYWNjZXNzXHJcbiAgICAgICAgICogdGhlIHJhdyBkYXRhIGxpa2UgdGhpczsgd2hpY2ggaXMgaW4ganNvbiB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHJlYWQgb25seS5cclxuICAgICAgICAgKiBUaGlzIGJ1aWxkcyBhIHJhdyBsaXN0IG9mIG9iamVjdGl2ZSBuYW1lcyBiYXNlZCBvbiBldmVyeSBhY3QgaW4gdGhlIHBsYXkgZGF0YS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRSYXdPYmplY3RpdmVMaXN0OiBmdW5jdGlvbiggYWN0RGF0YSApIHtcclxuICAgICAgICAgIHZhciBvYmplY3RMaXN0ID0gW107XHJcbiAgICAgICAgICBpZiggYWN0RGF0YS5vYmplY3RpdmUgKSB7XHJcbiAgICAgICAgICAgICAgb2JqZWN0TGlzdC5wdXNoKGFjdERhdGEub2JqZWN0aXZlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKCBhY3REYXRhLm9iamVjdGl2ZXMgKSB7XHJcbiAgICAgICAgICAgICAgb2JqZWN0TGlzdCA9IG9iamVjdExpc3QuY29uY2F0KGFjdERhdGEub2JqZWN0aXZlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gb2JqZWN0TGlzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBsb2FkIG9yIGluaXRpYWxpemUgYW4gb2JqZWN0aXZlIG9iamVjdCBmb3IgZXZlcnkgb2JqZWN0aXZlIGluIHRoZSBwbGF5LiBJdCB3aWxsIGluaXRpYWxpemVcclxuICAgICAgICAgKiB0aGUgb2JqZWN0IHdpdGggU0NPUk0gaWYgaXQgaGFzbid0IGJlZW4gcHJldmlvdXNseSBpbml0aWFsaXplZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsb2FkU2Nvcm1PYmplY3RpdmVEYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdGl2ZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nT2JqZWN0aXZlO1xyXG4gICAgICAgICAgICB2YXIgYWN0T2JqZWN0aXZlTGlzdDtcclxuICAgICAgICAgICAgdmFyIG5ld09iamVjdGl2ZTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5wbGF5QWN0U2V0LCBmdW5jdGlvbiggc2luZ2xlQWN0ICkge1xyXG4gICAgICAgICAgICAgICAgYWN0T2JqZWN0aXZlTGlzdCA9IHRoaXMuZ2V0UmF3T2JqZWN0aXZlTGlzdChzaW5nbGVBY3QpO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKCBhY3RPYmplY3RpdmVMaXN0LCBmdW5jdGlvbiggZWFjaE9iamVjdGl2ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3RpdmUgPSBuZXcgU2Nvcm1PYmplY3RpdmUoc2luZ2xlQWN0LmlkLCBvYmplY3RpdmVJbmRleCwgZWFjaE9iamVjdGl2ZSwgU1RBVFVTX05PVF9BVFRFTVBURUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nT2JqZWN0aXZlID0gdGhpcy5sb2FkT2JqZWN0aXZlKG9iamVjdGl2ZUluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBleGlzdGVkLCBvdGhlcndpc2Ugd2Ugd291bGRuJ3QgaGF2ZSBhIG1hdGNoaW5nIGlkIVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBleGlzdGluZ09iamVjdGl2ZS5zdGF0dXMgJiYgZXhpc3RpbmdPYmplY3RpdmUuaWQgPT09IG5ld09iamVjdGl2ZS5nZXRJZCgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3RpdmUuc2V0U3RhdHVzKGV4aXN0aW5nT2JqZWN0aXZlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlT2JqZWN0aXZlKG5ld09iamVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdGl2ZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVTZXQucHVzaChuZXdPYmplY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdmVTY29ybU9iamVjdGl2ZURhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBTY29ybSBvYmplY3RpdmVzIGFyZSBub3QgcmVndWxhcmx5IHNhdmVkLlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZFNjb3JtU3VzcGVuZERhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgdmFyIHNjb3JtRGF0YSA9IHRoaXMuc2Nvcm0uZ2V0U3VzcGVuZERhdGEoKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsb2cud2FybihzY29ybURhdGEpO1xyXG5cclxuICAgICAgICAgICAgc2Nvcm1EYXRhID0gc2Nvcm1EYXRhLnNwbGl0KHRoaXMuc2V0dGluZ3Muc2Nvcm1fc2VwYXJhdG9yX2NoYXIpO1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLnBsYXlBY3RTZXQsIGZ1bmN0aW9uKCBzaW5nbGVBY3QgKSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVBY3Quc3VzcGVuZERhdGEgPSBzY29ybURhdGFbaW5kZXhdIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdmVTY29ybVN1c3BlbmREYXRhOiBmdW5jdGlvbiggYWN0SWQsIHNjb3JtU3RyaW5nICkge1xyXG4gICAgICAgICAgICB2YXIgc2Nvcm1EYXRhID0gW107XHJcbiAgICAgICAgICAgIHZhciBzYXZlU3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5QWN0U2V0W2FjdElkXS5zdXNwZW5kRGF0YSA9IHNjb3JtU3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLnBsYXlBY3RTZXQsIGZ1bmN0aW9uKHNpbmdsZUFjdCkge1xyXG4gICAgICAgICAgICAgICAgc2Nvcm1EYXRhLnB1c2goc2luZ2xlQWN0LnN1c3BlbmREYXRhKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBzYXZlU3RyaW5nID0gc2Nvcm1EYXRhLmpvaW4odGhpcy5zZXR0aW5ncy5zY29ybV9zZXBhcmF0b3JfY2hhcik7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKHNhdmVTdHJpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLnNjb3JtLnNldFN1c3BlbmREYXRhKHNhdmVTdHJpbmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYWN0IGNvbXBsZXRlIGV2ZW50IGhhcyBiZWVuIHNlbnQsIGdlbmVyYWxseSBtZWFuaW5nIFwiY29tcGxldGUgdGhlIG9ubHkgb2JqZWN0aXZlIGZvciB0aGlzIGFjdFwiLlxyXG4gICAgICAgICAqIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbiBvYmplY3RpdmUgaW4gdGhlIGFjdCwgdGhpcyBmdW5jdGlvbiBvbmx5IGNoZWNrcyBmb3IgJ2FsbCBjb21wbGV0ZScuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJbiBcIkFjdCBOb3dcIiwgYm90aCBcIm9iamVjdGl2ZV9jb21wbGV0ZVwiIGFuZCBcImFjdF9jb21wbGV0ZVwiIHdvdWxkIGxlYWQgdG8gdGhpcy4gRm9yIG5vbi1hY3Rub3csIGN1cnJlbnRseVxyXG4gICAgICAgICAqIG9ubHkgXCJvYmplY3RpdmVfY29tcGxldGVcIiB3aWxsIGxlYWQgdG8gdGhpcywgYnV0IG90aGVyIG1vZGVscyBtYXkgYWN0IGRpZmZlcmVudGx5LiBUaGlzIGRlcGVuZHMgb24gYVxyXG4gICAgICAgICAqICBcImNvbXBsZXRlXCIgYWN0LXN0YXR1cyBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0SWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBoYW5kbGVBY3RDb21wbGV0ZTogZnVuY3Rpb24oYWN0SWQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdE9iamVjdGl2ZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYoIHRoaXMucGxheUhhc09iamVjdGl2ZXMoKSApIHtcclxuICAgICAgICAgICAgICAgIGFjdE9iamVjdGl2ZXMgPSAgdGhpcy5nZXRBY3RPYmplY3RpdmVTdGF0dXNTZXQoYWN0SWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIG9iamVjdGl2ZSwgc28gbWFyayBpdCBjb21wbGV0ZS5cclxuICAgICAgICAgICAgICAgIGlmKCBhY3RPYmplY3RpdmVzLmxlbmd0aCA9PT0gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RPYmplY3RpdmVzWzBdLnNldFN0YXR1cyhTVEFUVVNfQ09NUExFVEVEKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVPYmplY3RpdmUoYWN0T2JqZWN0aXZlc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGxheUNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBvYmplY3RpdmVzIC0geW91J3JlIGRvbmUhXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3JtLm1hcmtDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja1BsYXlDb21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5vYmplY3RpdmVTZXQsIGZ1bmN0aW9uKG9iamVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIG9iamVjdGl2ZS5nZXRTdGF0dXMoKSAhPT0gU1RBVFVTX0NPTVBMRVRFRCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgaWYoIGFsbENvbXBsZXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY29ybS5tYXJrQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZE9iamVjdGl2ZTogZnVuY3Rpb24oIG9iamVjdGl2ZUluZGV4ICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29ybS5nZXRPYmplY3RpdmUob2JqZWN0aXZlSW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2F2ZU9iamVjdGl2ZTogZnVuY3Rpb24oIG9iamVjdGl2ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zY29ybS5zZXRPYmplY3RpdmUob2JqZWN0aXZlLmdldEluZGV4KCksIG9iamVjdGl2ZS5nZXRJZCgpLCBvYmplY3RpdmUuZ2V0U3RhdHVzKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gU2Nvcm1TZXJ2aWNlO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDYvMDQvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdHZhciBCb290U3RhdGUgPSByZXF1aXJlKFwiLi9zdGF0ZXMvYm9vdC5qc1wiKSxcclxuXHRcdFByZWxvYWRTdGF0ZSA9IHJlcXVpcmUoXCIuL3N0YXRlcy9wcmVsb2FkLmpzXCIpLFxyXG5cdFx0TWFpblN0YXRlID0gcmVxdWlyZShcIi4vc3RhdGVzL21haW4uanNcIiksXHJcblx0XHRTY29ybSA9IHJlcXVpcmUoXCIuL3Njb3JtXCIpO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb21FbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHR2YXIgY29uZmlnID0ge1xyXG5cdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRyZW5kZXJlcjogUGhhc2VyLkNBTlZBUywgLy8gU2V0IHRvIENhbnZhcyB0byBoZWxwIElFLlxyXG5cdFx0XHRwYXJlbnQ6IGRvbUVsZW1lbnQsXHJcblx0XHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHRcdFx0YW50aWFsaWFzOiB0cnVlLFxyXG5cdFx0XHRmb3JjZVNldFRpbWVPdXQ6IGZhbHNlLFxyXG5cdFx0XHRhc3NldFBhdGg6IF9lbnZpcm9ubWVudFNldHRpbmdzLmFzc2V0UGF0aCwgLy8gbm90IGEgc3RhbmRhcmQgUGhhc2VyIHByb3BlcnR5IC0gdXNlZCB0byBwYXNzIGluIHJlbGF0aXZlIGxvYWRpbmcgcGF0aHMgZm9yIGRpZmZlcmVudCBob3N0IGVudmlyb25tZW50cyAoTE1TLCBDTVMsIGV0Yy4pLiBfZW52aXJvbm1lbnRTZXR0aW5ncy5hc3NldFBhdGggaXMgZGVjbGFyZWQgaW4gSFRNTCBmaWxlLlxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgc2V0dGluZ3MgPSB7XHJcblx0XHRcdHBsYXlfanNvbl9rZXk6IFwicGxheURhdGFcIixcclxuXHRcdFx0bG9hZGluZ19pbWFnZV9rZXk6IFwicHJlbG9hZGVyQmFyXCIsXHJcblx0XHRcdGxvYWRpbmdfaW1hZ2VfdXJsOiBjb25maWcuYXNzZXRQYXRoICsgXCJtZWRpYS9jd2xvZ28ucG5nXCIsXHJcblx0XHRcdGxvYWRpbmdfYmdfY29sb3I6IFwiMHgwMDc0YzhcIixcclxuXHRcdFx0bG9hZGluZ19mb250OiB7XHJcblx0XHRcdFx0Zm9udDogXCJBcmlhbCwgSGVsdmV0aWNhLCBTYW5zXCIsXHJcblx0XHRcdFx0Zm9udFNpemU6IDI2LFxyXG5cdFx0XHRcdGZpbGw6IFwiI2ZmZmZmZlwiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsb2FkaW5nX3RleHQ6IFwiTG9hZGluZy4uLlwiLFxyXG5cdFx0XHRwbGF5X2pzb25fdXJsOiBjb25maWcuYXNzZXRQYXRoICsgXCJtZWRpYS9wbGF5Lmpzb25cIixcclxuXHRcdFx0dGhlbWVfcHJlZml4OiBcInRoZW1lX1wiLFxyXG5cdFx0XHRkYXRhX3ByZWZpeDogXCJkYXRhX1wiLFxyXG5cdFx0XHRwcmVsb2FkX3N0YXRlX25hbWU6IFwicHJlbG9hZFwiLFxyXG5cdFx0XHRtYWluX3N0YXRlX25hbWU6IFwibWFpblwiLFxyXG5cdFx0XHRib290X3N0YXRlX25hbWU6IFwiYm9vdFwiLFxyXG5cdFx0XHRkZWZhdWx0X2FjdF9uYW1lOiBcImRlZmF1bHRcIixcclxuXHRcdFx0c2Nvcm1fc2VwYXJhdG9yX2NoYXI6IFwiJFwiLFxyXG5cdFx0XHRsb2dnaW5nOiB0cnVlLFxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgZ2FtZSA9IG5ldyBQaGFzZXIuR2FtZShjb25maWcpO1xyXG5cdFx0Z2FtZS5zY29ybSA9IG5ldyBTY29ybSgpO1xyXG5cdFx0Z2FtZS5zdGF0ZS5hZGQoc2V0dGluZ3MuYm9vdF9zdGF0ZV9uYW1lLCBuZXcgQm9vdFN0YXRlKHNldHRpbmdzKSk7XHJcblx0XHRnYW1lLnN0YXRlLmFkZChzZXR0aW5ncy5wcmVsb2FkX3N0YXRlX25hbWUsIG5ldyBQcmVsb2FkU3RhdGUoc2V0dGluZ3MpKTtcclxuXHRcdGdhbWUuc3RhdGUuYWRkKHNldHRpbmdzLm1haW5fc3RhdGVfbmFtZSwgbmV3IE1haW5TdGF0ZShzZXR0aW5ncykpO1xyXG5cdFx0Z2FtZS5zdGF0ZS5zdGFydChzZXR0aW5ncy5ib290X3N0YXRlX25hbWUpO1xyXG5cclxuXHRcdHJldHVybiBnYW1lO1xyXG5cdH07XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDcvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEFuIGFjdGlvbiB0aGF0IGFkZHMgYW4gYWN0b3IgdG8gYSBzY2VuZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgQWRkQWN0b3JBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hcmdzLCBmdW5jdGlvbiggZWFjaEFyZyApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5hY3RDb21tYW5kKFwiYWRkLWFjdG9yXCIsIGVhY2hBcmcpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFkZEFjdG9yQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBhZGRzIGFuIGFjdG9yIHRvIGEgc2NlbmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIENoYW5nZU9iamVjdGl2ZUFjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBlYWNoQXJnICkge1xyXG4gICAgICAgICAgICAgICAgYWN0LmFjdENvbW1hbmQoXCJvYmplY3RpdmVcIiwgZWFjaEFyZyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhbmdlT2JqZWN0aXZlQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBzY2VuZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgU2NlbmVBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdC5zaG93TmV3U2NlbmUodGhpcy5hcmdzWzBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjZW5lQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBkb2VzIGFuIGFkZGl0aW9uYWwgb3V0Y29tZSBjaGVjayBiYXNlZCBvbiBnaXZlbiB2YXJpYWJsZShzKSwgY2FuIGJlIHVzZWQgdG8gZm9yY2UgdGhlIGNoZWNrXHJcbiAqIG9mIG91dGNvbWVzIGV2ZW4gd2hlbiB0aGUgcGxheWVyIGhhc24ndCBkaXJlY3RseSBhY3RlZCBvbiBpdC5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgQ2hlY2tPdXRjb21lc0FjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBlYWNoQXJnICkge1xyXG4gICAgICAgICAgICAgICAgYWN0LmNoZWNrQ3VycmVudFNjZW5lT3V0Y29tZXMoZWFjaEFyZyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hlY2tPdXRjb21lc0FjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wNy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIG1vc3QgYmFzaWMgb2YgYWN0aW9ucywgcmVjb3JkIGEgdmFyaWFibGUuXHJcbiAqIFRoaXMgYWN0aW9uIHRha2VzIHRocmVlIGFyZ3VtZW50cy5cclxuICogMSAtIG5hbWUgb2YgdmFyaWFibGV8Y2hvaWNlfGNvbW1hbmRcclxuICogMiAtIHZhbHVlIG9mIHZhcmlhYmxlfGNob2ljZXxjb21tYW5kXHJcbiAqIDMgLSBib29sZWFuIGZvcmNlIHZhbHVlLCBvcHRpb25hbC5cclxuICpcclxuICogSWYgeW91IHNldCB0aGUgJ2ZvcmNlIHZhbHVlJywgdGhlIHZhbHVlIHdpbGwgZmlyc3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtb2RlbCBtYW51YWxseS4gVGhpcyB3b3VsZCBhbGxvdyB5b3UgdG9cclxuICogc2V0IGEgdmFsdWUgKGFuZCBjYXVzZSBhbiBvdXRjb21lKSBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdy4gVGhpcyB3b3VsZCBub3JtYWxseSBiZSBibG9ja2VkIGJlY2F1c2UgdGhlIG1vZGVsXHJcbiAqIGlnbm9yZXMgdmFsdWVzIGJlaW5nIHNldCByZXBlYXRlZGx5LlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBWYXJpYWJsZUFjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7fTtcclxuICAgICAgICAgICAgdGVtcFthY3QubW9kZWwuZ2V0VmFsdWUodGhpcy5hcmdzWzBdKV0gPSBhY3QubW9kZWwuZ2V0VmFsdWUodGhpcy5hcmdzWzFdKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYXJnc1szXSA9PT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5jbGVhclZhcmlhYmxlKHRoaXMuYXJnc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0Lm9uR2FtZUNob2ljZUFjdGlvbih0ZW1wKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZhcmlhYmxlQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBhZGRzIGFuIGFjdG9yIHRvIGEgc2NlbmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIE1hcmtDb21wbGV0ZUFjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBlYWNoQXJnICkge1xyXG4gICAgICAgICAgICAgICAgYWN0LmFjdENvbW1hbmQoXCJhY3Rpdml0eV9jb21wbGV0ZVwiLCBlYWNoQXJnKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXJrQ29tcGxldGVBY3Rpb247XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFBhdWwgS25lbGxcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEyLzIwLzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGFjdGlvbiBpcyBjdXN0b21pemVkIGZvciBNaXNzaW9uLUhlYWx0aCBhbmQgdXNlZFxyXG4gKiB0byB1cGRhdGUgU0NPUk0gZGF0YSBwcmlvciB0byBzd2l0Y2hpbmcgc2NlbmVzLiBUaGlzIHdhcyBuZWVkZWRcclxuICogYmVjYXVzZSBzZXR0aW5nIHRoZSBTQ09STSBcImNvbXBsZXRlZFwiIGZsYWcgKGF0IHRoZSBlbmQgb2YgdGhlIGxlc3NvbilcclxuICogbWF5IHRha2UgMS0yIHNlY29uZHMuICBDb25zZXF1ZW50bHksIHdlIG5lZWQgdG8gc2V0IHRoaXMgaW1tZWRpYXRlbHlcclxuICogcHJpb3IgdG8gc3dpdGNoaW5nIHRvIHRoZSBtaXNzaW9uLWNvbXBsZXRlZCBzY2VuZSBBTkQgd2UgbmVlZCB0byBzdG9wXHJcbiAqIGF1ZGlvIGZpcnN0IHRvIGF2b2lkIGl0IGJlaW5nIGludGVyZmVyZWQgd2l0aCBieSB0aGUgc3luY2hyb25vdXMgSFRUUCByZXF1ZXN0XHJcbiAqIHRoYXQgU0NPUk0gdXNlcy4gUmVmZXIgdG8gR2l0TGFiIElzc3VlICM0MjcuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBWYXJpYWJsZUFjdGlvbiA9IHJlcXVpcmUoJy4uL2dhbWUtY2hvaWNlLmpzJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBNaFNjZW5lQWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihhY3QpIHtcclxuICAgICAgICAgICAgaWYoICFhY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImFjdGlvbiByZXF1aXJlcyBhbiBhY3QgdG8gd29yayBvbi5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1NjZW5lTmFtZSA9IHRoaXMuYXJnc1swXTtcclxuICAgICAgICAgICAgdmFyIHZhcnNNYXAgPSB0aGlzLmFyZ3NbMV0gfHwge307XHJcblxyXG4gICAgICAgICAgICBfLmZvck93bih2YXJzTWFwLCBmdW5jdGlvbih2YWx1ZSwgdmFyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgKG5ldyBWYXJpYWJsZUFjdGlvbihbdmFyTmFtZSwgdmFsdWVdKSkuZXhlY3V0ZShhY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGFjdC5hdWRpb1NlcnZpY2Uuc3RvcFNjZW5lKCk7IC8vIFN0b3AgYXVkaW8gYmVmb3JlIHNlbmRpbmcgU0NPUk0gdXBkYXRlcyB0byBhdm9pZCBpbnRlcnJ1cHRlZCBhdWRpb1xyXG5cclxuICAgICAgICAgICAgYWN0LmV2ZW50cy5vbkFjdFN0YXR1cy5kaXNwYXRjaChcInNhdmVcIik7XHJcblxyXG4gICAgICAgICAgICBhY3Quc2hvd05ld1NjZW5lKG5ld1NjZW5lTmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNaFNjZW5lQWN0aW9uO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBzY2VuZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgUmVtb3ZlQWN0b3JBY3Rpb24gPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGFjdCkge1xyXG4gICAgICAgICAgICBpZiggIWFjdCApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIGFuIGFjdCB0byB3b3JrIG9uLlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hcmdzLCBmdW5jdGlvbiggZWFjaEFyZyApIHtcclxuICAgICAgICAgICAgICAgIGFjdC5hY3RDb21tYW5kKFwicmVtb3ZlLWFjdG9yXCIsYWN0Lm1vZGVsLmdldFZhbHVlKGVhY2hBcmcpKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVBY3RvckFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgUGF1bCBLbmVsbFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMTAvMTUvMjAxOFxyXG4gKiBDb3B5cmlnaHQgMjAxOCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgYWN0aW9uIGFkZHMgYSB2YWx1ZSB0byBhIG51bWVyaWMgdmFyaWFibGUuXHJcbiAqIFNpbmNlIGFsbCB2YXJpYWJsZXMgYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBpdCB3aWxsIGZpcnN0IGJlIHBhcnNlZCBpbnRvIGEgbnVtYmVyLlxyXG4gKiBcclxuICogVGhpcyBhY3Rpb24gdGFrZXMgdGhyZWUgYXJndW1lbnRzLlxyXG4gKiAxIC0gbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gaW5jcmVtZW50XHJcbiAqIDIgLSBudW1lcmljIGFtb3VudCBvZiB0aGUgaW5jcmVtZW50IChvciBkZWNyZW1lbnQsIGlmIG5lZ2F0aXZlKVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBWYXJpYWJsZUluY3JlbWVudEFjdGlvbiA9IEJhc2UuZXh0ZW5kKCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oYWN0KSB7XHJcbiAgICAgICAgICAgIGlmKCAhYWN0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJhY3Rpb24gcmVxdWlyZXMgYW4gYWN0IHRvIHdvcmsgb24uXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBudW1lcmljVmFsdWUgPSBOdW1iZXIoYWN0Lm1vZGVsLmdldFZhbHVlKCckJyt0aGlzLmFyZ3NbMF0pKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKG51bWVyaWNWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIHRoZSB2YXJpYWJsZSB0byBiZSBudW1iZXIuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBOdW1iZXIodGhpcy5hcmdzWzFdKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGluY3JlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0aW9uIHJlcXVpcmVzIHRoZSBpbmNyZW1lbnQgdG8gYmUgbnVtYmVyLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBudW1lcmljVmFsdWUgKz0gaW5jcmVtZW50O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7fTtcclxuICAgICAgICAgICAgdGVtcFthY3QubW9kZWwuZ2V0VmFsdWUodGhpcy5hcmdzWzBdKV0gPSBudW1lcmljVmFsdWUudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGFjdC5vbkdhbWVDaG9pY2VBY3Rpb24odGVtcCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZUluY3JlbWVudEFjdGlvbjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gYW5ub3VuY2VyIGJ1YmJsZS4gVGhlIGFubm91bmNlciBib3ggaXMgb3B0aW9uYWwuXHJcbiAqIEl0IHdpbGwgZGlzcGxheSB0ZXh0IGFuZCBvcHRpb25hbGx5IHBsYXkgYXVkaW8uXHJcbiAqIFRoaXMgaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBzcGVlY2ggYnViYmxlLCBvbmx5IGl0IGlzbid0IGxpc3RlbmluZyBmb3IgZXZlbnRzIHRvIGNoYW5nZSBpdHMgdGV4dC5cclxuICpcclxuICoge1xyXG4gKiAgICBcIm5hbWVcIjogXCJhbm5vdW5jZXJCb3hcIixcclxuICogICAgIFwidHlwZVwiOiBcImFubm91bmNlclwiLFxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDIsIDUgXSwgLy8gbG9jYXRpb24gb24gc2NyZWVuLlxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiV2VsY29tZSB0byBOZXdicmlkZ2UgTWlkZGxlIFNjaG9vbC5cIiwgLy8gdGV4dCB0byBkaXNwbGF5LlxyXG4gKiAgICAgXCJhdWRpb1wiOiBcIm5hcl82dGhfaW50XzAxXCIsIC8vIEF1ZGlvIHRvIHBsYXlcclxuICogICAgIFwiYW5ub3VuY2VyQm94XCI6IHRydWUgLy8gc2hvdyB0aGUgYW5ub3VuY2VyIGJveFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9LFxyXG4gKlxyXG4gKiBAVE9ETyB1cGRhdGUgdGhpcyBjbGFzcyB0byBzaG93IGFueSBpY29uIGFzIHRoZSAnYW5ub3VuY2VyJy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBBbm5vdW5jZXJBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gQ29uc3RydWN0b3IgaXMgaW4gcGFyZW50LlxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSB0aGlzLmRhdGEuYXVkaW87XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0gdGhpcy5kYXRhLmtleTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFggPSB0aGlzLmRhdGEubG9jYXRpb25bMF07XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYW5ub3VuY2VyQm94KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFubm91bmNlckJveCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pbnZlcnNlU291bmRFdmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvdygpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFNwZWVjaCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEFubm91bmNlckJveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFubm91bmNlckJveCA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKCAnYW5ub3VuY2VyLWJveCcsICdhY3RvckltYWdlcycpICk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFggKz0gdGhpcy5hbm5vdW5jZXJCb3gud2lkdGggLSAxMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCA1IHRoaW5ncyB0byBhIGdyb3VwOlxyXG4gICAgICAgICAqIDEuIEEgdG9wIFwic3ByaXRlXCIgd2hpY2ggaXMgdGhlIHRvcCBvZiB0aGUgdGV4dCBidWJibGUuXHJcbiAgICAgICAgICogMi4gVGV4dCwgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGZvciB0aGlzIHNwcml0ZSBhbmQgd3JhcHBpbmcgaXRzIGZvbnQuXHJcbiAgICAgICAgICogMy4gQSBtaWRkbGUgXCJ0aWxlc3ByaXRlXCIgd2hpY2ggaXMgYSByZXBlYXRpbmcgbWlkZGxlIHNwcml0ZSBtYWRlIHRvIG1hdGNoIHRoZSBoZWlnaHQgb2YgdGhlIHRleHQuXHJcbiAgICAgICAgICogNC4gQSBib3R0b20gXCJzcHJpdGVcIiB3aGljaCBpcyB0aGUgYm90dG9tIG9mIHRoZSB0ZXh0IGJ1YmJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRXaW5kb3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzIHx8ICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzLmFubm91bmNlICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBbm5vdW5jZXIgYWN0b3IgcmVxdWlyZXMgdGV4dFdpbmRvd3MgdGhlbWUgZW50cnksIGFuZCBhbm5vdW5jZSBzZWN0aW9uIGluc2lkZSBpdC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgd2luZG93R3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLnggPSB0aGlzLmN1cnJlbnRYO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC55ID0gdGhpcy5jdXJyZW50WTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXJnaW5YID0gOCxcclxuICAgICAgICAgICAgICAgIG1hcmdpblkgPSAyMDtcclxuICAgICAgICAgICAgdmFyIHRvcFdpbmRvdyA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3MuYW5ub3VuY2UudG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdidWJibGVUZXh0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gdGhpcy5nZXRGb250KCdyZXBsYXlBdWRpbycpO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLndvcmRXcmFwV2lkdGggPSB0b3BXaW5kb3cud2lkdGggKiAuODU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgbWFyZ2luWCArIDUwLCBtYXJnaW5ZLCB0aGlzLnRleHQsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKHRoaXMuY3VycmVudFRleHQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pZGRsZUhlaWdodCA9IHRoaXMuY3VycmVudFRleHQuaGVpZ2h0IC0gKHRvcFdpbmRvdy5oZWlnaHQgLSBtYXJnaW5ZKTtcclxuICAgICAgICAgICAgaWYoIG1pZGRsZUhlaWdodCA8IDUgKSB7XHJcbiAgICAgICAgICAgICAgICBtaWRkbGVIZWlnaHQgPSA1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVXaW5kb3cgPSBuZXcgUGhhc2VyLlRpbGVTcHJpdGUodGhpcy5nYW1lLCAwLCB0b3BXaW5kb3cuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgdG9wV2luZG93LndpZHRoLCBtaWRkbGVIZWlnaHQsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0V2luZG93cy5hbm5vdW5jZS5taWRkbGUpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5hZGQobWlkZGxlV2luZG93KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBib3R0b21ZID0gdGhpcy5jdXJyZW50VGV4dC55ICsgdGhpcy5jdXJyZW50VGV4dC5oZWlnaHQgKyBtYXJnaW5ZO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tV2luZG93ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIHRvcFdpbmRvdy5oZWlnaHQgKyBtaWRkbGVXaW5kb3cuaGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3MuYW5ub3VuY2UuYm90dG9tKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDUuIEFkZCBldmVudGluZy5cclxuICAgICAgICAgICAgdGhpcy53aW5kb3dzID0ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiB0b3BXaW5kb3csXHJcbiAgICAgICAgICAgICAgICBtaWRkbGU6IG1pZGRsZVdpbmRvdyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tV2luZG93XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBfLmVhY2godGhpcy53aW5kb3dzLCBmdW5jdGlvbiAoYnViYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBidWJibGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZS5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZUluLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZS5ldmVudHMub25JbnB1dE91dC5hZGQodGhpcy5vbk1vdXNlT3V0LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZS5ldmVudHMub25JbnB1dFVwLmFkZCh0aGlzLm9uUG9pbnRlclVwLCB0aGlzKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCAoYm90dG9tV2luZG93LnggKyBib3R0b21XaW5kb3cud2lkdGggLSA0MCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgKHRvcFdpbmRvdy5oZWlnaHQgKyBib3R0b21XaW5kb3cuaGVpZ2h0ICsgbWlkZGxlV2luZG93LmhlaWdodCkgLyAyLCBcIlJlcGxheSBBdWRpb1wiLCB0aGlzLnJTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC5hbmNob3Iuc2V0VG8oMC41LCAwLjUpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5hZGQodGhpcy5yZXBsYXlUZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0LnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gd2luZG93R3JvdXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlSW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUuZmlsbCA9IHRoaXMudGhlbWUudGludHMuYnViYmxlVGV4dDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRTdHlsZSh0aGlzLmZTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUuZmlsbCA9IHRoaXMuZ2V0Rm9udCgnYnViYmxlVGV4dCcpLmZpbGw7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuc2V0U3R5bGUodGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEdhbWVTcGVlY2goIHt0ZXh0OiB0aGlzLnRleHQsIGF1ZGlvOiB0aGlzLmF1ZGlvLCBrZXk6IHRoaXMua2V5fSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTcGVlY2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRUZXh0KHRoaXMudGV4dCk7XHJcbiAgICAgICAgICAgIC8vIG1heSBuZWVkIHRvIGFkanVzdCBoZWlnaHRzL2V0Yy5cclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEdhbWVTcGVlY2goIHt0ZXh0OiB0aGlzLnRleHQsIGF1ZGlvOiB0aGlzLmF1ZGlvLCBrZXk6IHRoaXMua2V5fSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93cyApIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCh0aGlzLndpbmRvd3MsIGZ1bmN0aW9uIChidWJibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWJibGUuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndpbmRvd3MgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuYW5ub3VuY2VyQm94ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZXJCb3guZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZXJCb3ggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5ub3VuY2VyQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIGNob2ljZSBhY3Rvciwgd2hpY2ggd2lsbCBzaG93IHRoZSBwbGF5ZXIgYSBtdWx0aXBsZSBjaG9pY2UgcXVlc3Rpb24uIEl0IHdpbGwgYWxzb1xyXG4gKiBwbGF5IGFueSBhdWRpby90ZXh0IGFzc29jaWF0ZWQgd2l0aCBhc2tpbmcgcXVlc3Rpb24uXHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImNob2ljZXNfbWFuZHlfMVwiLCAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcImNob2ljZVwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJzdGFydENob2ljZVwiOiBcImRwMVwiLCAvLyB3aGljaCBjaG9pY2UgdG8gc3RhcnQgd2l0aCBmcm9tIHRoZSBjaG9pY2VNYXAgc2V0LlxyXG4gKiAgICAgXCJjaG9pY2VNYXBcIjoge1xyXG4gKiAgICAgICAgIFwiZHAxXCI6IHsgLy8gdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGlzIGNob2ljZSwgdXNlZCB3aGVuIGxpbmtpbmcgY2hvaWNlc1xyXG4gKiAgICAgICAgICAgICBcInRleHRcIjogXCJJ4oCZbSBNYW5keS4gQ2xpY2sgb25lIG9mIHRoZSByZXNwb25zZSBidWJibGVzIGJlbG93IHRvIHJlc3BvbmQgdG8gbWUuXCIsIC8vIHF1ZXN0aW9uLiBJdCBjYW4gYmUgYmxhbmsuXHJcbiAqICAgICAgICAgICAgIFwiYXVkaW9cIjogXCI2dGhfaW50XzAxXCIsIC8vIGF1ZGlvLCBpdCBpcyBvcHRpb25hbC5cclxuICogICAgICAgICAgICAgXCJrZXlcIjogXCJtYW5keVwiLCAvLyBhIGtleSBpbnRvIGEgc2V0IG9mIGF1ZGlvLiBvcHRpb25hbC5cclxuICogICAgICAgICAgICAgXCJkZWNpc2lvblBvaW50XCI6IHRydWUsIC8vIG1hcmsgdGhpcyBvcHRpb24gZm9yIHNhdmluZy5cclxuICogICAgICAgICAgICAgXCJjaG9pY2VzXCI6IFtcclxuICogICAgICAgICAgICAgICAgIHtcclxuICogICAgICAgICAgICAgICAgICAgIFwibGlua1wiOiBcImRwMlwiLCAgLy8gd2hpY2ggcXVlc3Rpb24vY2hvaWNlcyB0byBzaG93IG5leHQuXHJcbiAqICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJPbmUgb2YgdGhlc2U/XCIgLy8gZGlzcGxheWVkIHRleHQgb2YgdGhpcyBjaG9pY2UuXHJcbiAqICAgICAgICAgICAgICAgICAgICBcImRlY2lzaW9uXCI6IFwiUFJcImV2ZW50IHwgXCJBTFwibG93IHwgXCJFTlwiY291cmFnZSB8IFwiUEFcInJ0aWNwYXRlIHwgXCJESVwic2NvdXJhZ2UgIChSZXF1aXJlZCBpZiBkZWNpc2lvblBvaW50ID09PSB0cnVlIClcclxuICogICAgICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICAgICB7XHJcbiAqICAgICAgICAgICAgICAgICAgICBcImxpbmtcIjogXCJkcDJcIixcclxuICogICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlNvLCB0aGlzIGlzIGhvdyB3ZSB0YWxrP1wiKlxyXG4gKiAgICAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgICAgIHtcclxuICogICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIllvdSBtZWFuIHRoZXNlIGJ1YmJsZXM/XCIsIC8vIHRleHQgdG8gc2hvdyBmb3IgdGhpcyBjaG9pY2UuXHJcbiAqICAgICAgICAgICAgICAgICAgICBcInZhcmlhYmxlXCI6IFwiY2hvaWNlXzJcIiwgLy8gdmFyaWFibGUgdG8gc2V0IHdoZW4gdGhpcyBjaG9pY2UgaXMgc2VsZWN0ZWQuXHJcbiAqICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiemlua19tYW5keVwiICAgLy8gdmFsdWUgdG8gc2V0IHZhcmlhYmxlIHRvLlxyXG4gKiAgICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAuLi4gLy8gYXMgbWFueSBjaG9pY2VzIGFzIHlvdSB3YW50LlxyXG4gKiAgICAgICAgICB9XHJcbiAqICAgICAgICAgfSxcclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKlxyXG4gKiAgRm9yIGEgZGVjaXNpb24gcG9pbnQsIHlvdSBjYW4gc3RsbCBkbyBhIHZhcmlhYmxlL3ZhbHVlIGFuZCBsaW5rLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBNQVhfQ0hPSUNFUyA9IDUsXHJcbiAgICAgICAgY2hvaWNlTWFwID0geyBcIlBSXCIgOiAwLCBcIkRJXCIgOiAxLCBcIkFMXCI6IDIsIFwiRU5cIjogMywgXCJQQVwiOiA0fSxcclxuICAgICAgICBtYXJnaW5ZID0gNixcclxuICAgICAgICBtYXJnaW5Gb250ID0gMjU7XHJcblxyXG4gICAgdmFyIENob2ljZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImNob2ljZU1hcFwiLCBcInN0YXJ0Q2hvaWNlXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNob2ljZU1hcCA9IHRoaXMuZGF0YS5jaG9pY2VNYXA7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENob2ljZSA9IHRoaXMuY2hvaWNlTWFwW3RoaXMuZGF0YS5zdGFydENob2ljZV07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgcXVlc3Rpb25zIGFuZCBidWlsZCB0aGUgY29ycmVjdCBjaG9pY2UgbGlzdC5cclxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIGRlY2lzaW9uIHBvaW50IGNob2ljZSwgdXNlIHRoZSBwcmV2aW91cyBjaG9pY2VzIHBlciB0aGUgZm9ybXVsYS4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNob2ljZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblkgPSA1MCxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkNudCxcclxuICAgICAgICAgICAgICAgIGN1cnJCdXR0b24sXHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dCxcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdidWJibGVUZXh0Jyk7XHJcblxyXG4gICAgICAgICAgICBmb3IoIGJ1dHRvbkNudCA9IE1BWF9DSE9JQ0VTOyBidXR0b25DbnQgPiAwOyBidXR0b25DbnQtLSApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbigwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMub25DaG9pY2UsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Jlc3BvbnNlLWJnLW92ZXIucG5nJywgJ3Jlc3BvbnNlLWJnLXVwLnBuZycsICdyZXNwb25zZS1iZy1kb3duLnBuZycsICdyZXNwb25zZS1iZy11cC5wbmcnKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMudGhlbWUuYnV0dG9ucy5yZXNwb25zZXMub3ZlciwgdGhpcy50aGVtZS5idXR0b25zLnJlc3BvbnNlcy5vdXQsIHRoaXMudGhlbWUuYnV0dG9ucy5yZXNwb25zZXMuZG93biwgdGhpcy50aGVtZS5idXR0b25zLnJlc3BvbnNlcy51cFxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb25YID0gKHRoaXMuZ2FtZS53b3JsZC53aWR0aCAtIGN1cnJCdXR0b24ud2lkdGggKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvblkgPSB0aGlzLmdhbWUud29ybGQuaGVpZ2h0IC0gKCAoY3VyckJ1dHRvbi5oZWlnaHQgKyBtYXJnaW5ZKSAqIGJ1dHRvbkNudCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uLnggPSBsb2NhdGlvblg7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uLnkgPSBsb2NhdGlvblk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VyclRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW5Gb250LCBjdXJyQnV0dG9uLmhlaWdodCAvIDIsIFwiXCIsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgICAgIGN1cnJCdXR0b24uYWRkQ2hpbGQoY3VyclRleHQpO1xyXG4gICAgICAgICAgICAgICAgY3VyclRleHQuYW5jaG9yLnNldFRvKDAsIDAuNSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zLnB1c2goY3VyckJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQucHVzaChjdXJyVGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvcHVsYXRlQ2hvaWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLmN1cnJlbnRDaG9pY2UsXHJcbiAgICAgICAgICAgICAgICBidXR0b25IaWRlQ291bnQgPSBNQVhfQ0hPSUNFUyAtIG9wdGlvbnMuY2hvaWNlcy5sZW5ndGgsLy8gaG93IG1hbnkgY2hvaWNlcyB0byBoaWRlLlxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ250LFxyXG4gICAgICAgICAgICAgICAgYW5zd2VyLFxyXG4gICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9ucyA9IFsgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0sXHJcbiAgICAgICAgICAgICAgICBkcENob2ljZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIGNob3NlbkluZGV4LFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQbGF5SGlkZGVuID0gLTE7XHJcblxyXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5kZWNpc2lvblBvaW50ID09PSB0cnVlIHx8IG9wdGlvbnMuZGVjaXNpb25Qb2ludCA9PT0gXCJ0cnVlXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHBJbmRleCA9IHRoaXMuZ2V0RGVjaXNpb25JbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJTaG93aW5nIGRlY2lzaW9uIHBvaW50OiBcIiArIHRoaXMuZHBJbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHR3byBxdWVzdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNlLCBhbmQgd2UnbGwgb25seSBoaWRlIG9uZS4uLlxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuZHBJbmRleCA9PT0gMCB8fCB0aGlzLmRwSW5kZXggPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyID0gdGhpcy5nZXRQcmV2aW91c1BsYXlBbnN3ZXIoIHRoaXMuZHBJbmRleCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBhbnN3ZXIgJiYgYW5zd2VyICE9PSBcIlhYXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiSGlkaW5nIGFuc3dlciBcIiArIGFuc3dlciArIFwiIGZyb20gcHJldmlvdXMgcGxheXRocm91Z2guXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BsYXlIaWRkZW4gPSBjaG9pY2VNYXBbYW5zd2VyXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcXVlc3Rpb25zIGFmdGVyIHRoYXQsIGp1c3QgdXNlIHRoZSBwcmV2aW91cyBhbnN3ZXIuXHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5kcEluZGV4ID4gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhbnN3ZXIgPSB0aGlzLmdldFByZXZpb3VzQW5zd2VyKCB0aGlzLmRwSW5kZXggKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcImdvdCBwcmV2aW91cyBhbnN3ZXIgb2YgXCIgKyBhbnN3ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNob3NlbkluZGV4ID0gY2hvaWNlTWFwW2Fuc3dlcl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGluZGV4IGlzIHRoZSBiZWdpbm5pbmcgb3IgZW5kLCBnbyB1cC9kb3duIDIsIG90aGVyd2lzZSwgZ28gYm90aCBzaWRlcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiggY2hvc2VuSW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1szXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93UXVlc3Rpb25zWzRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBjaG9zZW5JbmRleCA9PT0gNCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1swXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93UXVlc3Rpb25zWzFdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9ucyA9IFsgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1tjaG9zZW5JbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93UXVlc3Rpb25zW2Nob3NlbkluZGV4KzFdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1F1ZXN0aW9uc1tjaG9zZW5JbmRleC0xXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2luY2Ugd2UgbWF5IGhhdmUgb3ZlcnJpZGVuIHRoZSBoaWRlIHdpdGggYSB0cnVlLCBoaWRlIEFGVEVSIHBhcnNpbmcgcHJldmlvdXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmKCBwcmV2aW91c1BsYXlIaWRkZW4gIT09IC0xICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3dRdWVzdGlvbnNbcHJldmlvdXNQbGF5SGlkZGVuXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMuY2hvaWNlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggc2hvd1F1ZXN0aW9uc1tpbmRleF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwQ2hvaWNlcy5wdXNoKCBvcHRpb25zLmNob2ljZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZWRvIHRoZSBvZmZzZXQsIG5vdyB0aGF0IGNob2ljZXMgYXJlIGJlaW5nIGhpZGRlbi5cclxuICAgICAgICAgICAgICAgIGJ1dHRvbkhpZGVDb3VudCA9IE1BWF9DSE9JQ0VTIC0gZHBDaG9pY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiZGV0ZXJtaW5lZCBidXR0b24gb2Zmc2V0IG9mIFwiICsgYnV0dG9uSGlkZUNvdW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMuY2hvaWNlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBkcENob2ljZXMucHVzaCggb3B0aW9ucy5jaG9pY2VzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhZCBidXR0b24gdXAgdG8gdGhlIGNvdW50LlxyXG4gICAgICAgICAgICBmb3IoIGJ1dHRvbkNudCA9IDA7IGJ1dHRvbkNudCA8IGJ1dHRvbkhpZGVDb3VudDsgYnV0dG9uQ250KysgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5idXR0b25zW2J1dHRvbkNudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbYnV0dG9uQ250XS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2J1dHRvbkNudF0uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkJhZCBidXR0b24gY291bnQ6IFwiICsgYnV0dG9uQ250ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWtlIGEgbGlzdCBvZiB0aGUgaW5kZXhlcywgYW5kIHRoZW4gcmFuZG9taXplIHRoYXQgbGlzdC5cclxuICAgICAgICAgICAgICogVGhpcyBpcyByYW5kb21pemUgdGhlIG9yZGVyIHRoZSBhbnN3ZXJzIGFyZSBwcmVzZW50ZWQgdG8gdGhlIHVzZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgcmFuZG9taXplZEluZGV4ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRwQ2hvaWNlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZWRJbmRleC5wdXNoKCBpbmRleCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBoYXNlci5BcnJheVV0aWxzLnNodWZmbGUocmFuZG9taXplZEluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciByYW5kb21LZXk7XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRwQ2hvaWNlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHJhbmRvbUtleSA9IHJhbmRvbWl6ZWRJbmRleFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRbaW5kZXggKyBidXR0b25IaWRlQ291bnRdLnNldFRleHQoZHBDaG9pY2VzW3JhbmRvbUtleV0udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbaW5kZXggKyBidXR0b25IaWRlQ291bnRdLmN1cnJlbnRPcHRpb24gPSBkcENob2ljZXNbcmFuZG9tS2V5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tpbmRleCArIGJ1dHRvbkhpZGVDb3VudF0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbaW5kZXggKyBidXR0b25IaWRlQ291bnRdLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCBvcHRpb25zLnRleHQgfHwgb3B0aW9ucy5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IG9wdGlvbnMudGV4dCwgXCJhdWRpb1wiOiBvcHRpb25zLmF1ZGlvLCBcImtleVwiOiBvcHRpb25zLmtleX07XHJcbiAgICAgICAgICAgICAgICAvL2xvZy53YXJuKFwiQ2hvaWNlIGFjdG9yIHNlbmRpbmcgZ2FtZSBzcGVlY2hcIik7XHJcbiAgICAgICAgICAgICAgICAvL2xvZy53YXJuKGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXA7XHJcbiAgICAgICAgICAgIHdoaWxlKCB0aGlzLnRleHQubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSB0aGlzLnRleHQuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHRlbXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoIHRoaXMuYnV0dG9ucy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMuYnV0dG9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdGVtcC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2hvaWNlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvL2xvZy53YXJuKFwiQ2hvaWNlIG1hZGUsIHBvcHVwbGF0aW5nIG5ldyBjaG9pY2VcIik7XHJcbiAgICAgICAgICAgIC8vbG9nLndhcm4oXy5jbG9uZURlZXAoZGF0YS5jdXJyZW50T3B0aW9uKSk7XHJcbiAgICAgICAgICAgIHZhciBjaG9pY2UgPSBkYXRhLmN1cnJlbnRPcHRpb247XHJcbiAgICAgICAgICAgIGlmKCBjaG9pY2UudmFyaWFibGUgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXJTZXRbY2hvaWNlLnZhcmlhYmxlXSA9IGNob2ljZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCBjaG9pY2UubGluayApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENob2ljZSA9IHRoaXMuY2hvaWNlTWFwW2Nob2ljZS5saW5rXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDaG9pY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlndXJlIG91dCB3aGljaCBkZWNpc2lvbiB0aGUgcGxheWVyIGlzIG1ha2luZywgYnkgYXNzdW1pbmcgdGhleSBtYWtlIHRoZW0gaW4gb3JkZXIuXHJcbiAgICAgICAgICogU28gZmluZCB0aGUgZmlyc3QgaW5kZXggdGhhdCBpcyBYWC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCBvZiBuZXh0IGRlY2lzaW9uIHBvaW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldERlY2lzaW9uSW5kZXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZGVjaXNpb25TZXQgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJGRlY2lzaW9uc0N1cnJlbnRcIiksXHJcbiAgICAgICAgICAgICAgICBkcEluZGV4O1xyXG5cclxuICAgICAgICAgICAgZm9yKCBkcEluZGV4ID0gMDsgZHBJbmRleCA8IGRlY2lzaW9uU2V0Lmxlbmd0aDsgZHBJbmRleCsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYoIGRlY2lzaW9uU2V0W2RwSW5kZXhdID09PSBcIlhYXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRwSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9yIGEgZ2l2ZW4gZGVjaXNpb24gaW5kZXgsIGZpbmQgdGhlIGFuc3dlciBmcm9tIHRoZSBwcmV2aW91cyBwbGF5IHRocm91Z2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UHJldmlvdXNQbGF5QW5zd2VyOiBmdW5jdGlvbihkZWNpc2lvbkluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJGRlY2lzaW9uc1ByZXZpb3VzXCIpW2RlY2lzaW9uSW5kZXhdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBhbnN3ZXIgdG8gdGhlIHByZXZpb3VzIGRlY2lzaW9uIGZyb20gdGhpcyBwbGF5IHRocm91Z2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UHJldmlvdXNBbnN3ZXI6IGZ1bmN0aW9uKCBkZWNpc2lvbkluZGV4ICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRkZWNpc2lvbnNDdXJyZW50XCIpW2RlY2lzaW9uSW5kZXgtMV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaG9pY2VBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgWmFjayBCaWVybmF0XHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNC8yMy8yMDE4XHJcbiAqIENvcHlyaWdodCAyMDE4IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBcclxuICogIEEgY2hvb3NlciBhY3RvciB3aGljaCByYW5kb21seSB0b2dnbGVzIGEgaGktbGl0ZWQgc2VsZWN0aW9uIHRocm91Z2ggYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoYW5nZXMgYmVmb3JlXHJcbiAqICB1bHRpbWF0ZWx5IGVuZGluZyBvbiBhIHNlbGVjdGlvbiB3aGljaCB3aWxsIGVpdGhlciBiZSAobm90IHJpZ2dlZCkgYWx3YXlzIHJhbmRvbSBvciAocmlnZ2VkKSB1bmlxdWUgZmlyc3QgYW5kIHRoZW4gcmFuZG9tLlxyXG4gKiAgVGhlIFwidG9nZ2xpbmdcIiBhY3Rpb24gd2lsbCBpbmNyZWFzZSBpbiBpbnRlcnZhbCB1bnRpbCBzdG9wcGluZywgdGhhdCBpcywgdGhlIGNob29zZXIgZGVjZWxlcmF0ZXMgdW50aWwgaXQgc3RvcHMsIHNvbWV3aGF0IFxyXG4gKiAgbGlrZSBhIHJvdWxldHRlIHdoZWVsLlxyXG4gKiBcclxuICogQ3JlYXRpbmcgYSBDaG9vc2VyIGFjdG9yOlxyXG4gKiB7XHJcbiAqICAgICAgXCJuYW1lXCI6IFwiY2hvb3NlcjFcIiwgICAgICAgICAgICAgLy8gQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGFjdG9yXHJcbiAqICAgICAgXCJ0eXBlXCI6IFwiY2hvb3NlclwiLCAgICAgICAgICAgICAgLy8gUmVxdWlyZWQgdHlwZVxyXG4gKiAgICAgIFwic3RhcnRCdXR0b25cIjogeyAgICAgICAgICAgICAgICAvLyBUaGUgaW1hZ2Ugd2hpY2ggc2hvdWxkIHRyaWdnZXIgdGhlIGNob29zaW5nIHNlcXVlbmNlLCBhbmQgd2hlcmUgdG8gcHV0IGl0XHJcbiAqICAgICAgICAgIFwiaW1hZ2VcIjogXCJjaG9vc2VfYnV0dG9uXCIsXHJcbiAqICAgICAgICAgIFwibG9jYXRpb25cIjogWyAzMDAsIDIwMCBdXHJcbiAqICAgICAgfSxcclxuICogICAgICBcImltYWdlc1wiOiBcImNob29zZXJfMVwiLCAgICAgICAgICAvLyBSZWZlcnMgdG8gdGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXMuY2hvb3Nlcl8xIHdoaWNoIGlzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJiYXNlXCI6IFwiaW1hZ2UxLnBuZ1wiLCBcImhpXCI6IFwiaW1hZ2UxX2hpLnBuZ1wiICB9XHJcbiAqICAgICAgXCJsb2NhdGlvblwiOiBbIDEwMCwgMTAwIF0sICAgICAgIC8vIFdoZXJlIHRoZSBmaXJzdCBpbWFnZSBpcyBwb3NpdGlvbmVkXHJcbiAqICAgICAgXCJhdWRpb1wiOiBcInRpY2tfc291bmRcIiwgICAgICAgICAgLy8gQW4gb3B0aW9uYWwgc291bmQgdG8gcGxheSBmb3IgZWFjaCBjaGFuZ2VcclxuICogICAgICBcIm51bUNoYW5nZXNcIjogMjQsICAgICAgICAgICAgICAgLy8gSG93IG1hbnkgZGlmZmVyZW50IGV2ZW50cyBhcmUgZW1pdGVkIGJlZm9yZSByZWFjaGluZyB0aGUgdWx0aW1hdGUgc2VsZWN0aW9uLiBJZiB0aGlzIGlzIHRvbyBtdWNoIGl0IGNvdWxkIGNhdXNlIHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gKiAgICAgIFwicmlnZ2VkXCI6IHRydWUsICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCwgaWYgdGhpcyBpcyB0cnVlIHRoZSBjaG9vc2VyIHdpbGwgc2VsZWN0IGVhY2ggb3B0aW9uIG9uY2UgdW50aWwgZWFjaCBpcyB1c2VkLCB0aGVuIGJlZ2luIHJhbmRvbWx5IHNlbGVjdGluZyB0aGluZ3MuXHJcbiAqICAgICAgXCJ2YXJpYWJsZVwiOiBcImNob29zZXJfdmFsdWVcIiwgICAgLy8gV2hlbiBhY3RvciBpcyBhZGRlZCwgdGhlIHZhcmlhYmxlICdjaG9vc2VyX3ZhbHVlJyB3aWxsIGJlIHNldCB0byBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIG51bU9wdGlvbnMgLSAxIC5cclxuICogICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAgICAgICAgICAgICAgLy8gT3B0aW9uYWwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kOyBpdCBpcyBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIENob29zZXJBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJ2YXJpYWJsZVwiLCBcIm51bUNoYW5nZXNcIiwgXCJpbWFnZXNcIiwgXCJsb2NhdGlvblwiLCBcInN0YXJ0QnV0dG9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJhbmRvbUludEZyb21JbnRlcnZhbDogZnVuY3Rpb24obWluLG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoIG1heCAtIG1pbikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnZ2VkU3BpblZhbHVlcyA9IHRoaXMuZGF0YS5yaWdnZWQgPyBfLnNodWZmbGUoXy5yYW5nZSgwLCB0aGlzLnRoZW1lLmltYWdlcy5jaG9vc2VySW1hZ2VzW3RoaXMuZGF0YS5pbWFnZXNdLmxlbmd0aCkpIDogW107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvaWNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuaGlfY2hvaWNlID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXS5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeF9wb3MgPSB0aGlzLmRhdGEubG9jYXRpb25bMF0gKyAoaSAlIDIpICogdGhpcy5nYW1lLmNhY2hlLmdldEZyYW1lQnlOYW1lKHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXVtpXS5iYXNlKS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB5X3BvcyA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlfcG9zICs9IHRoaXMuZ2FtZS5jYWNoZS5nZXRGcmFtZUJ5TmFtZSh0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuaW1hZ2VzLmNob29zZXJJbWFnZXNbdGhpcy5kYXRhLmltYWdlc11baV0uYmFzZSkuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaG9pY2UucHVzaCh0aGlzLmdhbWUuYWRkLnNwcml0ZSggeF9wb3MsIHlfcG9zLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZSggdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXVtpXS5iYXNlLCBudWxsKSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaV9jaG9pY2UucHVzaCh0aGlzLmdhbWUuYWRkLnNwcml0ZSggeF9wb3MsIHlfcG9zLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZSggdGhpcy50aGVtZS5pbWFnZXMuY2hvb3NlckltYWdlc1t0aGlzLmRhdGEuaW1hZ2VzXVtpXS5oaSwgbnVsbCkpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlfY2hvaWNlW2ldLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGFydEJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEuc3RhcnRCdXR0b24ubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5zdGFydEJ1dHRvbi5sb2NhdGlvblsxXSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5zdGFydEJ1dHRvbi5pbWFnZV0ub3ZlciwgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5zdGFydEJ1dHRvbi5pbWFnZV0ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5zdGFydEJ1dHRvbi5pbWFnZV0uZG93biwgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5zdGFydEJ1dHRvbi5pbWFnZV0udXApO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNob2ljZUl0ZXJhdG9yOiBmdW5jdGlvbiAoY2hvaWNlcywgY2IpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMTA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hvaWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGNob2ljZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5hZGQoc3RhcnQsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLCB0aGlzLCBjaG9pY2VzW2kgLSAxXSwgY2hvaWNlc1tpXSwgY2IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5hZGQoc3RhcnQsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLCB0aGlzLCBjaG9pY2VzW2kgLSAxXSwgY2hvaWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gMTIgKiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGVTZWxlY3Rpb246IGZ1bmN0aW9uIChsYXN0LCBuZXh0LCBkb25lKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMuZGF0YS5hdWRpbywgXCJwcmlvcml0eVwiOiBcInN0b3BBbGxcIiB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5oaV9jaG9pY2VbbGFzdF0udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhpX2Nob2ljZVtuZXh0XS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb25lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG51bU9wdGlvbnMgPSB0aGlzLnRoZW1lLmltYWdlcy5jaG9vc2VySW1hZ2VzW3RoaXMuZGF0YS5pbWFnZXNdLmxlbmd0aFxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nob29zaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNDaG9vc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT3B0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpX2Nob2ljZVtpXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJhbmRvbUludCA9IHRoaXMucmlnZ2VkU3BpblZhbHVlcy5sZW5ndGggPyB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMucG9wKCkgOiB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgxLCBudW1PcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIGNob2ljZXMgPSBbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtT3B0aW9ucyldO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmRhdGEubnVtQ2hhbmdlcyAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51bU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNob2ljZSA9PT0gY2hvaWNlc1tpIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBudW1PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNob2ljZXMucHVzaChjaG9pY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChyYW5kb21JbnQgPT09IGNob2ljZXNbY2hvaWNlcy5sZW5ndGggLTFdKSB7XHJcbiAgICAgICAgICAgICAgICBjaG9pY2VzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtT3B0aW9ucykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaG9pY2VzLnB1c2gocmFuZG9tSW50KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hvaWNlSXRlcmF0b3IoY2hvaWNlcywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ2hvb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSByYW5kb21JbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcnJvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvdy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaG9vc2VyQWN0b3I7XHJcbn0oKSk7IiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHBob25lIGJ1dHRvbiBhY3Rvci4gVGhpcyBhY3RvciBpcyB1c2VkIGZvciBvcGVuaW5nIHRoZSBwaG9uZSBhbmQgc2hvd2luZyBwaG9uZSBhbGVydHMuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgcGhvbmUgYnV0dG9uIGFjdG9yOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwaG9uZTFcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwicGhvbmUtYnV0dG9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogXCJwaG9uZVwiLCAvLyB3aGVyZSBpbiB0aGUgdGhlbWUgdG8gZmluZCB0aGUgaW1hZ2VzLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSxcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKlxyXG4gKiAgSGFuZGxlcyBzcGVjaWFsIHZhcmlhYmxlczpcclxuICogIHBob25lX2FsZXJ0IDogdHlwZSAvLyBzaG93IGFuIGFsZXJ0LCBvZiB0aGUgdHlwZSBnaXZlbi5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgUGhvbmVCdXR0b25BY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FsZXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYWxlcnQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uR2FtZUNob2ljZSggeyAncGhvbmVfYWxlcnQnOiB0aGlzLmRhdGEuYWxlcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciB0TG9jID0gdGhpcy5kYXRhLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0gKyAzNiwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWVbdExvY10uYnV0dG9uLm92ZXIsIHRoaXMudGhlbWVbdExvY10uYnV0dG9uLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWVbdExvY10uYnV0dG9uLmRvd24sIHRoaXMudGhlbWVbdExvY10uYnV0dG9uLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3JBbGVydHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRHcm91cC54ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAueSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIHRMb2MgPSB0aGlzLmRhdGEuaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0cyA9IHtcclxuICAgICAgICAgICAgICAgIGdhbWU6IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lW3RMb2NdLmFsZXJ0cy5nYW1lKSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lW3RMb2NdLmFsZXJ0cy5tZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgIHBkZjogbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWVbdExvY10uYWxlcnRzLnBkZiksXHJcbiAgICAgICAgICAgICAgICB2aWRlbzogbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWVbdExvY10uYWxlcnRzLnZpZGVvKSxcclxuICAgICAgICAgICAgICAgIGd0ZnM6IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lW3RMb2NdLmFsZXJ0cy5ndGZzKVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmFkZCh0aGlzLmFsZXJ0cy5nYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmFkZCh0aGlzLmFsZXJ0cy5tZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmFkZCh0aGlzLmFsZXJ0cy5wZGYpO1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAuYWRkKHRoaXMuYWxlcnRzLnZpZGVvKTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydEdyb3VwLmFkZCh0aGlzLmFsZXJ0cy5ndGZzKTtcclxuICAgICAgICAgICAgdGhpcy5zaG93QWxlcnQoZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW55IGdhbWUgY2hvaWNlIGR1cmluZyBhbiBhbGVydCB3aWxsIGNhdXNlIHRoZSBwaG9uZSB0byAndmlicmF0ZScgb24gc2NyZWVuLlxyXG4gICAgICAgICAqIEBwYXJhbSBjaG9pY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkdhbWVDaG9pY2U6IGZ1bmN0aW9uKCBjaG9pY2UgKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzQWxlcnRlZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUFsZXJ0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggY2hvaWNlWydwaG9uZV9hbGVydCddICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FsZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93QWxlcnQoY2hvaWNlWydwaG9uZV9hbGVydCddKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUFsZXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3cgb25lIG9mIHRoZSBhbGVydHMsIG9yIGhpZGUgdGhlbSBhbGwgaWYgbm8gdHlwZSAob3IgZmFsc2UpIGlzIHBhc3NlZC5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSBnYW1lfG1lc3NhZ2V8cGRmfHZpZGVvfGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hvd0FsZXJ0OiBmdW5jdGlvbiggdHlwZSApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYWxlcnRHcm91cCA9PT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvckFsZXJ0cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRzLmdhbWUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0cy5tZXNzYWdlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydHMucGRmLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbGVydHMudmlkZW8udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFsZXJ0cy5ndGZzLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYoIHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsZXJ0c1t0eXBlXS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheSB0aGUgcmluZyBhbmltYXRpb24gYW5kIGN1cnJlbnQgcmluZyB0b25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBsYXlBbGVydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciByaW5nVG9uZUluZGV4ID0gcGFyc2VJbnQodGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRwaG9uZVJpbmdlckluZGV4XCIpLCAxMCk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmJ1dHRvbkFuaW1hdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25BbmltYXRpb24gPSB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLmFkZCgncmluZycsIHRoaXMudGhlbWVbdGhpcy5kYXRhLmltYWdlXS5yaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnBsYXkoJ3JpbmcnLCA0KTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy50aGVtZS5waG9uZS5yaW5ndG9uZXNbcmluZ1RvbmVJbmRleF0gfTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRoZSBwbGF5ZXIgY2xpY2tzIHRoZSBwaG9uZSBidXR0b24sIHN0b3AgYW55IGFsZXJ0IGFuZCB0aGVuIHNlbmQgb3V0IHRoZSBnYW1lIGNob2ljZS5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB0aGlzLmlzQWxlcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dBbGVydChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFuaW1hdGlvbnMuc3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbJ3Nob3dfY2VsbF9waG9uZSddID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRzID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmFsZXJ0R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsZXJ0R3JvdXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQaG9uZUJ1dHRvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzIwLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsaXplZCBhY3RvciBmb3IgdXNlIHdpdGggV2VsY29tZSBUbyBOZXdicmlkZ2UgYW5kIEFjdCBOb3chIGl0IHNob3dzIGEgY2VsbCBwaG9uZSB0aGF0IHNlbmRzIG91dFxyXG4gKiBzcGVjaWFsIGV2ZW50cywgcmVzcG9uZHMgdG8gZXZlbnRzLCBhbmQgY2FuIGludGVyYWN0IHdpdGggdGhlIHVzZXIgYnkgZHJhd2luZyBvdmVyIHRoZSBzY2VuZS4gVGhlIHVzZXIgY2FuIGludGVyYWN0XHJcbiAqIHdpdGggdGhlIHBob25lIGFuZCBwb3NzaWJseSBsYXVuY2ggc3ViLWFjdGl2aXRpZXMgZnJvbSBpdC4gQmVjYXVzZSBvZiB0aGlzLCB0aGUgcGhvbmUgbXVzdCBibG9jayB1c2VyIGlucHV0LCB3aGljaFxyXG4gKiBpcyB0aGUgcHVycG9zZSBvZiB0aGUgYmxvY2tpbmdTcHJpdGUocykuXHJcbiAqXHJcbiAqIHJpbmd0b25lIGFuZCBiYWNrZ3JvdW5kIGFyZSBub3cgc3RvcmVkIG9uIHRoZSBwbGF5LW1vZGVsIG9mIHRoZSBjdXJyZW50IHNjZW5lLlxyXG4gKlxyXG4gKiAge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicGhvbmVfMVwiLFxyXG4gKiAgICAgXCJ0eXBlXCI6IFwicGhvbmVcIixcclxuICogICAgIFwiaGVscFwiOiB7XHJcbiAqICAgICAgIFwidmFyaWFibGVcIjogXCJwaG9uZV8xXCIsIC8vIHRoZXNlIHZhcmlhYmxlcyB3aWxsIGJlIHNldCB0byAnb3Blbicgb3IgJ2Nsb3NlZCcgYXV0b21hdGljYWxseS4gSXQncyBvcHRpb25hbC5cclxuICogICAgICAgXCJ0ZXh0XCIgOiBcIllvdSdsbCBmaW5kIGdvb2QgYWR2aWNlIGhlcmUuXCIgLy8gdGV4dCB0byBkaXNwbGF5IGZvciB0aGlzICdpY29uJ1xyXG4gKiAgICAgfSxcclxuICogICAgIFwiZ3Rmc1wiOiB7XHJcbiAqICAgICAgIFwidmFyaWFibGVcIjogXCJwaG9uZV8yXCIsXHJcbiAqICAgICAgIFwidGV4dFwiOiBcIllvdSdsbCBiZSBub3RpZmllZCB3aGVuIGl0J3MgdGltZSB0byBsZWFybiBzb21lIGZhY3RzIGFib3V0IGJ1bGx5aW5nLlwiXHJcbiAqICAgICB9LFxyXG4gKiAgICAgXCJnYW1lc1wiOiB7XHJcbiAqICAgICAgIFwidGV4dFwiOiBcIlNvbWV0aW1lcyB5b3UgY2FuIGNob29zZSB0aGlzIGljb24gdG8gcGxheSBhbm90aGVyIGdhbWUgd2l0aGluIHRoZSBzY2hvb2wgZGF5LlwiXHJcbiAqICAgIH0sXHJcbiAqICAgICBcIm1lc3NhZ2VzXCI6IHtcclxuICogICAgICAgXCJ2YXJpYWJsZVwiOiBcInBob25lXzNcIixcclxuICogICAgICAgXCJmcm9tXCI6IFwiYW5vbnltb3VzXCIsIC8vIG1lc3NhZ2VzIGhhcyBhICdmcm9tJzsgc2luY2UgdGhleSBhcmUgZGlzcGxheWVkIGFzIHRleHQgbWVzc2FnZXMuXHJcbiAqICAgICAgIFwidGV4dFwiOiBcInRoaXMgaXMgYSB0ZXh0IG1lc3NhZ2UuXCJcclxuICogICAgIH0sXHJcbiAqICAgICBcInZpZGVvc1wiOiB7XHJcbiAqICAgICAgIFwibGlua1wiOiBcIlwiLFxyXG4gKiAgICAgICBcInRleHRcIjogXCJZb3UnbGwgYmUgZGlyZWN0ZWQgd2hlbiB0byB3YXRjaCB2aWRlb3MgYWJvdXQgYnVsbHlpbmcuIENsaWNrIHRoaXMgaWNvbiB3aGVuIHRvbGQgdG8gc2VlIGEgdmlkZW8gb24geW91ciBwaG9uZS5cIlxyXG4gKiAgICAgfSxcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogIH1cclxuICpcclxuICogIFNwZWNpYWwgZGF0YSBzdG9yZWQgb24gbW9kZWwuIFRoZXNlIGRhdGEgYXJlIHN0b3JlZCBvbiB0aGUgbW9kZWwgdG8gbWFrZSB0aGVtIHN0YXRlZnVsIGJldHdlZW4gaW5zdGFuY2VzOlxyXG4gKiAgICAgXCJwaG9uZVJpbmdlckluZGV4XCI6IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCByaW5nIHRvbmUuXHJcbiAqICAgICBcInBob25lQmdJbmRleFwiOiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgYmFja2dyb3VuZCBpbWFnZS5cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpLFxyXG4gICAgICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuICAgIHZhciBQaG9uZSA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXTsgLy8gbm8gcmVxdWlyZWQgZmllbGRzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEhlYWRlciA9IHRoaXMuZ2V0Rm9udCgncGhvbmVIZWFkZXInKTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keSA9IHRoaXMuZ2V0Rm9udCgncGhvbmVCb2R5Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHlMaW5rID0gdGhpcy5nZXRGb250KCdwaG9uZUJvZHlMaW5rJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5vcGVuICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93UGhvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggY2hvaWNlICkge1xyXG4gICAgICAgICAgICBpZiggY2hvaWNlWydzaG93X2NlbGxfcGhvbmUnXSApIHtcclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgdGhpcy5waG9uZUdyb3VwLnZpc2libGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UGhvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChkYXRhLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFtkYXRhLnZhcmlhYmxlXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNsaWNrSGVscDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJY29uID0gdGhpcy5kYXRhLmhlbHA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJY29uLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwib3BlblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNob3dUZXh0KFwiSGVscFwiLCB0aGlzLmN1cnJlbnRJY29uLnRleHQsIGZhbHNlLCB0aGlzLmN1cnJlbnRJY29uLmxpbmssICB0aGlzLmN1cnJlbnRJY29uLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tHdGZzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEljb24gPSB0aGlzLmRhdGEuZ3RmcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEljb24udmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5jdXJyZW50SWNvbiwgXCJvcGVuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1RleHQoXCJHZXQgVGhlIEZhY3RzXCIsIHRoaXMuY3VycmVudEljb24udGV4dCwgZmFsc2UsIHRoaXMuY3VycmVudEljb24ubGluaywgIHRoaXMuY3VycmVudEljb24udmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja01lc3NhZ2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEljb24gPSB0aGlzLmRhdGEubWVzc2FnZXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJY29uLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwib3BlblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNob3dUZXh0KHRoaXMuY3VycmVudEljb24uZnJvbSwgdGhpcy5jdXJyZW50SWNvbi50ZXh0LCB0cnVlLCB0aGlzLmN1cnJlbnRJY29uLmxpbmssICB0aGlzLmN1cnJlbnRJY29uLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tWaWRlb3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWNvbiA9IHRoaXMuZGF0YS52aWRlb3M7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJY29uLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwib3BlblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNob3dUZXh0KFwiVmlkZW9zXCIsIHRoaXMuY3VycmVudEljb24udGV4dCwgZmFsc2UsIHRoaXMuY3VycmVudEljb24ubGluaywgIHRoaXMuY3VycmVudEljb24udmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja1Jpbmd0b25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByaW5nVG9uZUluZGV4ID0gcGFyc2VJbnQodGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRwaG9uZVJpbmdlckluZGV4XCIpLCAxMCk7XHJcbiAgICAgICAgICAgIHJpbmdUb25lSW5kZXgrKztcclxuICAgICAgICAgICAgcmluZ1RvbmVJbmRleCAlPSB0aGlzLnRoZW1lLnBob25lLnJpbmd0b25lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgeyBcImF1ZGlvXCI6IHRoaXMudGhlbWUucGhvbmUucmluZ3RvbmVzW3JpbmdUb25lSW5kZXhdfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwge1wicGhvbmVSaW5nZXJJbmRleFwiOiByaW5nVG9uZUluZGV4IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0JhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBob25lQmdJbmRleCA9IHBhcnNlSW50KHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkcGhvbmVCZ0luZGV4XCIpLCAxMCk7XHJcbiAgICAgICAgICAgIHBob25lQmdJbmRleCsrO1xyXG4gICAgICAgICAgICBwaG9uZUJnSW5kZXggJT0gdGhpcy50aGVtZS5waG9uZS5iYWNrZ3JvdW5kcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVCZy5mcmFtZU5hbWUgPSB0aGlzLnRoZW1lLnBob25lLmJhY2tncm91bmRzW3Bob25lQmdJbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwge1wicGhvbmVCZ0luZGV4XCI6IHBob25lQmdJbmRleH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB7XCJwaG9uZVwiOiBcImNsb3NlZFwifSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVQaG9uZUJ1dHRvbjogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IG5ldyBQaGFzZXIuQnV0dG9uKHRoaXMuZ2FtZSwgMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMV0sIHRoaXMudGhlbWUucGhvbmUuaWNvbnNba2V5XVswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUucGhvbmUuaWNvbnNba2V5XVsxXSwgdGhpcy50aGVtZS5waG9uZS5pY29uc1trZXldWzBdKTtcclxuICAgICAgICAgICAgYnV0dG9uLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvd2luZyB0aGUgcGhvbmUgaXMgYSBiaXQgY29tcGxpY2F0ZWQuIEV2ZXJ5dGhpbmcgaGFzIHRvIGJlIGJyb3VnaHQgdG8gdGhlIHRvcCBpblxyXG4gICAgICAgICAqIHJldmVyc2Ugb3JkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hvd1Bob25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzSW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0SG9tZVNjcmVlbkdyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRCbG9ja2luZ0dyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRNZXNzYWdlV2luZG93R3JvdXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMucGhvbmVHcm91cCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLndvcmxkLmJyaW5nVG9Ub3AodGhpcy50ZXh0R3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lXCI6IFwib3BlblwifSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIG1haW4gc2NyZWVuLCBpbmNsdWRpbmcgYWxsIG9mIHRoZSBidXR0b25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXRIb21lU2NyZWVuR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcGhvbmVCZ0luZGV4ID0gcGFyc2VJbnQodGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShcIiRwaG9uZUJnSW5kZXhcIiksIDEwKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAueCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5waG9uZUJnID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUucGhvbmUuYmFja2dyb3VuZHNbcGhvbmVCZ0luZGV4XSk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVCZy5hbmNob3Iuc2V0VG8oMC41LCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMucGhvbmVCZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdoZWxwJywgdGhpcy5vbkNsaWNrSGVscCwgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5oZWxwQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnggPSAtdGhpcy5oZWxwQnV0dG9uLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24ueSA9IDUwO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmd0ZnNCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdndGZzJywgdGhpcy5vbkNsaWNrR3RmcywgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5ndGZzQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5ndGZzQnV0dG9uLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmd0ZnNCdXR0b24ueSA9IDUwO1xyXG4gICAgICAgICAgICB0aGlzLmd0ZnNCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3Rmc0J1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbignbWVzc2FnZXMnLCB0aGlzLm9uQ2xpY2tNZXNzYWdlcywgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5tZXNzYWdlc0J1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXNCdXR0b24ueCA9IHRoaXMubWVzc2FnZXNCdXR0b24ud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXNCdXR0b24ueSA9IDUwO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQnV0dG9uLmJyaW5nVG9Ub3AoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9zQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbigndmlkZW9zJywgdGhpcy5vbkNsaWNrVmlkZW9zLCB0aGlzLCAyKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLnZpZGVvc0J1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9zQnV0dG9uLnggPSAtdGhpcy52aWRlb3NCdXR0b24ud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9zQnV0dG9uLnkgPSA1MCArIHRoaXMudmlkZW9zQnV0dG9uLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy52aWRlb3NCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9zQnV0dG9uLmJyaW5nVG9Ub3AoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmluZ3RvbmVCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdyaW5ndG9uZXMnLCB0aGlzLm9uQ2xpY2tSaW5ndG9uZSwgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5yaW5ndG9uZUJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMucmluZ3RvbmVCdXR0b24ueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucmluZ3RvbmVCdXR0b24ueSA9IDUwICsgdGhpcy52aWRlb3NCdXR0b24uaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLnJpbmd0b25lQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmd0b25lQnV0dG9uLmJyaW5nVG9Ub3AoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ2JhY2tncm91bmQnLCB0aGlzLm9uQ2xpY2tCYWNrZ3JvdW5kLCB0aGlzLCAyKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLmJhY2tncm91bmRCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRCdXR0b24ueCA9IHRoaXMubWVzc2FnZXNCdXR0b24ud2lkdGg7IC8vIHRoaXMgaXMgb24gcHVycG9zZS5cclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQnV0dG9uLnkgPSA1MCArIHRoaXMudmlkZW9zQnV0dG9uLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ2Nsb3NlJywgdGhpcy5vbkNsaWNrQ2xvc2UsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMuY2xvc2VCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLnkgPSA1MCArICh0aGlzLmd0ZnNCdXR0b24uaGVpZ2h0ICogMyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbml0QmxvY2tpbmdHcm91cDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUgPSB0aGlzLmNyZWF0ZUJsb2NraW5nU3ByaXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tpbmdTcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tpbmdTcHJpdGUyKTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRNZXNzYWdlV2luZG93R3JvdXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5waG9uZUJnLndpZHRoIC0gMzI7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclggLSAod2lkdGggLyAyKSxcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLnBob25lQmcueSArIDMyLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5waG9uZUJnLmhlaWdodCAtIDc0LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0SGVhZGluZyA9IGhlaWdodCAvIDcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW4gPSAxMDtcclxuXHJcbiAgICAgICAgICAgIGhlaWdodCAtPSAoaGVpZ2h0SGVhZGluZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLnkgPSB5O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5oZWFkaW5nVGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIHdpZHRoIC8gMiwgaGVpZ2h0SGVhZGluZyAvIDIsIFwiSEVBRElORyBURVNUXCIsIHRoaXMuZm9udEhlYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZ1RleHQuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHkud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5LndvcmRXcmFwV2lkdGggPSB3aWR0aCAqIDAuOTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keUxpbmsud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5TGluay53b3JkV3JhcFdpZHRoID0gd2lkdGggKiAwLjk7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keVRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW4sIGhlaWdodEhlYWRpbmcgKyBtYXJnaW4sIFwiVEhJUyBJUyBBIFRFWFQgTUVTU0FHRSBGT1IgWU9VIFRPIFNFRSBURVNUXCIsIHRoaXMuZm9udEJvZHkpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlUZXh0LmFuY2hvci5zZXRUbygwLjAsIDAuMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keVRleHQuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMuY2xpY2tlZEJvZHlUZXh0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAuYWRkKGdyYXBoaWNzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBhIGZpbGwgYW5kIGxpbmUgc3R5bGVcclxuICAgICAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4MzUzNTM1KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDEsIDB4MDAwMDAwLCAxKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodEhlYWRpbmcpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhGRkZGRkYsIDAuOSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KDAsIGhlaWdodEhlYWRpbmcsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYnV0dG9uU3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUucGhvbmUubWVzc2FnZXMuYnV0dG9uKTtcclxuICAgICAgICAgICAgYnV0dG9uU3ByaXRlLnggPSB3aWR0aCAtIGJ1dHRvblNwcml0ZS53aWR0aCAtIG1hcmdpbjtcclxuICAgICAgICAgICAgYnV0dG9uU3ByaXRlLnkgPSBoZWlnaHRIZWFkaW5nICsgaGVpZ2h0IC0gbWFyZ2luIC0gYnV0dG9uU3ByaXRlLmhlaWdodDtcclxuICAgICAgICAgICAgYnV0dG9uU3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJ1dHRvblNwcml0ZS5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMuY2hvb3NlT2ssIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCBtYXJnaW4sIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5waG9uZS5wbGF5QnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMuY2xpY2tlZEJvZHlUZXh0LCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGV4dEdyb3VwLmFkZCh0aGlzLmhlYWRpbmdUZXh0KTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAuYWRkKHRoaXMuYm9keVRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC5hZGQoYnV0dG9uU3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0R3JvdXAuYWRkKHRoaXMucGxheUJ1dHRvbik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhpZGVUZXh0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93VGV4dDogZnVuY3Rpb24gKGhlYWRpbmcxLCBib2R5LCBpc1RleHRNZXNzYWdlLCBsaW5rLCB2YWx1ZUluKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmKCB2YWx1ZUluICkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKCB2YWx1ZUluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmdUZXh0LnNldFRleHQoaGVhZGluZzEpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEJvZHlUZXh0KCBib2R5LCBsaW5rLCB2YWx1ZUluICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZTIudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKCBpc1RleHRNZXNzYWdlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGR0ID0gXCJSZWNlaXZlZDogXCIgKyBtb21lbnQoKS5mb3JtYXQoXCJNTU0gRG8gWVlZWSwgaDptbSBhIFwiKTsgLy8gSnVsIDIxc3QgMjAxNSwgMTE6MTIgYW1cclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShoZWFkaW5nMSk7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gZnJvbS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGZyb20uc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmdUZXh0LnNldFRleHQoIFwiRnJvbTogXCIgKyBmcm9tICsgXCJcXG5cIiArIGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Qm9keVRleHQ6IGZ1bmN0aW9uKCB0ZXh0LCBpc0xpbmssIHVzZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiSW4gc2V0IGJvZHkgdGV4dC5cIik7XHJcbiAgICAgICAgICAgIGlmKCBpc0xpbmsgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiU2V0dGluZyBhcyBzaW1wbGUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5zZXRTdHlsZSggdGhpcy5mb250Qm9keSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5zZXRUZXh0KCB0aGlzLnN1YnN0aXR1dGVUZXh0KHRleHQpICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIm5vdCBhIHN0cmluZywgcGFyc2luZyBldmVyeXRoaW5nLi5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LnNldFN0eWxlKCB0aGlzLmZvbnRCb2R5TGluayApO1xyXG4gICAgICAgICAgICAgICAgaWYoIHVzZVZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwidXNlVmFsdWUgZGVmaW5lZCwgYXM6IFwiICsgdXNlVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodXNlVmFsdWUpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJ2YWx1ZSBpcyBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRTY29yZVJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKCB0ZXh0LCBmdW5jdGlvbihzaW5nbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggdmFsdWUgPj0gc2luZ2xlRW50cnlbMF0gJiYgdmFsdWUgPD0gc2luZ2xlRW50cnlbMV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlUZXh0LnNldFRleHQoIHRoaXMuc3Vic3RpdHV0ZVRleHQoc2luZ2xlRW50cnlbMl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU2NvcmVSYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRTY29yZVJhbmdlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvZy53YXJuKFwiJCQkJCQkJCQkJCQgbm90ZWQgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2NvcmUgd2Fzbid0IHdpdGhpbiBhbnkgcmFuZ2UuIEl0IGNvdWxkIGJlIGhpZ2hlciB0aGFuIGFueSBvciBsb3dlciB0aGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSwgb3IgdGhlcmUgY291bGQgYmUgYSBob2xlIGluIHRoZSByYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdoZXN0U2NvcmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0U2NvcmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGVzdFRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0VGV4dCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaCggdGV4dCwgZnVuY3Rpb24oc2luZ2xlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBzaW5nbGVFbnRyeVswXSA+IGhpZ2hlc3RTY29yZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0U2NvcmUgPSBzaW5nbGVFbnRyeVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0VGV4dCA9IHNpbmdsZUVudHJ5WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHNpbmdsZUVudHJ5WzFdID4gaGlnaGVzdFNjb3JlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RTY29yZSA9IHNpbmdsZUVudHJ5WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RUZXh0ID0gc2luZ2xlRW50cnlbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbmdsZUVudHJ5WzBdIDwgbG93ZXN0U2NvcmUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U2NvcmUgPSBzaW5nbGVFbnRyeVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RUZXh0ID0gc2luZ2xlRW50cnlbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbmdsZUVudHJ5WzFdIDwgbG93ZXN0U2NvcmUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U2NvcmUgPSBzaW5nbGVFbnRyeVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RUZXh0ID0gc2luZ2xlRW50cnlbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBoaWdoZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjb3JlIGlzIGhpZ2hlciB0aGFuIGhpZ2hlc3QgcmFuZ2U7IHVzZSBoaWdoZXN0IHJhbmdlIHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0VGV4dCggdGhpcy5zdWJzdGl0dXRlVGV4dChoaWdoZXN0VGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgbG93ZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjb3JlIGlzIGxvd2VyIHRoYW4gbG93ZXN0IHJhbmdlOyB1c2UgbG93ZXN0IHJhbmdlIHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0VGV4dCggdGhpcy5zdWJzdGl0dXRlVGV4dChsb3dlc3RUZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIGEgaG9sZSBpbiB0aGUgcmFuZ2VzOyBqdXN0IHVzZSB0aGUgZmlyc3QgZW50cnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVRleHQuc2V0VGV4dCh0aGlzLnN1YnN0aXR1dGVUZXh0KHRleHRbMF1bMl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib2R5VGV4dC5zZXRUZXh0KCB0aGlzLnN1YnN0aXR1dGVUZXh0KHRleHRbMF1bMl0pKTsgLy8ganVzdCB1c2UgZmlyc3QgZW50cnkuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLnkgPSB0aGlzLmJvZHlUZXh0LnkgKyB0aGlzLmJvZHlUZXh0LmhlaWdodCArIDU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJzdGl0dXRlVGV4dDogZnVuY3Rpb24oIHRleHQgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRG9pbmcgc3Vic3RpdHV0aW9uIG9uOiBcIiArIHRleHQpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdEluZGV4LCByaWdodEluZGV4O1xyXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIpO1xyXG4gICAgICAgICAgICBpZiggbGVmdEluZGV4ID09PSAtMSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIsIGxlZnRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiggcmlnaHRJbmRleCA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGV4dC5zdWJzdHJpbmcoIGxlZnRJbmRleCwgcmlnaHRJbmRleCArMSk7XHJcbiAgICAgICAgICAgIHZhciBrZXkyID0ga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSB0cmFpbGluZyBkb2xsYXJzaWduLlxyXG4gICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShrZXkyKTtcclxuICAgICAgICAgICAgZmluYWxUZXh0ID0gZmluYWxUZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZmluYWxUZXh0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKGtleSwgZmluYWxUZXh0ICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoaWRlVGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHRHcm91cC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNob29zZU9rOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJY29uICYmIHRoaXMuY3VycmVudEljb24udmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5jdXJyZW50SWNvbiwgXCJjbG9zZWRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJY29uID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVUZXh0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGlja2VkQm9keVRleHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwiY2xpY2tlZFwiKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBob25lIGxpbmtzIG11c3QgYmVoYXZlIGRpZmZlcmVudGx5IHRoYW4gb3RoZXIgYnV0dG9ucyBpbiB0aGUgc2NlbmUgZW5naW5lLlxyXG4gICAgICAgICAgICAgKiBUaGV5IGNhbiBiZSBjbGlja2VkIG92ZXIgYW5kIG92ZXIuIFNvLCBhZnRlciBzZW5kaW5nIHRoZSBjbGlja2VkIGV2ZW50LCB3ZSBzZW5kIGFuXHJcbiAgICAgICAgICAgICAqIGFmdGVyQ2xpY2tlZCBldmVudCwgd2hpY2ggZm9yY2VzIHRoZSB2YXJpYWJsZSB0byBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdGltZSB0aGVcclxuICAgICAgICAgICAgICogbGluayBpcyBjbGlja2VkLCB0aGUgJ2NsaWNrZWQnIGV2ZW50IGlzIHNlZW4gYXMgYSBjaGFuZ2UgYWdhaW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMuY3VycmVudEljb24sIFwiYWZ0ZXJDbGlja2VkXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRIZWFkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLnBob25lR3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy50ZXh0R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRHcm91cC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJsb2NraW5nU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5ibG9ja2luZ1Nwcml0ZTIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlMi5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5wbGF5QnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBob25lO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgZGVjb3JhdGlvbiBhY3Rvci4gSnVzdCBhbiBpbWFnZSBvbiB0aGUgc2NyZWVuLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9ydHJhaXQxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImRlY29yYXRpb25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwicGhvbmVcIiwgLy8gdGhlIGltYWdlcyB0byB1c2UgZnJvbSB0aGUgYnV0dG9uIHNlY3Rpb24gb2YgdGhlIHRoZW1lLlxyXG4gKiAgICAgXCJrZXlcIjogXCJzb21ldGhpbmdcIiwgLy8gYW4gb3B0aW9uYWwga2V5IHRvIGxvb2sgdW5kZXIgZm9yIHRoZSBpbWFnZS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInNjYWxlXCI6IFsgeCwgeV0sIC8vIG9wdGlvbmFsIHgveSBzY2FsZS5cclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBQbGF5VGhyb3VnaEFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGdhbWUsIHRoZW1lKSB7XHJcbiAgICAgICAgICAgIGlmKCAhZ2FtZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiYWN0b3IgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwbGF5dGhyb3VnaGRpc3BsYXlcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnBsYXl0aHJvdWdoRGlzcGxheUNvbnRhaW5lciApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiWW91IGNhbm5vdCBkaXNwbGF5IHBsYXl0aHJvdWdoIHdpdGhvdXQgcHJvdmlkaW5nIGFuIGltYWdlIGluIHRoZSB0aGVtZS5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnBsYXl0aHJvdWdoRGlzcGxheUNvbnRhaW5lciApO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0gdGhpcy5nYW1lLndvcmxkLndpZHRoIC0gdGhpcy5zcHJpdGUud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZlN0eWxlID0gdGhpcy5nZXRGb250KCdwbGF5VGhyb3VnaCcpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB0aGlzLnNwcml0ZS53aWR0aC8yLCB0aGlzLnNwcml0ZS5oZWlnaHQvMiwgXCJQbGF5dGhyb3VnaDogXCIgKyB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJHBsYXlUaHJvdWdoXCIpLCBmU3R5bGUpO1xyXG4gICAgICAgICAgICBjdXJyZW50VGV4dC5hbmNob3Iuc2V0VG8oMC41LDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFkZENoaWxkKGN1cnJlbnRUZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQbGF5VGhyb3VnaEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBEYXZpZCBMZWVcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA0LzAzLzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFxyXG4gKiBBIHNwaW5uZXIgYWN0b3Igd2l0aCBhIGNlbnRyYWwgYnV0dG9uIGFuZCBhIHBvaW50ZXIgdGhhdCBleHRlbmRzIG9mZiBpdC5cclxuICogXHJcbiAqIENyZWF0aW5nIGEgU3Bpbm5lciBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgIFwibmFtZVwiOiBcInNwaW5uZXIxXCIsICAgICAgICAgICAgIC8vIEEgdW5pcXVlIG5hbWUgZm9yIHRoZSBhY3RvclxyXG4gKiAgICAgIFwidHlwZVwiOiBcInNwaW5uZXJcIiwgICAgICAgICAgICAgIC8vIFJlcXVpcmVkIHR5cGVcclxuICogICAgICBcImltYWdlc1wiOiBcInNwaW5uZXJcIiwgICAgICAgICAgICAvLyBUaGUga2V5IHRvIHVzZSBmcm9tIHRoZSBzcGlubmVycyBzZWN0aW9uIG9mIHRoZSB0aGVtZVxyXG4gKiAgICAgIFwiY2VudGVySW1hZ2VcIjogXCJjZW50ZXJcIiAgICAgICAgIC8vIFRoZSBrZXkgdG8gdXNlIHdpdGhpbiB0aGUgdGhlbWUgZmlsZSBmb3IgdGhlIGNlbnRlciBpbWFnZVxyXG4gKiAgICAgIFwiYXJyb3dJbWFnZVwiOiBcImFycm93XCIgICAgICAgICAgIC8vIFRoZSBrZXkgdG8gdXNlIHdpdGhpbiB0aGUgdGhlbWUgZmlsZSBmb3IgdGhlIGFycm93IGltYWdlXHJcbiAqICAgICAgXCJvZmZzZXRcIjogMC4yNSAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCBpbiByYWRpYW5zIHVzZWQgYnkgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIC8gd2hlbiBzcGlubmluZ1xyXG4gKiAgICAgIFwibnVtT3B0aW9uc1wiOiA0ICAgICAgICAgICAgICAgICAvLyBIb3cgbWFueSBkaWZmZXJlbnQgb3B0aW9ucyB0aGUgc3Bpbm5lciB1c2VzLiBEZWZhdWx0cyB0byA0XHJcbiAqICAgICAgXCJhdWRpb1wiOiBcInNwaW5cIiwgICAgICAgICAgICAgICAgLy8gQW4gb3B0aW9uYWwgc291bmQgdG8gcGxheSB3aGVuIHRoZSBzcGlubmVyIGlzIGNsaWNrZWQuIERvbid0IHBsYXkgbG9uZyBhdWRpbyFcclxuICogICAgICBcImF1ZGlvUHJpb3JpdHlcIjogXCJzZnhcIiwgICAgICAgICAvLyBBbiBvcHRpb25hbCBwcmlvcml0eSB0byB1c2UgZm9yIHRoZSBzcGlubmVyIGF1ZGlvIHByb3BlcnR5LiBJZiB0aGlzIGlzIG5vdCBzZXQsIGl0IGRlZmF1bHRzIHRvIFwic2Z4XCJcclxuICogICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLCAgICAgICAgICAgLy8gV2hlcmUgdG8gcHV0IHRoZSBjZW50ZXIgb2YgdGhlIHNwaW5uZXJcclxuICogICAgICBcInNwaW5EdXJhdGlvblwiOiAzNjAwLCAgICAgICAgICAgLy8gSG93IGxvbmcgdGhlIHNwaW4gYW5pbWF0aW9uIHNob3VsZCB0YWtlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIGEgZHVyYXRpb24gYmFzZWQgb24gdGhlIG51bWJlciBvZiBzcGlucyB3aWxsIGJlIHVzZWQgYnkgZGVmYXVsdFxyXG4gKiAgICAgIFwiZmFrZVNwaW5zUmFuZ2VcIjogWzIsIDVdLCAgICAgICAvLyBSYW5nZSBbbWluLCBtYXhdIG9mIGZha2Ugc3BpbnMgdG8gc2hvdyBiZWZvcmUgdGhlIGFycm93IGlzIHNldCB0byB0aGUgcmFuZG9tbHkgc2VsZWN0ZWQgc2VjdGlvbi4gVGhpcyBkZWZhdWx0cyB0byBbMiwgNV0gaWYgbm90IHNwZWNpZmllZFxyXG4gKiAgICAgIFwicmlnZ2VkXCI6IHRydWUsICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCwgaWYgdGhpcyBpcyB0cnVlIHRoZSBzcGlubmVyIHdpbGwgc2VsZWN0IGVhY2ggb3B0aW9uIG9uY2UgdW50aWwgZWFjaCBpcyB1c2VkLCB0aGVuIGJlZ2luIHJhbmRvbWx5IHNlbGVjdGluZyB0aGluZ3MuXHJcbiAqICAgICAgXCJjbGlja1ZhbHVlXCI6IFwicmVzZXRcIiwgICAgICAgICAgLy8gT3B0aW9uYWwsIGlmIHRoaXMgaXMgc2V0LCB3aGVuIHRoZSBjZW50ZXIgaXMgY2xpY2tlZCB0aGUgdmFyaWFibGUgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgdG8gdHJpZ2dlciBldmVudHMgb24gY2xpY2sgdGhhdCBtdXN0IGhhcHBlbiBiZWZvcmUgdGhlIHNwaW4gaXMgY29tcGxldGVkIGFuZCB0aGUgdmFyaWFibGUgaXMgdXBkYXRlZCB0byB0aGUgZmluYWwgdmFsdWVcclxuICogICAgICBcInZhcmlhYmxlXCI6IFwic3Bpbm5lcl92YWx1ZVwiICAgICAvLyBpZiB5b3UgY2xpY2sgdGhlIHNwaW5uZXIsIHRoZSB2YXJpYWJsZSAnc3Bpbm5lcl92YWx1ZScgd2lsbCBiZSBzZXQgdG8gYSBudW1iZXIgYmV0d2VlbiAxIGFuZCA0LlxyXG4gKiAgICAgIFwic3RhcnREZWxheVwiOiAxMDAwICAgICAgICAgICAgICAvLyBvcHRpb25hbCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQ7IGl0IGlzIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogICAgICBcImFycm93T2Zmc2V0WFwiOiAwLjA1ICAgICAgICAgICAgLy8gb3B0aW9uYWwgb2Zmc2V0IGZvciBzcGlubmVyIGFycm93WFxyXG4gKiB9XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBERUZBVUxUX05VTV9PUFRJT05TID0gNDtcclxuXHJcbiAgICB2YXIgU3Bpbm5lckFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcblxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiLCBcImltYWdlc1wiLCBcImNlbnRlckltYWdlXCIsIFwiYXJyb3dJbWFnZVwiLCBcInZhcmlhYmxlXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJhbmRvbUludEZyb21JbnRlcnZhbDogZnVuY3Rpb24obWluLG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoIG1heCAtIG1pbiArIDEpKSArIG1pbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUuc3Bpbm5lcnMgfHwgIXRoaXMudGhlbWUuc3Bpbm5lcnNbdGhpcy5kYXRhLmltYWdlc10gKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlNwaW5uZXIgQWN0b3IgcmVxdWlyZXMgc3Bpbm5lcnMgZW50cnkgaW4gdGhlbWUsIHdpdGggc3BlY2lmaWMgZW50cnkgbWF0Y2hpbmcgXCIgKyB0aGlzLmRhdGEuaW1hZ2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aGVtZS5zcGlubmVyc1t0aGlzLmRhdGEuaW1hZ2VzXVt0aGlzLmRhdGEuY2VudGVySW1hZ2VdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlNwaW5uZXIgQWN0b3IgcmVxdWlyZXMgc3Bpbm5lciBlbnRyeSB0byBoYXZlIGEgY2VudGVyIGltYWdlLCB3aXRoIGEgc3BlY2lmaWMgZW50cnkgbWF0Y2hpbmcgXCIgKyB0aGlzLmRhdGEuaW1hZ2VzICsgXCIuXCIgKyB0aGlzLmRhdGEuY2VudGVySW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRoZW1lLnNwaW5uZXJzW3RoaXMuZGF0YS5pbWFnZXNdW3RoaXMuZGF0YS5hcnJvd0ltYWdlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTcGlubmVyIEFjdG9yIHJlcXVpcmVzIHNwaW5uZXIgZW50cnkgdG8gaGF2ZSBhbiBhcnJvdyBpbWFnZSwgd2l0aCBhIHNwZWNpZmljIGVudHJ5IG1hdGNoaW5nIFwiICsgdGhpcy5kYXRhLmltYWdlcyArIFwiLlwiICsgdGhpcy5kYXRhLmFycm93SW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmRhdGEubnVtT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLm51bU9wdGlvbnMgPSBERUZBVUxUX05VTV9PUFRJT05TO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighdGhpcy5kYXRhLmZha2VTcGluc1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZmFrZVNwaW5zUmFuZ2UgPSBbMiwgNV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmRhdGEuYXVkaW9Qcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmF1ZGlvUHJpb3JpdHkgPSBcInNmeFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMgPSB0aGlzLmRhdGEucmlnZ2VkID8gXy5zaHVmZmxlKF8ucmFuZ2UoMSwgdGhpcy5kYXRhLm51bU9wdGlvbnMgKyAxKSkgOiBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbmNob3JYID0gMC41LFxyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXJyb3cgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh4LCB5LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuc3Bpbm5lcnNbdGhpcy5kYXRhLmltYWdlc11bdGhpcy5kYXRhLmFycm93SW1hZ2VdKTtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh4LCB5LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuc3Bpbm5lcnNbdGhpcy5kYXRhLmltYWdlc11bdGhpcy5kYXRhLmNlbnRlckltYWdlXSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5hbmNob3Iuc2V0VG8oYW5jaG9yWCwgYW5jaG9yWSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmFycm93T2Zmc2V0WCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvdy5hbmNob3Iuc2V0VG8oYW5jaG9yWCAtIHRoaXMuZGF0YS5hcnJvd09mZnNldFgsIGFuY2hvclkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvdy5hbmNob3Iuc2V0VG8oYW5jaG9yWCwgYW5jaG9yWSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXJyb3cucm90YXRpb24gPSBNYXRoLlBJICogdGhpcy5kYXRhLm9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFycm93LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyb3cuaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMub25DbGljaywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyb3cuZXZlbnRzLm9uSW5wdXREb3duLmFkZCh0aGlzLm9uQ2xpY2ssIHRoaXMpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuY2xpY2tWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSB0aGlzLmRhdGEuY2xpY2tWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hdWRpbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy5kYXRhLmF1ZGlvLCBcInByaW9yaXR5XCI6IHRoaXMuZGF0YS5hdWRpb1ByaW9yaXR5IH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJhbmRvbUludCA9IHRoaXMucmlnZ2VkU3BpblZhbHVlcy5sZW5ndGggPyB0aGlzLnJpZ2dlZFNwaW5WYWx1ZXMuc2hpZnQoKSA6IHRoaXMucmFuZG9tSW50RnJvbUludGVydmFsKDEsIHRoaXMuZGF0YS5udW1PcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByYW5kb21GdWxsU3BpbnMgPSB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCh0aGlzLmRhdGEuZmFrZVNwaW5zUmFuZ2VbMF0sIHRoaXMuZGF0YS5mYWtlU3BpbnNSYW5nZVsxXSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmFuZG9tUm90YXRpb24gPSAoKE1hdGguUEkgKiAyKSAvIHRoaXMuZGF0YS5udW1PcHRpb25zKSAqIHJhbmRvbUludDtcclxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gKDIgKiByYW5kb21GdWxsU3BpbnMgKiBNYXRoLlBJKSArIHJhbmRvbVJvdGF0aW9uICsgKE1hdGguUEkgKiB0aGlzLmRhdGEub2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghIHRoaXMuZGF0YS5zcGluRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzcGluRHVyYXRpb24gaXNuJ3QgcGFzc2VkIGluLCBvdmVycmlkZSBpdCB3aXRoIHRoZSBvbGQgY29kZSBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BpbkR1cmF0aW9uID0gKHJvdGF0aW9uIC8gKDIgKiBNYXRoLlBJKSkgKiAxMDAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4gPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuYXJyb3cpLnRvKCB7IHJvdGF0aW9uOiByb3RhdGlvbiB9LCB0aGlzLmRhdGEuc3BpbkR1cmF0aW9uLCBQaGFzZXIuRWFzaW5nLlF1YWRyYXRpYy5PdXQsIHRydWUsIDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50d2Vlbi5vbkNvbXBsZXRlLmFkZCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvdy5yb3RhdGlvbiA9IHRoaXMuYXJyb3cucm90YXRpb24gJSAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bpbm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSByYW5kb21JbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcnJvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvdy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudHdlZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gU3Bpbm5lckFjdG9yO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgc3BlZWNoIGJ1YmJsZS4gSXQgZGlzcGxheXMgdGV4dCBhbmQgcmVxdWVzdHMgdGhhdCBhdWRpbyBiZSBwbGF5ZWQuIEEgc3BlZWNoIGJ1YmJsZSBjYW4gaGF2ZSBpdHMgb3duIHRleHQvYXVkaW9cclxuICogYW5kIGNhbiBhbHNvIGxpc3RlbiBmb3IgdGV4dC9hdWRpbyBldmVudHMgdG8gc2hvdy5cclxuICogVGhlIHNwZWVjaCBidWJibGUgd2lsbCBhZGp1c3QgaXRzIHNpemUgdG8gZml0IHRoZSBwcm92aWRlZC9zZXQgdGV4dC5cclxuICpcclxuICp7XHJcbiAqICAgIFwibmFtZVwiOiBcImNob2ljZUJ1YmJsZVwiLCAvLyBuYW1lLlxyXG4gKiAgICBcInR5cGVcIjogXCJzcGVlY2gtYnViYmxlXCIsXHJcbiAqICAgIFwidGV4dFwiOiBcIlwiLCAvLyB0ZXh0IHRvIHNob3cuXHJcbiAqICAgIFwiYXVkaW9cIjogXCJcIiwgLy8gYXVkaW8ga2V5IHRvIHBsYXkuXHJcbiAqICAgIFwiaGlkZGVuXCI6IHRydWUsIC8vIHNldCB0byB0cnVlIHRvIG9wdGlvbmFsbHkgaGlkZSB0aGUgYnViYmxlIGluaXRpYWxseSwgdXNlZCB3aGVuIGNoYXJhY3RlciBpc24ndCB0aGUgZmlyc3QgdG8gdGFsay5cclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgbWFyZ2luWCA9IDE1LCBtYXJnaW5ZID0gMjA7XHJcblxyXG4gICAgdmFyIFppbmtDb21wdXRlckFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQgfHwgXCIgXCI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0gdGhpcy5kYXRhLmtleTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93KHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcGVlY2goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFdpbmRvdzogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzIHx8ICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzLnppbmsgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkluc3RydWN0aW9uIGFjdG9yIHJlcXVpcmVzIHRleHRXaW5kb3dzIHRoZW1lIGVudHJ5LCBhbmQgemluayBkZWZpbml0aW9uIGluc2lkZSBpdC5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC54ID0geDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueSA9IHk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdG9wV2luZG93ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0V2luZG93cy56aW5rKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdidWJibGVUZXh0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLndvcmRXcmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXBXaWR0aCA9IHRvcFdpbmRvdy53aWR0aCAqIDAuNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgbWFyZ2luWCwgbWFyZ2luWSwgXCIgXCIsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKHRoaXMuY3VycmVudFRleHQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAgPSB3aW5kb3dHcm91cDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNwZWVjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFRleHQoIHRoaXMuZ2V0VGV4dCh0aGlzLnRleHQsIHRoaXMua2V5KSApO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbygge3RleHQ6IHRoaXMudGV4dCwgYXVkaW86IHRoaXMuYXVkaW8sIGtleTogdGhpcy5rZXl9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSBzcGVlY2gudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5rZXkgPSBzcGVlY2gua2V5O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFRleHQoIHRoaXMuZ2V0VGV4dCh0aGlzLnRleHQsIHRoaXMua2V5KSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dHcm91cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gWmlua0NvbXB1dGVyQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSB6aW5rIHBvc3RlciBhY3Rvci4gVGhpcyBpcyBhIHNwZWNpYWwgYWN0b3IgdGhhdCByZXF1aXJlcyBvbmx5IHRleHQgYW5kIGZvbnQgY29uZmlndXJhdGlvbi4gSXQgd2lsbCBzaG93IGFcclxuICogemluayBwb3N0ZXIgd2l0aCB0ZXh0IG9uIGl0LlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHppbmsgcG9zdGVyIGFjdG9yOlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJtYW5keVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJ6aW5rLXBvc3RlclwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwidGV4dFwiOiBcIllvLCBJJ20gemlua1wiLCAvLyB3aGF0IHRvIHB1dCBvbiB0aGUgcG9zdGVyLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFppbmtQb3N0ZXJBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIF07IC8vIG5vIHJlcXVpcmVkIGZpZWxkcy5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS50ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUZXh0Qm94KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhcmtPdXQgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMCwwKTtcclxuICAgICAgICAgICAgdGhpcy5kYXJrT3V0LmJlZ2luRmlsbCggMHgwMDAwMDAsIDAuNCApO1xyXG4gICAgICAgICAgICB0aGlzLmRhcmtPdXQuZHJhd1JlY3QoIDAsICAwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgdGhpcy5kYXJrT3V0LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmRhcmtPdXQpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCAodGhpcy5nYW1lLndvcmxkLmNlbnRlclgpLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKCd6aW5rLXBvc3RlcicsICdhY3RvckltYWdlcycpKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYIC0gKHRoaXMuc3ByaXRlLndpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuZ2xlIC09IDM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRUZXh0Qm94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250ID0gdGhpcy5nZXRGb250KCd6aW5rUG9zdGVyJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJveFkgPSB0aGlzLnNwcml0ZS55ICsgKHRoaXMuc3ByaXRlLmhlaWdodCAqIDAuNzUpO1xyXG4gICAgICAgICAgICB0aGlzLmJveFdpZHRoID0gdGhpcy5zcHJpdGUud2lkdGggLSAyO1xyXG4gICAgICAgICAgICB0aGlzLmJveEhlaWdodCA9IDExNTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9udC53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udC53b3JkV3JhcFdpZHRoID0gdGhpcy5ib3hXaWR0aCAqIDAuOTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIDEwICwgNSwgdGhpcy5kYXRhLnRleHQgLCB0aGlzLmZvbnQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lLCAxLCB0aGlzLmJveFkpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCggMHhFRkVGRUYsIDEuMCApO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KCAwLCAgMCwgdGhpcy5ib3hXaWR0aCwgdGhpcy5ib3hIZWlnaHQgKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmFkZENoaWxkKHRoaXMudGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFkZENoaWxkKHRoaXMuZ3JhcGhpY3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGFya091dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGFya091dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaaW5rUG9zdGVyQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMTAvMDIzLzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTcgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgYW5pbWF0aW9uIGFjdG9yLiBXaWxsIHJ1biBpdCdzIGFuaW1hdGlvbiwgYW5kIGNhbiBvcHRpb25hbGx5IGJlIGNsaWNrZWQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgY2xpY2stYW5pbWF0aW9uIGFjdG9yLCBhIHN0YXJ0aW5nLCBhbmltYXRpb24gc2V0LCBhbmQgZW5kaW5nIGltYWdlOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwb3J0cmFpdDFcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiYW5pbWF0aW9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZVxyXG4gKiAgICAgXCJrZXlcIjogXCJ3aGF0ZXZzXCIsIC8vIG9wdGlvbmFsIGltYWdlIGtleVxyXG4gKiAgICAgXCJ0ZXh0dXJlS2V5XCI6IFwia2V5XCIsIC8vIG9wdGlvbmFsIHRleHQga2V5IHRvIGdldCBhbmltYXRpb24gZnJvbVxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSxcclxuICogICAgIFwic2NhbGVcIjogWyB4LCB5XSwgLy8gb3B0aW9uYWwgeC95IHNjYWxlLlxyXG4gKiAgICAgXCJmcHNcIjogMTAsIC8vIGZyYW1lcyB3ZXJlIHNlY29uZCwgd2lsbCBkZWZhdWx0IHRvIDMwXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCwgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInhcIiwgLy8gdmFyaWFibGUgdG8gc2VuZCBvdXQgMm5kIGNsaWNrIGV2ZW50cywgd2lsbCBiZSBuYW1lICsgXCJfcGxheWluZ1wiIGFuZCBuYW1lICsgXCJfZmluaXNoZWRcIlxyXG4gKiAgICAgXCJsb29wXCI6IHRydWUgLy8gdHJ1ZT1sb29wIGluZGVmaW5pdGx5LCBmYWxzZT1ubyBsb29wLCBvciBudW1iZXIgb2YgdGltZXMgdG8gcGxheSB0aGUgYW5pbWF0aW9uOyBkZWZhdWx0cyB0byB0cnVlLlxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyksXHJcbiAgICAgICAgVHdlZW5IZWxwZXIgPSByZXF1aXJlKFwiLi90d2Vlbi1oZWxwZXJcIik7XHJcblxyXG4gICAgdmFyIEFuaW1hdGlvbkFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VzXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhcmlhYmxlTGlzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEudmFyaWFibGUgPyBbIHRoaXMuZGF0YS52YXJpYWJsZSArIFwiX3BsYXlpbmdcIiwgdGhpcy5kYXRhLnZhcmlhYmxlICsgXCJfZmluaXNoZWRcIiBdIDogW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHZhciBsb29wSW5kZWZpbml0ZWx5ID0gdGhpcy5kYXRhLmxvb3AgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGEubG9vcCA9PSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25zLnBsYXkoXCJhbmltYXRpb25cIiwgdGhpcy5mcHMsIGxvb3BJbmRlZmluaXRlbHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMzA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGV4dHVyZUtleSh0aGlzLmRhdGEpLCB0aGlzLmdldEltYWdlKCB0aGlzLmRhdGEuaW1hZ2VzLCB0aGlzLmRhdGEua2V5KVswXSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuZXZlbnRzLm9uSW5wdXRVcC5hZGQoIHRoaXMub25Qb2ludGVyVXAsIHRoaXMpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnZhcmlhYmxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2FuaW1hdGlvbicsIHRoaXMuZ2V0SW1hZ2UoIHRoaXMuZGF0YS5pbWFnZXMsIHRoaXMuZGF0YS5rZXkpICk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLm9uU3RhcnQuYWRkKHRoaXMuYW5pbWF0aW9uU3RhcnRlZCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLm9uQ29tcGxldGUuYWRkKHRoaXMuYW5pbWF0aW9uU3RvcHBlZCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmZwcyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnBzID0gdGhpcy5kYXRhLmZwcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGFuY2hvclggPSAwLCBhbmNob3JZID0gMDtcclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxLjA7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB0aGlzLmRhdGEuc2NhbGVbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHRoaXMuZGF0YS5zY2FsZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5zY2FsZVgsIHRoaXMuc2NhbGVZICk7XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hbmNob3IgKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gdGhpcy5kYXRhLmFuY2hvclswXTtcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSB0aGlzLmRhdGEuYW5jaG9yWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmNob3Iuc2V0VG8oIGFuY2hvclgsIGFuY2hvclkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0geDtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueSA9IHk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXBlYXRDb3VudCA9IE51bWJlcih0aGlzLmRhdGEubG9vcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0Q291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLnR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnR3ZWVuSGVscGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIgPSBuZXcgVHdlZW5IZWxwZXIodGhpcy5nYW1lLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIuYWRkVHdlZW5zKHRoaXMuZGF0YS50d2VlbiwgdGhpcy5zcHJpdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmltYXRpb25TdGFydGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS52YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGUgKyBcIl9wbGF5aW5nXCIgXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmltYXRpb25TdG9wcGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0Q291bnQgJiYgLS10aGlzLnJlcGVhdENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5yZXN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlICsgXCJfZmluaXNoZWRcIiBdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS52YXJpYWJsZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy50d2VlbkhlbHBlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIucmVtb3ZlVHdlZW5zKHRoaXMuc3ByaXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBbiBhdWRpbyBhY3Rvci4gSXQgd2lsbCBwbGF5IGEgc291bmQocykgYW5kIHRoZW4gc2V0IHRoZSB2YXJpYWJsZS5cclxuICogSXQgaXMgdXAgdG8gdGhlIHVzZXIvc2NyaXB0IHdyaXRlciB0byBtYWtlIHN1cmUgdGhpcyBhdWRpbyBpc24ndCBiZWluZyBpbnRlcnJ1cHRlZCBieSBvdGhlciBhdWRpby5cclxuICpcclxuICp7XHJcbiAqICAgIFwibmFtZVwiOiBcImF1ZGlvX2FjdG9yXzFcIiwgLy8gbmFtZS5cclxuICogICAgXCJ0eXBlXCI6IFwiYXVkaW9cIixcclxuICogICAgXCJhdWRpb1wiOiBbXCJzb3VuZDEsIHNvdW5kMlwiXSwgLy8gYXVkaW8ga2V5KHMpIHRvIHBsYXkuXHJcbiAqICAgIFwidmFyaWFibGVcIjogXCJ4XCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIHNvdW5kcyBoYXZlIGNvbXBsZXRlZCBwbGF5aW5nLlxyXG4gKiAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgIFwicHJpb3JpdHlcIjogc2Z4IHwgaW50ZXJydXB0IHwgcXVldWUgfCBzdG9wIHwgc3RvcGFsbCB8IGxvd1xyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBBdWRpb0FjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImF1ZGlvXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvID0gdGhpcy5kYXRhLmF1ZGlvO1xyXG4gICAgICAgICAgICAvLyBBbGxvdyBhIHNpbmdsZSBzdHJpbmcgdGhyb3VnaC5cclxuICAgICAgICAgICAgaWYoIHR5cGVvZiB0aGlzLmF1ZGlvID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW8gPSBbIHRoaXMuYXVkaW8gXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlDdXJyZW50KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5Q3VycmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmF1ZGlvSW5kZXggPiAodGhpcy5hdWRpby5sZW5ndGgtMSkgKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIlNldHRpbmcgYXVkaW8gc3ByaXRlIHZhcmlhYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBcInBsYXllZFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKCB0aGlzLmRhdGEubmFtZSwgdmFyU2V0ICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF1ZGlvS2V5ID0gdGhpcy5hdWRpb1t0aGlzLmF1ZGlvSW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiBhdWRpb0tleSwga2V5OiBudWxsLCBwcmlvcml0eTogdGhpcy5kYXRhLnByaW9yaXR5fSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoU3RvcDogZnVuY3Rpb24oIHNwZWVjaCApIHtcclxuICAgICAgICAgICAgLy8gbG9nLndhcm4oXCJPbiBnYW1lIHNwZWVjaCByZWFjaGVkIGF1ZGlvIGFjdG9yOiBcIiArIHNwZWVjaCk7XHJcbiAgICAgICAgICAgIGlmKCBzcGVlY2ggPT09IHRoaXMuYXVkaW9bdGhpcy5hdWRpb0luZGV4XSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9JbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5Q3VycmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF1ZGlvQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFN5ZCBHcm9zY2xhdWRlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8yMy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJsb2NrZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgdG8gYmxvY2sgaW5wdXQgZXZlbnRzIGZyb20gdGhlIGFjdG9ycyBiZWhpbmQgaXQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgYmxvY2tlciBhY3RvcjpcclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwiYWxlcnRCbG9ja2VyXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImJsb2NrZXJcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgMCwgMCBdLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBbMCwwXTsgd2hlcmUgb24gdGhlIHNjcmVlbiB0byBwbGF5IHRoaXMgYWN0b3JcclxuICogICAgIFwic2l6ZVwiOiBbIDgwMCwgNjAwIF0sIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIFtnYW1lLndvcmxkLndpZHRoLGdhbWUud29ybGQuaGVpZ2h0XSBob3cgbGFyZ2VcclxuICogICAgIFwiYmxvY2tlclRpbnRcIiA6IFwiMHgwMDAwMDBcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgYmxhY2sgKDB4MDAwMDAwKVxyXG4gKiAgICAgXCJibG9ja2VyQWxwaGFcIiA6IDAuNSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgMC41XHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgIHZhciBCbG9ja2VyQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlclggPSAodHlwZW9mIHRoaXMuZGF0YS5sb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IHRoaXMuZGF0YS5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJZID0gKHR5cGVvZiB0aGlzLmRhdGEubG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDAgOiB0aGlzLmRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyV2lkdGggPSAodHlwZW9mIHRoaXMuZGF0YS5zaXplID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmdhbWUud29ybGQud2lkdGggOiB0aGlzLmRhdGEuc2l6ZVswXTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJIZWlnaHQgPSAodHlwZW9mIHRoaXMuZGF0YS5zaXplID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmdhbWUud29ybGQuaGVpZ2h0IDogdGhpcy5kYXRhLnNpemVbMV07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyVGludCA9ICh0eXBlb2YgdGhpcy5kYXRhLmJsb2NrZXJUaW50ID09PSAndW5kZWZpbmVkJykgPyAweDAwMDAwMCA6IHRoaXMuZGF0YS5ibG9ja2VyVGludDtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJBbHBoYSA9ICh0eXBlb2YgdGhpcy5kYXRhLmJsb2NrZXJBbHBoYSA9PT0gJ3VuZGVmaW5lZCcpID8gMC41IDogdGhpcy5kYXRhLmJsb2NrZXJBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZSA9IG5ldyBQaGFzZXIuU3ByaXRlKHRoaXMuZ2FtZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lLCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmFkZENoaWxkKGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKCBibG9ja2VyVGludCwgYmxvY2tlckFscGhhICk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KCBibG9ja2VyWCwgYmxvY2tlclksIGJsb2NrZXJXaWR0aCwgYmxvY2tlckhlaWdodCApO1xyXG4gICAgICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmJyaW5nVG9Ub3AoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5ibG9ja2VyU3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkRGVidWdCb3goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlYnVnQm94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHdpbmRvdy5pc0RlYnVnZ2luZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3ggPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRyYXdSZWN0KDAsIDAsIHRoaXMuZGF0YS5zaXplWzBdLCB0aGlzLmRhdGEuc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYmxvY2tlclNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRlYnVnQm94ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCbG9ja2VyQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFphY2sgYmllcm5hdFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMTgvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBidXR0b24tY2hhcmFjdGVyIGFjdG9yLiBUaGlzIGFjdG9yIGNhbiBiZSB1c2VkIGZvciBzZWxlY3RpbmcgYSBjaGFyYWN0ZXIsIGFuZCBjYW4gYmVcclxuICogdXNlZCBmb3IgYW5pbWF0aW5nIGEgY2hhcmFjdGVyIHRoYXQgaXMgdGFsa2luZyAocHJvdmlkZSBtb3V0aCBhbmltYXRpb24pLiBJdCBpcyBkaWZmZXJlbnRpYXRlZCBmcm9tIHRoZVxyXG4gKiBOb0lucHV0Q2hhcmFjdGVyIEFjdG9yIGJ5IGFsbG93aW5nIHRoZSBpbWFnZSBmaWVsZCB0byBhY2Nlc3MgXCJidXR0b25zXCIgZnJvbSB0aGUgdGhlbWUgaW5zdGVhZCBvZiBcImFjdG9ySW1hZ2VzXCIuIFxyXG4gKiBUaGlzIGFsbG93cyBidXR0b24tbGlrZSBiZWhhdmlvciBmb3IgdGhlIGdyYXBoaWMuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgYnV0dG9uLWNoYXJhY3RlciBhY3RvcjpcclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwibWFuZHlcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiYnV0dG9uLWNoYXJhY3RlclwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VcIjogXCJtYW5keVwiLCAvLyB0aGUgYnV0dG9uIGltYWdlIHRvIHVzZSBmcm9tIHRoZSB0aGVtZSAoc2hvdWxkIGluY2x1ZGUgXCJ1cFwiLCBcImRvd25cIiwgXCJvdmVyXCIsIFwib3V0XCIpLlxyXG4gKiAgICAgXCJzcGVlY2hBbmltYXRpb25cIjogdHJ1ZXxmYWxzZSwgLy8gaWYgdGhlcmUgaXMgYSBzcGVlY2ggYW5pbWF0aW9uLlxyXG4gKiAgICAgXCJmcmFtZVJhdGVcIjogMjQgLy8gb3B0aW9uYWwgZnJhbWUgcmF0ZSBmb3IgdGhlIHNwZWVjaCBhbmltYXRpb24sIGRlZmF1bHRzIHRvIDEwLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDIwMCwgMjAwIF0sIC8vIHdoZXJlIG9uIHRoZSBzY3JlZW4gdG8gcGxheSB0aGlzIGFjdG9yXHJcbiAqICAgICBcInNpemVcIjogWyB3LCBoIF0sIC8vIHByb3ZpZGUgdGhpcyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgYW4gaW1hZ2UuXHJcbiAqICAgICBcInNwZWVjaEF1ZGlvXCI6IFwiNnRoXzAxXCIsIC8vIFRoZSBhY3RvciBzaG91bGQgYW5pbWF0ZSB0aGlzIHBpZWNlIG9mIGF1ZGlvLlxyXG4gKiAgICAgXCJrZXlcIjogXCJtYW5keVwiLCAvLyBvcHRpb25hbCBhdWRpbyBrZXksIGlmIG5vdCBwcmVzZW50LCBuYW1lIHdpbGwgYmUgdXNlZC5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJjaGFyYWN0ZXJfMlwiLCAvLyBpZiB5b3UgY2xpY2sgdGhpcyBjaGFyYWN0ZXIsIHRoZSB2YXJpYWJsZSAnY2hhcmFjdGVyXzInIHdpbGwgYmUgc2V0IHRvICdtYW5keScuXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICogIElmIHlvdSBzZXQgc3BlZWNoQW5pbWF0aW9uIHRvIHRydWUsIC10YWxrIG11c3QgYmUgYXBwZW5kZWQgdG8gdGhlIGJ1dHRvbi1jaGFyYWN0ZXIncyBpbWFnZSBuYW1lIHRvIGRpZmZlcmVudGlhdGVcclxuICogIGZyb20gdGhlIG5vbi1zcGVha2luZyB2ZXJzaW9uICh3aGljaCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBtb3V0aCBncmFwaGljISlcclxuICpcclxuICogIEZvciB0aGUgc3BlZWNoIGFuaW1hdGlvbnMgdG8gd29yaywgeW91J2xsIG5lZWQgYSBzcGVlY2hBbmltYXRpb25zIHNlY3Rpb24gaW4gdGhlIHRoZW1lLmpzb24sIHdoaWNoIHNwZWNpZmllc1xyXG4gKiAgc3BlYWtpbmctYW5pbWF0aW9uIGltYWdlcyBhbmQgbG9jYXRpb24gb2Zmc2V0cyBmb3IgdGhlIG1vdXRoOlxyXG4gKlxyXG4gKiAgIFwic3BlZWNoQW5pbWF0aW9uc1wiOiB7XHJcbiAqICAgIFwiamFuZWxsZVwiOiB7XHJcbiAqICAgICAgXCJpbWFnZXNcIjogW1widGFsa2luZy1qYW5lbGxlLW1vdXRoMS5wbmdcIiwgXCJ0YWxraW5nLWphbmVsbGUtbW91dGgxLnBuZ1wiLCBcInRhbGtpbmctamFuZWxsZS1tb3V0aDIucG5nXCJdLFxyXG4gKiAgICAgIFwibW91dGhPZmZzZXRcIjogWzY1LCAxNjVdICAgLy8gd2hlcmUgd2l0aGluIHRoZSBhY3RvciBcIi10YWxrXCIgaW1hZ2UgdG8gcGxhY2UgdGhlIGFuaW1hdGlvblxyXG4gKiAgICB9XHJcbiAqXHJcbiAqICBUaGVyZSBtdXN0IGFkZGl0aW9uYWxseSBiZSBcIlNvdW5kIFN5bmMgRGF0YVwiLCBkZWZpbmluZyB3aGljaCBpbWFnZSB0byBzaG93Li4uXHJcbiAqXHJcbiAqIFwic291bmRTeW5jRGF0YVwiOiB7XHJcbiAqICAgXCI2dGhfMDFcIjogW1xyXG4gKiAgICAgMCwxLDEsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDEsMCwxLDEsMCwwLDAsMCwxLDFcclxuICogICBdLCAuLi5cclxuICogfVxyXG4gKlxyXG4gKiAgVGhlIDBzIGFuZCAxcyByZXByZXNlbnQgd2hpY2ggaW1hZ2UsIGFuZCBjb3VsZCBiZSAwLDEsMiwzIGV0YyBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIuIFRoZXkga2V5IHNob3VsZCBtYXRjaFxyXG4gKiAgdGhlIFwic3BlZWNoQXVkaW9cIiBvZiB0aGlzIGFjdG9yIGFzIHdlbGwgYXMgdGhlIGF1ZGlvIGJlaW5nIHBsYXllZC4gXHJcbiAqICBOT1RFOiBNb3N0IG9mIHRoZSBzcGVlY2hTeW5jRGF0YSBkb2VzIG5vdCBjb250YWluICcxJ3MgYW5kIGxvb2tzIGxpa2UgWzAsMCwyLDMsMywzLDIsMCwyLDMsMiwwLDAsMCwyLDMsNCw0LDMsNCwyLDBdLlxyXG4gKiAgSW4gdGhpcyBjYXNlIGl0IGlzIGFkdmlzZWQgdG8gdXNlIHRoZSBbQSwgQiwgQiwgQywgRF0gcGF0dGVybiBmb3IgdGhlIGRpZmZlcmVudCBmcmFtZXMgaW4geW91ciB0aGVtZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgICB2YXIgQnV0dG9uQ2hhcmFjdGVyQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuc3BlZWNoQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTcGVlY2hBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUlkID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSh0aGlzLmRhdGEuaW1hZ2UpO1xyXG4gICAgICAgICAgICBpZiggaW1hZ2VJZCApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuc3BlZWNoQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VJZCArPSBcIi10YWxrXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbGljaywgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5vdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZV0uZG93biwgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZV0udXApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuc2NhbGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5idXR0b24oIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VdLm91dCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS51cCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS53aWR0aCA9IHRoaXMuZGF0YS5zaXplWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERlYnVnQm94KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBpcyBvbmUgb2YgdGhlIG1vc3QgQ1BVL2V4cGVuc2l2ZSB0aGluZ3MgeW91IGNhbiBkbyBpbiBwaGFzZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRGVidWdCb3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggd2luZG93LmlzRGVidWdnaW5nICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveCA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lLCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmJlZ2luRmlsbCgweDAwMDAwMCwgMS4wKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZHJhd1JlY3QoMCwgMCwgdGhpcy5kYXRhLnNpemVbMF0sIHRoaXMuZGF0YS5zaXplWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmRlYnVnQm94KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU3BlZWNoQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFTcGVlY2hBbmltYXRpb24gPSB0aGlzLnRoZW1lLnNwZWVjaEFuaW1hdGlvbnNbdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSh0aGlzLmRhdGEuaW1hZ2UpXTtcclxuICAgICAgICAgICAgaWYoICFhU3BlZWNoQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiQ291bGQgbm90IGFkZCBzcGVlY2ggYW5pbWF0aW9uIGZvciBjaGFyYWN0ZXI6IFwiICsgdGhpcy5kYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU3BlZWNoIGFuaW1hdGlvbiBub3QgZm91bmQgZm9yIFwiICsgdGhpcy5kYXRhLmltYWdlICk7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJDaGVjayB0aGF0IHlvdSBoYXZlIGEgc3BlZWNoQW5pbWF0aW9ucyBzZWN0aW9uIGluIHlvdXIgdGhlbWUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubG9jYXRpb25bMF0gKyBhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvY2F0aW9uWzFdICsgYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uYW5pbWF0aW9ucy5hZGQoJ3RhbGsnLCBhU3BlZWNoQW5pbWF0aW9uLmltYWdlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uU2V0ID0gYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXM7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uRGVmYXVsdCA9IGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLnNjYWxlLnNldFRvKCB0aGlzLmRhdGEuc2NhbGVbMF0sIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi54ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgKGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0gKiB0aGlzLmRhdGEuc2NhbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzFdICogdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiAoc3BlZWNoKSB7XHJcbiAgICAgICAgICAgIHZhciBhdWRpbyA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoc3BlZWNoLmF1ZGlvKTtcclxuICAgICAgICAgICAgaWYoIHNwZWVjaC5rZXkgKSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpbyA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoc3BlZWNoLmtleSkgKyBcIl9cIiArIGF1ZGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiT24gZ2FtZSBzcGVlY2g6IFwiICsgYXVkaW8pO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gJiYgdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhXHJcbiAgICAgICAgICAgICAgJiYgdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhW2F1ZGlvXSAmJiB0aGlzLmRhdGEuc3BlZWNoQXVkaW8gPT09IGF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZFN5bmNEYXRhID0gdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhW2F1ZGlvXTtcclxuICAgICAgICAgICAgICAgIGlmKCAhIHRoaXMudGltZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIEZSQU1FX1JBVEUgPSB0aGlzLmRhdGEuZnJhbWVSYXRlID8gdGhpcy5kYXRhLmZyYW1lUmF0ZSA6IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSB0aGlzLmdhbWUudGltZS5jcmVhdGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXIubG9vcCgxMDAwIC8gRlJBTUVfUkFURSwgdGhpcy5pbmNyZW1lbnRTcGVlY2gsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5jcmVtZW50U3BlZWNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc291bmRTeW5jRGF0YSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLmZyYW1lTmFtZSA9IHRoaXMuc3BlZWNoQW5pbWF0aW9uU2V0W3RoaXMuc291bmRTeW5jRGF0YVt0aGlzLnNwZWVjaEluZGV4XV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaFN0b3A6IGZ1bmN0aW9uIChzcGVlY2gpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc3BlZWNoQW5pbWF0aW9uICYmIHRoaXMuc291bmRTeW5jRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZFN5bmNEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLmZyYW1lTmFtZSA9IHRoaXMuc3BlZWNoQW5pbWF0aW9uRGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuc3BlZWNoQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRlYnVnQm94ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMudGltZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkNoYXJhY3RlckFjdG9yO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBidXR0b24gYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgZm9yIHNpbXBsZSBhY3Rpb25zLCBzdWNoIGFzIG9wZW5pbmcgdGhlIGNlbGwgcGhvbmUuIEluIG1hbnkgJ3BsYXlzJywgdGhpcyBhY3RvcnNcclxuICogaXNuJ3QgbmVlZGVkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicGhvbmUxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImJ1dHRvblwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VcIjogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b24gc2VjdGlvbiBvZiB0aGUgdGhlbWUuXHJcbiAqICAgICBcImF1ZGlvXCI6IFwicmluZ1wiLCAvLyBhbiBvcHRpb25hbCBzb3VuZCB0byBwbGF5IHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLiBEb24ndCBwbGF5IGxvbmcgYXVkaW8hKioqXHJcbiAqICAgICBcInNmeFwiOiB7XHJcbiAqICAgICAgICBcIm92ZXJcIjogXCJkaW5nXCIgLy8gb3B0aW9uYWwgc291bmRzIHRvIHBsYXkgb24gdXAvb3Zlci9kb3duL291dC4gQWRkIHN1cHBvcnQgYXMgbmVlZGVkLiBPdmVyIGFkZGVkLlxyXG4gKiAgICAgfSxcclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwic2hvd19jZWxsX3Bob25lXCIgLy8gaWYgeW91IG9wZW4gdGhlIHBob25lLCB0aGUgdmFyaWFibGUgJ3Nob3dfY2VsbF9waG9uZScgd2lsbCBiZSBzZXQgdG8gJ3Bob25lMScuXHJcbiAqICAgICBcImFuaW1hdGVkXCI6IFwidHJ1ZVwiLCAvLyBvcHRpb25hbDsgdGhlbWUuYnV0dG9uQW5pbWF0aW9ucy48aW1hZ2U+IGl0ZW0gbmFtZSBjb250YWluaW5nIGEgbGlzdCBvZiBpbWFnZXNcclxuICogICAgIFwiYW5pbWF0aW9uRnJhbWVSYXRlXCI6IDMwLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAzMCBmcHM7IGlnbm9yZWQgaWYgYW5pbWF0ZWQgaXMgbm90IHRydWVcclxuICogICAgIFwiYW5pbWF0aW9uTG9vcFwiOiBcInRydWVcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2U7IGlnbm9yZWQgaWYgYW5pbWF0ZWQgaXMgbm90IHRydWVcclxuICogICAgIFwiYW5pbWF0aW9uUmVwZWF0XCI6IDQwMDAsIC8vIG9wdGlvbmFsLCB0aW1lIGluIHNlY29uZHMsIGRlZmF1bHQgaXMgbm8gcmVwZWF0OyBvdmVycmlkZXMgYW5pbWF0aW9uTG9vcCBpZiBib3RoIGFyZSBzcGVjaWZpZWQ7IGlnbm9yZWQgaWYgYW5pbWF0ZWQgaXMgbm90IHRydWVcclxuICogICAgIFwiYWxwaGFcIjogMC40IC8vIG9wdGlvbmFsLCBvcGFjaXR5IGNvZWZmaWNpZW50XHJcbiAqICAgICAvLyBvcHRpb25hbCBcInNjYWxlXCI6IFsgMS4xLCAxLjEgXSwgLy8gVXNlIG5lZ2F0aXZlIHNjYWxlcyB0byAnZmxpcCcgdGhlIGltYWdlcy5cclxuICogICAgIC8vIG9wdGlvbmFsIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZDsgaXQgaXMgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqICAqKiogSWYgeW91IHdhbnQgdG8gcGxheSBsb25nIGF1ZGlvIG9uIGEgYnV0dG9uLCB1c2UgYW4gZXZlbnQgYW5kIGFkZCB0aGUgYXVkaW8gYWN0b3IuIFRoaXMgaXMgbWVhbnQgZm9yIHRoaW5ncyBsaWtlXHJcbiAqICAgICAgY2xpY2tzIGFuZCBiZWVwcyB0aGF0IHBsYXkgZm9yIGFib3V0IGEgc2Vjb25kLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyksXHJcbiAgICAgICAgVHdlZW5IZWxwZXIgPSByZXF1aXJlKFwiLi90d2Vlbi1oZWxwZXJcIik7XHJcblxyXG4gICAgdmFyIEJVVFRPTl9USU1FT1VUID0gMjAwOyAvLyBVc2UgdGhpcyBzbyB0aGUgYXVkaW8gaGFzIGEgY2hhbmNlIHRvIHBsYXkuXHJcblxyXG4gICAgdmFyIEJ1dHRvbkFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaXMgaW4gcGFyZW50LlxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiLCBcImltYWdlXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy50aGVtZS5idXR0b25zIHx8ICF0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQnV0dG9uIEFjdG9yIHJlcXVpcmVzIGJ1dHRvbnMgZW50cnkgaW4gdGhlbWUsIHdpdGggc3BlY2lmaWMgZW50cnkgbWF0Y2hpbmcgXCIgKyB0aGlzLmRhdGEuaW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdLFxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLFxyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuYW5jaG9yID09PSBcImNlbnRlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gMC41O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IHRoaXMuZGF0YS5hbmNob3JbMF07XHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gdGhpcy5kYXRhLmFuY2hvclsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggeCx5LCB0aGlzLmdldFRleHR1cmVLZXkodGhpcy5kYXRhKSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5vdXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlXS51cCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uSXNBbmltYXRlZCA9ICggdHlwZW9mIHRoaXMuZGF0YS5hbmltYXRlZCAhPT0gXCJ1bmRlZmluZWRcIiApICYmICggdGhpcy5kYXRhLmFuaW1hdGVkID09PSB0cnVlICk7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b25Jc0FuaW1hdGVkICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uYW5pbWF0aW9ucy5hZGQodGhpcy5kYXRhLmltYWdlLCB0aGlzLnRoZW1lLmJ1dHRvbkFuaW1hdGlvbnNbdGhpcy5kYXRhLmltYWdlXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmF0ZSA9ICggdHlwZW9mIHRoaXMuZGF0YS5hbmltYXRpb25GcmFtZVJhdGUgIT09IFwidW5kZWZpbmVkXCIgKSA/IHRoaXMuZGF0YS5hbmltYXRpb25GcmFtZVJhdGUgOiAzMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9vcEFuaW1hdGlvbiA9ICggdHlwZW9mIHRoaXMuZGF0YS5hbmltYXRpb25Mb29wICE9PSBcInVuZGVmaW5lZFwiICkgPyB0aGlzLmRhdGEuYW5pbWF0aW9uTG9vcCA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25SZXBlYXQgPSAoIHR5cGVvZiB0aGlzLmRhdGEuYW5pbWF0aW9uUmVwZWF0ICE9PSBcInVuZGVmaW5lZFwiICkgPyB0aGlzLmRhdGEuYW5pbWF0aW9uUmVwZWF0IDogMDtcclxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5hbmltYXRpb25SZXBlYXQgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vcEFuaW1hdGlvbiA9IGZhbHNlOyAvLyB0aW1lZCByZXBlYXQgb3ZlcnJpZGVzIGxvb3BpbmdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWVyRXZlbnQgPSB0aGlzLmdhbWUudGltZS5ldmVudHMubG9vcCggdGhpcy5hbmltYXRpb25SZXBlYXQsIHRoaXMuYW5pbWF0ZUJ1dHRvbiwgdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlQnV0dG9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFuY2hvci5zZXRUbyggYW5jaG9yWCwgYW5jaG9yWSApO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnNjYWxlLnNldFRvKCB0aGlzLmRhdGEuc2NhbGVbMF0sIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYWxwaGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFscGhhID0gdGhpcy5kYXRhLmFscGhhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9udE5hbWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IHRoaXMuYnV0dG9uLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIHRleHRZID0gdGhpcy5idXR0b24uaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IFswLjUsIDAuNDVdO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdKRiAtIHRoaXMgd2FzIGFscmVhZHkgaGVyZSBhbmQgSSBkb24ndCB3YW50IHRvIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBzbyBJJ20gYWRkaW5nIGFcclxuICAgICAgICAgICAgICogXCJ0ZXh0RGF0YVwiIHNlY3Rpb24gYmVsb3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnRleHQgKSB7XHJcbiAgICAgICAgICAgICAgICBmb250TmFtZSA9IHRoaXMuZGF0YS5mb250O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwicXVlc3Rpb25UZXh0XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRleHRYLCB0ZXh0WSwgdGhpcy5kYXRhLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnRleHREYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHREYXRhID0gdGhpcy5kYXRhLnRleHREYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9udE5hbWUgPSB0ZXh0RGF0YS5mb250O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwicXVlc3Rpb25UZXh0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCB0ZXh0RGF0YS50ZXh0WCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0WCA9IHRleHREYXRhLnRleHRYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIHRleHREYXRhLnRleHRZICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRZID0gdGV4dERhdGEudGV4dFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdGV4dERhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHRleHREYXRhLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0ZXh0WCwgdGV4dFksIHRleHREYXRhLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmFuY2hvci5zZXRUbyggYW5jaG9yWzBdLCBhbmNob3JbMV0gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFkZENoaWxkKHRoaXMudGV4dFNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLm9uSW5wdXRPdmVyLmFkZCh0aGlzLm9uTW91c2VPdmVyLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudHdlZW4gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnR3ZWVuSGVscGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIgPSBuZXcgVHdlZW5IZWxwZXIodGhpcy5nYW1lLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIuYWRkVHdlZW5zKHRoaXMuZGF0YS50d2VlbiwgdGhpcy5idXR0b24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGV4dFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5IZWxwZXIuYWRkVHdlZW5zKHRoaXMuZGF0YS50d2VlbiwgdGhpcy50ZXh0U3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIGlmKCB0aGlzLmRhdGEuc2Z4ICYmIHRoaXMuZGF0YS5zZngub3ZlciApIHtcclxuICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy5kYXRhLnNmeC5vdmVyLCBcInByaW9yaXR5XCI6IFwic2Z4XCIgfTtcclxuICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5pbWF0ZUJ1dHRvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b25Jc0FuaW1hdGVkICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uYW5pbWF0aW9ucy5wbGF5KHRoaXMuZGF0YS5pbWFnZSwgdGhpcy5hbmltYXRpb25GcmFtZVJhdGUsIHRoaXMubG9vcEFuaW1hdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMuZGF0YS5hdWRpbywgXCJwcmlvcml0eVwiOiBcInNmeFwiIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyU2V0W3RoYXQuZGF0YS52YXJpYWJsZV0gPSB0aGF0LmRhdGEubmFtZTtcclxuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhhdC5kYXRhLm5hbWUsIHZhclNldCApO1xyXG5cclxuICAgICAgICAgICAgfSwgQlVUVE9OX1RJTUVPVVQpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMudHdlZW5IZWxwZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2VlbkhlbHBlci5yZW1vdmVUd2VlbnModGhpcy5idXR0b24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdGhpcy5hbmltYXRpb25UaW1lckV2ZW50ICE9ICd1bmRlZmluZWQnICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5yZW1vdmUoIHRoaXMuYW5pbWF0aW9uVGltZXJFdmVudCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnRleHRTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy50d2VlbkhlbHBlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWVuSGVscGVyLnJlbW92ZVR3ZWVucyh0aGlzLnRleHRTcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgY2hhcmFjdGVyIGFjdG9yLiBUaGlzIGFjdG9yIGNhbiBiZSB1c2VkIGZvciBzZWxlY3RpbmcgYSBjaGFyYWN0ZXIgKGNsaWNrYWJsZSB3aXRoIHRleHQgYnViYmxlKSwgb3IgY2FuIGJlXHJcbiAqIHVzZWQgZm9yIGFuaW1hdGluZyBhIGNoYXJhY3RlciB0aGF0IGlzIHRhbGtpbmcgKHByb3ZpZGUgbW91dGggYW5pbWF0aW9uKVxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGNoYXJhY3RlciBhY3RvcjpcclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwibWFuZHlcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiY2hhcmFjdGVyXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZVwiOiBcIm1hbmR5XCIsIC8vIHRoZSBpbWFnZSB0byB1c2UgZnJvbSB0aGUgdGhlbWUuXHJcbiAqICAgICBcInNwZWVjaEFuaW1hdGlvblwiOiB0cnVlfGZhbHNlLCAvLyBpZiB0aGVyZSBpcyBhIHNwZWVjaCBhbmltYXRpb24uXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgMjAwLCAyMDAgXSwgLy8gd2hlcmUgb24gdGhlIHNjcmVlbiB0byBwbGF5IHRoaXMgYWN0b3JcclxuICogICAgIFwic2l6ZVwiOiBbIHcsIGggXSwgLy8gcHJvdmlkZSB0aGlzIGlmIHlvdSBkbyBub3QgcHJvdmlkZSBhbiBpbWFnZS5cclxuICogICAgIFwidGV4dFwiOiBcIk1hbmR5XCIsIC8vIHdoYXQgdG8gcHV0IGluIGEgdGV4dCBidWJibGUgZHVyaW5nIG1vdXNlIG92ZXIuXHJcbiAqICAgICBcImF1ZGlvXCI6IFwiNnRoXzAxXCIsIC8vIG9wdGlvbmFsIGF1ZGlvIHRvIHNwZWFrIG9uIG1vdXNlIG92ZXIuXHJcbiAqICAgICBcImtleVwiOiBcIm1hbmR5XCIsIC8vIG9wdGlvbmFsIGF1ZGlvIGtleSwgaWYgbm90IHByZXNlbnQsIG5hbWUgd2lsbCBiZSB1c2VkLlxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcImNoYXJhY3Rlcl8yXCIsIC8vIGlmIHlvdSBjbGljayB0aGlzIGNoYXJhY3RlciwgdGhlIHZhcmlhYmxlICdjaGFyYWN0ZXJfMicgd2lsbCBiZSBzZXQgdG8gJ21hbmR5Jy5cclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICpcclxuICogfVxyXG4gKlxyXG4gKiAgSWYgeW91IHNldCBzcGVlY2hBbmltYXRpb24gdG8gdHJ1ZSwgLXRhbGsgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgY2hhcmFjdGVycyBpbWFnZSBuYW1lLlxyXG4gKiBzcGVlY2hBbmltYXRpb24vc3BlZWNoTG9jYXRpb24gYXJlIG9wdGlvbmFsLlxyXG4gKlxyXG4gKiBTZWUgYWxzbyB0aGVtZS5qc29uJ3Mgc3BlZWNoQW5pbWF0aW9ucywgd2hpY2ggc3BlY2lmeSBzcGVha2luZy1hbmltYXRpb24gaW1hZ2VzIGFuZCBsb2NhdGlvbiBvZmZzZXRzOlxyXG4gKlxyXG4gKiAgIFwic3BlZWNoQW5pbWF0aW9uc1wiOiB7XHJcbiAqICAgIFwiamFuZWxsZVwiOiB7XHJcbiAqICAgICAgXCJpbWFnZXNcIjogW1widGFsa2luZy1qYW5lbGxlLW1vdXRoMS5wbmdcIiwgXCJ0YWxraW5nLWphbmVsbGUtbW91dGgxLnBuZ1wiLCBcInRhbGtpbmctamFuZWxsZS1tb3V0aDIucG5nXCJdLFxyXG4gKiAgICAgIFwibW91dGhPZmZzZXRcIjogWzY1LCAxNjVdICAgLy8gd2hlcmUgd2l0aGluIHRoZSBhY3RvciBcIi10YWxrXCIgaW1hZ2UgdG8gcGxhY2UgdGhlIGFuaW1hdGlvblxyXG4gKiAgICB9XHJcbiAqXHJcbiAqICBZb3VyIHRoZW1lIHNob3VsZCBoYXZlIGEgJ2J1YmJsZVRleHRXaWR0aCcgZW50cnkgdG8gc3BlY2lmeSBob3cgd2lkZSB0byBtYWtlIHRoZSB0ZXh0IGJ1YmJsZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgICB2YXIgQ2hhcmFjdGVyQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGV4dEJveCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuc3BlZWNoQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTcGVlY2hBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VJZCA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKTtcclxuICAgICAgICAgICAgaWYoIGltYWdlSWQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnNwZWVjaEFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlSWQgKz0gXCItdGFsa1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW1hZ2UoaW1hZ2VJZCwgJ2FjdG9ySW1hZ2VzJykpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnNjYWxlLnNldFRvKCB0aGlzLmRhdGEuc2NhbGVbMF0sIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLndpZHRoID0gdGhpcy5kYXRhLnNpemVbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5oZWlnaHQgPSB0aGlzLmRhdGEuc2l6ZVsxXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRGVidWdCb3goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5ldmVudHMub25JbnB1dE92ZXIuYWRkKCB0aGlzLm9uTW91c2VJbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5ldmVudHMub25JbnB1dE91dC5hZGQoIHRoaXMub25Nb3VzZU91dCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZXZlbnRzLm9uSW5wdXRVcC5hZGQoIHRoaXMub25Qb2ludGVyVXAsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLnRleHQgfHwgdGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IENQVS9leHBlbnNpdmUgdGhpbmdzIHlvdSBjYW4gZG8gaW4gcGhhc2VyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRGVidWdCb3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggd2luZG93LmlzRGVidWdnaW5nICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveCA9IG5ldyBQaGFzZXIuR3JhcGhpY3ModGhpcy5nYW1lLCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmJlZ2luRmlsbCgweDAwMDAwMCwgMS4wKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZHJhd1JlY3QoMCwgMCwgdGhpcy5kYXRhLnNpemVbMF0sIHRoaXMuZGF0YS5zaXplWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmRlYnVnQm94KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVGV4dEJveDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy50aGVtZS5idWJibGVUZXh0V2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJZb3UgbXVzdCBzcGVjaWZ5IGEgYnViYmxlVGV4dFdpZHRoIGluIHlvdXIgdGhlbWUgd2hlbiB1c2luZyBjaGFyYWN0ZXIgbGFiZWxzLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYm94WSA9IHRoaXMuc3ByaXRlLmhlaWdodCAvIDQsXHJcbiAgICAgICAgICAgICAgICBib3hYID0gdGhpcy5zcHJpdGUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgYm94V2lkdGggPSB0aGlzLnRoZW1lLmJ1YmJsZVRleHRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGZvbnQgPSB0aGlzLmdldEZvbnQoJ2J1YmJsZUljb24nKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsWCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXSArIGJveFgsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV0gKyBib3hZO1xyXG5cclxuICAgICAgICAgICAgZm9udC53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvbnQud29yZFdyYXBXaWR0aCA9IGJveFdpZHRoICogMC45O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBib3hXaWR0aCAvIDIsIDEwLCB0aGlzLmRhdGEudGV4dCwgZm9udCAgKTtcclxuICAgICAgICAgICAgdGV4dC5hbmNob3Iuc2V0VG8oIDAuNSwgMCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJveEhlaWdodCA9IHRleHQuaGVpZ2h0ICsgMTA7XHJcblxyXG4gICAgICAgICAgICAvLyBBQ1QtMzUzIElmIGl0IGlzIG92ZXJsYXBwaW5nIHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4sIGFkanVzdCB0aGUgbG9jYXRpb24uXHJcbiAgICAgICAgICAgIGlmKCBsYWJlbFggKyBib3hXaWR0aCArIDMgPiB0aGlzLmdhbWUud29ybGQud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbFggPSAodGhpcy5nYW1lLndvcmxkLndpZHRoIC0gYm94V2lkdGggLSAzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIGxhYmVsWSArIGJveEhlaWdodCArIDMgPiB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbFkgPSAodGhpcy5nYW1lLndvcmxkLmhlaWdodCAtIGJveEhlaWdodCAtIDMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIGxhYmVsWCwgbGFiZWxZKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoIDB4MDAwMDAwLCAxLjAgKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoIDMsIDMsIGJveFdpZHRoLCBib3hIZWlnaHQsIDkgKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKDB4ZmZmZmZmKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoMCwgMCwgYm94V2lkdGgsIGJveEhlaWdodCAsIDkpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWRkQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5ncmFwaGljcyk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU3BlZWNoQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFTcGVlY2hBbmltYXRpb24gPSB0aGlzLnRoZW1lLnNwZWVjaEFuaW1hdGlvbnNbdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSh0aGlzLmRhdGEuaW1hZ2UpXTtcclxuICAgICAgICAgICAgaWYoICFhU3BlZWNoQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiQ291bGQgbm90IGFkZCBzcGVlY2ggYW5pbWF0aW9uIGZvciBjaGFyYWN0ZXI6IFwiICsgdGhpcy5kYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU3BlZWNoIGFuaW1hdGlvbiBub3QgZm91bmQgZm9yIFwiICsgdGhpcy5kYXRhLmltYWdlICk7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJDaGVjayB0aGF0IHlvdSBoYXZlIGEgc3BlZWNoQW5pbWF0aW9ucyBzZWN0aW9uIGluIHlvdXIgdGhlbWUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubG9jYXRpb25bMF0gKyBhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvY2F0aW9uWzFdICsgYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uYW5pbWF0aW9ucy5hZGQoJ3RhbGsnLCBhU3BlZWNoQW5pbWF0aW9uLmltYWdlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uU2V0ID0gYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXM7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uRGVmYXVsdCA9IGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLnNjYWxlLnNldFRvKCB0aGlzLmRhdGEuc2NhbGVbMF0sIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi54ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgKGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0gKiB0aGlzLmRhdGEuc2NhbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzFdICogdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiAoc3BlZWNoKSB7XHJcbiAgICAgICAgICAgIHZhciBhdWRpbyA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoc3BlZWNoLmF1ZGlvKTtcclxuICAgICAgICAgICAgaWYoIHNwZWVjaC5rZXkgKSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpbyA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoc3BlZWNoLmtleSkgKyBcIl9cIiArIGF1ZGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiT24gZ2FtZSBzcGVlY2g6IFwiICsgYXVkaW8pO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gJiYgdGhpcy50aGVtZS5zb3VuZFN5bmNEYXRhICYmIHRoaXMudGhlbWUuc291bmRTeW5jRGF0YVthdWRpb10gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGFbYXVkaW9dO1xyXG4gICAgICAgICAgICAgICAgaWYoICEgdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gdGhpcy5nYW1lLnRpbWUuY3JlYXRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLmxvb3AoMTAwLCB0aGlzLmluY3JlbWVudFNwZWVjaCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmNyZW1lbnRTcGVlY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zb3VuZFN5bmNEYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25TZXRbdGhpcy5zb3VuZFN5bmNEYXRhW3RoaXMuc3BlZWNoSW5kZXhdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoU3RvcDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gJiYgdGhpcy5zb3VuZFN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlSW46IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZ3JhcGhpY3MgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLndvcmxkLmJyaW5nVG9Ub3AodGhpcy5ncmFwaGljcyk7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lU3BlZWNoKCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB0aGlzLmRhdGEudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdWRpb1wiOiB0aGlzLmRhdGEuYXVkaW8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCI6IHRoaXMuZGF0YS5rZXkgfHwgdGhpcy5kYXRhLm5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZ3JhcGhpY3MgJiYgdGhpcy5ncmFwaGljcy52aXNpYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSggdmFyU2V0ICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGVidWdCb3ggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhcmFjdGVyQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBjbGljay1hbmltYXRpb24gYWN0b3IuIFdpbGwgc3RhcnQgd2l0aCBhbiBpbWFnZSwgYW5kIHdoZW4gY2xpY2tlZDsgd2lsbCBhbmltYXRlIGFuZCB0aGVuIHNldCB0byBmaW5hbCBpbWFnZS5cclxuICogV2lsbCBnZW5lcmF0ZSBldmVudHMgZm9yIGVhY2hcclxuICpcclxuICogQ3JlYXRpbmcgYSBjbGljay1hbmltYXRpb24gYWN0b3IsIGEgc3RhcnRpbmcsIGFuaW1hdGlvbiBzZXQsIGFuZCBlbmRpbmcgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJjbGljay1hbmltYXRpb25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGJ1dHRvbiBzZWN0aW9uIG9mIHRoZSB0aGVtZS5cclxuICogICAgIFwia2V5XCI6IFwid2hhdGV2c1wiLCAvLyBvcHRpb25hbCBpbWFnZSBrZXlcclxuICogICAgIFwidGV4dHVyZUtleVwiOiBcImtleVwiLCAvLyBvcHRpb25hbCB0ZXh0IGtleSB0byBnZXQgYW5pbWF0aW9uIGZyb21cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcImF1ZGlvXCI6IFwiYXVkaW9cIiwgLy8gb3B0aW9uYWwgYXVkaW8gdG8gcGxheSBkdXJpbmcgYW5pbWF0aW9uLlxyXG4gKiAgICAgXCJzY2FsZVwiOiBbIHgsIHldLCAvLyBvcHRpb25hbCB4L3kgc2NhbGUuXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwieFwiIC8vIHZhcmlhYmxlIHRvIHNlbmQgb3V0IDJuZCBjbGljayBldmVudHMsIHdpbGwgYmUgbmFtZSArIFwiX3BsYXlpbmdcIiBhbmQgbmFtZSArIFwiX2ZpbmlzaGVkXCJcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBDbGlja0FuaW1hdGlvbkFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VzXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGV4dHVyZUtleSh0aGlzLmRhdGEpLCB0aGlzLmdldEltYWdlKCB0aGlzLmRhdGEuaW1hZ2VzLCB0aGlzLmRhdGEua2V5KVswXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBDUFUvZXhwZW5zaXZlIHRoaW5ncyB5b3UgY2FuIGRvIGluIHBoYXNlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0LnBpeGVsUGVyZmVjdE92ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmV2ZW50cy5vbklucHV0VXAuYWRkKCB0aGlzLm9uUG9pbnRlclVwLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2FuaW1hdGlvbicsIHRoaXMuZ2V0SW1hZ2UoIHRoaXMuZGF0YS5pbWFnZXMsIHRoaXMuZGF0YS5rZXkpICk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLm9uQ29tcGxldGUuYWRkKCB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFuY2hvclggPSAwLCBhbmNob3JZID0gMDtcclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmRhdGEubG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxLjA7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB0aGlzLmRhdGEuc2NhbGVbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHRoaXMuZGF0YS5zY2FsZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5zY2FsZVgsIHRoaXMuc2NhbGVZICk7XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hbmNob3IgKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gdGhpcy5kYXRhLmFuY2hvclswXTtcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSB0aGlzLmRhdGEuYW5jaG9yWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmNob3Iuc2V0VG8oIGFuY2hvclgsIGFuY2hvclkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0geDtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbiggICkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhciBzdWZmaXg7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzQW5pbWF0ZWQgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBcIl9maW5pc2hlZFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gXCJfcGxheWluZ1wiO1xyXG4gICAgICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSB0aGlzLmRhdGEubmFtZSArIFwiX3BsYXlpbmdcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuaW1hdGlvbnMucGxheShcImFuaW1hdGlvblwiLCAxMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYXVkaW8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggeyBhdWRpbzogdGhpcy5kYXRhLmF1ZGlvLCBrZXk6IG51bGx9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lICsgc3VmZml4O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbiggICkge1xyXG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGlja0FuaW1hdGlvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgZGVjb3JhdGlvbiBhY3Rvci4gSnVzdCBhbiBpbWFnZSBvbiB0aGUgc2NyZWVuLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGRlY29yYXRpb24gYWN0b3IsIGEgc2ltcGxlIGltYWdlOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwb3J0cmFpdDFcIiwgICAgIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImRlY29yYXRpb25cIiwgICAgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwicGhvbmVcIiwgICAgICAgIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGJ1dHRvbiBzZWN0aW9uIG9mIHRoZSB0aGVtZS5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsICAgICAgLy8gYW4gb3B0aW9uYWwga2V5IHRvIGxvb2sgdW5kZXIgZm9yIHRoZSBpbWFnZS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInNjYWxlXCI6IFsgeCwgeV0sICAgICAgICAvLyBvcHRpb25hbCB4L3kgc2NhbGUuXHJcbiAqICAgICBcImFuZ2xlXCI6IC0zMCwgICAgICAgICAgICAvLyBvcHRpb25hbCwgZGVncmVlcyBmcm9tIG5vcnRoICgtMTgwIHRvIDE4MClcclxuICogICAgIFwicm90YXRpb25cIjogMC41LCAgICAgICAgIC8vIG9wdGlvbmFsLCByYWRpYW5zIGluIHVuaXRzIG9mIFBJLiBUaGlzIG92ZXJyaWRlcyBhbmdsZSBpZiBib3RoIGFyZSBzZXQuXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcImFscGhhXCI6IDAuNSAvLyBvcHRpb25hbCBhbHBoYSB0cmFuc3BhcmVuY3lcclxuICogICAgIFwidHdlZW5cIjogW09iamVjdF0gLy8gb3B0aW9uYWwgdHJhbnNpdGlvbiBvYmplY3RcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBEZWNvcmF0aW9uQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRleHR1cmVLZXkodGhpcy5kYXRhKSwgdGhpcy5nZXRJbWFnZSggdGhpcy5kYXRhLmltYWdlLCB0aGlzLmRhdGEua2V5KSk7XHJcbiAgICAgICAgICAgIHZhciBhbmNob3JYID0gMCwgYW5jaG9yWSA9IDA7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdLFxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuc2NhbGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hbmNob3IgKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JYID0gdGhpcy5kYXRhLmFuY2hvclswXTtcclxuICAgICAgICAgICAgICAgIGFuY2hvclkgPSB0aGlzLmRhdGEuYW5jaG9yWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmNob3Iuc2V0VG8oIGFuY2hvclgsIGFuY2hvclkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0geDtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueSA9IHk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGF0YS5hbHBoYSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFscGhhID0gdGhpcy5kYXRhLmFscGhhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGF0YS5hbmdsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuZ2xlID0gdGhpcy5kYXRhLmFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGF0YS5yb3RhdGlvbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnJvdGF0aW9uID0gTWF0aC5QSSAqIHRoaXMuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS50d2VlbiApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0d2VlbkRhdGEgPSB0aGlzLmRhdGEudHdlZW47XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gdHdlZW5EYXRhLmRlbGF5ID8gdHdlZW5EYXRhLmRlbGF5IDogMDtcclxuICAgICAgICAgICAgICAgIHZhciBlYXNpbmcgPSAoIHR5cGVvZiB0d2VlbkRhdGEuZWFzaW5nICE9IFwidW5kZWZpbmVkXCIgKSA/IHR3ZWVuRGF0YS5lYXNpbmcgOiBcIkxpbmVhclwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCB0d2VlbkRhdGEubG9jYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZSkudG8oIHsgeDogdHdlZW5EYXRhLmxvY2F0aW9uWzBdLCB5OiB0d2VlbkRhdGEubG9jYXRpb25bMV0gIH0sIHR3ZWVuRGF0YS50aW1lLCBlYXNpbmcsIHRydWUsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCB0d2VlbkRhdGEuc2NhbGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZS5zY2FsZSkudG8oIHsgeDogdHdlZW5EYXRhLnNjYWxlWzBdLCB5OiB0d2VlbkRhdGEuc2NhbGVbMV0gIH0sIHR3ZWVuRGF0YS50aW1lLCBlYXNpbmcsIHRydWUsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEuYWxwaGEpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5zcHJpdGUpLnRvKCB7YWxwaGE6IHR3ZWVuRGF0YS5hbHBoYX0sIHR3ZWVuRGF0YS50aW1lLCBlYXNpbmcsIHRydWUsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEZWNvcmF0aW9uQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBkcmFnIGFjdG9yLiBBbiBpbWFnZSBvbiB0aGUgc2NyZWVuIHdpdGggb3B0aW9uYWwgdGV4dCB0aGF0IGNhbiBiZSBkcmFnZ2VkIGFyb3VuZC5cclxuICpcclxuICogQ3JlYXRpbmcgYSBkZWNvcmF0aW9uIGFjdG9yLCBhIHNpbXBsZSBpbWFnZTpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9ydHJhaXQxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImRyYWdcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiB7IFwibm9ybWFsXCIgOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGltYWdlcyBzZWN0aW9uIHRoZSB0aGVtZS5cclxuICogICAgICAgICAgICAgICAgIFwiZHJhZ2dpbmdcIiA6IFwicGhvbmVcIiwgLy8gb3B0aW9uYWwgaW1hZ2Ugd2hpbGUgZHJhZ2dpbmdcclxuICogICAgICAgICAgICAgICAgIFwib3ZlcmxhcFwiIDogXCJwaG9uZVwiLCAvLyBvcHRpb25hbCBpbWFnZSB3aGVuIG92ZXJsYXBwaW5nLlxyXG4gKiAgICAgXCJrZXlcIjogXCJzb21ldGhpbmdcIiwgLy8gYW4gb3B0aW9uYWwga2V5IHRvIGxvb2sgdW5kZXIgZm9yIHRoZSBpbWFnZShzKS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwic3RyaW5nXCIgLy8gbmFtZSBvZiB2YXJpYWJsZSB0byBiZSBzZXQgd2hlbiB0aGlzIGlzIGRyYWdnaW5nL2Ryb3BwZWQvZXRjLlxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgRHJhZ0FjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiaW1hZ2VzXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMuZ2V0SW1hZ2UoIHRoaXMuZ2V0RnJhbWUoKSwgdGhpcy5kYXRhLmtleSkpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUucGh5c2ljcy5lbmFibGUoc3ByaXRlLCBQaGFzZXIuUGh5c2ljcy5BUkNBREUpO1xyXG4gICAgICAgICAgICBzcHJpdGUuYm9keS5zZXRTaXplKCAxLCAxLCAgc3ByaXRlLndpZHRoLzIsIHNwcml0ZS5oZWlnaHQvMik7XHJcbiAgICAgICAgICAgIHNwcml0ZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzcHJpdGUuaW5wdXQucGl4ZWxQZXJmZWN0T3ZlciA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwcml0ZS5pbnB1dC5lbmFibGVEcmFnKHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICBzcHJpdGUuaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwcml0ZS5ldmVudHMub25EcmFnU3RvcC5hZGQodGhpcy5pdGVtRHJhZ1N0b3AsIHRoaXMpO1xyXG4gICAgICAgICAgICBzcHJpdGUuZXZlbnRzLm9uRHJhZ1N0YXJ0LmFkZCh0aGlzLml0ZW1EcmFnU3RhcnQsIHRoaXMpO1xyXG4gICAgICAgICAgICBzcHJpdGUub3JpZ0xvYyA9IFsgc3ByaXRlLngsIHNwcml0ZS55XTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9udE5hbWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IHRoaXMuc3ByaXRlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIHRleHRZID0gdGhpcy5zcHJpdGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IFswLjUsIDAuNV07XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnRleHREYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHREYXRhID0gdGhpcy5kYXRhLnRleHREYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9udE5hbWUgPSB0ZXh0RGF0YS5mb250O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwicXVlc3Rpb25UZXh0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCB0ZXh0RGF0YS50ZXh0WCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0WCA9IHRleHREYXRhLnRleHRYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIHRleHREYXRhLnRleHRZICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRZID0gdGV4dERhdGEudGV4dFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdGV4dERhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHRleHREYXRhLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0ZXh0WCwgdGV4dFksIHRleHREYXRhLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmFuY2hvci5zZXRUbyggYW5jaG9yWzBdLCBhbmNob3JbMV0gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFkZENoaWxkKHRoaXMudGV4dFNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJldHVyblRvSG9tZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXRlbURyYWdTdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlKCk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbXCJkcm9wcGVkXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG4gICAgICAgICAgICAvLyBJdCB3aWxsIGhhdmUgYmVlbiBkcm9wcGVkLCBhbmQgcG9zc2libHkgcmVtb3ZlZCBmcm9tIHNjZW5lLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnNwcml0ZS5vcmlnTG9jWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpdGVtRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoICkge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlKCk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbXCJkcmFnZ2luZ1wiXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh0ZW1wKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuYm9keS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmV2ZW50cy5vbkRyYWdTdG9wLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZXZlbnRzLm9uRHJhZ1N0YXJ0LnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRGcmFtZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgZnJhbWVOYW1lID0gdGhpcy5kYXRhLmltYWdlcy5ub3JtYWw7XHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT09IFwib3ZlcmxhcFwiICYmIHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcCApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCAodHlwZSA9PT0gXCJkcmFnZ2luZ1wiIHx8ICFmcmFtZU5hbWUpICYmIHRoaXMuZGF0YS5pbWFnZXMuZHJhZ2dpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZU5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVJbWFnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBmcmFtZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNPdmVybGFwcGluZyAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5nZXRGcmFtZShcIm92ZXJsYXBcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdGhpcy5pc0RyYWdnaW5nID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwiZHJhZ2dpbmdcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoXCJub3JtYWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuZnJhbWVOYW1lID0gdGhpcy5nZXRJbWFnZSggZnJhbWUsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5ib2R5LnNldFNpemUoIDEsIDEsICB0aGlzLnNwcml0ZS53aWR0aC8yLCB0aGlzLnNwcml0ZS5oZWlnaHQvMik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRCb2R5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlLmJvZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk92ZXJsYXBwaW5nOiBmdW5jdGlvbiggb3RoZXJBY3RvciApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNPdmVybGFwcGluZyA9PT0gb3RoZXJBY3RvciApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzT3ZlcmxhcHBpbmcgPSBvdGhlckFjdG9yO1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdG8gb3ZlcmxhcHBpbmcgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IERyYWdBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgWmFjayBCaWVybmF0XHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiA2LzI2LzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgYmxvY2tlciBhY3Rvci4gVGhpcyBhY3RvciBjYW4gYmUgdXNlZCB0byBibG9jayBpbnB1dCBldmVudHMgZnJvbSB0aGUgYWN0b3JzIGJlaGluZCBpdC5cclxuICpcclxuICogQ3JlYXRpbmcgYSBkcmF3IGFjdG9yOlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJkcmF3LWRlbW9cIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiZHJhd1wiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiZmllbGRMb2NhdGlvbnNcIjogW1s0MDAsIDMwMF0sIFs1MDAsIDMwMF1dLCAvLyBUaGUgdGFyZ2V0IGNvb3JkaW5hdGVzIGZvciBlYWNoIHNlbGVjdGFibGUgZmllbGRcclxuICogICAgIFwiZmllbGRTaXplXCI6IDUwLCAvLyB0aGUgcmFkaXVzIG9mIGVhY2ggYXJlYVxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcImRyYXdDaG9vc2VyXCIgLy8gVGhlIHZhcmlhYmxlIG5hbWUgZm9yIGRpc3BhdGNoZWQgZXZlbnRzXHJcbiAqIH1cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgIHZhciBEcmF3QWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5maWVsZFNpemUgfHwgIXRoaXMuZGF0YS5maWVsZExvY2F0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJSZXF1aXJlZCBmaWVsZCBzaXplIG9yIGZpZWxkIGxvY2F0aW9ucyBub3QgZm91bmRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJtZCA9IHRoaXMuZ2FtZS5tYWtlLmJpdG1hcERhdGEodGhpcy5nYW1lLndpZHRoLCB0aGlzLmdhbWUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5ibWQuYWRkVG9Xb3JsZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZERlYnVnQm94KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5pbnB1dC5vbkRvd24uYWRkKHRoaXMub25Nb3VzZURvd24sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQub25VcC5hZGQodGhpcy5vbk1vdXNlVXAsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJtZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJtZC5jdHguc3Ryb2tlU3R5bGUgPSBcIiMwMDU5OTZcIlxyXG4gICAgICAgICAgICB0aGlzLmJtZC5jdHgubGluZVdpZHRoID0gODtcclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4Lm1vdmVUbyhwb2ludGVyLngsIHBvaW50ZXIueSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQuYWRkTW92ZUNhbGxiYWNrKHRoaXMub25EcmF3LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRHJhdzogZnVuY3Rpb24ocG9pbnRlciwgeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoIDwgMTAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKFt4LCB5XSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJtZC5jdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmJtZC5jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUF2ZXJhZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5ibWQuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQuZGVsZXRlTW92ZUNhbGxiYWNrKHRoaXMub25EcmF3LCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGN1bGF0ZUF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoIDwgMjApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXZlWCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBhdmVZID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXZlWCArPSB0aGlzLnBvc2l0aW9uc1tpXVswXTtcclxuICAgICAgICAgICAgICAgIGF2ZVkgKz0gdGhpcy5wb3NpdGlvbnNbaV1bMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXZlWCAvPSB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGF2ZVkgLz0gdGhpcy5wb3NpdGlvbnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tUYXJnZXRzKGF2ZVgsIGF2ZVkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrVGFyZ2V0czogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuZGF0YS5maWVsZExvY2F0aW9ucztcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5kYXRhLmZpZWxkU2l6ZTtcclxuICAgICAgICAgICAgdmFyIGNob2ljZSA9IHRhcmdldHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IHJhbmdlICsgdGFyZ2V0c1tpXVsxXSAmJiBcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldWzFdIDwgeSAmJiBcclxuICAgICAgICAgICAgICAgICAgICB4IDwgMTAwICsgdGFyZ2V0c1tpXVswXSAmJiBcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldWzBdIDwgeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBjaG9pY2U7IC8vVGhpcyBuZWVkcyB0byBkZXRlcm1pbmUgd2hpY2ggdGhpbmcgd2FzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5hZGQoMTAsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Qm1kID0gdGhpcy5ibWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RCbWQuYWRkVG9Xb3JsZCgpOyBcclxuICAgICAgICAgICAgfSwgdGhpcylcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlYnVnQm94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHdpbmRvdy5pc0RlYnVnZ2luZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3ggPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRyYXdSZWN0KDAsIDAsIHRoaXMuZGF0YS5zaXplWzBdLCB0aGlzLmRhdGEuc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm1kICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5kZWJ1Z0JveCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3guZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5pbnB1dC5kZWxldGVNb3ZlQ2FsbGJhY2sodGhpcy5vbkRyYXcsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuaW5wdXQub25Eb3duLnJlbW92ZSh0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0Lm9uVXAucmVtb3ZlKHRoaXMub25Nb3VzZVVwLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmF3QWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBkcm9wIGFjdG9yLiBZb3UgY2FuIGRyb3AgZHJhZyBhY3RvcnMgb250byB0aGlzIG9uZSwgdHJpZ2dlcmluZyBpdCdzIHZhcmlhYmxlIGFuZCBvcHRpb25hbCBpbWFnZSBzdGFnZS5cclxuICpcclxuICogQ3JlYXRpbmcgYSBkZWNvcmF0aW9uIGFjdG9yLCBhIHNpbXBsZSBpbWFnZTpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9ydHJhaXQxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImRyb3BcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiB7IFwibm9ybWFsXCIgOiBcInBob25lXCIsIC8vIHRoZSBpbWFnZXMgdG8gdXNlIGZyb20gdGhlIGltYWdlcyBzZWN0aW9uIHRoZSB0aGVtZS5cclxuICogICAgICAgICAgICAgICAgIFwib3ZlcmxhcFwiIDogXCJwaG9uZVwiLCAvLyBvcHRpb25hbCBpbWFnZSB3aGVuIG92ZXJsYXBwaW5nLlxyXG4gKiAgICAgXCJrZXlcIjogXCJzb21ldGhpbmdcIiwgLy8gYW4gb3B0aW9uYWwga2V5IHRvIGxvb2sgdW5kZXIgZm9yIHRoZSBpbWFnZShzKS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcImJvZHlcIjogWyB3aWR0aCUsIGhlaWdodCUsIG9mZnNldHgsIG9mZnNldHkgXSwgLy8gb3B0aW9uYWwgYm9keS5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJzdHJpbmdcIiAvLyBuYW1lIG9mIHZhcmlhYmxlIHRvIGJlIHNldCB3aGVuIHRoaXMgaXMgZHJvcHBlZC9ldGMuXHJcbiAqIH1cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBEcm9wQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZXNcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZSggdGhpcy5kYXRhLmltYWdlcy5vdmVybGFwLCB0aGlzLmRhdGEua2V5KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5waHlzaWNzLmVuYWJsZShzcHJpdGUsIFBoYXNlci5QaHlzaWNzLkFSQ0FERSk7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gW3Nwcml0ZS53aWR0aCAqIDAuNiwgc3ByaXRlLmhlaWdodCAqIDAuNiwgIHNwcml0ZS53aWR0aCAqIDAuMiwgc3ByaXRlLmhlaWdodCAqIDAuMl07XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYm9keSApIHtcclxuICAgICAgICAgICAgICAgIGJvZHlbMF0gPSBzcHJpdGUud2lkdGggKiB0aGlzLmRhdGEuYm9keVswXTtcclxuICAgICAgICAgICAgICAgIGJvZHlbMV0gPSBzcHJpdGUuaGVpZ2h0ICogdGhpcy5kYXRhLmJvZHlbMV07XHJcbiAgICAgICAgICAgICAgICBib2R5WzJdID0gdGhpcy5kYXRhLmJvZHlbMl0gfHwgYm9keVsyXTtcclxuICAgICAgICAgICAgICAgIGJvZHlbM10gPSB0aGlzLmRhdGEuYm9keVszXSB8fCBib2R5WzNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNwcml0ZS5ib2R5LnNldFNpemUoIGJvZHlbMF0sIGJvZHlbMV0sIGJvZHlbMl0sIGJvZHlbM10gKTtcclxuICAgICAgICAgICAgc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgICAgIHNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9udE5hbWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IHRoaXMuc3ByaXRlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIHRleHRZID0gdGhpcy5zcHJpdGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IFswLjUsIDAuNV07XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnRleHREYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHREYXRhID0gdGhpcy5kYXRhLnRleHREYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9udE5hbWUgPSB0ZXh0RGF0YS5mb250O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwicXVlc3Rpb25UZXh0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCB0ZXh0RGF0YS50ZXh0WCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0WCA9IHRleHREYXRhLnRleHRYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIHRleHREYXRhLnRleHRZICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRZID0gdGV4dERhdGEudGV4dFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdGV4dERhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHRleHREYXRhLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0ZXh0WCwgdGV4dFksIHRleHREYXRhLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAodHlwZW9mICh0aGlzLnN0eWxlW1wibGluZVNwYWNpbmdcIl0pKSAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmxpbmVTcGFjaW5nID0gdGhpcy5zdHlsZVtcImxpbmVTcGFjaW5nXCJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMudGV4dFNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5hbmNob3Iuc2V0VG8oIGFuY2hvclswXSwgYW5jaG9yWzFdICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5hZGRDaGlsZCh0aGlzLnRleHRTcHJpdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRGcmFtZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgZnJhbWVOYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYoIHR5cGUgPT09IFwibm9ybWFsXCIgJiYgdGhpcy5kYXRhLmltYWdlcy5ub3JtYWwgKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLm5vcm1hbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwib3ZlcmxhcFwiICYmIHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcCApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMub3ZlcmxhcDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCAodHlwZSA9PT0gXCJkcmFnZ2luZ1wiIHx8ICFmcmFtZU5hbWUpICYmIHRoaXMuZGF0YS5pbWFnZXMuZHJhZ2dpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZU5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVJbWFnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzT3ZlcmxhcHBpbmcgIT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoXCJvdmVybGFwXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHRoaXMuaXNEcmFnZ2luZyA9PT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5nZXRGcmFtZShcImRyYWdnaW5nXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwibm9ybWFsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCBmcmFtZSAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZnJhbWVOYW1lID0gdGhpcy5nZXRJbWFnZShmcmFtZSwgdGhpcy5kYXRhLmtleSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEJvZHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGUuYm9keTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uT3ZlcmxhcHBpbmc6IGZ1bmN0aW9uKCBvdGhlckFjdG9yICkge1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNPdmVybGFwcGluZyA9PT0gb3RoZXJBY3RvciApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzT3ZlcmxhcHBpbmcgPSBvdGhlckFjdG9yO1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdG8gb3ZlcmxhcHBpbmcgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUmVjZWl2ZURyb3A6IGZ1bmN0aW9uKCBvdGhlckFjdG9yTmFtZSApIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJSZWNlaXZlZCBkcm9wPyBcIiArIG90aGVyQWN0b3JOYW1lKTtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7fTtcclxuICAgICAgICAgICAgdGVtcFt0aGlzLmRhdGEudmFyaWFibGVdID0gb3RoZXJBY3Rvck5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNPdmVybGFwcGluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5ib2R5LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcm9wQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFN5ZCBHcm9zY2xhdWRlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8yMy8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGZhZGVvdXQgYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgdG8gZmFkZSBvdXQgdGhlIHNjcmVlblxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIGJsb2NrZXIgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImFsZXJ0QmxvY2tlclwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJmYWRlb3V0XCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDAsIDAgXSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgWzAsMF07IHdoZXJlIG9uIHRoZSBzY3JlZW4gdG8gcGxheSB0aGlzIGFjdG9yXHJcbiAqICAgICBcInNpemVcIjogWyA4MDAsIDYwMCBdLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBbZ2FtZS53b3JsZC53aWR0aCxnYW1lLndvcmxkLmhlaWdodF0gaG93IGxhcmdlXHJcbiAqICAgICBcImNvbG9yXCIgOiBcIjB4MDAwMDAwXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrICgweDAwMDAwMClcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcImZhZGVQZXJpb2RcIjogMzAwMCwgLy8gIGhvdyBsb25nIHRvIGZhZGUgb3Zlci5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJ4XCIgLy8gdmFyaWFibGUgdG8gc2V0IHVwb24gY29tcGxldGlvbi5cclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgRmFkZW91dEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcImZhZGVQZXJpb2RcIiwgXCJ2YXJpYWJsZVwiXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJsb2NrZXJYID0gKHR5cGVvZiB0aGlzLmRhdGEubG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDAgOiB0aGlzLmRhdGEubG9jYXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyWSA9ICh0eXBlb2YgdGhpcy5kYXRhLmxvY2F0aW9uID09PSAndW5kZWZpbmVkJykgPyAwIDogdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlcldpZHRoID0gKHR5cGVvZiB0aGlzLmRhdGEuc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5nYW1lLndvcmxkLndpZHRoIDogdGhpcy5kYXRhLnNpemVbMF07XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VySGVpZ2h0ID0gKHR5cGVvZiB0aGlzLmRhdGEuc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5nYW1lLndvcmxkLmhlaWdodCA6IHRoaXMuZGF0YS5zaXplWzFdO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tlclRpbnQgPSAodHlwZW9mIHRoaXMuZGF0YS5ibG9ja2VyVGludCA9PT0gJ3VuZGVmaW5lZCcpID8gMHgwMDAwMDAgOiB0aGlzLmRhdGEuYmxvY2tlclRpbnQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoYmxvY2tlclRpbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KGJsb2NrZXJYLCBibG9ja2VyWSwgYmxvY2tlcldpZHRoLCBibG9ja2VySGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuZmFkZVBlcmlvZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5hbHBoYSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhZGVUd2VlbiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5ncmFwaGljcykudG8oe2FscGhhOiAxfSwgdGhpcy5kYXRhLmZhZGVQZXJpb2QsICdMaW5lYXInLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhZGVUd2Vlbi5vbkNvbXBsZXRlLmFkZCh0aGlzLm9uQ29tcGxldGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4uc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZmFkZVR3ZWVuICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlVHdlZW4gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRmFkZW91dEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBQYXVsIEtuZWxsXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAxMS8wMi8yMDE4XHJcbiAqIENvcHlyaWdodCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgYWN0b3IgdXNlcyB0aGUgcGhhc2VyLWlucHV0LmpzIGV4dGVuc2lvbiB0byBhZGQgYSB0ZXh0IGlucHV0IGZpZWxkIHRvIHRoZSBzY2VuZS5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwidGV4dElucHV0MVwiLCAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcImlucHV0LWZpZWxkXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJvcHRpb25zXCI6IHtwYWRkaW5nOiA4LCBib3JkZXJXaWR0aDogMSwgYm9yZGVyQ29sb3I6ICcjMDAwJ30gLy8gb3B0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIElucHV0RmllbGQsIHJlZmVyIHRvIHBoYXNlci1pbnB1dC5qcyBkb2NzIGZvciBmdWxsIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmFuZ2UtZ2FtZXMvcGhhc2VyLWlucHV0XHJcbiAqICB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgSW5wdXRGaWVsZEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuZGF0YS5sb2NhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5kYXRhLm9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gdGhpcy5nYW1lLmFkZC5pbnB1dEZpZWxkKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblswXSwgdGhpcy5sb2NhdGlvblsxXSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IElucHV0RmllbGRBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQW4gaW5zdHJ1Y3Rpb24gYnViYmxlLiBUaGlzIGlzIGEgc3BlY2lhbGl6ZWQgYWN0b3IgZm9yIHNob3dpbmcgbGFyZ2UgZm9udCB0ZXh0IHdpdGggbm8gc3BlZWNoIGluIGEgZml4ZWQgc2l6ZVxyXG4gKiBidWJibGUuIE5vcm1hbGx5IHVzZWQgZm9yIHRoZSBlbmQgb2YgYW4gYWN0aXZpdHkuXHJcbiAqXHJcbiAqICBDcmVhdGluZyBhbiBpbnN0cnVjdGlvbiBidWJibGUgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImVuZG9mYWN0aXZpdHlcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaW5zdHJ1Y3Rpb25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcInRleHRcIjogXCJQbGVhc2UgbW92ZSBvbiB0byBuZXh0IGFjdGl2aXR5XCIsIC8vIHRleHQgdG8gc2hvdy5cclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIG9wdGlvbmFsLCBkZWxheSBpbiB0aWNrcyBiZWZvcmUgYWRkaW5nIHRoZSBhY3RvciAodGhpbmsgb2YgYSB0aWNrIGFzIGEgbWlsbGlzZWNvbmQsIGRlZmluZWQgaW4gbWFpbi5qcylcclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgbWFyZ2luWCA9IDgsXHJcbiAgICAgICAgbWFyZ2luWSA9IDEyO1xyXG5cclxuICAgIHZhciBJbnN0cnVjdGlvbkJ1YmJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwidGV4dFwiLCBcImxvY2F0aW9uXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93KHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFdpbmRvdzogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzIHx8ICF0aGlzLnRoZW1lLnRleHRXaW5kb3dzLmluc3RydWN0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnN0cnVjdGlvbiBhY3RvciByZXF1aXJlcyB0ZXh0V2luZG93cyB0aGVtZSBlbnRyeSwgYW5kIGluc3RydWN0aW9uIGFyZWEgaW5zaWRlIGl0LlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLndpbmRvdyA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHgsIHksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0V2luZG93cy5pbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdtb3ZlT24nKTtcclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcFdpZHRoID0gdGhpcy53aW5kb3cud2lkdGggKiAwLjk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB0aGlzLndpbmRvdy53aWR0aCAvIDIsIHRoaXMud2luZG93LmhlaWdodC8yLCB0aGlzLnRleHQsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5hbmNob3Iuc2V0VG8oMC41LDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93LmFkZENoaWxkKHRoaXMuY3VycmVudFRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3cuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSW5zdHJ1Y3Rpb25CdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8xNy8yMDE3XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbGluZSBhY3Rvciwgd2hpY2ggd2lsbDpcclxuICogICAtIERyYXcgYSBsaW5lIG9uIHRoZSBzY3JlZW5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwic25pdGNoaW5nT3JUZWxsaW5nX2ZlZWRiYWNrXzAxXCIsIC8vIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGFjdG9yLlxyXG4gKiAgICAgXCJ0eXBlXCI6IFwibGluZVwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJzdGFydFwiOiBbIHgsIHkgXSwgLy8gb3IgXCJjZW50ZXJcIiBmb3IgZWl0aGVyIGZpZWxkLlxyXG4gKiAgICAgXCJlbmRcIjogWyB4LCB5IF0sIC8vIG9yIFwiY2VudGVyXCIgZm9yIGVpdGhlciBmaWVsZC5cclxuICogICAgIFwiY29sb3JcIjogXCJyZ2JhKDAsMCwwLDEpXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrXHJcbiAqICAgICBcIndpZHRoXCI6IFwiNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxXHJcbiAqICAgICBcImFscGhhXCI6IFwiMC41XCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIDEuMFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIExpbmVBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcInN0YXJ0XCIsIFwiZW5kXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZGF0YS5zdGFydDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSB0aGlzLmRhdGEuZW5kO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MgPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKCAwLDApO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSAweEZGMzMwMDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gMjA7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmNvbG9yICkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmRhdGEuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53aWR0aCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFscGhhICkge1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KHRoaXMuZGF0YS5hbHBoYSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKHdpZHRoLCBjb2xvciwgYWxwaGEpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyh0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8odGhpcy5lbmRMb2NbMF0sIHRoaXMuZW5kTG9jWzFdKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uKCBjaG9pY2UgKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFphY2sgQmllcm5hdFxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMjMvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBuby1pbnB1dC1jaGFyYWN0ZXIgYWN0b3IuIFRoaXMgYWN0b3IgY2Fubm90IGJlIGludGVyYWN0ZWQgd2l0aC4gSXQgc3BlYWtzIHdoZW4gaXQncyBhdWRpbyBiaXQgaXMgcGxheWVkLCBidXQgaXMgb3RoZXJ3aXNlIGEgZGVjb3JhdGlvbi5cclxuICogQ3JlYXRpbmcgYSBuby1pbnB1dC1jaGFyYWN0ZXIgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm1hbmR5XCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcImNoYXJhY3RlclwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwiaW1hZ2VcIjogXCJtYW5keVwiLCAvLyB0aGUgaW1hZ2UgdG8gdXNlIGZyb20gdGhlIHRoZW1lLlxyXG4gKiAgICAgXCJzcGVlY2hBbmltYXRpb25cIjogdHJ1ZXxmYWxzZSwgLy8gaWYgdGhlcmUgaXMgYSBzcGVlY2ggYW5pbWF0aW9uLlxyXG4gKiAgICAgXCJmcmFtZVJhdGVcIjogMjQgLy8gb3B0aW9uYWwgZnJhbWUgcmF0ZSBmb3IgdGhlIHNwZWVjaCBhbmltYXRpb24sIGRlZmF1bHRzIHRvIDEwLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDIwMCwgMjAwIF0sIC8vIHdoZXJlIG9uIHRoZSBzY3JlZW4gdG8gcGxheSB0aGlzIGFjdG9yXHJcbiAqICAgICBcInNpemVcIjogWyB3LCBoIF0sIC8vIHByb3ZpZGUgdGhpcyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgYW4gaW1hZ2UuXHJcbiAqICAgICBcImF1ZGlvXCI6IFwiNnRoXzAxXCIsIC8vIG9wdGlvbmFsIGF1ZGlvIHRvIHNwZWFrIG9uIG1vdXNlIG92ZXIuXHJcbiAqICAgICBcImtleVwiOiBcIm1hbmR5XCIsIC8vIG9wdGlvbmFsIGF1ZGlvIGtleSwgaWYgbm90IHByZXNlbnQsIG5hbWUgd2lsbCBiZSB1c2VkLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqICBJZiB5b3Ugc2V0IHNwZWVjaEFuaW1hdGlvbiB0byB0cnVlLCAtdGFsayB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjaGFyYWN0ZXJzIGltYWdlIG5hbWUuXHJcbiAqIHNwZWVjaEFuaW1hdGlvbi9zcGVlY2hMb2NhdGlvbiBhcmUgb3B0aW9uYWwuXHJcbiAqXHJcbiAqIFNlZSBhbHNvIHRoZW1lLmpzb24ncyBzcGVlY2hBbmltYXRpb25zLCB3aGljaCBzcGVjaWZ5IHNwZWFraW5nLWFuaW1hdGlvbiBpbWFnZXMgYW5kIGxvY2F0aW9uIG9mZnNldHM6XHJcbiAqXHJcbiAqICAgXCJzcGVlY2hBbmltYXRpb25zXCI6IHtcclxuICogICAgXCJqYW5lbGxlXCI6IHtcclxuICogICAgICBcImltYWdlc1wiOiBbXCJ0YWxraW5nLWphbmVsbGUtbW91dGgxLnBuZ1wiLCBcInRhbGtpbmctamFuZWxsZS1tb3V0aDEucG5nXCIsIFwidGFsa2luZy1qYW5lbGxlLW1vdXRoMi5wbmdcIl0sXHJcbiAqICAgICAgXCJtb3V0aE9mZnNldFwiOiBbNjUsIDE2NV0gICAvLyB3aGVyZSB3aXRoaW4gdGhlIGFjdG9yIFwiLXRhbGtcIiBpbWFnZSB0byBwbGFjZSB0aGUgYW5pbWF0aW9uXHJcbiAqICAgIH1cclxuICogXHJcbiAqIFRoZXJlIG11c3QgYWRkaXRpb25hbGx5IGJlIFwiU291bmQgU3luYyBEYXRhXCIsIGRlZmluaW5nIHdoaWNoIGltYWdlIHRvIHNob3cuLi5cclxuICpcclxuICogXCJzb3VuZFN5bmNEYXRhXCI6IHtcclxuICogICBcIjZ0aF8wMVwiOiBbXHJcbiAqICAgICAwLDEsMSwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMSwwLDEsMSwwLDAsMCwwLDEsMVxyXG4gKiAgIF0sIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqICBUaGUgMHMgYW5kIDFzIHJlcHJlc2VudCB3aGljaCBpbWFnZSwgYW5kIGNvdWxkIGJlIDAsMSwyLDMgZXRjIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gMi4gVGhlIGtleSBzaG91bGQgbWF0Y2hcclxuICogIHRoZSBcInNwZWVjaEF1ZGlvXCIgb2YgdGhpcyBhY3RvciBhcyB3ZWxsIGFzIHRoZSBhdWRpbyBiZWluZyBwbGF5ZWQuIFxyXG4gKiAgTk9URTogTW9zdCBvZiB0aGUgc3BlZWNoU3luY0RhdGEgZG9lcyBub3QgY29udGFpbiAnMSdzIGFuZCBsb29rcyBsaWtlIFswLDAsMiwzLDMsMywyLDAsMiwzLDIsMCwwLDAsMiwzLDQsNCwzLDQsMiwwXS5cclxuICogIEluIHRoaXMgY2FzZSBpdCBpcyBhZHZpc2VkIHRvIHVzZSB0aGUgW0EsIEIsIEIsIEMsIERdIHBhdHRlcm4gZm9yIHRoZSBkaWZmZXJlbnQgZnJhbWVzIGluIHlvdXIgdGhlbWUuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICAgdmFyIE5vSW5wdXRDaGFyYWN0ZXJBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGlzIG5vdyBpbiBiYXNlIGNsYXNzIVxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zcGVlY2hBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNwZWVjaEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUlkID0gdGhpcy5kYXRhLmltYWdlO1xyXG4gICAgICAgICAgICBpZiggaW1hZ2VJZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUodGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKGltYWdlSWQsICdhY3RvckltYWdlcycpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS53aWR0aCA9IHRoaXMuZGF0YS5zaXplWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERlYnVnQm94KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlYnVnQm94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHdpbmRvdy5pc0RlYnVnZ2luZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdCb3ggPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0JveC5iZWdpbkZpbGwoMHgwMDAwMDAsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRyYXdSZWN0KDAsIDAsIHRoaXMuZGF0YS5zaXplWzBdLCB0aGlzLmRhdGEuc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5kZWJ1Z0JveCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFNwZWVjaEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhU3BlZWNoQW5pbWF0aW9uID0gdGhpcy50aGVtZS5zcGVlY2hBbmltYXRpb25zW3RoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUodGhpcy5kYXRhLmltYWdlKV07XHJcbiAgICAgICAgICAgIGlmKCAhYVNwZWVjaEFuaW1hdGlvbiApIHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkNvdWxkIG5vdCBhZGQgc3BlZWNoIGFuaW1hdGlvbiBmb3IgY2hhcmFjdGVyOiBcIiArIHRoaXMuZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIlNwZWVjaCBhbmltYXRpb24gbm90IGZvdW5kIGZvciBcIiArIHRoaXMuZGF0YS5pbWFnZSApO1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiQ2hlY2sgdGhhdCB5b3UgaGF2ZSBhIHNwZWVjaEFuaW1hdGlvbnMgc2VjdGlvbiBpbiB5b3VyIHRoZW1lLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICBhU3BlZWNoQW5pbWF0aW9uLmltYWdlc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLmFuaW1hdGlvbnMuYWRkKCd0YWxrJywgYVNwZWVjaEFuaW1hdGlvbi5pbWFnZXMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvblNldCA9IGFTcGVlY2hBbmltYXRpb24uaW1hZ2VzO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbkRlZmF1bHQgPSBhU3BlZWNoQW5pbWF0aW9uLmltYWdlc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5mbGlwTW91dGggJiYgdGhpcy5kYXRhLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdICogLTEsIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi54ID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdICsgKGFTcGVlY2hBbmltYXRpb24ubW91dGhPZmZzZXRbMF0gKiB0aGlzLmRhdGEuc2NhbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueSA9IHRoaXMuZGF0YS5sb2NhdGlvblsxXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzFdICogdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmRhdGEuc2NhbGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24ueCA9IHRoaXMuZGF0YS5sb2NhdGlvblswXSArIChhU3BlZWNoQW5pbWF0aW9uLm1vdXRoT2Zmc2V0WzBdICogdGhpcy5kYXRhLnNjYWxlWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoQW5pbWF0aW9uLnkgPSB0aGlzLmRhdGEubG9jYXRpb25bMV0gKyAoYVNwZWVjaEFuaW1hdGlvbi5tb3V0aE9mZnNldFsxXSAqIHRoaXMuZGF0YS5zY2FsZVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICB2YXIgYXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5hdWRpbyk7XHJcbiAgICAgICAgICAgIGlmKCBzcGVlY2gua2V5ICkge1xyXG4gICAgICAgICAgICAgICAgYXVkaW8gPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKHNwZWVjaC5rZXkpICsgXCJfXCIgKyBhdWRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2cud2FybihcIk9uIGdhbWUgc3BlZWNoOiBcIiArIGF1ZGlvKTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc3BlZWNoQW5pbWF0aW9uICYmIHRoaXMudGhlbWUuc291bmRTeW5jRGF0YSAmJiB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGFbYXVkaW9dICYmIHRoaXMuZGF0YS5zcGVlY2hBdWRpbyA9PT0gYXVkaW8gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSB0aGlzLnRoZW1lLnNvdW5kU3luY0RhdGFbYXVkaW9dO1xyXG4gICAgICAgICAgICAgICAgaWYoICEgdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRlJBTUVfUkFURSA9IHRoaXMuZGF0YS5mcmFtZVJhdGUgPyB0aGlzLmRhdGEuZnJhbWVSYXRlIDogMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHRoaXMuZ2FtZS50aW1lLmNyZWF0ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lci5sb29wKDEwMDAgLyBGUkFNRV9SQVRFLCB0aGlzLmluY3JlbWVudFNwZWVjaCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmNyZW1lbnRTcGVlY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zb3VuZFN5bmNEYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25TZXRbdGhpcy5zb3VuZFN5bmNEYXRhW3RoaXMuc3BlZWNoSW5kZXhdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoU3RvcDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gJiYgdGhpcy5zb3VuZFN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kU3luY0RhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hBbmltYXRpb24uZnJhbWVOYW1lID0gdGhpcy5zcGVlY2hBbmltYXRpb25EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLnNwcml0ZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5zcGVlY2hBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGVidWdCb3ggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnQm94LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy50aW1lciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTm9JbnB1dENoYXJhY3RlckFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBTeWQgR3Jvc2NsYXVkZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDgvMDUvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIHF1ZXN0aW9uIGFjdG9yLCB3aGljaCB3aWxsOlxyXG4gKiAgIC0gc2hvdyB0aGUgcGxheWVyIGEgKHNpbmdsZSBzZWxlY3Rpb24vcmFkaW8pIG11bHRpcGxlIGNob2ljZSBxdWVzdGlvblxyXG4gKiAgIC0gcGxheSBhbnkgYXVkaW8vdGV4dCBhc3NvY2lhdGVkIHdpdGggYXNraW5nIHF1ZXN0aW9uXHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uc19zbml0Y2hpbmdPclRlbGxpbmdfMDFcIiwgICAgICAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInF1ZXN0aW9uXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImZvbnRcIjogXCJxdWVzdGlvblRleHRcIixcclxuICogICAgIFwic3VibWl0QnV0dG9uSW1hZ2VcIjogXCJzdWJtaXRcIiwgICAgICAgICAgICAgICAgICAvLyBidXR0b24gaW1hZ2UgZnJvbSB0aGVtZS5idXR0b25zXHJcbiAqICAgICBcInN1Ym1pdEJ1dHRvbklEXCI6IFwic25pdE9yVGVsbFN1Ym1pdEJ1dHRvblwiLCAgICAgLy8gdG8gaWRlbnRpZnkgdGhlIHRleHQgZXZlbnQgY29taW5nIGZyb20gaXRcclxuICogICAgIFwic3VibWl0QnV0dG9uTG9jYXRpb25cIjogWyA1NDYsIDI1NSBdLFxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIDkwLCAzNSBdLFxyXG4gKiAgICAgXCJzdGFydFF1ZXN0aW9uXCI6IFwic25pdE9yVGVsbF9xdWVzdGlvbl8wMVwiLCAgICAgIC8vIHdoaWNoIGNob2ljZSB0byBzdGFydCB3aXRoIGZyb20gdGhlIGNob2ljZU1hcCBzZXQuXHJcbiAqICAgICBcImNob2ljZU1hcFwiOiB7XHJcbiAqICAgICAgIFwic25pdE9yVGVsbF9xdWVzdGlvbl8wMVwiOiB7IC8vIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhpcyBxdWVzdGlvbiwgdXNlZCB3aGVuIGxpbmtpbmcgcXVlc3Rpb25zXHJcbiAqICAgICAgICAgIFwidGV4dFwiOiAob3B0aW9uYWwpIFwiU2hhbmRyYSBzdHVtYmxlZCB1cG9uIHNvbWUgcHJldHR5IG5hc3R5IGNvbW1lbnRzIG9ubGluZSBhYm91dCBCcmlhbm5hLiBUaGV5IHdlcmUgY2FsbGluZyBoZXIgYSBzbHV0LCBhbW9uZyBvdGhlciB0aGluZ3MuIFNoYW5kcmEgZGVjaWRlcyB0byBtZW50aW9uIGl0IHRvIGhlciBtb20uW2JyXVticl1JcyB0aGlzIHNuaXRjaGluZyBvciB0ZWxsaW5nP1wiIC8vIHF1ZXN0aW9uXHJcbiAqICAgICAgICAgIFwiYXVkaW9cIjogKG9wdGlvbmFsKSBcInNuaXRjaGluZ09yVGVsbGluZ19xdWVzdGlvbl8wMVwiLCAvLyBhdWRpbyBrZXkuXHJcbiAqICAgICAgICAgIFwia2V5XCI6IChvcHRpb25hbCkgXCJtYW5keVwiLCAvLyBhIHByZWZpeCBmb3IgdGhlIGF1ZGlvIGtleS4gKGJlY29tZXMgXCJtYW5keV9zbml0Y2hpbmdPclRlbGxpbmdfcXVlc3Rpb25fMDFcIiBpbiB0aGlzIGV4YW1wbGUpXHJcbiAqICAgICAgICAgIFwiY2hvaWNlc1wiOiBbXHJcbiAqICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlNuaXRjaGluZ1wiLCAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXllZCB0ZXh0IG9mIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjogXCJzbml0T3JUZWxsX3F1ZXN0aW9uXzAxXCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJpbmNvcnJlY3RcIiAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIHNldCB2YXJpYWJsZSB0byB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRlbGxpbmdcIiwgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXllZCB0ZXh0IG9mIHRoaXMgY2hvaWNlLlxyXG4gKiAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjogXCJzbml0T3JUZWxsX3F1ZXN0aW9uXzAxXCIsIC8vIHZhcmlhYmxlIHRvIHNldCB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJjb3JyZWN0XCIgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIHNldCB2YXJpYWJsZSB0byB3aGVuIGNob3NlblxyXG4gKiAgICAgICAgICAgIH1cclxuICogICAgICAgICAgICAuLi4gLy8gYXMgbWFueSBjaG9pY2VzIGFzIHlvdSB3YW50LlxyXG4gKiAgICAgICAgIF1cclxuICogICAgICAgfSxcclxuICogICAgIH0sXHJcbiAqICAgICBcInN0YXJ0RGVsYXlcIjogMTAwMCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICB9XHJcbiAqXHJcbiAqICBGb3IgYSBkZWNpc2lvbiBwb2ludCwgeW91IGNhbiBzdGxsIGRvIGEgdmFyaWFibGUvdmFsdWUgYW5kIGxpbmsuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgUXVlc3Rpb25BY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChnYW1lLCBkYXRhLCB0aGVtZSkge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRGVjb3JhdGlvbiBhY3RvciByZXF1aXJlcyBnYW1lIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEZWNvcmF0aW9uIGFjdG9yIHJlcXVpcmVzIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkdhbWVDaG9pY2U6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcbiAgICAgICAgICAgICAgICBvbkdhbWVTcGVlY2g6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jaG9pY2VNYXAgPSB0aGlzLmRhdGEuY2hvaWNlTWFwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbk5hbWUgPSB0aGlzLmRhdGEuc3RhcnRRdWVzdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UXVlc3Rpb24gPSB0aGlzLmNob2ljZU1hcFt0aGlzLmN1cnJlbnRRdWVzdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmdpblkgPSA2O1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gdGhpcy5kYXRhLmZvbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmdldEZvbnQoKHR5cGVvZiBmb250TmFtZSAhPT0gJ3VuZGVmaW5lZCcpID8gZm9udE5hbWUgOiBcInF1ZXN0aW9uVGV4dFwiKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFjayB3aGVyZSB3ZSBhcmUgYXQgbW92aW5nIGRvd24gdGhlIHNjcmVlbi5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50WCA9ICh0aGlzLmxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblswXSA6IHRoaXMudGhlbWUuc25pdGNoaW5nT3JUZWxsaW5nbGVmdE1hcmdpbiAqIDM7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFkgPSAodGhpcy5sb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5sb2NhdGlvblsxXSA6IDM1O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgbnVtYmVyIG9mIHF1ZXN0aW9ucyBhbmQgYnVpbGQgdGhlIGNvcnJlY3QgY2hvaWNlIGxpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuZGV0ZXJtaW5lQ2hvaWNlTGlzdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNob2ljZXMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRldGVybWluZUNob2ljZUxpc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3VycmVudFF1ZXN0aW9uLnRleHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXN0aW9uVGV4dCA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmN1cnJlbnRYLCB0aGlzLmN1cnJlbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50WSArPSAodGhpcy5xdWVzdGlvblRleHQuaGVpZ2h0ICsgdGhpcy5tYXJnaW5ZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoICF0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2UgfHwgIXRoaXMuZGF0YS5zdWJtaXRCdXR0b25JRCB8fCAhdGhpcy5kYXRhLnN1Ym1pdEJ1dHRvbkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlF1ZXN0aW9uIEFjdG9yIHJlcXVpcmVzIHN1Ym1pdCBidXR0b24gY29uZmlndXJhdGlvbiBpbiBzY2VuZSBkYXRhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lLmJ1dHRvbnMgfHwgIXRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlF1ZXN0aW9uIEFjdG9yIHJlcXVpcmVzIGEgc3VibWl0IGJ1dHRvbiBlbnRyeSBpbiB0aGVtZVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEuc3VibWl0QnV0dG9uTG9jYXRpb25bMF0sIHRoaXMuZGF0YS5zdWJtaXRCdXR0b25Mb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5vblN1Ym1pdEJ1dHRvblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuc3VibWl0QnV0dG9uSW1hZ2VdLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJtaXRCdXR0b24uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3B1bGF0ZUNob2ljZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXN0aW9uID0gKHRoaXMuY3VycmVudFF1ZXN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgbGlzdCBvZiBvcHRpb25zLlxyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gdGhpcy5jdXJyZW50WSxcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbixcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uSW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNob2ljZXMgPSBxdWVzdGlvbi5jaG9pY2VzO1xyXG4gICAgICAgICAgICBfLmVhY2goY2hvaWNlcywgZnVuY3Rpb24gKGNob2ljZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uID0gdGhpcy5yYWRpb0dyb3VwLmNyZWF0ZSgwLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAudW5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyUmFkaW9CdXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbi5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMub25DaG9vc2VPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLmdyb3VwID0gdGhpcy5yYWRpb0dyb3VwO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnggPSB0aGlzLnRoZW1lLnNuaXRjaGluZ09yVGVsbGluZ2xlZnRNYXJnaW4gKiAzO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnkgPSB0aGlzLmN1cnJlbnRZICsgMjtcclxuICAgICAgICAgICAgICAgIGN1cnJSYWRpb0J1dHRvbi5mcmFtZU5hbWUgPSB0aGlzLnRoZW1lLmJ1dHRvbnMucmFkaW9CdXR0b25Hcm91cC51bnNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnZhcmlhYmxlID0gY2hvaWNlLnZhcmlhYmxlO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnZhbHVlID0gY2hvaWNlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY3VyclJhZGlvQnV0dG9uLnNjYWxlLnNldCgwLjc1ICwgMC43NSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgdGhpcy50aGVtZS5zbml0Y2hpbmdPclRlbGxpbmdsZWZ0TWFyZ2luICogNCwgMCxcclxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvVGV4dEdyb3VwLmFkZChjdXJyVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC55ID0gdGhpcy5jdXJyZW50WTtcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC5ldmVudHMub25JbnB1dERvd24uYWRkKHRoaXMub25DaG9vc2VPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY3VyclRleHQuZ3JvdXAgPSB0aGlzLnJhZGlvVGV4dEdyb3VwO1xyXG4gICAgICAgICAgICAgICAgY3VyclRleHQudmFyaWFibGUgPSBjaG9pY2UudmFyaWFibGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyVGV4dC52YWx1ZSA9IGNob2ljZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJUZXh0LnJhZGlvQnV0dG9uID0gY3VyclJhZGlvQnV0dG9uOyAvLyBsaW5rIHRoZSB0ZXh0IGFuZCByYWRpbyBidXR0b24gdG9nZXRoZXIuXHJcbiAgICAgICAgICAgICAgICBjdXJyUmFkaW9CdXR0b24ub3B0aW9uVGV4dCA9IGN1cnJUZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50WSArPSBjdXJyUmFkaW9CdXR0b24ub3B0aW9uVGV4dC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25JbmRleCsrO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCBxdWVzdGlvbi50ZXh0IHx8IHF1ZXN0aW9uLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogcXVlc3Rpb24udGV4dCwgXCJhdWRpb1wiOiBxdWVzdGlvbi5hdWRpbywgXCJrZXlcIjogcXVlc3Rpb24ua2V5fTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNob29zZU9wdGlvbjogZnVuY3Rpb24gKHNlbGVjdGVkSW5wdXQpIHtcclxuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBvdGhlciByYWRpbyBidXR0b25zLlxyXG4gICAgICAgICAgICBpZiggc2VsZWN0ZWRJbnB1dC5yYWRpb0J1dHRvbiApIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5wdXQucmFkaW9CdXR0b24uZ3JvdXAuc2V0QWxsKCdmcmFtZU5hbWUnLCB0aGlzLnRoZW1lLmJ1dHRvbnMucmFkaW9CdXR0b25Hcm91cC51bnNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5wdXQucmFkaW9CdXR0b24uZnJhbWVOYW1lID0gdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElucHV0Lmdyb3VwLnNldEFsbCgnZnJhbWVOYW1lJywgdGhpcy50aGVtZS5idXR0b25zLnJhZGlvQnV0dG9uR3JvdXAudW5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElucHV0LmZyYW1lTmFtZSA9IHRoaXMudGhlbWUuYnV0dG9ucy5yYWRpb0J1dHRvbkdyb3VwLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIHdoZXRoZXIgdGhlIHNlbGVjdGVkIGFuc3dlciBpcyBjb3JyZWN0LlxyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFtzZWxlY3RlZElucHV0LnZhcmlhYmxlXSA9IHNlbGVjdGVkSW5wdXQudmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3BvbnNlVmFsdWUgPSBzZWxlY3RlZElucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TdWJtaXRCdXR0b25Qb2ludGVyVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogdGhpcy5sYXN0UmVzcG9uc2VWYWx1ZSB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5mb3JFYWNoRXhpc3RzKGZ1bmN0aW9uIChyYWRpbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWRpby5vcHRpb25UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGlvLm9wdGlvblRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYWRpby5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5yYWRpb1RleHRHcm91cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAuZm9yRWFjaEV4aXN0cyhmdW5jdGlvbiAocmFkaW9UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvVGV4dC5yYWRpb0J1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpb1RleHQucmFkaW9CdXR0b24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYWRpb1RleHQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9UZXh0R3JvdXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zdWJtaXRCdXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnF1ZXN0aW9uVGV4dCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVlc3Rpb25UZXh0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2guZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUXVlc3Rpb25BY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOS8xOS8yMDE3XHJcbiAqIENvcHlyaWdodCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIHJlY3RhbmdsZSBhY3Rvciwgd2hpY2ggd2lsbDpcclxuICogICAtIERyYXcgYSByZWN0YW5nbGUgb24gdGhlIHNjcmVlbiwgd2l0aCBvcHRpb25hbCBib3JkZXIuXHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInNuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiLCAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInJlY3RhbmdsZVwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJzdGFydFwiOiBbIHgsIHkgXSxcclxuICogICAgIFwiY29sb3JcIjogXCJyZ2JhKDAsMCwwLDEpXCIsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGJsYWNrXHJcbiAqICAgICBcIndpZHRoXCI6IFwiNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxXHJcbiAqICAgICBcImhlaWdodFwiOiBcIjVcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgMVxyXG4gKiAgICAgXCJhbHBoYVwiOiBcIjAuNVwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAxLjBcclxuICogICAgIFwiYm9yZGVyXCIgOiBcIjFcIiwgLy8gb3B0aW9uYWwsIHRoaWNrbmVzcyBvZiBib3JkZXIgKG5vbmUgb2Ygbm90IHByb3ZpZGVkKVxyXG4gKiAgICAgXCJib3JkZXJDb2xvclwiOiBcInJiZ2EoMCwwLDAsMSlcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgYmxhY2tcclxuICogICAgIFwicm91bmRuZXNzXCI6IFwiMjhcIiwgLy8gZGVmYXVsdCAyOFxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiAgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFJlY3RhbmdsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnRcclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwic3RhcnRcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5kYXRhLnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmVuZExvYyA9IHRoaXMuZGF0YS5lbmQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcyA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoIDAsMCk7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IDB4RkYzMzAwLCBib3JkZXJDb2xvciA9IDB4RkYzMzAwO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxO1xyXG4gICAgICAgICAgICB2YXIgcm91bmRuZXNzID0gMjg7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDQ0MCwgaGVpZ2h0ID0gMjAwO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuc3RhcnRMb2NbMF0sIHkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVjdGFuZ2xlID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5jb2xvciApIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5kYXRhLmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmJvcmRlckNvbG9yICkge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLmRhdGEuYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53aWR0aCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhlaWdodCApIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KHRoaXMuZGF0YS5oZWlnaHQsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5yb3VuZG5lc3MgKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZG5lc3MgPSBwYXJzZUludCh0aGlzLmRhdGEucm91bmRuZXNzLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYWxwaGEgKSB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQodGhpcy5kYXRhLmFscGhhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5ib3JkZXIgKSB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXIgPSBwYXJzZUludCh0aGlzLmRhdGEuYm9yZGVyLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKGNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcm91bmRuZXNzKTsgLy8gZHJhdyBhIHJvdW5kZWQgcmVjdCBtYXNrXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICBpZiggYm9yZGVyICYmIGJvcmRlciA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSggYm9yZGVyLCBib3JkZXJDb2xvciwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWxwaGEgPSBhbHBoYTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkdhbWVTcGVlY2g6IGZ1bmN0aW9uKCBjaG9pY2UgKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9jID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5lbmRMb2MgPSBudWxsO1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyYXBoaWNzKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgc3BlZWNoIGJ1YmJsZS4gSXQgZGlzcGxheXMgdGV4dCBhbmQgcmVxdWVzdHMgdGhhdCBhdWRpbyBiZSBwbGF5ZWQuIEEgc3BlZWNoIGJ1YmJsZSBjYW4gaGF2ZSBpdHMgb3duIHRleHQvYXVkaW9cclxuICogYW5kIGNhbiBhbHNvIGxpc3RlbiBmb3IgdGV4dC9hdWRpbyBldmVudHMgdG8gc2hvdy5cclxuICogVGhlIHNwZWVjaCBidWJibGUgd2lsbCBhZGp1c3QgaXRzIHNpemUgdG8gZml0IHRoZSBwcm92aWRlZC9zZXQgdGV4dC5cclxuICpcclxuICp7XHJcbiAqICAgIFwibmFtZVwiOiBcImNob2ljZUJ1YmJsZVwiLCAvLyBuYW1lLlxyXG4gKiAgICBcInR5cGVcIjogXCJzcGVlY2gtYnViYmxlXCIsXHJcbiAqICAgIFwidGV4dFwiOiBcIlwiLCAvLyB0ZXh0IHRvIHNob3cuXHJcbiAqICAgIFwiYXVkaW9cIjogXCJcIiwgLy8gYXVkaW8ga2V5IHRvIHBsYXkuXHJcbiAqICAgIFwiaGlkZGVuXCI6IHRydWUsIC8vIHNldCB0byB0cnVlIHRvIG9wdGlvbmFsbHkgaGlkZSB0aGUgYnViYmxlIGluaXRpYWxseSwgdXNlZCB3aGVuIGNoYXJhY3RlciBpc24ndCB0aGUgZmlyc3QgdG8gdGFsay5cclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBtYXJnaW5YID0gMTIsIG1hcmdpblkgPSAxMjtcclxuXHJcbiAgICB2YXIgU3BlZWNoQnViYmxlQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gTm8gcmVxdWlyZWQgZmllbGRzLlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmRhdGEudGV4dCB8fCBcIiBcIjtcclxuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IHRoaXMuZGF0YS5hdWRpbyB8fCBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IHRoaXMuZGF0YS5rZXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvdygyMDAsIDUwKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcGVlY2goKTtcclxuICAgICAgICAgICAgLy8gQUNULTM1MiBIaWRlIGVtcHR5IHNwZWVjaCBidWJibGVzLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhpZGRlbiB8fCAhdGhpcy50ZXh0IHx8IHRoaXMudGV4dCA9PT0gXCIgXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkV2luZG93OiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUudGV4dFdpbmRvd3MgfHwgIXRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkluc3RydWN0aW9uIGFjdG9yIHJlcXVpcmVzIHRleHRXaW5kb3dzIHRoZW1lIGVudHJ5LCBhbmQgc21hbGwgZGVmaW5pdGlvbiBpbnNpZGUgaXQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueCA9IHg7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLnkgPSB5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRvcFdpbmRvdyA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwudG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCdidWJibGVUZXh0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gdGhpcy5nZXRGb250KCdyZXBsYXlBdWRpbycpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mU3R5bGUud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcFdpZHRoID0gdG9wV2luZG93LndpZHRoICogMC44NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW5YLCBtYXJnaW5ZLCBcIiBcIiwgdGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5hZGQodGhpcy5jdXJyZW50VGV4dCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm90dG9tV2luZG93ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIDAgLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwuYm90dG9tKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IDMwIGJlY2F1c2UgdGhlIHRvcCBzcGVlY2ggYnViYmxlIGlzIDQwIHB4IHRhbGwuXHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVXaW5kb3cgPSBuZXcgUGhhc2VyLlRpbGVTcHJpdGUodGhpcy5nYW1lLCAwLCB0b3BXaW5kb3cuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgMzM4LCB0aGlzLmN1cnJlbnRUZXh0LmhlaWdodCAtIDMwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dFdpbmRvd3Muc21hbGwubWlkZGxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKG1pZGRsZVdpbmRvdyk7XHJcblxyXG4gICAgICAgICAgICBib3R0b21XaW5kb3cueSA9IHRvcFdpbmRvdy5oZWlnaHQgKyBtaWRkbGVXaW5kb3cuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gNS4gQWRkIGV2ZW50aW5nLlxyXG4gICAgICAgICAgICB0aGlzLndpbmRvd3MgPSB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFdpbmRvdyxcclxuICAgICAgICAgICAgICAgIG1pZGRsZTogbWlkZGxlV2luZG93LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBib3R0b21XaW5kb3dcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLndpbmRvd3MsIGZ1bmN0aW9uIChidWJibGUpIHtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0T3Zlci5hZGQodGhpcy5vbk1vdXNlSW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0T3V0LmFkZCh0aGlzLm9uTW91c2VPdXQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnViYmxlLmV2ZW50cy5vbklucHV0VXAuYWRkKHRoaXMub25Qb2ludGVyVXAsIHRoaXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCAoYm90dG9tV2luZG93LnggKyBib3R0b21XaW5kb3cud2lkdGggLSA0MCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgKHRvcFdpbmRvdy5oZWlnaHQgKyBib3R0b21XaW5kb3cuaGVpZ2h0ICsgbWlkZGxlV2luZG93LmhlaWdodCkgLyAyLCBcIlJlcGxheSBBdWRpb1wiLCB0aGlzLnJTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC5hbmNob3Iuc2V0VG8oMC41LDAuNSk7XHJcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwLmFkZCh0aGlzLnJlcGxheVRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAgPSB3aW5kb3dHcm91cDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueCAtPSB0b3BXaW5kb3cud2lkdGggLyAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gc3VidHJhY3QgMzAgYmVjYXVzZSB0aGUgdG9wIHNwZWVjaCBidWJibGUgaXMgNDAgcHggdGFsbC5cclxuICAgICAgICAgICAgdGhpcy53aW5kb3dzLm1pZGRsZS5oZWlnaHQgPSB0aGlzLmN1cnJlbnRUZXh0LmhlaWdodCAtIDMwO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd3MuYm90dG9tLnkgPSB0aGlzLndpbmRvd3MudG9wLmhlaWdodCArIHRoaXMud2luZG93cy5taWRkbGUuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Nb3VzZUluOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLnRoZW1lLnRpbnRzLmJ1YmJsZVRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQuc2V0U3R5bGUodGhpcy5mU3R5bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxheVRleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLmZpbGwgPSB0aGlzLmdldEZvbnQoJ2J1YmJsZVRleHQnKS5maWxsO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFN0eWxlKHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlUZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAge3RleHQ6IHRoaXMudGV4dCwgYXVkaW86IHRoaXMuYXVkaW8sIGtleTogdGhpcy5rZXl9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNwZWVjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy5nZXRUZXh0KHRoaXMudGV4dCwgdGhpcy5rZXkpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dC5zZXRUZXh0KCB0ZXh0ICk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCB7dGV4dDogdGV4dCwgYXVkaW86IHRoaXMuYXVkaW8sIGtleTogdGhpcy5rZXl9KTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24gKHNwZWVjaCkge1xyXG4gICAgICAgICAgICAvL2xvZy53YXJuKFwic3BlZWNoIGJ1YmJsZSByZWNlaXZlZFwiKTtcclxuICAgICAgICAgICAgLy9sb2cud2FybihzcGVlY2gpO1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSBzcGVlY2gudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5rZXkgPSBzcGVlY2gua2V5O1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvID0gc3BlZWNoLmF1ZGlvO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0LnNldFRleHQoIHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy5nZXRUZXh0KHRoaXMudGV4dCwgdGhpcy5rZXkpKSApO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICAvLyBBQ1QtMzUyIEhpZGUgZW1wdHkgc3BlZWNoIGJ1YmJsZXMsIGhlcmUsIHNob3cgaXQgaWYgdGhlcmUgaXMgdGV4dC5cclxuICAgICAgICAgICAgaWYoICB0aGlzLnRleHQgJiYgdGhpcy50ZXh0ICE9PSBcIiBcIiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5yU3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dzICkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMud2luZG93cywgZnVuY3Rpb24gKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTcGVlY2hCdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgSmVmZiBCbHVtZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMjQvMjAxN1xyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEEgc3BlZWNoIGJ1YmJsZSB0aGF0IG9ubHkgZGlzcGxheXMgdGV4dCBhbmQgYSBidWJibGUgYmVoaW5kIGl0LiBBbGxvd3MgZm9yIG1vdmFibGUgY2Fycm90LiBBdXRvIGFkanVzdHMgdG8gdGV4dCBzaXplLlxyXG4gKiBOT1RFOiBORUVEUyBERUZBVUxUIFBBUkFNRVRFUiBWQUxVRVMgQU5EL09SIFJFUVVJUkVNRU5UIENIRUNLSU5HIEFORCBFUlJPUiBIQU5ETElOR1xyXG4gKlxyXG4gKntcclxuICogICAgXCJuYW1lXCI6IFwiY2hvaWNlQnViYmxlXCIsIC8vIG5hbWUuXHJcbiAqICAgIFwidHlwZVwiOiBcInRleHQtYnViYmxlXCIsXHJcbiAqICAgIFwiY2Fycm90U2lkZVwiOiBcImJvdHRvbVwiLCAvLyBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIgLSBzaWRlIG9mIGJ1YmJsZSB0aGUgY2Fycm90IGlzIHRvIGJlIHBvc2l0aW9uZWRcclxuICogICAgXCJsb2NhdGlvblwiOiBbMCwwXSxcclxuICogICAgXCJjYXJyb3RQb3NpdGlvblwiOiAwLjUsIC8vIGxvY2F0aW9uLCBhcyBwZXJjZW50YWdlIG9mIGxlbmd0aCBvciB3aWR0aCBvZiBjYXJyb3RTaWRlXHJcbiAqICAgIFwiY2VudGVyRmlsbFwiOiBcIjB4ZmZmZmZmXCIsXHJcbiAqICAgIFwidGV4dFwiOiBcIlwiLCAvLyB0ZXh0IHRvIHNob3cuXHJcbiAqICAgIFwiYnViYmxlV2lkdGhcIjogMjAwLFxyXG4gKiAgICBcInRleHRQYWRkaW5nXCI6IDIwLCAvLyBQYWRkaW5nIGJldHdlZW4gYnViYmxlIGFuZCB0ZXh0XHJcbiAqICAgIFwiaGlkZGVuXCI6IHRydWUsIC8vIHNldCB0byB0cnVlIHRvIG9wdGlvbmFsbHkgaGlkZSB0aGUgYnViYmxlIGluaXRpYWxseSwgdXNlZCB3aGVuIGNoYXJhY3RlciBpc24ndCB0aGUgZmlyc3QgdG8gdGFsay5cclxuICogICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKn0sXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBtYXJnaW5YID0gMTIsIG1hcmdpblkgPSAxMjtcclxuXHJcbiAgICB2YXIgVGV4dEJ1YmJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107IC8vIE5vIHJlcXVpcmVkIGZpZWxkcy5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXJyb3RTaWRlID0gdGhpcy5kYXRhLmNhcnJvdFNpZGU7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY2Fycm90UG9zaXRpb24gPSB0aGlzLmRhdGEuY2Fycm90UG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRmlsbCA9IHRoaXMuZGF0YS5jZW50ZXJGaWxsO1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmRhdGEudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5idWJibGVXaWR0aCA9IHRoaXMuZGF0YS5idWJibGVXaWR0aFxyXG4gICAgICAgICAgICB0aGlzLnRleHRQYWRkaW5nID0gdGhpcy5kYXRhLnRleHRQYWRkaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGRlbiA9IHRoaXMuZGF0YS5oaWRkZW47XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWxheSA9IHRoaXMuZGF0YS5zdGFydERlbGF5O1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93KHRoaXMubG9jYXRpb25bMF0sIHRoaXMubG9jYXRpb25bMV0pO1xyXG4gICAgICAgICAgICAvL3RoaXMuc2V0U3BlZWNoKCk7XHJcbiAgICAgICAgICAgIC8vIEFDVC0zNTIgSGlkZSBlbXB0eSBzcGVlY2ggYnViYmxlcy5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5oaWRkZW4gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkV2luZG93OiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcyApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiSW5zdHJ1Y3Rpb24gYWN0b3IgcmVxdWlyZXMgdGV4dEJ1YmJsZUltYWdlcyB0aGVtZSBlbnRyeS5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC54ID0geDtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAueSA9IHk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYnViYmxlVG9wTGVmdCA9IHdpbmRvd0dyb3VwLmNyZWF0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3BMZWZ0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZVRvcCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3ApO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlVG9wUmlnaHQgPSB3aW5kb3dHcm91cC5jcmVhdGUoYnViYmxlVG9wTGVmdC53aWR0aCArIGJ1YmJsZVRvcC53aWR0aCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMudG9wUmlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlUmlnaHQgPSB3aW5kb3dHcm91cC5jcmVhdGUoYnViYmxlVG9wUmlnaHQueCwgYnViYmxlVG9wUmlnaHQuaGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5yaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVCb3R0b21SaWdodCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BSaWdodC54LCBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVSaWdodC5oZWlnaHQsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmJvdHRvbVJpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUJvdHRvbSA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3AueCwgYnViYmxlQm90dG9tUmlnaHQueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tKTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUJvdHRvbUxlZnQgPSB3aW5kb3dHcm91cC5jcmVhdGUoMCwgYnViYmxlQm90dG9tUmlnaHQueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVMZWZ0ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIGJ1YmJsZVRvcExlZnQuaGVpZ2h0LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5sZWZ0KTtcclxuICAgICAgICAgICAgdmFyIGJ1YmJsZUNlbnRlciA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoYnViYmxlVG9wTGVmdC53aWR0aCwgYnViYmxlVG9wTGVmdC5oZWlnaHQsIHdpbmRvd0dyb3VwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlID0gdGhpcy5nZXRGb250KCd0ZXh0QnViYmxlVGV4dCcpO1xyXG4gICAgICAgICAgICB0aGlzLmZTdHlsZS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZlN0eWxlLndvcmRXcmFwV2lkdGggPSB0aGlzLmJ1YmJsZVdpZHRoIC0gKHRoaXMudGV4dFBhZGRpbmcgKiAyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCB0aGlzLnRleHRQYWRkaW5nLCB0aGlzLnRleHRQYWRkaW5nLCB0aGlzLnRleHQsIHRoaXMuZlN0eWxlKTtcclxuICAgICAgICAgICAgd2luZG93R3JvdXAuYWRkKHRoaXMuY3VycmVudFRleHQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1YmJsZVRvcFdpZHRoID0gdGhpcy5idWJibGVXaWR0aCAtIGJ1YmJsZVRvcExlZnQud2lkdGggLSBidWJibGVUb3BSaWdodC53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHRvcHMgPSBNYXRoLmNlaWwoYnViYmxlVG9wV2lkdGggLyBidWJibGVUb3Aud2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgdG9wUmVtYWluZGVyID0gYnViYmxlVG9wV2lkdGggJSBidWJibGVUb3Aud2lkdGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG9wczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1RvcCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoICsgKGkgKiBidWJibGVUb3Aud2lkdGgpLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy50b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRvcFJlbWFpbmRlciAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzVG9wLnggLT0gYnViYmxlVG9wLndpZHRoIC0gdG9wUmVtYWluZGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBidWJibGVUb3BSaWdodC54ID0gdGhpcy5idWJibGVXaWR0aCAtIGJ1YmJsZVRvcFJpZ2h0LndpZHRoO1xyXG4gICAgICAgICAgICBidWJibGVSaWdodC54ID0gYnViYmxlQm90dG9tUmlnaHQueCA9IGJ1YmJsZVRvcFJpZ2h0Lng7XHJcbiAgICAgICAgICAgIHZhciBidWJibGVSaWdodEhlaWdodCA9IHRoaXMuY3VycmVudFRleHQuaGVpZ2h0ICsgKDIgKiB0aGlzLnRleHRQYWRkaW5nKSAtIGJ1YmJsZVRvcC5oZWlnaHQgLSBidWJibGVCb3R0b20uaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRzID0gTWF0aC5jZWlsKGJ1YmJsZVJpZ2h0SGVpZ2h0IC8gYnViYmxlUmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0UmVtYWluZGVyID0gYnViYmxlUmlnaHRIZWlnaHQgJSBidWJibGVSaWdodC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByaWdodHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNSaWdodCA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BSaWdodC54LCBidWJibGVUb3BSaWdodC5oZWlnaHQgKyAoYnViYmxlUmlnaHQuaGVpZ2h0ICogaSksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLnJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihyaWdodFJlbWFpbmRlciAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzUmlnaHQueSAtPSBidWJibGVSaWdodC5oZWlnaHQgLSByaWdodFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUJvdHRvbVJpZ2h0LnkgPSBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVSaWdodEhlaWdodDtcclxuICAgICAgICAgICAgYnViYmxlQm90dG9tLnkgPSBidWJibGVCb3R0b21SaWdodC55O1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdG9wczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0JvdHRvbSA9IHdpbmRvd0dyb3VwLmNyZWF0ZShidWJibGVUb3BMZWZ0LndpZHRoICsgKGkgKiBidWJibGVUb3Aud2lkdGgpLCBidWJibGVCb3R0b20ueSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuYm90dG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0b3BSZW1haW5kZXIgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpc0JvdHRvbS54IC09IGJ1YmJsZVRvcC53aWR0aCAtIHRvcFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUJvdHRvbUxlZnQueSA9IGJ1YmJsZUJvdHRvbVJpZ2h0Lnk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByaWdodHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNMZWZ0ID0gd2luZG93R3JvdXAuY3JlYXRlKDAsIGJ1YmJsZVRvcFJpZ2h0LmhlaWdodCArIChidWJibGVSaWdodC5oZWlnaHQgKiBpKSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMubGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYocmlnaHRSZW1haW5kZXIgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpc0xlZnQueSAtPSBidWJibGVSaWdodC5oZWlnaHQgLSByaWdodFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNhcnJvdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLmNhcnJvdFNpZGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJvdCA9IHdpbmRvd0dyb3VwLmNyZWF0ZSh0aGlzLmJ1YmJsZVdpZHRoICogdGhpcy5jYXJyb3RQb3NpdGlvbiwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LnNjYWxlLnkgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QuYW5jaG9yLnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy5idWJibGVXaWR0aCAtIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5jYXJyb3RPdmVybGFwLCAoYnViYmxlUmlnaHRIZWlnaHQgKyBidWJibGVUb3BSaWdodC5oZWlnaHQgKyBidWJibGVCb3R0b21SaWdodC5oZWlnaHQpICogdGhpcy5jYXJyb3RQb3NpdGlvbiwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLnRleHRCdWJibGVJbWFnZXMuY2Fycm90KTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QuYW5jaG9yLnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LnJvdGF0aW9uID0gLTkwICogKE1hdGguUEkvMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy5idWJibGVXaWR0aCAqIHRoaXMuY2Fycm90UG9zaXRpb24sIGJ1YmJsZVJpZ2h0SGVpZ2h0ICsgYnViYmxlVG9wUmlnaHQuaGVpZ2h0ICsgYnViYmxlQm90dG9tUmlnaHQuaGVpZ2h0IC0gdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Fycm90LmFuY2hvci54ID0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3QgPSB3aW5kb3dHcm91cC5jcmVhdGUodGhpcy50aGVtZS50ZXh0QnViYmxlSW1hZ2VzLmNhcnJvdE92ZXJsYXAsIChidWJibGVSaWdodEhlaWdodCArIGJ1YmJsZVRvcFJpZ2h0LmhlaWdodCArIGJ1YmJsZUJvdHRvbVJpZ2h0LmhlaWdodCkgKiB0aGlzLmNhcnJvdFBvc2l0aW9uLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUudGV4dEJ1YmJsZUltYWdlcy5jYXJyb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJvdC5hbmNob3IueCA9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyb3Qucm90YXRpb24gPSA5MCAqIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUNlbnRlci5iZWdpbkZpbGwodGhpcy5jZW50ZXJGaWxsKTtcclxuICAgICAgICAgICAgYnViYmxlQ2VudGVyLmRyYXdSZWN0KDAsIDAsIGJ1YmJsZVRvcFdpZHRoLCBidWJibGVSaWdodEhlaWdodCk7XHJcbiAgICAgICAgICAgIGJ1YmJsZUNlbnRlci5lbmRGaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3dHcm91cC5icmluZ1RvVG9wKHRoaXMuY3VycmVudFRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gd2luZG93R3JvdXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuclN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgLyp0aGlzLmZTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dzICkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMud2luZG93cywgZnVuY3Rpb24gKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZS5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7Ki9cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy53aW5kb3dHcm91cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHRCdWJibGVBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgU3lkIEdyb3NjbGF1ZGVcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA4LzA3LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSB0ZXh0IGFjdG9yLCB3aGljaCB3aWxsOlxyXG4gKiAgIC0gc2hvdyB0aGUgc3BlY2lmaWVkIHRleHRcclxuICogICAtIHBsYXkgYW55IGF1ZGlvL3RleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZXh0XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInNuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiLCAgICAvLyB1bmlxdWUgbmFtZSBmb3IgdGhpcyBhY3Rvci5cclxuICogICAgIFwidHlwZVwiOiBcInRleHRcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiQ29ycmVjdC4gQ2xpY2sgdGhlIE5leHQgYnV0dG9uIHRvIGZpbmQgb3V0IHdoeS5cIlxyXG4gKiAgICAgXCJmb250XCI6IFwicXVlc3Rpb25UZXh0XCIsXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLCAgICAvLyBvciBcImNlbnRlclwiIGZvciBlaXRoZXIgZmllbGQuXHJcbiAqICAgICBcImFuZ2xlXCI6IC0zMCwgICAgICAgICAgICAvLyBvcHRpb25hbCwgZGVncmVlcyBmcm9tIG5vcnRoICgtMTgwIHRvIDE4MClcclxuICogICAgIFwicm90YXRpb25cIjogMC41LCAgICAgICAgIC8vIG9wdGlvbmFsLCByYWRpYW5zIGluIHVuaXRzIG9mIFBJLiBUaGlzIG92ZXJyaWRlcyBhbmdsZSBpZiBib3RoIGFyZSBzZXQuXHJcbiAqICAgICBcImFuY2hvclwiOiAob3B0aW9uYWwpIFwibGVmdFwiLCAgICAgLy8gd2hpY2ggc2lkZSB0byBhbmNob3IgdGhlIHRleHQgc3ByaXRlLiBDYW4gYWxzbyBzZXQgYW5jaG9yIHRvIHNwZWNpZmljIHBvc2l0aW9uIFt4LHldXHJcbiAqICAgICBcImF1ZGlvXCI6IChvcHRpb25hbCkgXCJzbml0Y2hpbmdPclRlbGxpbmdfZmVlZGJhY2tfMDFcIiwgICAgLy8gYXVkaW8ga2V5LlxyXG4gKiAgICAgXCJrZXlcIjogKG9wdGlvbmFsKSBcIm1hbmR5XCIsIC8vIGEgcHJlZml4IGZvciB0aGUgYXVkaW8ga2V5LiAoYmVjb21lcyBcIm1hbmR5X3NuaXRjaGluZ09yVGVsbGluZ19mZWVkYmFja18wMVwiIGluIHRoaXMgZXhhbXBsZSksXHJcbiAqICAgICBcIndvcmRXcmFwV2lkdGhcIjogIywgIC8vIG9wdGlvbmFsbHkgc2V0IGEgd3JhcHBpbmcgd2lkdGhcclxuICogICAgIFwiYnVsbGV0XCI6IHRydWUsXHJcbiAqICAgICBcImJ1bGxldE9mZnNldFwiOiAzLCAvLyBvcHRpb25hbCwgc3BhY2UgaW4gcGl4ZWxzIGFmdGVyIGJ1bGxldCBpZiB5b3Ugd2FudCBvdGhlciB0aGFuIGRlZmF1bHQgc3BhY2luZ1xyXG4gKiAgICAgXCJzaGFkb3dYXCI6IDUsIC8vIG9wdGlvbmFsLCBkcm9wIHNoYWRvdyB3aWR0aCBpbiBwaXhlbHM7IGRlZmF1bHQgaXMgbm8gc2hhZG93IC0gc2FtZSBhcyBzaGFkb3dZIGlmIG9ubHkgb25lIGlzIHNwZWNpZmllZCAtIDUgaWYgb25seSBjb2xvciBpcyBzcGVjaWZpZWRcclxuICogICAgIFwic2hhZG93WVwiOiA1LCAvLyBvcHRpb25hbCwgZHJvcCBzaGFkb3cgaGVpZ2h0IGluIHBpeGVsczsgZGVmYXVsdCBpcyBubyBzaGFkb3cgLSBzYW1lIGFzIHNoYWRvd1ggaWYgb25seSBvbmUgaXMgc3BlY2lmaWVkIC0gNSBpZiBvbmx5IGNvbG9yIGlzIHNwZWNpZmllZFxyXG4gKiAgICAgXCJzaGFkb3dDb2xvclwiOiBcInJnYmEoMCwwLDAsMSlcIiwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgYmxhY2sgd2l0aCBhbHBoYSAxLjBcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcInR3ZWVuXCI6IHsgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwsIHR3ZWVuIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRleHRcclxuICogICAgICAgXCJ0aW1lXCI6IDMwMCwgICAgICAgICAgICAgICAgICAvLyAocmVxdWlyZWQgZm9yIHR3ZWVuKSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cclxuICogICAgICAgXCJsb2NhdGlvblwiOiBbIDE5MCwgMTUwIF0sICAgICAvLyAocmVxdWlyZWQgZm9yIHR3ZWVuKSBsb2NhdGlvbiB0byB0d2VlbiB0bywgcmVxdWlyZWRcclxuICogICAgICAgXCJkZWxheVwiOiAxMDAwMCwgICAgICAgICAgICAgICAvLyAob3B0aW9uYWwgZm9yIHR3ZWVuKSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHR3ZWVuaW5nXHJcbiAqICAgICAgIFwieW95b1wiOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gKG9wdGlvbmFsIGZvciB0d2VlbikgcmV0dXJuIHRvIG9yaWdpbmFsIHBvc2l0aW9uIGFmdGVyIHR3ZWVuP1xyXG4gKiAgICAgICBcImFsaWduXCI6IFwibGVmdFwiICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwsIGFsaWduIHZhbHVlIHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgc3R5bGUgc2V0dGluZyBpbiB0aGUgdGhlbWUgKGFkZGVkIGJ5IEplZmYgQmx1bWUgMTIuMTcuMjAxOSlcclxuICogICAgIH1cclxuICogIH1cclxuICpcclxuICogIE5vdGUgdGhhdCB0aGlzIGFjdG9yIHJlY29nbml6ZXMgb3B0aW9uYWwgcHJvcGVydGllcyBpbiB0aGUgZm9udCBzdHlsZTpcclxuICpcclxuICogICAgICBcImxpbmVTcGFjaW5nXCIgKGEgbnVtYmVyIG9mIHBpeGVscyB0byBhZGQgdG8gdGhlIG5vcm1hbCB3cmFwcGVkIHRleHQgbGluZSBzcGFjaW5nKS4gRm9yIGV4YW1wbGUsIHRvIHJlZHVjZSBsaW5lIHNwYWNpbmcgYnkgMTUgcGl4ZWxzOlxyXG4gKlxyXG4gKiAgICAgICAgICBcImxlc3Nvbl9saWdodFwiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcIndvcmRXcmFwXCI6IHRydWUsIFwid29yZFdyYXBXaWR0aFwiOiAyMDAsIFwibGluZVNwYWNpbmdcIjogLTE1IH1cclxuICpcclxuICogICAgIFwiYWxwaGFcIiAob3BhY2l0eSwgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxKVxyXG4gKlxyXG4gKiAgICAgICAgICBcImxlc3Nvbl9saWdodFwiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcImFscGhhXCI6IDAuNSB9XHJcbiAqXHJcbiAqICAgICBcInNoYWRvd1hcIjogKGluY2x1ZGUgYSBkcm9wIHNoYWRvdyB3aXRoIHRoaXMgd2lkdGgsIGluIHBpeGVscykgVGhpcyB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgaW4gc2hhZG93WSBpZiBvbmx5XHJcbiAqICAgICAgICAgIG9uZSBpcyBzcGVjaWZpZWQsIG9yIHNldCB0byA1IHBpeGVscyBpZiBvbmx5IHNoYWRvd0NvbG9yIGlzIHNwZWNpZmllZC5cclxuICogICAgIFwic2hhZG93WVwiOiAoaW5jbHVkZSBhIGRyb3Agc2hhZG93IHdpdGggdGhpcyBoZWlnaHQsIGluIHBpeGVscykgVGhpcyB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgaW4gc2hhZG93WCBpZiBvbmx5XHJcbiAqICAgICAgICAgIG9uZSBpcyBzcGVjaWZpZWQsIG9yIHNldCB0byA1IHBpeGVscyBpZiBvbmx5IHNoYWRvd0NvbG9yIGlzIHNwZWNpZmllZC5cclxuICogICAgIFwic2hhZG93Q29sb3JcIjogKGluY2x1ZGUgYSBkcm9wIHNoYWRvdyB3aXRoIHRoaXMgY29sb3IgYW5kIGFscGhhIHZhbHVlKSBJZiBzaGFkb3dYIGFuZC9vciBzaGFkb3dZIGFyZSBzcGVjaWZpZWRcclxuICogICAgICAgICAgYnV0IHNoYWRvd0NvbG9yIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHQgaXMgYmxhY2sgd2l0aCBhbHBoYSAxLjBcclxuICogICAgIFwic2hhZG93Qmx1clwiOiAoZ2F1c3NpYW4gYmx1ciB0byBzb2Z0ZW4gc2hhZG93KSBvcHRpb25hbCwgQSBudW1iZXIgZnJvbSAwIChubyBibHVyKSB1cCB0byBhcHByb3hpbWF0ZWx5XHJcbiAqICAgICAgICAgIDEwIChkZXBlbmRpbmcgb24gc2NlbmUpLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGUsIHRvIHNwZWNpZnkgYW4gOC1waXhlbCB3aWRlIGFuZCAzLXBpeGVsIGhpZ2ggYmx1cnJlZCBkcm9wIHNoYWRvdyBpbiByZWQ6XHJcbiAqXHJcbiAqICAgICAgICAgIFwibGVzc29uX3JlZFNoYWRvd1wiOiB7IFwiZm9udFwiOiBcIjM1cHggZmxhc2hkbGlncmVndWxhclwiLCBcInNoYWRvd1hcIjogOCwgXCJzaGFkb3dZXCI6IDMsIFwic2hhZG93Q29sb3JcIjogXCJyZ2JhKDI1NSwwLDAsMSlcIiwgXCJzaGFkb3dCbHVyXCI6IDUgfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFRleHRBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50XHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImxvY2F0aW9uXCIsIFwiZm9udFwiLCBcInRleHRcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5kYXRhLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmRhdGEubG9jYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSB0aGlzLmRhdGEuYXVkaW87XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0gdGhpcy5kYXRhLmtleTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5mb250O1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5nZXRGb250KCh0eXBlb2YgZm9udE5hbWUgIT09ICd1bmRlZmluZWQnKSA/IGZvbnROYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLndvcmRXcmFwV2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLndvcmRXcmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUud29yZFdyYXBXaWR0aCA9IHBhcnNlSW50KHRoaXMuZGF0YS53b3JkV3JhcFdpZHRoLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5hbGlnbil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmFsaWduID0gdGhpcy5kYXRhLmFsaWduO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3Vic3RpdHV0ZVRleHQodGhpcy50ZXh0KTsgXHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMubG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLFxyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiggeCA9PT0gXCJjZW50ZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdhbWUud29ybGQuY2VudGVyWDtcclxuICAgICAgICAgICAgICAgIGFuY2hvclggPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB5ID09PSBcImNlbnRlclwiICkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgYW5jaG9yWCA9IDA7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YS5hbmNob3IgPT09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgICBhbmNob3JYID0gMC41O1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRhdGEuYW5jaG9yID09PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICBhbmNob3JYID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKCB0aGlzLmRhdGEuYW5jaG9yICkge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yWCA9IHRoaXMuZGF0YS5hbmNob3JbMF07XHJcbiAgICAgICAgICAgICAgICBhbmNob3JZID0gdGhpcy5kYXRhLmFuY2hvclsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idWxsZXRYID0geDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5idWxsZXQgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlQnVsbGV0T2Zmc2V0ID0gKCh0eXBlb2YgKHRoaXMuZGF0YS5idWxsZXRPZmZzZXQpKSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1bGxldFRleHQgPSB1c2VCdWxsZXRPZmZzZXQgPyBcIuKAolwiIDogXCLigKIgXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVsbGV0T2Zmc2V0V2lkdGggPSAwOyAvL2luaXRpYWxpemUgd2lkdGggZnJvbSBidWxsZXQgdG8gdGV4dFxyXG4gICAgICAgICAgICAgICAgaWYodXNlQnVsbGV0T2Zmc2V0KXtcclxuICAgICAgICAgICAgICAgICAgICBidWxsZXRPZmZzZXRXaWR0aCA9IHRoaXMuZGF0YS5idWxsZXRPZmZzZXQ7IC8vc2V0cyBidWxsZXRPZmZzZXQgZnJvbSB0aGVtZS5qc29uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRmFjdG9yID0gYW5jaG9yWDsgXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGFuY2hvclggPT09IDAuNSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZvciBjZW50ZXJlZCB0ZXh0IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUgPSB0aGlzLmdhbWUubWFrZS50ZXh0KHgsIHksIHRoaXMudGV4dCwgdGhpcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUgPSB0aGlzLmdhbWUubWFrZS50ZXh0KHgsIHksYnVsbGV0VGV4dCwgdGhpcy5zdHlsZSk7ICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50QWRqdXN0bWVudCA9ICgodGhpcy5idWxsZXRTcHJpdGUud2lkdGggKyBidWxsZXRPZmZzZXRXaWR0aCArIHRoaXMudGV4dFNwcml0ZS53aWR0aCkvMik7IC8vIGxlbmd0aCB0byBjZW50ZXJcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUgPSB0aGlzLmdhbWUuYWRkLnRleHQoeCAtIGFsaWdubWVudEFkanVzdG1lbnQsIHksIGJ1bGxldFRleHQsIHRoaXMuc3R5bGUpOyBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFRleHRYID0geCAtICh0aGlzLmJ1bGxldFNwcml0ZS5wb3NpdGlvbi54IC0gKHRoaXMuYnVsbGV0U3ByaXRlLndpZHRoIC8yKSk7IC8vIGdldCB4IHBvc2l0aW9uIG9mIHRleHRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuYnVsbGV0U3ByaXRlLmFkZENoaWxkKHRoaXMuZ2FtZS5tYWtlLnRleHQoY2FsY3VsYXRlZFRleHRYICwgeSAtIHRoaXMuYnVsbGV0WSwgdGhpcy50ZXh0LCB0aGlzLnN0eWxlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgbGVmdCBPUiByaWdodCBhbGlnbmVkIHRleHRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh4ICArIGJ1bGxldE9mZnNldFdpZHRoLCB5LCBidWxsZXRUZXh0LCB0aGlzLnN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcHJpdGUgPSB0aGlzLmJ1bGxldFNwcml0ZS5hZGRDaGlsZCh0aGlzLmdhbWUubWFrZS50ZXh0KHRoaXMuYnVsbGV0U3ByaXRlLndpZHRoLCB5IC0gdGhpcy5idWxsZXRZLCB0aGlzLnRleHQsIHRoaXMuc3R5bGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh4LCB5LCB0aGlzLnRleHQsIHRoaXMuc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRYID0geDtcclxuXHJcbiAgICAgICAgICAgIGlmICggKHR5cGVvZiAodGhpcy5zdHlsZS5saW5lU3BhY2luZykpICE9PSAndW5kZWZpbmVkJyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5saW5lU3BhY2luZyA9IHRoaXMuc3R5bGUubGluZVNwYWNpbmc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKHR5cGVvZiAodGhpcy5zdHlsZS5hbHBoYSkpICE9PSAndW5kZWZpbmVkJyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5hbHBoYSA9IHRoaXMuc3R5bGUuYWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNYID0gKCggdHlwZW9mICh0aGlzLnN0eWxlLnNoYWRvd1gpKSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgICAgICAgICAgIHZhciBoYXNZID0gKCggdHlwZW9mICh0aGlzLnN0eWxlLnNoYWRvd1kpKSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgICAgICAgICAgIHZhciBoYXNDb2xvciA9ICgoIHR5cGVvZiAodGhpcy5zdHlsZS5zaGFkb3dDb2xvcikpICE9PSB1bmRlZmluZWQgKTtcclxuICAgICAgICAgICAgdmFyIGhhc0JsdXIgPSAoKCB0eXBlb2YgKHRoaXMuc3R5bGUuc2hhZG93Qmx1cikpICE9PSB1bmRlZmluZWQgKTtcclxuICAgICAgICAgICAgaWYgKCBoYXNYIHx8IGhhc1kgfHwgaGFzQ29sb3IgfHwgaGFzQmx1ciApIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dYID0gNTtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dZID0gNTtcclxuICAgICAgICAgICAgICAgIGlmICggaGFzWCApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dYID0gdGhpcy5zdHlsZS5zaGFkb3dYO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhhc1kgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1kgPSBzaGFkb3dYO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggaGFzWSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dZID0gdGhpcy5zdHlsZS5zaGFkb3dZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhhc1ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1ggPSBzaGFkb3dZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwxKVwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNDb2xvciApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDb2xvciA9IHRoaXMuc3R5bGUuc2hhZG93Q29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93Qmx1ciA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGhhc0JsdXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Qmx1ciA9IHRoaXMuc3R5bGUuc2hhZG93Qmx1cjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5zZXRTaGFkb3coIHNoYWRvd1gsIHNoYWRvd1ksIHNoYWRvd0NvbG9yLCBzaGFkb3dCbHVyICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmFuY2hvci5zZXRUbyggYW5jaG9yWCwgYW5jaG9yWSApO1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zY2FsZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5zY2FsZS5zZXRUbyggdGhpcy5kYXRhLnNjYWxlWzBdLCB0aGlzLmRhdGEuc2NhbGVbMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJhdWRpb1wiOiB0aGlzLmF1ZGlvLCBcImtleVwiOiB0aGlzLmtleX07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRhdGEuYW5nbGUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWxsZXRTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5kYXRhLnJvdGF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVsbGV0U3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRTcHJpdGUucm90YXRpb24gPSBNYXRoLlBJICogdGhpcy5kYXRhLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLnJvdGF0aW9uID0gTWF0aC5QSSAqIHRoaXMuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudHdlZW4gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW5EYXRhID0gdGhpcy5kYXRhLnR3ZWVuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gdGhpcy50ZXh0WCAtIHRoaXMuYnVsbGV0WDtcclxuICAgICAgICAgICAgICAgIHZhciB5b3lvID0gKCB0eXBlb2YgdHdlZW5EYXRhLnlveW8gIT0gXCJ1bmRlZmluZWRcIiApID8gdHdlZW5EYXRhLnlveW8gOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxheSA9ICggdHlwZW9mIHR3ZWVuRGF0YS5kZWxheSAhPSBcInVuZGVmaW5lZFwiICkgPyB0d2VlbkRhdGEuZGVsYXkgOiAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9ICggdHlwZW9mIHR3ZWVuRGF0YS5lYXNpbmcgIT0gXCJ1bmRlZmluZWRcIiApID8gdHdlZW5EYXRhLmVhc2luZyA6IFwiTGluZWFyXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIHR3ZWVuRGF0YS5sb2NhdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhLmJ1bGxldCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLmJ1bGxldFNwcml0ZSkudG8oIHsgeDogdHdlZW5EYXRhLmxvY2F0aW9uWzBdLCB5OiB0d2VlbkRhdGEubG9jYXRpb25bMV0gIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEudGltZSwgZWFzaW5nLCB0cnVlLCBkZWxheSwgMCwgeW95byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlKS50byggeyB4OiAodHdlZW5EYXRhLmxvY2F0aW9uWzBdICsgdGV4dE9mZnNldCksIHk6IHR3ZWVuRGF0YS5sb2NhdGlvblsxXSAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgdHJ1ZSwgZGVsYXksIDAsIHlveW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiggdHdlZW5EYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlLnNjYWxlKS50byggeyB4OiB0d2VlbkRhdGEuc2NhbGVbMF0sIHk6IHR3ZWVuRGF0YS5zY2FsZVsxXSAgfSwgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgdHJ1ZSwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEuYWxwaGEpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy50ZXh0U3ByaXRlKS50byggeyBhbHBoYTogdHdlZW5EYXRhLmFscGhhIH0sIHR3ZWVuRGF0YS50aW1lLCBlYXNpbmcsIHRydWUsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiggY2hvaWNlICkge1xyXG4gICAgICAgICAgICBpZiggY2hvaWNlICYmIGNob2ljZS50ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLnNldFRleHQoY2hvaWNlLnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy50ZXh0U3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggdGhpcy5idWxsZXRTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bGxldFNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuYXVkaW8gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0geyBcImF1ZGlvXCI6IHRoaXMuYXVkaW8sIFwia2V5XCI6IHRoaXMua2V5LCBcInByaW9yaXR5XCI6IFwic3RvcFwifTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0QWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIERhdmlkIExlZVxyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDQvMDQvMjAxOFxyXG4gKiBDb3B5cmlnaHQgMjAxOCBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogXHJcbiAqIEEgdGltZWxpbmUgYWN0b3IgdGhhdCB1cGRhdGVzIGEgdmFyaWFibGUgYWZ0ZXIgYSBnaXZlbiBwZXJpb2QgKGluIG1zKSBoYXMgZWxhcHNlZC4gXHJcbiAqIFRoaXMgYWN0b3IgaGFzIG5vIHZpc2libGUgcmVuZGVyZWQgY29tcG9uZW50LlxyXG4gKiBJdCBkb2VzICpOT1QqIHJlbW92ZSBpdHNlbGYgb25jZSB0aGUgdmFyaWFibGUgaGFzIGJlZW4gc2V0OyB0aGlzIGlzIGxlZnQgdG8gdGhlIHNjcmlwdGVyIGlmIHRoYXQgYmVoYXZpb3IgaXMgZGVzaXJlZC5cclxuICogXHJcbiAqIENyZWF0aW5nIGEgVGltZWxpbmUgYWN0b3I6XHJcbiAqIHtcclxuICogICAgICBcIm5hbWVcIjogXCJldmVudDFcIiwgICAgICAgICAgICAgICAvLyBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYWN0b3JcclxuICogICAgICBcInR5cGVcIjogXCJ0aW1lbGluZVwiLCAgICAgICAgICAgICAvLyBSZXF1aXJlZCB0eXBlXHJcbiAqICAgICAgXCJwZXJpb2RcIjogMTAwMCwgICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiBtaWxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBcclxuICogICAgICBcInZhcmlhYmxlXCI6IFwidGltZWxpbmVfZXZlbnRcIiAgICAvLyBBZnRlciB0aGUgZ2l2ZW4gcGVyaW9kIGhhcyBlbGFwc2VkLCB1cGRhdGUgdGhpcyB2YXJpYWJsZSB3aXRoIHRoZSBuYW1lIG9mIHRoaXMgYWN0b3JcclxuICpcclxuICogICAgICBcInN0YXJ0RGVsYXlcIjogMCAgICAgICAgICAgICAgICAgLy8gSSAqU1RST05HTFkqIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nIHRoaXMgdmFsdWUsIGJ1dCBpZiB5b3UgZG8sIHJlbWVtYmVyIHRoZSBldmVudCB3aWxsIG5vdCBmaXJlIHVudGlsIHBlcmlvZCArIHN0YXJ0RGVsYXkgbXMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBhY3RvciB3YXMgYWRkZWQgdG8gdGhlIHNjZW5lLlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG5cclxuICAgIHZhciBUaW1lbGluZUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcblxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJwZXJpb2RcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEucGVyaW9kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRpbWVyIEFjdG9yIHJlcXVpcmVzIGEgcGVyaW9kIHRvIGJlIHNldFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRpbWVyIEFjdG9yIHJlcXVpcmVzIGEgdmFyaWFibGUgdG8gYmUgc2V0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhlcmUgbWF5IGJlIHNvbWUgdXNlIGZvciBwZXJpb2QgPT0gMCwgaW4gdGhlIHNhbWUgdmVpbiBhcyBzZXRUaW1lb3V0KGZuLCAwKSBzbyBJJ2xsIGFsbG93IGl0IGZvciBub3dcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5wZXJpb2QgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUaW1lciBBY3RvciByZXF1aXJlcyBwZXJpb2QgdG8gYmUgPj0gMFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpbWVyRXZlbnQgPSB0aGlzLmdhbWUudGltZS5ldmVudHMuYWRkKHRoaXMuZGF0YS5wZXJpb2QsIHRoaXMudGltZXJGaXJlZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW1lckZpcmVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS50aW1lLmV2ZW50cy5yZW1vdmUodGhpcy50aW1lckV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lQWN0b3I7XHJcbn0oKSk7IiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHRvZ2dsZSBidXR0b24gYWN0b3IuIFRoaXMgYWN0b3IgY2FuIGJlIHVzZWQgZm9yIHNpbXBsZSBhY3Rpb25zLCBzdWNoIGFzIG9wZW5pbmcgdGhlIGNlbGwgcGhvbmUsIGFuZCB3aWxsXHJcbiAqIHJlbWVtYmVyIGl0cyBpbnRlcm5hbCBzdGF0ZSBvZiBvbiBvciBvZmYuIEluIG1hbnkgJ3BsYXlzJywgdGhpcyBhY3RvcnMgaXNuJ3QgbmVlZGVkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHRvZ2dsZSBidXR0b24gYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm11dGUxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInRvZ2dsZS1idXR0b25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlc1wiOiB7XHJcbiAqICAgICAgXCJvblwiOiBcIm11dGVvblwiLFxyXG4gKiAgICAgIFwib2ZmXCI6IFwibXV0ZW9mZlwiXHJcbiAqICAgICB9LCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b24gc2VjdGlvbiBvZiB0aGUgdGhlbWUuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcIm11dGVfZ2FtZVwiLFxyXG4gKiAgICAgXCJ2YWx1ZXNcIjoge1xyXG4gKiAgICAgICAgICBcIm9uXCI6IFwibXV0ZV9vblwiLCAgLy8gdGhlIHZhbHVlIHVzZWQgaW5zdGVhZCBvZiB0aGUgbmFtZSB3aGVuIHRoZSB2YXJpYWJsZSBpcyBzZXQuXHJcbiAqICAgICAgICAgIFwib2ZmXCI6IFwibXV0ZV9vZmZcIlxyXG4gKiAgICAgfVxyXG4gKiAgICAgLy8gb3B0aW9uYWwgXCJzY2FsZVwiOiBbIDEuMSwgMS4xIF0gLy8gVXNlIG5lZ2F0aXZlIHNjYWxlcyB0byAnZmxpcCcgdGhlIGltYWdlcy5cclxuICogICAgIC8vIG9wdGlvbmFsOiBcImFjdGl2ZVwiOiB0cnVlL2ZhbHNlLCAvLyB3aWxsIGRlZmF1bHQgdG8gZmFsc2UuXHJcbiAqICAgICAvLyBvcHRpb25hbDogXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqIH1cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBUb2dnbGVBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiwgXCJpbWFnZXNcIiwgXCJ2YWx1ZXNcIiwgXCJ2YXJpYWJsZVwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFjdGl2ZSAmJiB0aGlzLmRhdGEuYWN0aXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSB1c2VyIGNvdWxkIHNldCBhY3RpdmUsIGNoZWNrIHRoZSBtb2RlbC4uLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnZhcmlhYmxlID09PSBcIm11dGVfZ2FtZVwiICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT24udmlzaWJsZSA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT2ZmLnZpc2libGUgPSAhdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMudGhlbWUuYnV0dG9ucyB8fCAhdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub2ZmXSB8fCAhdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub25dKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkJ1dHRvbiBBY3RvciByZXF1aXJlcyBidXR0b25zIGVudHJ5IGluIHRoZW1lLCB3aXRoIHNwZWNpZmljIGVudHJ5IG1hdGNoaW5nIGltYWdlcyBvZmYvb25cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5idXR0b25PZmYgPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vZmZdLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VzLm9mZl0ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub2ZmXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vZmZdLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uT24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5kYXRhLmxvY2F0aW9uWzBdLCB0aGlzLmRhdGEubG9jYXRpb25bMV0sIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vbl0ub3ZlciwgdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5pbWFnZXMub25dLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1t0aGlzLmRhdGEuaW1hZ2VzLm9uXS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnNbdGhpcy5kYXRhLmltYWdlcy5vbl0udXApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnNjYWxlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT24uc2NhbGUuc2V0VG8oIHRoaXMuZGF0YS5zY2FsZVswXSwgdGhpcy5kYXRhLnNjYWxlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5pc0FjdGl2ZSA/IHRoaXMuZGF0YS52YWx1ZXNbXCJvblwiXSA6IHRoaXMuZGF0YS52YWx1ZXNbXCJvZmZcIl07XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLnZpc2libGUgPSB0aGlzLmlzQWN0aXZlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbk9mZi52aXNpYmxlID0gIXRoaXMuaXNBY3RpdmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oICApIHtcclxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICF0aGlzLmlzQWN0aXZlO1xyXG4gICAgICAgICAgICB0aGlzLm9uQWN0aW9uKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJ1dHRvbk9mZiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT2ZmLmlucHV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25PZmYuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5idXR0b25PbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uT24uaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbk9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvZ2dsZUFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgaW52aXNpYmxlIGJ1dHRvbiB1cmwgYWN0b3IuIFBsYWNlIGl0IG92ZXIgdGV4dCB0byBwcm92aWRlIGh5cGVybGluay1saWtlIGZ1bmN0aW9uYWxpdHksIG9wZW5pbmdcclxuICogdGhlIHNwZWNpZmllZCBsaW5rIGluIGEgbmV3IHdpbmRvdyBvciB0YWIuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgdXJsLWJ1dHRvbi1pbnZpc2libGUgYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImhyZWYxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInVybEludmlzaWJsZVwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcIndpZHRoXCI6IHcsXHJcbiAqICAgICBcImhlaWdodFwiOiBoLFxyXG4gKiAgICAgXCJ1cmxcIjogXCJ3d3cuZ29vZ2xlLmNvbVwiLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInNob3dfdXJsXCIsIC8vIGlmIHlvdSBjbGljayB0aGUgYnV0dG9uLCB0aGUgdmFyaWFibGUgJ3Nob3dfdXJsJyB3aWxsIGJlIHNldCB0byAnaHJlZjEnLlxyXG4gKiAgICAgXCJzdGFydERlbGF5XCI6IDEwMDAgLy8gb3B0aW9uYWwsIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIFVybEJ1dHRvbkludmlzaWJsZUFjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaXMgaW4gcGFyZW50LlxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidXJsXCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oIHRoaXMuZGF0YS5sb2NhdGlvblswXSwgdGhpcy5kYXRhLmxvY2F0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b24ud2lkdGggPSB0aGlzLmRhdGEud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmhlaWdodCA9IHRoaXMuZGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmRhdGEudXJsLCBcIl9ibGFua1wiKTtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVXJsQnV0dG9uSW52aXNpYmxlQWN0b3I7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIFN5ZCBHcm9zY2xhdWRlXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwOC8yMC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHVybCBhY3Rvci4gVGhpcyBhY3RvciBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgYnV0dG9uOyB3aGVuIGNsaWNrZWQsIG9wZW4gYSB1cmwgaW4gYSBuZXcgd2luZG93L3RhYi5cclxuICpcclxuICogQ3JlYXRpbmcgYSB1cmwgYWN0b3I6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcImhyZWYxXCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcInVybC1idXR0b25cIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcImltYWdlXCI6IFwicmVzb3VyY2VJbWFnZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBidXR0b25zIHNlY3Rpb24gb2YgdGhlIHRoZW1lLlxyXG4gKiAgICAgXCJsb2NhdGlvblwiOiBbIHgsIHkgXSxcclxuICogICAgIFwidXJsXCI6IFwid3d3Lmdvb2dsZS5jb21cIixcclxuICogICAgIFwidmFyaWFibGVcIjogXCJzaG93X3VybFwiIC8vIGlmIHlvdSBjbGljayB0aGUgYnV0dG9uLCB0aGUgdmFyaWFibGUgJ3Nob3dfdXJsJyB3aWxsIGJlIHNldCB0byAnaHJlZjEnLlxyXG4gKiAgICAgLy8gb3B0aW9uYWwgXCJzY2FsZVwiOiBbIDEuMSwgMS4xIF0gLy8gVXNlIG5lZ2F0aXZlIHNjYWxlcyB0byAnZmxpcCcgdGhlIGltYWdlcy5cclxuICogICAgIC8vIG9wdGlvbmFsIFwic3RhcnREZWxheVwiOiAxMDAwIC8vIGRlbGF5IGluIHRpY2tzIGJlZm9yZSBhZGRpbmcgdGhlIGFjdG9yICh0aGluayBvZiBhIHRpY2sgYXMgYSBtaWxsaXNlY29uZCwgZGVmaW5lZCBpbiBtYWluLmpzKVxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cdHZhciBfID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuXHRcdEJ1dHRvbkFjdG9yID0gcmVxdWlyZShcIi4vYWN0b3ItYnV0dG9uXCIpO1xyXG5cclxuXHR2YXIgVXJsQnV0dG9uQWN0b3IgPSBCdXR0b25BY3Rvci5leHRlbmQoe1xyXG5cdFx0Z2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIG15UmVxdWlyZWQgPSBbXCJ1cmxcIl07XHJcblx0XHRcdHZhciBiYXNlUmVxdWlyZWQgPSB0aGlzLmJhc2UoKTtcclxuXHRcdFx0dmFyIGFsbFJlcXVpcmVkID1cclxuXHRcdFx0XHR0eXBlb2YgYmFzZVJlcXVpcmVkICE9IFwidW5kZWZpbmVkXCJcclxuXHRcdFx0XHRcdD8gYmFzZVJlcXVpcmVkLmNvbmNhdChteVJlcXVpcmVkKVxyXG5cdFx0XHRcdFx0OiBteVJlcXVpcmVkO1xyXG5cdFx0XHRyZXR1cm4gYWxsUmVxdWlyZWQ7XHJcblx0XHR9LFxyXG5cdFx0b25Qb2ludGVyVXA6IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHR3aW5kb3cub3Blbih0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIHRoaXMuZGF0YS51cmwsIFwiX2JsYW5rXCIpO1xyXG5cdFx0XHR0aGlzLmJhc2UoZXZlbnQpO1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBVcmxCdXR0b25BY3RvcjtcclxufSkoKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogQSBhIHZpZGVvIGFjdG9yIHVzaW4gV2lzdGlhLlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgIFwibmFtZVwiOiBcInZpZGVvMVwiLFxyXG4gKiAgICAgXCJ0eXBlXCI6IFwid2lzdGlhXCIsXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgMiwgNSBdLCAvLyBsb2NhdGlvbiBvbiBzY3JlZW4uXHJcbiAqICAgICBcInNpemVcIjogWyAzMDAsIDIwMCBdLFxyXG4gKiAgICAgXCJ2aWRlb1wiIDogXCJkdW4xZnV1MjUzXCIsXHJcbiAqICAgICBcImNsb3NlQnV0dG9uTG9jYXRpb25cIiA6IFsgNzAsIDQ0IF0sIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRvcCByaWdodCBvZiB2aWRlb1xyXG4gKiAgICAgXCJoaWRlQ2xvc2VCdXR0b25cIjogdHJ1ZSwgLy8gb3B0aW9uYWwsIHdpbGwgaGlkZSB0aGUgY2xvc2UgYnV0dG9uLlxyXG4gKiAgICAgXCJibG9ja2VyVGludFwiIDogXCIweDAwMDAwMFwiLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBibGFjayAoMHgwMDAwMDApXHJcbiAqICAgICBcImJsb2NrZXJBbHBoYVwiIDogMC41LCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyAwLjVcclxuICogICAgIFwiYmxvY2tJbnB1dFwiOiBmYWxzZSwgLy8gYmxvY2sgaW5wdXQgdW50aWwgdmlkZW8gaXMgZG9uZSwgb3B0aW9uYWxcclxuICogICAgIFwic3RhcnREZWxheVwiOiAxMDAwLCAvLyBvcHRpb25hbCwgZGVsYXkgaW4gdGlja3MgYmVmb3JlIGFkZGluZyB0aGUgYWN0b3IgKHRoaW5rIG9mIGEgdGljayBhcyBhIG1pbGxpc2Vjb25kLCBkZWZpbmVkIGluIG1haW4uanMpXHJcbiAqICAgICBcImF1dG9wbGF5XCI6IHRydWUsIC8vIG9wdGlvbmFsLiB3aWxsIGF1dG9tYXRpY2FsbHkgc3RhcnQgdGhlIHZpZGVvLlxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInN0cmluZ1wiLCAvLyBvcHRpb25hbCB2YXJpYWJsZS4gSWYgcHJlc2VudCwgd2lsbCBiZSBzZXQgdG8gc3RhcnRlZCBhbmQgZmluaXNoZWRcclxuICogICAgIFwibWFya2Vyc1wiOiBbIDUsIDE1LCAyMCBdIC8vIG9wdGlvbmFsLiBBdCBzcGVjaWZpZWQgbWFya2VycywgdmFyaWFibGUgd2lsbCBiZSBzZXQgdG8gbWFya2VyIHZhbHVlLlxyXG4gKiB9LFxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcblx0XHRsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIiksXHJcblx0XHRBY3RvciA9IHJlcXVpcmUoXCIuL2FjdG9yXCIpLFxyXG5cdFx0JCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XHJcblxyXG5cdHZhciBXaXN0aWFBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcblx0XHQvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcblx0XHRnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gW1wibG9jYXRpb25cIiwgXCJzaXplXCIsIFwidmlkZW9cIl07XHJcblx0XHR9LFxyXG5cdFx0ZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIVdpc3RpYSkge1xyXG5cdFx0XHRcdHRocm93IFwiV2lzdGlhIGFwcGVhcnMgdG8gYmUgbWlzc2luZywgY2Fubm90IGNyZWF0ZSB3aXN0aWEgYWN0b3IuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy52aWRlbyA9IHRoaXMuZGF0YS52aWRlbztcclxuXHRcdFx0dGhpcy5ibG9ja0lucHV0ID0gdGhpcy5kYXRhLmJsb2NrSW5wdXQgfHwgZmFsc2U7XHJcblx0XHRcdHRoaXMuZWxlbWVudCA9ICQodGhpcy5nYW1lLmNhbnZhcy5wYXJlbnRFbGVtZW50KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmJsb2NrSW5wdXQpIHtcclxuXHRcdFx0XHR0aGlzLmJsb2NraW5nU3ByaXRlID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG5cdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG5cdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRYID0gdGhpcy5kYXRhLmxvY2F0aW9uWzBdO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRZID0gdGhpcy5kYXRhLmxvY2F0aW9uWzFdO1xyXG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5kYXRhLnNpemVbMF07XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5kYXRhLnNpemVbMV07XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRYID09PSBcImNlbnRlclwiKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50WCA9IHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYIC0gdGhpcy53aWR0aCAvIDI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFkgPT09IFwiY2VudGVyXCIpIHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRZID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgLSB0aGlzLmhlaWdodCAvIDI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF8uYmluZEFsbCh0aGlzLCBcImFkZFdpbmRvd1wiKTtcclxuXHRcdFx0d2luZG93Lndpc3RpYUluaXQgPSB0aGlzLmFkZFdpbmRvdztcclxuXHRcdH0sXHJcblx0XHRhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gQmluZCB0aGVzZSwgb3RoZXJ3aXNlIFwidGhpc1wiIHdpbGwgYmUgbG9zdC4gV2lzdGlhIGRvZXNuJ3QgYWNjZXB0IGEgY29udGV4dCFcclxuXHRcdFx0Xy5iaW5kQWxsKHRoaXMsIFwib25XaXN0aWFFbmRcIik7XHJcblx0XHRcdF8uYmluZEFsbCh0aGlzLCBcIm9uV2lzdGlhUGxheVwiKTtcclxuXHRcdFx0dGhpcy53aXN0aWFFbWJlZC5iaW5kKFwicGxheVwiLCB0aGlzLm9uV2lzdGlhUGxheSk7XHJcblx0XHRcdHRoaXMud2lzdGlhRW1iZWQuYmluZChcImVuZFwiLCB0aGlzLm9uV2lzdGlhRW5kKTtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG5cdFx0XHRcdF8uYmluZEFsbCh0aGlzLCBcIm9uV2lzdGlhTWFya2VyXCIpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmRhdGEubWFya2VycyAmJiBfLmlzQXJyYXkodGhpcy5kYXRhLm1hcmtlcnMpKSB7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLmJpbmQoXCJzZWNvbmRjaGFuZ2VcIiwgdGhpcy5vbldpc3RpYU1hcmtlcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0b25HYW1lU3BlZWNoOiBmdW5jdGlvbiAoc3BlZWNoKSB7XHJcblx0XHRcdGlmIChzcGVlY2guYXVkaW8gJiYgc3BlZWNoLmF1ZGlvICE9PSB0aGlzLnZpZGVvKSB7XHJcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLndpc3RpYUVtYmVkICE9IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnBhdXNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYU11dGU6IGZ1bmN0aW9uIChpc011dGVkKSB7XHJcblx0XHRcdGxvZy53YXJuKFwiQ2FsbGVkIG9uV2lzdGlhTXV0ZTogXCIgKyBpc011dGVkKTtcclxuXHRcdFx0aWYgKGlzTXV0ZWQpIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnZvbHVtZSgwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnZvbHVtZSgxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uV2lzdGlhTWFya2VyOiBmdW5jdGlvbiAoc2Vjb25kcykge1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0dGhpcy5kYXRhLm1hcmtlcnMsXHJcblx0XHRcdFx0ZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0XHRcdFx0aWYgKHBhcnNlSW50KG1hcmtlciwgMTApID09PSBzZWNvbmRzKSB7XHJcblx0XHRcdFx0XHRcdHZhciB2YXJTZXQgPSB7fTtcclxuXHRcdFx0XHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBzZWNvbmRzO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGV4aXQgbG9vcC5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLnZhcmlhYmxlKSB7XHJcblx0XHRcdFx0dmFyIHZhclNldCA9IHt9O1xyXG5cdFx0XHRcdHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gXCJmaW5pc2hlZFwiO1xyXG5cdFx0XHRcdHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHZhclNldCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbldpc3RpYVBsYXk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5vbldpc3RpYU11dGUodGhpcy5nYW1lLnNvdW5kLm11dGUpO1xyXG5cdFx0XHR0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiB0aGlzLnZpZGVvLCBrZXk6IG51bGwgfSk7XHJcblx0XHRcdGlmICh0aGlzLmRhdGEudmFyaWFibGUpIHtcclxuXHRcdFx0XHR2YXIgdmFyU2V0ID0ge307XHJcblx0XHRcdFx0dmFyU2V0W3RoaXMuZGF0YS52YXJpYWJsZV0gPSBcInN0YXJ0ZWRcIjtcclxuXHRcdFx0XHR0aGlzLmRpc3BhdGNoR2FtZUNob2ljZSh2YXJTZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0YWRkV2luZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBUaGlzIHNob3VsZCBiZSBhIGhhbmRsZWJhcnMgdGVtcGxhdGUgYnV0IHdlJ3JlIGhhdmluZyBpbnRlcm5ldCB0cm91YmxlIHNvIGhlcmUgaXQgaXMuLi4gdGV4dC5cclxuXHRcdFx0ICogQHR5cGUge3N0cmluZ31cclxuXHRcdFx0ICovXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJ3aXN0aWEgYXBpIGxvYWRlZFwiKTtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC5cclxuXHJcblx0XHRcdFx0dmFyIHZpZGVvQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0XHRpZiAodGhpcy50aGVtZS5pbnRlcm5hbF9hdXRvU2NhbGUgPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBwcm9wZXJ0eSBpcyB0YWNrZWQgb250byB0aGUgdGhlbWUgYnkgcGxheS5qcyBpZiBzZXQgdG8gdHJ1ZSBpbiB0aGUgcGxheS5qc29uIHNldHRpbmdzLlxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXHJcblx0XHRcdFx0XHRcdFwiY3VycmVudFg6IFwiICsgdGhpcy5jdXJyZW50WCArIFwiIC0gY3VycmVudFk6IFwiICsgdGhpcy5jdXJyZW50WVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwidGhpcy5kYXRhLnNpemVbMF06IFwiICsgdGhpcy5kYXRhLnNpemVbMF0pO1xyXG5cdFx0XHRcdFx0dmFyIGxlZnRQY3QgPSAodGhpcy5jdXJyZW50WCAvIHRoaXMuZ2FtZS53b3JsZC53aWR0aCkgKiAxMDA7XHJcblx0XHRcdFx0XHR2YXIgdG9wUGN0ID0gKHRoaXMuY3VycmVudFkgLyB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KSAqIDEwMDtcclxuXHRcdFx0XHRcdHZhciBzY2FsZVBjdCA9ICh0aGlzLmRhdGEuc2l6ZVswXSAvIHRoaXMuZ2FtZS53b3JsZC53aWR0aCkgKiAxMDA7XHJcblx0XHRcdFx0XHR2aWRlb0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXHJcblx0XHRcdFx0XHRcdFwic3R5bGVcIixcclxuXHRcdFx0XHRcdFx0XCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDE1MDsgd2lkdGg6IFwiICtcclxuXHRcdFx0XHRcdFx0XHRzY2FsZVBjdCArXHJcblx0XHRcdFx0XHRcdFx0XCIlOyB0b3A6IFwiICtcclxuXHRcdFx0XHRcdFx0XHR0b3BQY3QgK1xyXG5cdFx0XHRcdFx0XHRcdFwiJTsgbGVmdDogXCIgK1xyXG5cdFx0XHRcdFx0XHRcdGxlZnRQY3QgK1xyXG5cdFx0XHRcdFx0XHRcdFwiJTtcIlxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmlkZW9Db250YWluZXIuc2V0QXR0cmlidXRlKFxyXG5cdFx0XHRcdFx0XHRcInN0eWxlXCIsXHJcblx0XHRcdFx0XHRcdFwicG9zaXRpb246IGFic29sdXRlOyB6LWluZGV4OiAxNTA7IHdpZHRoOiBcIiArXHJcblx0XHRcdFx0XHRcdFx0dGhpcy53aWR0aCArXHJcblx0XHRcdFx0XHRcdFx0XCJweDsgaGVpZ2h0OiBcIiArXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5oZWlnaHQgK1xyXG5cdFx0XHRcdFx0XHRcdFwicHg7IHRvcDogXCIgK1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY3VycmVudFkgK1xyXG5cdFx0XHRcdFx0XHRcdFwicHg7IGxlZnQ6IFwiICtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmN1cnJlbnRYICtcclxuXHRcdFx0XHRcdFx0XHRcInB4O1wiXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmlkZW9Db250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJ2aWRlb0NvbnRhaW5lclwiKTtcclxuXHJcblx0XHRcdFx0dGhpcy52aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdHZhciBjbGFzc1N0cmluZyA9IFwid2lzdGlhX2VtYmVkIHdpc3RpYV9hc3luY19cIiArIHRoaXMudmlkZW87XHJcblx0XHRcdFx0Ly9jbGFzc1N0cmluZyArPSBcIiBlbmRWaWRlb0JlaGF2aW9yPXJlc2V0XCI7XHJcblx0XHRcdFx0Ly9jbGFzc1N0cmluZyArPSBcIiBwbGF5YmFyPWZhbHNlXCI7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ2FtZS5kZXZpY2UuaVBhZCkge1xyXG5cdFx0XHRcdFx0Y2xhc3NTdHJpbmcgKz0gXCIgcXVhbGl0eU1heD0zNjBcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuZGF0YS5hdXRvU2NhbGUgPT0gdHJ1ZSB8fCB0aGlzLmRhdGEuYXV0b1NjYWxlID09IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIGVuYWJsZSBieSBkZWZhdWx0LCBldmVuIGlmIG5vdCBkZWNsYXJlZFxyXG5cdFx0XHRcdFx0Y2xhc3NTdHJpbmcgKz0gXCIgdmlkZW9Gb2FtPXRydWVcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy52aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY2xhc3NTdHJpbmcpO1xyXG5cdFx0XHRcdHRoaXMudmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcclxuXHRcdFx0XHRcdFwic3R5bGVcIixcclxuXHRcdFx0XHRcdFwid2lkdGg6XCIgKyB0aGlzLndpZHRoICsgXCJweDsgaGVpZ2h0OlwiICsgdGhpcy5oZWlnaHQgKyBcInB4O1wiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0aGlzLnZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInZpZGVvRWxlbWVudFwiKTtcclxuXHJcblx0XHRcdFx0dmlkZW9Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlb0VsZW1lbnQpO1xyXG5cdFx0XHRcdHZhciBnYW1lQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNnYW1lQ29udGFpbmVyXCIpO1xyXG5cdFx0XHRcdGdhbWVDb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9Db250YWluZXIpO1xyXG5cclxuXHRcdFx0XHR3aW5kb3cuX3dxID0gd2luZG93Ll93cSB8fCBbXTtcclxuXHRcdFx0XHRfLmJpbmRBbGwodGhpcywgXCJvbldpc3RpYUVtYmVkXCIpO1xyXG5cdFx0XHRcdF93cS5wdXNoKHsgaWQ6IHRoaXMudmlkZW8sIG9uUmVhZHk6IHRoaXMub25XaXN0aWFFbWJlZCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uV2lzdGlhRW1iZWQ6IGZ1bmN0aW9uICh2aWRlbykge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwid2lzdGlhIHZpZGVvIGxvYWRlZFwiKTtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCAmJiAhdGhpcy53aXN0aWFFbWJlZCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC4gdGhpcy53aXN0aWFFbWJlZCBjaGVja2VkIHRvIGtlZXAgZnVuY3Rpb24gZnJvbSBydW5uaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gc2xpZGUgaXMgcmV2aXNpdGVkIC0gV2lzdGlhIHNlZW1zIHRvIGRvZXNuJ3QgY2xlYXIgdGhlIG9uUmVhZHkgZXZlbnQgYmluZGluZy5cclxuXHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkID0gdmlkZW87XHJcblxyXG5cdFx0XHRcdHRoaXMuc2hvd0Jsb2NraW5nU3ByaXRlKCk7XHJcblx0XHRcdFx0dGhpcy5hZGRDbG9zZUJ1dHRvbigpO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5ibG9ja0lucHV0KSB7XHJcblx0XHRcdFx0XHR0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRMaXN0ZW5lcnMoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhLmF1dG9wbGF5ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkLnBsYXkoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaG93QmxvY2tpbmdTcHJpdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuYmxvY2tJbnB1dCkge1xyXG5cdFx0XHRcdHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcy5ibG9ja2luZ1Nwcml0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRhZGRDbG9zZUJ1dHRvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5kYXRhLmhpZGVDbG9zZUJ1dHRvbiAhPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHZhciBjbG9zZUJ1dHRvblgsIGNsb3NlQnV0dG9uWTtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuZGF0YS5jbG9zZUJ1dHRvbkxvY2F0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0XHRjbG9zZUJ1dHRvblggPSB0aGlzLmN1cnJlbnRYICsgdGhpcy53aWR0aDtcclxuXHRcdFx0XHRcdGNsb3NlQnV0dG9uWSA9IHRoaXMuY3VycmVudFk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNsb3NlQnV0dG9uWCA9IHRoaXMuZGF0YS5jbG9zZUJ1dHRvbkxvY2F0aW9uWzBdO1xyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25ZID0gdGhpcy5kYXRhLmNsb3NlQnV0dG9uTG9jYXRpb25bMV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmJ1dHRvbiA9IG5ldyBQaGFzZXIuQnV0dG9uKFxyXG5cdFx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25YLFxyXG5cdFx0XHRcdFx0Y2xvc2VCdXR0b25ZLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG5cdFx0XHRcdFx0dGhpcy5vbkNsb3NlLFxyXG5cdFx0XHRcdFx0dGhpcyxcclxuXHRcdFx0XHRcdHRoaXMudGhlbWUuYnV0dG9ucy52aWRlb0Nsb3NlLm92ZXIsXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnMudmlkZW9DbG9zZS5vdXQsXHJcblx0XHRcdFx0XHR0aGlzLnRoZW1lLmJ1dHRvbnMudmlkZW9DbG9zZS5kb3duLFxyXG5cdFx0XHRcdFx0dGhpcy50aGVtZS5idXR0b25zLnZpZGVvQ2xvc2UudXBcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5kYXRhLmNsb3NlQnV0dG9uTG9jYXRpb24gPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0Ly8gV2UncmUgdXNpbmcgdGhlIGRlZmF1bHQgY2xvc2UgYnV0dG9uIGxvY2F0aW9uLCBzbyBtb3ZlIGl0IHVwIGJ5IGl0cyBoZWlnaHQgdG8gc2l0IGFib3ZlIHRoZSB2aWRlby5cclxuXHRcdFx0XHRcdHRoaXMuYnV0dG9uLnkgLT0gdGhpcy5idXR0b24uaGVpZ2h0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblx0XHRcdFx0dGhpcy5idXR0b24uaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmJ1dHRvbik7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRjcmVhdGVCbG9ja2luZ1Nwcml0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYmxvY2tlclRpbnQgPVxyXG5cdFx0XHRcdHR5cGVvZiB0aGlzLmRhdGEuYmxvY2tlclRpbnQgPT09IFwidW5kZWZpbmVkXCJcclxuXHRcdFx0XHRcdD8gMHgwMDAwMDBcclxuXHRcdFx0XHRcdDogdGhpcy5kYXRhLmJsb2NrZXJUaW50O1xyXG5cdFx0XHR2YXIgYmxvY2tlckFscGhhID1cclxuXHRcdFx0XHR0eXBlb2YgdGhpcy5kYXRhLmJsb2NrZXJBbHBoYSA9PT0gXCJ1bmRlZmluZWRcIlxyXG5cdFx0XHRcdFx0PyAwLjVcclxuXHRcdFx0XHRcdDogdGhpcy5kYXRhLmJsb2NrZXJBbHBoYTtcclxuXHJcblx0XHRcdHZhciBzcHJpdGUgPSBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDApO1xyXG5cdFx0XHR2YXIgZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMCwgMCk7XHJcblx0XHRcdHNwcml0ZS5hZGRDaGlsZChncmFwaGljcyk7XHJcblx0XHRcdGdyYXBoaWNzLmJlZ2luRmlsbChibG9ja2VyVGludCwgYmxvY2tlckFscGhhKTtcclxuXHRcdFx0Z3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgdGhpcy5nYW1lLndvcmxkLndpZHRoLCB0aGlzLmdhbWUud29ybGQuaGVpZ2h0KTtcclxuXHRcdFx0Z3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cdFx0XHRzcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIHNwcml0ZTtcclxuXHRcdH0sXHJcblx0XHRvbkNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xyXG5cdFx0fSxcclxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCkge1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBleGlzdGFuY2UgaW4gY2FzZSBzb21lb25lIGlzICdmYXN0JyBhbmQgdHJpZXMgY2xvc2luZyB0aGUgdmlkZW8gYmVmb3JlIFdpc3RpYSBpcyBkb25lXHJcblx0XHRcdFx0Ly8gbG9hZGluZyBpdC5cclxuXHRcdFx0XHRpZiAodGhpcy53aXN0aWFFbWJlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy53aXN0aWFFbWJlZC51bmJpbmQoKTtcclxuXHRcdFx0XHRcdHRoaXMud2lzdGlhRW1iZWQucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHR0aGlzLndpc3RpYUVtYmVkID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuYmxvY2tJbnB1dCkge1xyXG5cdFx0XHRcdFx0dGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLmJ1dHRvbikge1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24udmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5idXR0b24gPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvL2xvZy53YXJuKHRoaXMudmlkZW9FbGVtZW50LmF0dHIoJ2lkJykpO1xyXG5cdFx0XHRcdCQoXCIjdmlkZW9Db250YWluZXJcIikuaGlkZSgpO1xyXG5cdFx0XHRcdHZhciB0ZW1wID0ge307XHJcblx0XHRcdFx0dGVtcFt0aGlzLmRhdGEubmFtZV0gPSBcImNsb3NlZFwiO1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdGVtcCk7XHJcblx0XHRcdFx0Ly8gTm93LCBkZWxldGUgaXQgYWxsLlxyXG5cdFx0XHRcdGlmICh0aGlzLmJsb2NrSW5wdXQpIHtcclxuXHRcdFx0XHRcdHRoaXMuYmxvY2tpbmdTcHJpdGUuZGVzdHJveSh0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9sb2cud2Fybih0aGlzLnZpZGVvRWxlbWVudC5hdHRyKCdpZCcpKTtcclxuXHRcdFx0XHQkKFwiI3ZpZGVvQ29udGFpbmVyXCIpLnJlbW92ZSgpO1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gV2lzdGlhQWN0b3I7XHJcbn0pKCk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjAuMFxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIEFuIGdlbmVyaWMgYWN0b3IuIEl0IGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gYWxsIGFjdG9yc1xyXG4gKlxyXG4gKiAgXCJpbnZlcnNlRXZlbnRzXCI6IHRydWUgLy8gb3B0aW9uYWwuIEV2ZW50cyB3aWxsIGdvIG9ubHkgdG8gdGhpcyBzcHJpdGUsIGluc3RlYWQgb2Ygb25seSB0byBvdGhlcnMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgREVGQVVMVF9GT05UID0geyBcImZvbnRcIjogXCIyMHB4IFRhaG9tYVwiLCBcImZpbGxcIjogXCIjMDAwMDAwXCIsICBcImZvbnRXZWlnaHRcIjogXCJib2xkXCJ9LFxyXG4gICAgICAgIERFRkFVTFRfVEVYVCA9IFwiVGV4dCBOb3QgRm91bmQuXCIsXHJcbiAgICAgICAgREVGQVVMVF9JTUFHRSA9IFwiSW1hZ2UgTm90IEZvdW5kLlwiO1xyXG5cclxuICAgIHZhciBBY3RvciA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgIGRhdGEsIHRoZW1lKSB7XHJcbiAgICAgICAgICAgIGlmKCAhZ2FtZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQWN0b3IgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggIWRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFjdG9yIHJlcXVpcmVzIGRhdGEgY29uc3RydWN0b3IgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoICF0aGVtZSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQWN0b3IgcmVxdWlyZXMgZGF0YSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkdhbWVDaG9pY2U6IG5ldyBQaGFzZXIuU2lnbmFsKCksXHJcbiAgICAgICAgICAgICAgICBvbkdhbWVTcGVlY2g6IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyZWVCYXNlQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAvL3RoaXMuZ2FtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYmFzaWMgdmFsaWRhdGlvbiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBUaGlzIHdpbGwgY2hlY2sgc29tZSBiYXNpYy9jb21tb24gZGF0YSBlcnJvcnMsIGluY2x1ZGluZyByZXF1aXJlZCBmaWVsZHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggIXRoaXMuZGF0YS5uYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBY3RvciBoYXMgZGF0YSwgYnV0IG5vIG5hbWUuIE5hbWUgaXMgcmVxdWlyZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy5kYXRhLnR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFjdG9yIGhhcyBkYXRhLCBidXQgbm8gbmFtZS4gTmFtZSBpcyByZXF1aXJlZC5cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmdldFJlcXVpcmVkRmllbGRzKCksIGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5kYXRhW2ZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZGF0YVtmaWVsZF0gPT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJbXCIgKyB0aGlzLmRhdGEudHlwZSArIFwiXSBBY3RvciBbXCIgKyB0aGlzLmRhdGEubmFtZSArIFwiXSBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiBcIiArIGZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEubmFtZSAmJiB0aGlzLmRhdGEubmFtZS5jaGFyQXQoMCkgPT09IFwiJFwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBY3RvciBuYW1lcyBjYW5ub3QgYmUgdmFyaWFibGVzLCBhbmQgd2lsbCBub3QgYmUgcmVzb2x2ZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXROYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UHJpbWFyeVNwcml0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFic3RyYWN0IG1ldGhvZCBmb3IgY2hpbGRyZW4gdG8gaW1wbGVtZW50LlxyXG4gICAgICAgICAqIGV4OiByZXR1cm4gWyBcIm5hbWVcIiwgXCJsb2NhdGlvblwiIF07XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBcIllvdSBtdXN0IGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gYW4gYXJyYXkgb2YgZmllbGQgbmFtZXMuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRNb2RlbEludGVyZmFjZTogZnVuY3Rpb24oIG1vZGVsSW50ZXJmYWNlICkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsSW50ZXJmYWNlID0gbW9kZWxJbnRlcmZhY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRGb250OiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQXNraW5nIGZvciBmb250IHdpdGggXCIgKyBuYW1lICk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnRoZW1lICYmIHRoaXMudGhlbWUuZm9udHMgJiYgdGhpcy50aGVtZS5mb250c1tuYW1lXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMudGhlbWUuZm9udHNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZvbnQgbm90IGZvdW5kIGZvciBcIiArIG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5jbG9uZShERUZBVUxUX0ZPTlQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9vayB1cCBhIHBpZWNlIG9mIHRleHQgaW4gdGhlIHRoZW1lLlxyXG4gICAgICAgICAqIElmIG5vdCB0aGVyZSwgdHJlYXQgYXMgbGl0ZXJhbC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKCBuYW1lLCBrZXkgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQXNraW5nIGZvciB0ZXh0IHdpdGggXCIgKyBuYW1lICsgXCIgLyBcIiArIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBzTmFtZSA9IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBzS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiggdGhpcy5tb2RlbEludGVyZmFjZSApIHtcclxuICAgICAgICAgICAgICAgIHNOYW1lID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIHNLZXkgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nLndhcm4oXCItLT4gQXNraW5nIGZvciB0ZXh0IHdpdGggXCIgKyBzTmFtZSArIFwiIC8gXCIgKyBzS2V5KTtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lIHx8ICghdGhpcy50aGVtZS50ZXh0cyAmJiAhc0tleSkgKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJ0ZXh0IHVuYXZhaWxhYmxlIGZvciBcIiArIHNOYW1lICsgXCIgLyBcIiArIHNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChERUZBVUxUX1RFWFQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50aGVtZS50ZXh0c1tzTmFtZV07XHJcbiAgICAgICAgICAgIGlmKCAhdGV4dCAmJiAhc0tleSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzTmFtZTsgLy8gbWlnaHQgYmUgYSBzdHJpbmcgbGl0ZXJhbC5cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBzS2V5ICYmIHRoaXMudGhlbWUudGV4dHNbc0tleV0gKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy50aGVtZS50ZXh0c1tzS2V5XVtzTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nLndhcm4oXCJyZXR1cm5pbmcgXCIgKyB0ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQgfHwgc05hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRUZXh0dXJlS2V5OiBmdW5jdGlvbiggc3ByaXRlRGF0YSApIHtcclxuICAgICAgICAgICAgaWYoIHNwcml0ZURhdGEgJiYgc3ByaXRlRGF0YS50ZXh0dXJlS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwcml0ZURhdGEudGV4dHVyZUtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZS50ZXh0dXJlS2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9vayB1cCBhbiBpbWFnZSBpbiB0aGUgdGhlbWUuXHJcbiAgICAgICAgICogSWYgbm90IHRoZXJlLCB0cmVhdCBhcyBsaXRlcmFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEltYWdlOiBmdW5jdGlvbiggbmFtZSwga2V5ICkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkFza2luZyBmb3IgaW1hZ2Ugd2l0aCBcIiArIG5hbWUgKyBcIiAvIFwiICsga2V5KTtcclxuICAgICAgICAgICAgdmFyIHNOYW1lID0gbmFtZSxcclxuICAgICAgICAgICAgICAgIHNLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLm1vZGVsSW50ZXJmYWNlICkge1xyXG4gICAgICAgICAgICAgICAgc05hbWUgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgc0tleSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2cud2FybihcIi0tPiBBc2tpbmcgZm9yIGltYWdlIHdpdGggXCIgKyBzTmFtZSArIFwiIC8gXCIgKyBzS2V5KTtcclxuICAgICAgICAgICAgaWYoICF0aGlzLnRoZW1lIHx8ICghdGhpcy50aGVtZS5pbWFnZXMgJiYgIXNLZXkpICkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiaW1hZ2Ugbm90IGZvdW5kIGZvciBcIiArIHNOYW1lICsgXCIgLyBcIiArIHNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChERUZBVUxUX0lNQUdFKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLnRoZW1lLmltYWdlc1tzTmFtZV07XHJcbiAgICAgICAgICAgIGlmKCAhaW1hZ2UgJiYgIXNLZXkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc05hbWU7IC8vIG1pZ2h0IGJlIGEgc3RyaW5nIGxpdGVyYWwsIHNvIHJldHVybiBpdC5cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBzS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLnRoZW1lLmltYWdlc1tzS2V5XVtzTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIoaW1hZ2UuZW5kSW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTnVtYmVyKGltYWdlLnN0YXJ0SW5kZXgpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gTnVtYmVyKGltYWdlLmVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciB6ZXJvUGFkID0gaW1hZ2UuemVyb1BhZCB8fCA0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGltYWdlLmZpbGVuYW1lUHJlZml4IHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gaW1hZ2UuZmlsZW5hbWVTdWZmaXggfHwgXCIucG5nXCI7XHJcbiAgICAgICAgICAgICAgICBpbWFnZSA9IFBoYXNlci5BbmltYXRpb24uZ2VuZXJhdGVGcmFtZU5hbWVzKHByZWZpeCwgc3RhcnQsIGVuZCwgc3VmZml4LCB6ZXJvUGFkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRNeVZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLnZhcmlhYmxlICYmIHRoaXMubW9kZWxJbnRlcmZhY2UgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0VmFsdWUoXCIkXCIgKyB0aGlzLmRhdGEudmFyaWFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gaW1wbGVtZW50IGRlc3Ryb3kgZm9yIGFjdG9yIHR5cGU6IFwiICsgdGhpcy5kYXRhLnR5cGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlQmxvY2tpbmdTcHJpdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLDApO1xyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgUGhhc2VyLkdyYXBoaWNzKHRoaXMuZ2FtZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5hZGRDaGlsZChncmFwaGljcyk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweDAwMDAwMCwgMC4wMSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIHRoaXMuZ2FtZS53b3JsZC53aWR0aCwgdGhpcy5nYW1lLndvcmxkLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJzdGl0dXRlVGV4dDogZnVuY3Rpb24oIHRleHQgKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRG9pbmcgc3Vic3RpdHV0aW9uIG9uOiBcIiArIHRleHQpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdEluZGV4LCByaWdodEluZGV4O1xyXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIpO1xyXG4gICAgICAgICAgICBpZiggbGVmdEluZGV4ID09PSAtMSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPSB0ZXh0LmluZGV4T2YoXCIkXCIsIGxlZnRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiggcmlnaHRJbmRleCA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGV4dC5zdWJzdHJpbmcoIGxlZnRJbmRleCwgcmlnaHRJbmRleCArMSk7XHJcbiAgICAgICAgICAgIHZhciBrZXkyID0ga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSB0cmFpbGluZyBkb2xsYXJzaWduLlxyXG4gICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZShrZXkyKTtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGZpbmFsVGV4dCA9PT0gJ3VuZGVmaW5lZCcgfHwgZmluYWxUZXh0ID09PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbFRleHQgPSBmaW5hbFRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmaW5hbFRleHQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2Uoa2V5LCBmaW5hbFRleHQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoR2FtZUNob2ljZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCBkYXRhLCB0aGlzICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXNwYXRjaEdhbWVTcGVlY2g6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBkYXRhLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU291bmRFdmVudEludmVyc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhICYmIHRoaXMuZGF0YS5pbnZlcnNlU291bmRFdmVudHMgPT09IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBvdmVycmlkZSBpZiB5b3UgaGF2ZSBwaHlzaWNzLlxyXG4gICAgICAgIGdldEJvZHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgaWYgdGhpcyBzcHJpdGUgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBzcHJpdGUgYW5kIGdldEJvZHkoKSBkb2VzIG5vdCByZXR1cm4gbnVsbDtcclxuICAgICAgICAgKiBUaGUgb3RoZXIgc3ByaXRlIHdpbGwgYWxzbyBub3QgYmUgcmV0dXJuaW5nIG51bGwgZm9yIGdldEJvZHkoKS5cclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXJBY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uT3ZlcmxhcHBpbmc6IGZ1bmN0aW9uKCBvdGhlckFjdG9yTmFtZSApIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWNlaXZlIGEgZHJvcHBlZCBzcHJpdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25SZWNlaXZlRHJvcDogZnVuY3Rpb24oIG90aGVyQWN0b3JOYW1lICkge1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXlBdWRpbzogZnVuY3Rpb24oIGV2ZW50RGF0YSApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpb0tleSApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5jaGFubmVsID0gdGhpcy5kYXRhLmF1ZGlvS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhcmlhYmxlTGlzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbEludGVyZmFjZS5jbGVhclZhbHVlKHRoaXMuZGF0YS52YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmdldFZhcmlhYmxlTGlzdCgpLCBmdW5jdGlvbiggZWFjaFZhcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbEludGVyZmFjZS5jbGVhclZhbHVlKGVhY2hWYXIpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBib29rIGFjdG9yLCB3aGljaCB3aWxsIHNob3cgdGhlIHBsYXllciBhIGJvb2sgd2l0aCBmbGlwcGFibGUgcGFnZXMuIEl0IHdpbGwgYWxzb1xyXG4gKiBwbGF5IGFueSBhdWRpby90ZXh0IGFzc29jaWF0ZWQgd2l0aCBhc2tpbmcgcXVlc3Rpb25zIGFuZCB0ZXh0LlxyXG4gKlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJjaG9pY2VzX21hbmR5XzFcIiwgLy8gdW5pcXVlIG5hbWUgZm9yIHRoaXMgYWN0b3IuXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWNib29rXCIsIC8vIHJlcXVpcmVkIHR5cGUuXHJcbiAqICAgICBcInBhZ2VzXCI6ICBbXHJcbiAqICAgICB7XHJcbiAqICAgICBcInRpdGxlXCI6IFwiV2hhdCBhcmUgRHJ1Z3M/XCIsXHJcbiAqICAgICBcInN1YnRpdGxlXCI6IFwiVGhpcyBpcyBhIHN1YnRpdGxlIVwiLFxyXG4gKiAgICAgXCJ0eXBlXCI6IFwicXVlc3Rpb25cInxcImluZm9ybWF0aW9uXCIgLy8gd2lsbCB0aGVyZSBiZSBxdWVzdGlvbnM/XHJcbiAqXHJcbiAqICAgICB9XHJcbiAqICAgICBdXHJcbiAqIH1cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcclxuXHJcbiAgICB2YXIgSXRzVXJDaG9pY2VCb29rQWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1wicGFnZXNcIl07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZXMgPSB0aGlzLmRhdGEucGFnZXM7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5wYWdlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgXCJib29rUXVlc3Rpb25UaXRsZVwiOiB0aGlzLmdldEZvbnQoXCJib29rUXVlc3Rpb25UaXRsZVwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1F1ZXN0aW9uU3VidGl0bGVcIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uU3VidGl0bGVcIiksXHJcbiAgICAgICAgICAgICAgICBcImJvb2tRdWVzdGlvblRleHRcIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uVGV4dFwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1F1ZXN0aW9uUmVtZWRpYXRpb25cIjogdGhpcy5nZXRGb250KFwiYm9va1F1ZXN0aW9uUmVtZWRpYXRpb25cIiksXHJcbiAgICAgICAgICAgICAgICBcImJvb2tQYWdlVGl0bGVcIjogdGhpcy5nZXRGb250KFwiYm9va1BhZ2VUaXRsZVwiKSxcclxuICAgICAgICAgICAgICAgIFwiYm9va1BhZ2VTdWJ0aXRsZVwiOiB0aGlzLmdldEZvbnQoXCJib29rUGFnZVN1YnRpdGxlXCIpLFxyXG4gICAgICAgICAgICAgICAgXCJib29rUGFnZUNvbnRlbnRcIjogdGhpcy5nZXRGb250KFwiYm9va1BhZ2VDb250ZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgXCJib29rUGFnZU51bWJlclwiOiB0aGlzLmdldEZvbnQoXCJib29rUGFnZU51bWJlclwiKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLlBBR0VfRkxJUF9TT1VORCA9IHRoaXMudGhlbWUuYm9va1NvdW5kcy5wYWdlRmxpcFNvdW5kO1xyXG4gICAgICAgICAgICB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5EID0gdGhpcy50aGVtZS5ib29rU291bmRzLmNvcnJlY3RTb3VuZDtcclxuICAgICAgICAgICAgdGhpcy5BTlNXRVJfSU5DT1JSRUNUX1NPVU5EID0gdGhpcy50aGVtZS5ib29rU291bmRzLmluY29ycmVjdFNvdW5kO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kKCk7ICAgICAgICAgIC8vIDAxLiBCYWNrZ3JvdW5kIGltYWdlLiBUaGlzIG1heSBhbHNvIGxhdGVyIG5lZWQgYSBib3JkZXIgZHJhd24/XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQWN0aW9uQnV0dG9ucygpOyAgICAgICAvLyAwMi4gVHVybiBwYWdlcy5cclxuICAgICAgICAgICAgdGhpcy5hZGRQYWdlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRQYWdlKDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQmFja2dyb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnSW1hZ2UgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSh0aGlzLmdhbWUud29ybGQud2lkdGgvMiwgMTUsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZShcImJhY2tncm91bmRcIiwgXCJib29rXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5iZ0ltYWdlLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQYWdlSW1hZ2UgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSg5MCwgMjgsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZShcImxlZnQtcGFnZVwiLCBcImJvb2tcIikpO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGFnZUltYWdlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoNDAyLCAyOCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKFwicmlnaHQtcGFnZVwiLCBcImJvb2tcIikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQWN0aW9uQnV0dG9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRQYWdlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oNzUwLCAxNzUsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25OZXh0UGFnZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snbmV4dFBhZ2UnXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbJ25leHRQYWdlJ10ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zWyduZXh0UGFnZSddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snbmV4dFBhZ2UnXS51cCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24oMTAsIDE3NSwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblByZXZpb3VzUGFnZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1sncHJldmlvdXNQYWdlJ10ub3ZlciwgdGhpcy50aGVtZS5idXR0b25zWydwcmV2aW91c1BhZ2UnXS5vdXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnNbJ3ByZXZpb3VzUGFnZSddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1sncHJldmlvdXNQYWdlJ10udXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkUGFnZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFnZUdyb3VwO1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUsIHN1YnRpdGxlLCBjb250ZW50LCByZW1lZGlhdGlvbiwgcGFnZU51bWJlcjtcclxuICAgICAgICAgICAgdmFyIGJ1bGxldEltYWdlcywgYnVsbGV0O1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuZGF0YS5wYWdlcywgZnVuY3Rpb24ocGFnZSwgcGFnZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYXVkaW8gPSBwYWdlLmF1ZGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCBwYWdlLmNvbnRlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGl0bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA1NjUsIDUwLCBwYWdlLnRpdGxlLCB0aGlzLmZvbnRzLmJvb2tQYWdlVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLmFuY2hvci5zZXRUbyggMC41LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VidGl0bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGUgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA0MTAsIDg1LCBwYWdlLnN1YnRpdGxlLCB0aGlzLmZvbnRzLmJvb2tQYWdlU3VidGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQoc3VidGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50IVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCA0MTIsIDExMCwgcGFnZS5jb250ZW50LCB0aGlzLmZvbnRzLmJvb2tQYWdlQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChjb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIHBhZ2UucXVlc3Rpb25zICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpdGxlLlxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNTY1LCA1MCwgcGFnZS50aXRsZSwgdGhpcy5mb250cy5ib29rUXVlc3Rpb25UaXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUuYW5jaG9yLnNldFRvKCAwLjUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQodGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0aXRsZS5cclxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIDU2NSwgODUsIHBhZ2Uuc3VidGl0bGUsIHRoaXMuZm9udHMuYm9va1F1ZXN0aW9uU3VidGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlLmFuY2hvci5zZXRUbyggMC41LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHN1YnRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudCFcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHBhZ2UucXVlc3Rpb25zICwgZnVuY3Rpb24oIGVhY2hRdWVzdGlvbiwgcXVlc3Rpb25JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRJbWFnZXMgPSB0aGlzLnRoZW1lLmJ1dHRvbnNbJ2Jvb2tDaG9pY2UnICsgcXVlc3Rpb25JbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldCA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCA0MTAsIDExMCArIChxdWVzdGlvbkluZGV4ICogMzUpLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlclVwLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0SW1hZ2VzLm92ZXIsIGJ1bGxldEltYWdlcy5vdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRJbWFnZXMuZG93biwgYnVsbGV0SW1hZ2VzLnVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0LmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldC5ldmVudHMub25JbnB1dE92ZXIuYWRkKCB0aGlzLm9uTW91c2VJbiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNDM1LCAxMjAgKyAocXVlc3Rpb25JbmRleCAqIDM1KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hRdWVzdGlvbi50ZXh0LCB0aGlzLmZvbnRzLmJvb2tRdWVzdGlvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LmxpbmVTcGFjaW5nID0gLTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldC5hbnN3ZXIgPSBlYWNoUXVlc3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VHcm91cC5hZGQoYnVsbGV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChjb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZWRpYXRpb25cclxuICAgICAgICAgICAgICAgICAgICByZW1lZGlhdGlvbiA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIDQxMywgMjY1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vdGhpbmdcIiwgdGhpcy5mb250cy5ib29rUXVlc3Rpb25SZW1lZGlhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtZWRpYXRpb24ubGluZVNwYWNpbmcgPSAtMztcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAuYWRkKHJlbWVkaWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlR3JvdXAucmVtZWRpYXRpb24gPSByZW1lZGlhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByZW1lZGlhdGlvbi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGFnZSAjXHJcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyID0gbmV3IFBoYXNlci5UZXh0KHRoaXMuZ2FtZSwgNjkwLCA0NDgsIHBhZ2VJbmRleCArIDEsIHRoaXMuZm9udHMuYm9va1BhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgcGFnZUdyb3VwLmFkZChwYWdlTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYWdlR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHBhZ2VHcm91cCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VzWzBdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Q3VycmVudFBhZ2U6IGZ1bmN0aW9uKCBwYWdlSW5kZXggKSB7XHJcbiAgICAgICAgICAgIGlmKCBwYWdlSW5kZXggPCAwIHx8IHBhZ2VJbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2VJbmRleF0udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlSW5kZXggPSBwYWdlSW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZUluZGV4XS52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uLnZpc2libGUgPSAodGhpcy5jdXJyZW50UGFnZUluZGV4ICE9PSAwKTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0UGFnZUJ1dHRvbi52aXNpYmxlID0gKHRoaXMuY3VycmVudFBhZ2VJbmRleCAhPT0gKHRoaXMucGFnZXMubGVuZ3RoIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oIHsgYXVkaW86IHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZUluZGV4XS5hdWRpbywga2V5OiBudWxsLCBwcmlvcml0eTogJ3F1ZXVlJyB9KTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk5leHRQYWdlQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oe2F1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsLCBcInByaW9yaXR5XCI6IFwic3RvcGFsbFwiIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyh7IGF1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRQYWdlKHRoaXMuY3VycmVudFBhZ2VJbmRleCArIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25QcmV2aW91c1BhZ2VBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyh7YXVkaW86IHRoaXMuUEFHRV9GTElQX1NPVU5ELCBrZXk6IG51bGwsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCIgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCB7IGF1ZGlvOiB0aGlzLlBBR0VfRkxJUF9TT1VORCwga2V5OiBudWxsfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5jdXJyZW50UGFnZUluZGV4IC0gMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlSW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjdXJyZW50bHksIGNsaWNraW5nIHRoZSBhbnN3ZXIgYWxzbyBjYXVzZXMgYXMgbW91c2UgaW4/IFRoaXMgaXMgY2F1c2luZyBwcm9ibGVtcy4uLlxyXG4gICAgICAgICAgICAvLyB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2guZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHsgYXVkaW86IFwiYnViYmxlX3Nsb3dcIiwga2V5OiBudWxsLCByZXN0YXJ0OiB0cnVlfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24gKGNob2ljZSkge1xyXG4gICAgICAgICAgIC8vIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgeyBhdWRpbzogXCJidWJibGVfc2xvd1wiLCBrZXk6IG51bGwsIHN0b3A6IHRydWV9KTtcclxuICAgICAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2VJbmRleF07XHJcbiAgICAgICAgICAgIHBhZ2UucmVtZWRpYXRpb24uc2V0VGV4dChjaG9pY2UuYW5zd2VyLnJlc3BvbnNlLnRleHQpO1xyXG4gICAgICAgICAgICBwYWdlLnJlbWVkaWF0aW9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbygge2F1ZGlvOiB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGwsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCIgfSk7XHJcbiAgICAgICAgICAgIGlmKCBjaG9pY2UuYW5zd2VyLnJlc3BvbnNlLmNvcnJlY3QgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlBdWRpbygge2F1ZGlvOiB0aGlzLkFOU1dFUl9DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGx9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgeyBhdWRpbzogdGhpcy5BTlNXRVJfSU5DT1JSRUNUX1NPVU5ELCBrZXk6IG51bGx9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIHsgYXVkaW86IGNob2ljZS5hbnN3ZXIucmVzcG9uc2UuYXVkaW8sIGtleTogbnVsbCwgXCJwcmlvcml0eVwiOiAncXVldWUnIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnSW1hZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQYWdlSW1hZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGFnZUltYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0UGFnZUJ1dHRvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlQnV0dG9uLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wO1xyXG4gICAgICAgICAgICB3aGlsZSggdGhpcy5wYWdlcy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMucGFnZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLnJlbWVkaWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRlbXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEl0c1VyQ2hvaWNlQm9va0FjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBjaGF0IGFjdG9yLCB3aGljaCB3aWxsIHNob3cgdGhlIHBsYXllciBhIGNvbnZlcnNhdGlvbi4gSXQgd2lsbCBhbHNvXHJcbiAqIHBsYXkgYW55IGF1ZGlvL3RleHQgYXNzb2NpYXRlZCB3aXRoIGFza2luZyBxdWVzdGlvbi5cclxuICpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwiY2hvaWNlc19tYW5keV8xXCIsIC8vIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGFjdG9yLlxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaXVjY2hhdFwiLCAvLyByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJiYWNrZ3JvdW5kXCI6IFwicHVycGxlV2FsbFwiLFxyXG4gKiAgICAgXCJwb3J0cmFpdFwiOiBcIm1yc1JpbGV5XCIsXHJcbiAqICAgICBcInBvcnRyYWl0TGFiZWxcIjogXCJNcnMuIFJpbGV5XCIsXHJcbiAqICAgICBcImNob29zZUxhYmVsXCI6IFwiQ2hvb3NlIHlvdXIgcmVzcG9uc2UuXCIsXHJcbiAqICAgICBcInZhcmlhYmxlXCI6IFwieFwiLCAvLyB0aGUgdmFyaWFibGUgdG8gc2V0IHdoZW4gdGhlIHVzZXIgbGVhdmVzXHJcbiAqICAgICBcImNvbnZlcnNhdGlvblwiOiAge1xyXG4gICAgICAgICAgICAgIFwicmVzcG9uc2VzXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImF1ZGlvXCI6IFwiYXVkaW8vZGF5MS9tZWxpc3NhX2ludHJvLm1wM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIk9oLCBoaS4gSSB3YXMganVzdCBhc2tpbmcgeW91ciBkYWQgaWYgSSBjb3VsZCBib3Jyb3cgaGlzIHRvb2xib3guIEknbSBmaXhpbmcgc29tZSBzaGVsdmVzIGluIEpvc2gncyByb29tLiBZb3VyIGRhZCB3aWxsIGJlIHJpZ2h0IGJhY2suIEhvdydzIGl0IGdvaW5nPyBIb3cncyBzY2hvb2w/IEknbSBraW5kIG9mIHdvcnJpZWQgYWJvdXQgU2V0aCBiZWNhdXNlIGhlIGhhc24ndCBldmVuIHRob3VnaHQgb2YgY29sbGVnZSB5ZXQsIG11Y2ggbGVzcyBoaXMgQWxnZWJyYSBob21ld29yayB0b21vcnJvdy4gSSB3aXNoIGhlIGNvdWxkIGJlIG1vcmUgbGlrZSBKb3NoIGFuZCBkZXZlbG9wIHNvbWUgc2hvcnQgYW5kIGxvbmctdGVybSBnb2Fscy4gSGUgb25jZSB0b2xkIG1lIHRoYXQgaGUgZmVsdCBsaWtlIGV2ZXJ5dGhpbmcgd2FzIG91dCBvZiBjb250cm9sIGFuZCBub3RoaW5nIG1hdHRlcmVkLiBJIGhvcGUgaGUgd2FzIGp1c3QgaW4gYSBiYWQgbW9vZCBhbmQgdGhhdCBoZSdzIG5vdCBleHBlcmltZW50aW5nIHdpdGggYW55dGhpbmcuXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJ0cmlnZ2Vyc1wiOiBcInExLHEyLHEzLHE0LHE1XCIsXHJcbiAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImludHJvXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdWRpb1wiOiBcImF1ZGlvL2RheTEvbWVsaXNzYV8xci5tcDNcIixcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJBIHNob3J0LXRlcm0gZ29hbCBpcyBzaW1wbHkgYSBnb2FsIHlvdSB3YW50IHRvIGFjaGlldmUgaW4gYSBmZXcgZGF5cywgYSBmZXcgd2Vla3Mgb3IgYSBmZXcgbW9udGhzLlwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwidHJpZ2dlcnNcIjogXCJxMV9hLHEyLHEzLHE0LHE1XCIsXHJcbiAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInIxXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgXCJxdWVzdGlvbnNcIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiTWF5YmUgU2V0aCBkb2Vzbid0IGtub3cgd2hhdCBhIHNob3J0LXRlcm0gZ29hbCBpcy4gSSBrbm93IEkgZG9uJ3QuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicTFcIixcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IFwicjFcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiWFwiIC8vIHNldCB0aGUgdmFyaWFibGUgdG8gWC5cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkFsbCByaWdodCwgTXJzLiBSaWxleS4gSSdtIGdvaW5nIHRvIG5lZWQgYW4gZXhhbXBsZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJxMV9hXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZXNwb25zZVwiOiBcInIxX2FcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiV2hhdCdzIGEgbG9uZy10ZXJtIGdvYWw/XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicTJcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdGl2ZU1ldFwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IFwicjJcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICogfVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgUm91bmRlZENoYXRSZWN0ID0gcmVxdWlyZSgnLi9yb3VuZGVkLWNoYXQtcmVjdCcpO1xyXG4gICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBNQVhfQ0hPSUNFUyA9IDUsXHJcbiAgICAgICAgbWFyZ2luWSA9IDMsXHJcbiAgICAgICAgUkVTUE9OU0VfU1RBUlRfWSA9IDMyMztcclxuICAgIHZhciBSRVNQT05TRV9URVhUX1ggPSA0MDtcclxuICAgIHZhciBDT0xPUl9WSVNJVEVEX09QVElPTiA9IFwiI2I1YjNiMlwiO1xyXG4gICAgdmFyIENPTE9SX0FDVElWRV9PUFRJT04gPSBcIiMwMDAwMDBcIjtcclxuXHJcbiAgICB2YXIgQ2hhdEFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcImNvbnZlcnNhdGlvblwiLCBcImJhY2tncm91bmRcIiwgXCJwb3J0cmFpdFwiLCBcInBvcnRyYWl0TGFiZWxcIiwgXCJjaG9vc2VMYWJlbFwiLCBcInZhcmlhYmxlXCJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IHRoaXMuZGF0YS5jb252ZXJzYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlID0gdGhpcy5maW5kUmVzcG9uc2UoXCJpbnRyb1wiKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJZb3UgbXVzdCBoYXZlIGFuIGludHJvIHJlc3BvbnNlOiBcIiArIHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IHRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDaG9pY2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kKCk7ICAgICAgICAgIC8vIDAxLiBCYWNrZ3JvdW5kIGltYWdlLiBUaGlzIG1heSBhbHNvIGxhdGVyIG5lZWQgYSBib3JkZXIgZHJhd24/XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUG9ydHJhaXQoKTsgICAgICAgICAgICAvLyAwMiwgMDMuIFBvcnRyYWl0ICsgTGFiZWxcclxuICAgICAgICAgICAgdGhpcy5hZGRTcGVlY2hCdWJibGUoKTsgICAgICAgIC8vIDA0LiBTcGVlY2ggQnViYmxlIChhbmQgMTAuIHNwZWVjaCB0ZXh0KVxyXG4gICAgICAgICAgICB0aGlzLmFkZFJlc3BvbnNlVGl0bGUoKTsgICAgICAgLy8gMDUsIDA2LiBcIkNob29zZSB5b3VyIHJlc3BvbnNlLlwiIHcvbGluZVxyXG4gICAgICAgICAgICB0aGlzLmFkZENob2ljZUJveCgpOyAgICAgICAgICAgLy8gMDcuIENob2ljZSBib3hcclxuICAgICAgICAgICAgdGhpcy5hZGRBY3Rpb25CdXR0b25zKCk7ICAgICAgIC8vIDA4LCAwOS4gQXVkaW8gTXV0ZSBhbmQgTGVhdmUgQ29udmVyc2F0aW9uIGJ1dHRvblxyXG4gICAgICAgICAgICB0aGlzLmFkZENob2ljZVRleHQoKTsgICAgICAgICAgLy8gMTEuIEN1cnJlbnQgQ2hvaWNlKHMpIHRleHQgLyBMaW5rcywgcG9zc2libHkgZ3JheWVkIG91dC5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEJhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5iZ0ltYWdlID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKHRoaXMuZGF0YS5iYWNrZ3JvdW5kLCB0aGlzLmRhdGEua2V5KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQb3J0cmFpdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcnRyYWl0ID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoNTgxLCA0MywgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKHRoaXMuZGF0YS5wb3J0cmFpdCwgdGhpcy5kYXRhLmtleSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gMDMuIFBvcnRyYWl0IGxhYmVsXHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5wb3J0cmFpdEZvbnQ7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxTdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnROYW1lICE9PSAndW5kZWZpbmVkJykgPyBmb250TmFtZSA6IFwiY2hhdExhYmVsXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsU3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxYID0gdGhpcy5wb3J0cmFpdC54ICsgKHRoaXMucG9ydHJhaXQud2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsWSA9IHRoaXMucG9ydHJhaXQueSArIHRoaXMucG9ydHJhaXQuaGVpZ2h0ICsgMTU7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXRMYWJlbCA9IHRoaXMuZ2FtZS5hZGQudGV4dChsYWJlbFgsIGxhYmVsWSwgdGhpcy5kYXRhLnBvcnRyYWl0TGFiZWwsIHRoaXMubGFiZWxTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXRMYWJlbC5hbmNob3Iuc2V0VG8oMC41LCAwLjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU3BlZWNoQnViYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoQnViYmxlID0gbmV3IFJvdW5kZWRDaGF0UmVjdCh0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEJ1YmJsZS5zaG93KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRSZXNwb25zZVRpdGxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmb250TmFtZSA9IHRoaXMuZGF0YS5jaG9vc2VGb250O1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVDaG9vc2UgPSB0aGlzLmdldEZvbnQoKHR5cGVvZiBmb250TmFtZSAhPT0gJ3VuZGVmaW5lZCcpID8gZm9udE5hbWUgOiBcImNoYXRMYWJlbFwiKTtcclxuICAgICAgICAgICAgdmFyIGNob29zZUxhYmVsWCA9IDE1MDtcclxuICAgICAgICAgICAgdmFyIGNob29zZUxhYmVsWSA9IHRoaXMucG9ydHJhaXQueSArIHRoaXMucG9ydHJhaXQuaGVpZ2h0ICsgNjU7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvb3NlTGFiZWwgPSB0aGlzLmdhbWUuYWRkLnRleHQoY2hvb3NlTGFiZWxYLCBjaG9vc2VMYWJlbFksIHRoaXMuZGF0YS5jaG9vc2VMYWJlbCwgc3R5bGVDaG9vc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNob29zZUxhYmVsLmFuY2hvci5zZXRUbygwLjUsIDEuMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRDaG9pY2VCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygwLCAwKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MubGluZVN0eWxlKDMsIDB4YzczMjQ4LCAxKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MubW92ZVRvKDQwLCBSRVNQT05TRV9TVEFSVF9ZIC0gMTUpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5saW5lVG8oNzYwLCBSRVNQT05TRV9TVEFSVF9ZIC0gMTUpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5saW5lU3R5bGUoMSwgMHhmZmZmZmYsIDEpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5iZWdpbkZpbGwoMHhGRkZGRkYsIDEpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5kcmF3UmVjdCgzMCwgUkVTUE9OU0VfU1RBUlRfWSAtIDUsIDc0MCwgMTUwKTtcclxuICAgICAgICAgICAgdGhpcy5jaG9pY2VHcmFwaGljcyA9IGNob2ljZUdyYXBoaWNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQWN0aW9uQnV0dG9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKDQ1MCwgNTM1LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTXV0ZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPZmYnXS5vdmVyLCB0aGlzLnRoZW1lLmJ1dHRvbnNbJ3NvdW5kT2ZmJ10ub3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5idXR0b25zWydzb3VuZE9mZiddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPZmYnXS51cCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKDQ1MCwgNTM1LCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTXV0ZUFjdGlvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLm92ZXIsIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLmRvd24sIHRoaXMudGhlbWUuYnV0dG9uc1snc291bmRPbiddLnVwKTtcclxuICAgICAgICAgICAgdmFyIHRleHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBcIkF1ZGlvIE9mZlwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBcIkF1ZGlvIE9uXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBidXR0b25zID0gdGhpcy50aGVtZS5idXR0b25zLmxlYXZlQ2hhdDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5idXR0b24gKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25zID0gdGhpcy50aGVtZS5idXR0b25zW3RoaXMuZGF0YS5idXR0b25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVhdmVCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbig1NjAsIDU0NywgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxlYXZlQWN0aW9uLCB0aGlzLCBidXR0b25zLm92ZXIsIGJ1dHRvbnMub3V0LCBidXR0b25zLmRvd24sIGJ1dHRvbnMudXApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0eWxlQ2hvb3NlID0gdGhpcy5nZXRGb250KFwiY2hhdE11dGVcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm11dGVUZXh0ID0gdGhpcy5nYW1lLmFkZC50ZXh0KDQ1MCwgNTIwLCB0ZXh0LCBzdHlsZUNob29zZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRDaG9pY2VUZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblkgPSBSRVNQT05TRV9TVEFSVF9ZLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ250LFxyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUNob29zZSA9IHRoaXMuZ2V0Rm9udChcImNoYXRPcHRpb25cIik7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVDaG9vc2Uud29yZFdyYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlQ2hvb3NlLndvcmRXcmFwV2lkdGggPSA3MjU7XHJcbiAgICAgICAgICAgIGZvciAoYnV0dG9uQ250ID0gMDsgYnV0dG9uQ250IDwgTUFYX0NIT0lDRVM7IGJ1dHRvbkNudCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnV0dG9uID0gdGhpcy5nYW1lLmFkZC50ZXh0KFJFU1BPTlNFX1RFWFRfWCwgbG9jYXRpb25ZLCBcImFuc3dlciB0ZXh0XCIsIHRoaXMuc3R5bGVDaG9vc2UpO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi5saW5lU3BhY2luZyA9IC02O1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb25ZICs9IGN1cnJCdXR0b24uaGVpZ2h0ICsgbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5wdXNoKGN1cnJCdXR0b24pO1xyXG4gICAgICAgICAgICAgICAgY3VyckJ1dHRvbi5hbnN3ZXJJbmRleCA9IGJ1dHRvbkNudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVGV4dEFuc3dlckJveDogZnVuY3Rpb24gKGFuc3dlclRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGFuc3dlclRleHQuYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIGFuc3dlclRleHQuYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXJUZXh0LmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYW5zd2VyVGV4dC5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXJUZXh0LmJ1dHRvbkdyYXBoaWNzID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzID0gdGhpcy5nYW1lLmFkZC5ncmFwaGljcygzMCwgYW5zd2VyVGV4dC55IC0gMyk7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmJlZ2luRmlsbCgweGZmZmZmZiwgMSk7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmRyYXdSZWN0KDIsIDAsIDczNiwgYW5zd2VyVGV4dC5oZWlnaHQgKyAxKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MuZW5kRmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNob2ljZUdyYXBoaWNzMiA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoMzAsIGFuc3dlclRleHQueSAtIDMpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljczIubGluZVN0eWxlKDIsIDB4ZmZmZmZmKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MyLmRyYXdSZWN0KDIsIDAsIDczNiwgYW5zd2VyVGV4dC5oZWlnaHQgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmlucHV0LnVzZUhhbmRDdXJzb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5pc1RvcEJ1dHRvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGNob2ljZUdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBjaG9pY2VHcmFwaGljczI7XHJcblxyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZU92ZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICBjaG9pY2VHcmFwaGljcy5ldmVudHMub25JbnB1dE91dC5hZGQodGhpcy5vbk1vdXNlT3V0LCB0aGlzKTtcclxuICAgICAgICAgICAgY2hvaWNlR3JhcGhpY3MuZXZlbnRzLm9uSW5wdXRVcC5hZGQodGhpcy5vbk1vdXNlVXAsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgYW5zd2VyVGV4dC5idXR0b25HcmFwaGljcyA9IGNob2ljZUdyYXBoaWNzO1xyXG4gICAgICAgICAgICBhbnN3ZXJUZXh0LmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoeC5pc1RvcEJ1dHRvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgeC50aW50ID0gMHhmZmQ0ODA7XHJcbiAgICAgICAgICAgICAgICB4LmJvcmRlckdyYXBoaWMudGludCA9IDB4ZmZhYTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoeC5pc1RvcEJ1dHRvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgeC50aW50ID0gMHhmZWZmZmY7XHJcbiAgICAgICAgICAgICAgICB4LmJvcmRlckdyYXBoaWMudGludCA9IDB4ZmVmZmZmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DaG9pY2UoeC5xdWVzdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5kUmVzcG9uc2U6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNvbnZlcnNhdGlvbi5yZXNwb25zZXMsIGZ1bmN0aW9uIChlYWNoUmVzcG9uc2UsIHJlc3BvbnNlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlYWNoUmVzcG9uc2UubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZWFjaFJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmRRdWVzdGlvbnM6IGZ1bmN0aW9uIChzZXROYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghc2V0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IHNldE5hbWUuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICB2YXIgcXVlc3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIF8uZWFjaChuYW1lcywgZnVuY3Rpb24gKGVhY2hOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5jb252ZXJzYXRpb24ucXVlc3Rpb25zLCBmdW5jdGlvbiAoZWFjaFF1ZXN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhY2hRdWVzdGlvbi5uYW1lID09PSBlYWNoTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbnMucHVzaChlYWNoUXVlc3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXN0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvcHVsYXRlQ2hvaWNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcXVlc3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hCdWJibGUuc2hvd1Jlc3BvbnNlKHRoaXMuY3VycmVudFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNwb25zZS50cmlnZ2Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9ucyA9IHRoaXMuZmluZFF1ZXN0aW9ucyh0aGlzLmN1cnJlbnRSZXNwb25zZS50cmlnZ2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBSRVNQT05TRV9TVEFSVF9ZO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHF1ZXN0aW9ucyA9IF8uc2h1ZmZsZShxdWVzdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChxdWVzdGlvbnMsIGZ1bmN0aW9uIChlYWNoUXVlc3Rpb24sIHF1ZXN0aW9uSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVhY2hRdWVzdGlvbi5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbcXVlc3Rpb25JbmRleF0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5zZXRUZXh0KGVhY2hRdWVzdGlvbi50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5oZWlnaHQgKyBtYXJnaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRleHRBbnN3ZXJCb3godGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLmJ1dHRvbkdyYXBoaWNzLnF1ZXN0aW9uID0gZWFjaFF1ZXN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmNvbXBsZXRlZCwgZnVuY3Rpb24oZWFjaENvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHByZWZpeC5zdGFydHNXaXRoKGVhY2hDb21wbGV0ZWQpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW3F1ZXN0aW9uSW5kZXhdLmFkZENvbG9yKENPTE9SX1ZJU0lURURfT1BUSU9OLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1txdWVzdGlvbkluZGV4XS5hZGRDb2xvcihDT0xPUl9BQ1RJVkVfT1BUSU9OLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBsb29wID0gTUFYX0NIT0lDRVMgLSAxOyBsb29wID49IHF1ZXN0aW9ucy5sZW5ndGg7IGxvb3AtLSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvbnNbbG9vcF0uYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbbG9vcF0uYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tsb29wXS5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2xvb3BdLmJ1dHRvbkdyYXBoaWNzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlICYmIHRoaXMuY3VycmVudFJlc3BvbnNlLnRleHQgJiYgdGhpcy5jdXJyZW50UmVzcG9uc2UudGV4dC5hdWRpbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHsgXCJhdWRpb1wiOiB0aGlzLmN1cnJlbnRSZXNwb25zZS50ZXh0LmF1ZGlvfTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcDtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMudGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gdGhpcy50ZXh0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1dHRvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMuYnV0dG9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAuYnV0dG9uR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmJ1dHRvbkdyYXBoaWNzLmJvcmRlckdyYXBoaWMuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAuYnV0dG9uR3JhcGhpY3MuYm9yZGVyR3JhcGhpYyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5idXR0b25HcmFwaGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5idXR0b25HcmFwaGljcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmdJbWFnZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydHJhaXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnRyYWl0TGFiZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVjaEJ1YmJsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvb3NlTGFiZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNob2ljZUdyYXBoaWNzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxlYXZlQnV0dG9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlVGV4dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiOiB0aGlzLnRoZW1lLmNoYXQuZXhpdH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKGV2ZW50RGF0YSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTXV0ZUFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5pc011dGVkID0gIXRoaXMuaXNNdXRlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IFwiQXVkaW8gT2ZmXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJBdWRpbyBPblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7XCJtdXRlX2dhbWVcIjogdGhpcy5pc011dGVkID8gXCJtdXRlX29uXCIgOiBcIm11dGVfb2ZmXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSAhdGhpcy5pc011dGVkO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24udmlzaWJsZSA9IHRoaXMuaXNNdXRlZDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlVGV4dC5zZXRUZXh0KHRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DaG9pY2U6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIjogdGhpcy50aGVtZS5jaGF0LnNvdW5kfTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBldmVudERhdGEpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmJyYW5jaGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlZC5wdXNoKGRhdGEuYnJhbmNoZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5vYmplY3RpdmVNZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhclNldFtkYXRhLm9iamVjdGl2ZU1ldF0gPSBcImNvbXBsZXRlXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHZhclNldCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZSA9IHRoaXMuZmluZFJlc3BvbnNlKGRhdGEucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNob2ljZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlU2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gZGF0YS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFsdWVTZXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhdEFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGUgY3VzdG9tIGZpbGUgY2FiaW5ldCBkcmFnIGFjdG9yLiBEcmFnZ2VkIGFyb3VuZCB0aGUgc2NyZWVuLCByZXByZXNlbnRlZCBieSBpbWFnZSwgaGFzIGhlYWRpbmcgYW5kIHRleHQuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgZGVjb3JhdGlvbiBhY3RvciwgYSBzaW1wbGUgaW1hZ2U6XHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcInBvcnRyYWl0MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJkcmFnXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLlxyXG4gKiAgICAgXCJpbWFnZXNcIjogeyBcIm5vcm1hbFwiIDogXCJwaG9uZVwiLCAvLyB0aGUgaW1hZ2VzIHRvIHVzZSBmcm9tIHRoZSBpbWFnZXMgc2VjdGlvbiB0aGUgdGhlbWUuXHJcbiAqICAgICAgICAgICAgICAgICBcImRyYWdnaW5nXCIgOiBcInBob25lXCIsIC8vIG9wdGlvbmFsIGltYWdlIHdoaWxlIGRyYWdnaW5nXHJcbiAqICAgICAgICAgICAgICAgICBcIm92ZXJsYXBcIiA6IFwicGhvbmVcIiwgLy8gb3B0aW9uYWwgaW1hZ2Ugd2hlbiBvdmVybGFwcGluZy5cclxuICogICAgIFwia2V5XCI6IFwic29tZXRoaW5nXCIsIC8vIGFuIG9wdGlvbmFsIGtleSB0byBsb29rIHVuZGVyIGZvciB0aGUgaW1hZ2UocykuXHJcbiAqICAgICBcImxvY2F0aW9uXCI6IFsgeCwgeSBdLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInN0cmluZ1wiIC8vIG5hbWUgb2YgdmFyaWFibGUgdG8gYmUgc2V0IHdoZW4gdGhpcyBpcyBkcmFnZ2luZy9kcm9wcGVkL2V0Yy5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBJdHNVckNob2ljZURyYWdBY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJsb2NhdGlvblwiLCBcImltYWdlc1wiLCBcInZhcmlhYmxlXCIgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQWN0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5pc092ZXJsYXBwaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCB7IGF1ZGlvOiB0aGlzLmRhdGEuYXVkaW8sIGtleTogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy5nZXRJbWFnZSggdGhpcy5nZXRGcmFtZSgpLCB0aGlzLmRhdGEua2V5KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5waHlzaWNzLmVuYWJsZShzcHJpdGUsIFBoYXNlci5QaHlzaWNzLkFSQ0FERSk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5ib2R5LnNldFNpemUoIDEsIDEsICBzcHJpdGUud2lkdGgvMiwgc3ByaXRlLmhlaWdodC8yKTtcclxuICAgICAgICAgICAgc3ByaXRlLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwcml0ZS5pbnB1dC5waXhlbFBlcmZlY3RPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3ByaXRlLmlucHV0LmVuYWJsZURyYWcoZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBzcHJpdGUuZXZlbnRzLm9uRHJhZ1N0b3AuYWRkKHRoaXMuaXRlbURyYWdTdG9wLCB0aGlzKTtcclxuICAgICAgICAgICAgc3ByaXRlLmV2ZW50cy5vbkRyYWdTdGFydC5hZGQodGhpcy5pdGVtRHJhZ1N0YXJ0LCB0aGlzKTtcclxuICAgICAgICAgICAgc3ByaXRlLmV2ZW50cy5vbkRyYWdVcGRhdGUuYWRkKGZ1bmN0aW9uIChzcHJpdGUsIHBvaW50ZXIsIHgsIHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBzcHJpdGUuZ2FtZS5pbnB1dC5nZXRMb2NhbFBvc2l0aW9uKHNwcml0ZS5wYXJlbnQsIHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS54ID0gcG9zLnggLSBzcHJpdGUud2lkdGgvMjtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUueSA9IHBvcy55IC0gc3ByaXRlLmhlaWdodC8yO1xyXG5cclxuICAgICAgICAgICAgfSwgc3ByaXRlKTtcclxuICAgICAgICAgICAgc3ByaXRlLm9yaWdMb2MgPSBbIHNwcml0ZS54LCBzcHJpdGUueV07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvbnRIZWFkZXJOYW1lLCBmb250Qm9keU5hbWU7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEudGV4dERhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dERhdGEgPSB0aGlzLmRhdGEudGV4dERhdGE7XHJcbiAgICAgICAgICAgICAgICBmb250SGVhZGVyTmFtZSA9IHRleHREYXRhLmZvbnRIZWFkaW5nO1xyXG4gICAgICAgICAgICAgICAgZm9udEJvZHlOYW1lID0gdGV4dERhdGEuZm9udEJvZHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlclN0eWxlID0gdGhpcy5nZXRGb250KCh0eXBlb2YgZm9udEhlYWRlck5hbWUgIT09ICd1bmRlZmluZWQnKSA/IGZvbnRIZWFkZXJOYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlTdHlsZSA9IHRoaXMuZ2V0Rm9udCgodHlwZW9mIGZvbnRCb2R5TmFtZSAhPT0gJ3VuZGVmaW5lZCcpID8gZm9udEJvZHlOYW1lIDogXCJxdWVzdGlvblRleHRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkaW5nU3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KDgsIDgsIHRleHREYXRhLmhlYWRpbmcsIHRoaXMuaGVhZGVyU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3ByaXRlID0gdGhpcy5nYW1lLmFkZC50ZXh0KDksIDM1LCB0ZXh0RGF0YS5ib2R5LCB0aGlzLmJvZHlTdHlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuYWRkQ2hpbGQodGhpcy5oZWFkaW5nU3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFkZENoaWxkKHRoaXMuYm9keVNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYW5nbGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmdsZSA9IHRoaXMuZGF0YS5hbmdsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJldHVyblRvSG9tZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXRlbURyYWdTdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlKCk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbXCJkcm9wcGVkXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG4gICAgICAgICAgICAvLyBJdCB3aWxsIGhhdmUgYmVlbiBkcm9wcGVkLCBhbmQgcG9zc2libHkgcmVtb3ZlZCBmcm9tIHNjZW5lLlxyXG4gICAgICAgICAgICBpZiggdGhpcy5zcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0gdGhpcy5zcHJpdGUub3JpZ0xvY1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnNwcml0ZS5vcmlnTG9jWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpdGVtRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoICkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICB7IGF1ZGlvOiB0aGlzLmRhdGEuYXVkaW8sIGtleTogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7fTtcclxuICAgICAgICAgICAgdGVtcFtcImRyYWdnaW5nXCJdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hHYW1lQ2hvaWNlKHRlbXApO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS54ID0gdGhpcy5nYW1lLmlucHV0LmFjdGl2ZVBvaW50ZXIucG9zaXRpb24ueCAtIDEwO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5ib2R5LnggPSB0aGlzLmdhbWUuaW5wdXQuYWN0aXZlUG9pbnRlci5wb3NpdGlvbi54IC0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLmdhbWUuaW5wdXQuYWN0aXZlUG9pbnRlci5wb3NpdGlvbi55IC0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmJvZHkueSA9IHRoaXMuZ2FtZS5pbnB1dC5hY3RpdmVQb2ludGVyLnBvc2l0aW9uLnkgLSAxMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEZyYW1lOiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmcmFtZU5hbWUgPSB0aGlzLmRhdGEuaW1hZ2VzLm5vcm1hbDtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gXCJvdmVybGFwXCIgJiYgdGhpcy5kYXRhLmltYWdlcy5vdmVybGFwICkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVOYW1lID0gdGhpcy5kYXRhLmltYWdlcy5vdmVybGFwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoICh0eXBlID09PSBcImRyYWdnaW5nXCIgfHwgIWZyYW1lTmFtZSkgJiYgdGhpcy5kYXRhLmltYWdlcy5kcmFnZ2luZyApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lTmFtZSA9IHRoaXMuZGF0YS5pbWFnZXMuZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZyYW1lTmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZUltYWdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGZyYW1lO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5oZWFkaW5nU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkaW5nU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keVNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNPdmVybGFwcGluZyAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5nZXRGcmFtZShcIm92ZXJsYXBcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdGhpcy5pc0RyYWdnaW5nID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzLmdldEZyYW1lKFwiZHJhZ2dpbmdcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoXCJub3JtYWxcIik7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5oZWFkaW5nU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGluZ1Nwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlTcHJpdGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuZnJhbWVOYW1lID0gdGhpcy5nZXRJbWFnZSggZnJhbWUsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5ib2R5LnNldFNpemUoIDEsIDEsICB0aGlzLnNwcml0ZS53aWR0aC8yLCB0aGlzLnNwcml0ZS5oZWlnaHQvMik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRCb2R5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlLmJvZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk92ZXJsYXBwaW5nOiBmdW5jdGlvbiggb3RoZXJBY3RvciApIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNPdmVybGFwcGluZyA9PT0gb3RoZXJBY3RvciApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzT3ZlcmxhcHBpbmcgPSBvdGhlckFjdG9yO1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdG8gb3ZlcmxhcHBpbmcgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXQuZGlzYWJsZURyYWcoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlLmJvZHkuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuZXZlbnRzLm9uRHJhZ1N0b3AucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5ldmVudHMub25EcmFnU3RhcnQucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5ldmVudHMub25EcmFnVXBkYXRlLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmhlYWRpbmdTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmdTcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJdHNVckNob2ljZURyYWdBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIG1hcCBhY3Rvci5cclxuICpcclxuICogQ3JlYXRpbmcgYSBtYXAgYWN0b3I6XHJcbiAqXHJcbiAqIHtcclxuICogICAgIFwibmFtZVwiOiBcIm1hbmR5XCIsIC8vIGEgdW5pcXVlIGlkZW50aWZpZXJcclxuICogICAgIFwidHlwZVwiOiBcIml1Y21hcFwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS5cclxuICogICAgIFwidmFyaWFibGVcIjogXCJsb2NhdGlvbkNob2ljZVwiXHJcbiAqICAgICBcIm5pZ2h0XCI6IHRydWUsIC8vIG1ha2VzIGl0IG5pZ2h0LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gKiB9XHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBMYXJnZUJpcmQgPSByZXF1aXJlKCcuL21hcC9hY3Rvci1iaXJkLWxhcmdlJyk7XHJcbiAgICB2YXIgU21hbGxCaXJkID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItYmlyZC1zbWFsbCcpO1xyXG4gICAgdmFyIEJhc2ljQ2FyID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItY2FyLWJhc2ljJyk7XHJcbiAgICB2YXIgWWVsbG93Q2FyID0gcmVxdWlyZSgnLi9tYXAvYWN0b3ItY2FyLXllbGxvdycpO1xyXG5cclxuICAgIHZhciBFWFRSQV9XQUlUX1RJTUUgPSA4MDAwO1xyXG5cclxuICAgICB2YXIgTWFwQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpcyBub3cgaW4gYmFzZSBjbGFzcyFcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuYW5pbWF0aW9ucy5wbGF5KCd3YXZlJywgMjQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnVzRmxhZy5hbmltYXRpb25zLnBsYXkoJ3dhdmUnLCAyNCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwVGltZXIuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMuZ2V0SW1hZ2UoXCJjaXR5bWFwXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5ob3VzZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLnRoZW1lLm1hcEluZm8uYnVpbGRpbmdzLCBmdW5jdGlvbiggYnVpbGRpbmcsIGJ1aWxkaW5nSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuc3ByaXRlKGJ1aWxkaW5nLngsIGJ1aWxkaW5nLnksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgYnVpbGRpbmcuaW1hZ2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gYnVpbGRpbmcuaG92ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZS5hZGQuc3ByaXRlKGxhYmVsLngsIGxhYmVsLnksIHRoaXMudGhlbWUudGV4dHVyZUtleSwgbGFiZWwuaW1hZ2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uY2xpY2tWYWx1ZSA9IGJ1aWxkaW5nLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaG91c2VzW2J1aWxkaW5nSW5kZXhdLmlzQnVpbGRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uYnVpbGRpbmdJbmRleCA9IGJ1aWxkaW5nSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uaW5wdXQudXNlSGFuZEN1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5ldmVudHMub25JbnB1dE92ZXIuYWRkKHRoaXMub25Nb3VzZU92ZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VzZXNbYnVpbGRpbmdJbmRleF0uZXZlbnRzLm9uSW5wdXRPdXQuYWRkKHRoaXMub25Nb3VzZU91dCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXNlc1tidWlsZGluZ0luZGV4XS5ldmVudHMub25JbnB1dFVwLmFkZCh0aGlzLm9uTW91c2VVcCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibHVlRmxhZyA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCAxODAsIDcwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUubWFwSW5mby5ibHVlRmxhZ0ZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuYW5pbWF0aW9ucy5hZGQoJ3dhdmUnLCB0aGlzLnRoZW1lLm1hcEluZm8uYmx1ZUZsYWdGcmFtZXMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXNGbGFnID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIDE4MCwgMzgsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5tYXBJbmZvLnVzRmxhZ0ZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMudXNGbGFnLmFuaW1hdGlvbnMuYWRkKCd3YXZlJywgdGhpcy50aGVtZS5tYXBJbmZvLnVzRmxhZ0ZyYW1lcyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zbWFsbEJpcmQgPSBuZXcgU21hbGxCaXJkKHRoaXMuZ2FtZSwgdGhpcy50aGVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFyZ2VCaXJkID0gbmV3IExhcmdlQmlyZCh0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhciA9IG5ldyBCYXNpY0Nhcih0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhciA9IG5ldyBZZWxsb3dDYXIodGhpcy5nYW1lLCB0aGlzLnRoZW1lKTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbEJpcmQuZXZlbnRzLnBsYXlBdWRpby5hZGQodGhpcy5vblN1YlNwZWVjaCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFyZ2VCaXJkLmV2ZW50cy5wbGF5QXVkaW8uYWRkKHRoaXMub25TdWJTcGVlY2gsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci5ldmVudHMucGxheUF1ZGlvLmFkZCh0aGlzLm9uU3ViU3BlZWNoLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZXZlbnRzLnBsYXlBdWRpby5hZGQodGhpcy5vblN1YlNwZWVjaCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZnID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLmdldEltYWdlKFwiY2l0eW1hcGZnXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEubmlnaHQgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUgPSBuZXcgUGhhc2VyLlNwcml0ZSh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmFkZENoaWxkKGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCggMHgwMDAwMDAsIDAuMzUgKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KCAwLCAwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tlclNwcml0ZS5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tlclNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5sYWJlbHMsIGZ1bmN0aW9uKCBlYWNoTGFiZWwgKSB7XHJcbiAgICAgICAgICAgICAgICBlYWNoTGFiZWwuc2NhbGUuc2V0VG8oMC44MCwwLjgwKTtcclxuICAgICAgICAgICAgICAgIGVhY2hMYWJlbC5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgICAgICBlYWNoTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFwVGltZXIgPSB0aGlzLmdhbWUudGltZS5jcmVhdGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFRpbWVyLmxvb3AoRVhUUkFfV0FJVF9USU1FLCB0aGlzLnNob3dFeHRyYU9uTWFwLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICBvblN1YlNwZWVjaDogZnVuY3Rpb24obmFtZSwgc3BlZWNoKSB7XHJcbiAgICAgICAgICAgICBpZiggbmFtZSAmJiBzcGVlY2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3BhdGNoKG5hbWUsIHNwZWVjaCk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIG9uR2FtZVNwZWVjaDogZnVuY3Rpb24oc3BlZWNoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdGhpbmcuXHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIHNob3dFeHRyYU9uTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICB2YXIgcmFuZG9tVmFsdWUgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDAsIDQpO1xyXG4gICAgICAgICAgICAgc3dpdGNoIChyYW5kb21WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgIGNhc2UgMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmxhcmdlQmlyZC5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgIGNhc2UgMToge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnNtYWxsQmlyZC5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIucGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgIGNhc2UgMzoge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmRvbUNhci5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICBpZiAoeC5pc0J1aWxkaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHNbeC5idWlsZGluZ0luZGV4XS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgIGlmICh4LmlzQnVpbGRpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsc1t4LmJ1aWxkaW5nSW5kZXhdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSxcclxuICAgICAgICAgb25Nb3VzZVVwOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgaWYgKHguaXNCdWlsZGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgICB2YXJTZXRbdGhpcy5kYXRhLnZhcmlhYmxlXSA9IHguY2xpY2tWYWx1ZTtcclxuICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIC8vIHRoaXMub25DaG9pY2UoeC5xdWVzdGlvbik7XHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5iZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5mZyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkZXN0cm95QnVpbGRpbmcgPSB0aGlzLmhvdXNlcy5wb3AoKTtcclxuICAgICAgICAgICAgd2hpbGUoIGRlc3Ryb3lCdWlsZGluZyApIHtcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3lCdWlsZGluZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBkZXN0cm95QnVpbGRpbmcgPSB0aGlzLmhvdXNlcy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvdXNlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBkZXN0cm95TGFiZWwgPSB0aGlzLmxhYmVscy5wb3AoKTtcclxuICAgICAgICAgICAgd2hpbGUoIGRlc3Ryb3lMYWJlbCApIHtcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3lMYWJlbC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBkZXN0cm95TGFiZWwgPSB0aGlzLmxhYmVscy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YXIgZGVzdHJveVR3ZWVuID0gdGhpcy5hbGxUd2VlbnMucG9wKCk7XHJcbiAgICAgICAgICAgIC8vIHdoaWxlKCBkZXN0cm95VHdlZW4gKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBkZXN0cm95VHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy5nYW1lLnR3ZWVucy5yZW1vdmUoZGVzdHJveVR3ZWVuKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB0aGlzLmdhbWUudHdlZW5zLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ZUZsYWcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVzRmxhZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc21hbGxCaXJkLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5sYXJnZUJpcmQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXBUaW1lci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLm5pZ2h0ID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXBBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIHBob25lIGJ1dHRvbiBhY3Rvci4gVGhpcyBhY3RvciBpcyB1c2VkIGZvciBvcGVuaW5nIHRoZSBwaG9uZSBhbmQgc2hvd2luZyBwaG9uZSBhbGVydHMuXHJcbiAqXHJcbiAqIENyZWF0aW5nIGEgcGhvbmUgYnV0dG9uIGFjdG9yOlxyXG4gKiB7XHJcbiAqICAgICBcIm5hbWVcIjogXCJwaG9uZTFcIiwgLy8gYSB1bmlxdWUgaWRlbnRpZmllclxyXG4gKiAgICAgXCJ0eXBlXCI6IFwiaXVjcGhvbmUtYnV0dG9uXCIsIC8vIHRoZSByZXF1aXJlZCB0eXBlLipcclxuICogICAgIFwibG9jYXRpb25cIjogWyB4LCB5IF0sXHJcbiAqICAgICBcImFsZXJ0XCI6IGFueSB2YWx1ZSAvLyBwaG9uZSB3aWxsIGFsZXJ0IGltbWVkaWF0ZWx5LlxyXG4gKiB9XHJcbiAqXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XHJcblxyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmVCdXR0b25BY3RvciA9IEFjdG9yLmV4dGVuZCgge1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwibG9jYXRpb25cIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBbGVydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmFsZXJ0ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkdhbWVDaG9pY2UoIHsgJ3Bob25lX2FsZXJ0JzogdGhpcy5kYXRhLmFsZXJ0IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZEFjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25BbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmRhdGEubG9jYXRpb25bMF0sIHRoaXMuZGF0YS5sb2NhdGlvblsxXSAsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAsIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLmJ1dHRvbnMucGhvbmUub3ZlciwgdGhpcy50aGVtZS5idXR0b25zLnBob25lLm91dCxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUuYnV0dG9ucy5waG9uZS5kb3duLCB0aGlzLnRoZW1lLmJ1dHRvbnMucGhvbmUudXApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGNob2ljZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuICAgICAgICAgICBpZiggY2hvaWNlWydwaG9uZV9hbGVydCddICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FsZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QWxlcnQoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5IHRoZSByaW5nIGFuaW1hdGlvbiBhbmQgY3VycmVudCByaW5nIHRvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGxheUFsZXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYnV0dG9uQW5pbWF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkFuaW1hdGlvbiA9IHRoaXMuYnV0dG9uLmFuaW1hdGlvbnMuYWRkKCdyaW5nJywgdGhpcy50aGVtZS5waG9uZS5hbGVydHMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnBsYXkoJ3JpbmcnLCAyNCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMudGhlbWUucGhvbmUucmluZ3RvbmUsIFwicHJpb3JpdHlcIjogXCJzZnhcIiB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRoZSBwbGF5ZXIgY2xpY2tzIHRoZSBwaG9uZSBidXR0b24sIHN0b3AgYW55IGFsZXJ0IGFuZCB0aGVuIHNlbmQgb3V0IHRoZSBnYW1lIGNob2ljZS5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB0aGlzLmlzQWxlcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hbmltYXRpb25zLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgdmFyU2V0WydzaG93X2NlbGxfcGhvbmUnXSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYnV0dG9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSXRzVXJDaG9pY2VQaG9uZUJ1dHRvbkFjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA5LzIyLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsaXplZCBhY3RvciBmb3IgdXNlIHdpdGggV2VsY29tZSBUbyBXZXN0cG9zdCBhbmQgSXRzIFVSIENob2ljZSEgaXQgc2hvd3MgYSBjZWxsIHBob25lIHRoYXRcclxuICogc2VuZHMgb3V0IHNwZWNpYWwgZXZlbnRzLCByZXNwb25kcyB0byBldmVudHMsIGFuZCBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgdXNlciBieSBkcmF3aW5nIG92ZXIgdGhlIHNjZW5lLlxyXG4gKiBUaGUgdXNlciBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgcGhvbmUsIHdoaWNoIG11c3QgYmxvY2sgdXNlciBpbnB1dC5cclxuICpcclxuICogIHtcclxuICogICAgIFwibmFtZVwiOiBcInBob25lXzFcIixcclxuICogICAgIFwidHlwZVwiOiBcIml1Y3Bob25lXCIsXHJcbiAqICAgICBcImhlbHBWYXJpYWJsZVwiOiBcImN1cnJlbnRfaGVscF9tZXNzYWdlXCIsXHJcbiAqICAgICBcIm9iamVjdGl2ZXNcIjoge1xyXG4gKiAgICAgICBcIm9iajFcIjogXCJFeHBsb3JlIFdlc3Rwb3J0XCIsXHJcbiAqICAgICAgIFwib2JqMlwiOiBcIlRyeSBvdXQgeW91ciBjZWxsIHBob25lIGFuZCBqb3VybmFsLlwiXHJcbiAqICAgICB9LFxyXG4gKiAgICAgZGlzYWJsZVBvd2VyOiB0cnVlfGZhbHNlLCAvLyBkZWZhdWx0cyB0byBmYWxzZSwgY2FuIGtlZXAgdGhlIHBsYXllciBmcm9tIGNsb3NpbmcgdGhlIHBob25lLlxyXG4gKiAgICAgZGVtb01vZGU6IHRydWV8ZmFsc2UgLy8gZGVmYXVsdHMgdG8gZmFsc2UuIFNob3dzIHBob25lIHNtYWxsZXIgb24gbGVmdCBzaWRlIG9mIHNjcmVlbi5cclxuICogIH1cclxuICpcclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpLFxyXG4gICAgICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuICAgIHZhciBTQ1JFRU5fWCA9IDI1ODtcclxuICAgIHZhciBTQ1JFRU5fRU5EX1ggPSA3MTI7XHJcbiAgICB2YXIgU0NSRUVOX1kgPSAzMjtcclxuICAgIHZhciBTQ1JFRU5fRU5EX1kgPSAzMTc7XHJcblxyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmUgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIGluIHBhcmVudC5cclxuICAgICAgICBnZXRSZXF1aXJlZEZpZWxkczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbIFwib2JqZWN0aXZlc1wiLCBcImhlbHBWYXJpYWJsZVwiLCBcIm9iamVjdGl2ZUF1ZGlvXCIsIFwiaGVscEF1ZGlvXCJdOyAvLyBubyByZXF1aXJlZCBmaWVsZHNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250SGVhZGVyID0gdGhpcy5nZXRGb250KCdwaG9uZUhlYWRlcicpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRCb2R5ID0gdGhpcy5nZXRGb250KCdwaG9uZUJvZHknKTtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IHRoaXMuZ2FtZS5zb3VuZC5tdXRlO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZU1hcmtlcnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEub3BlbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHtcclxuICAgICAgICAgICAgaWYoIGNob2ljZVsnc2hvd19jZWxsX3Bob25lJ10gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMucGhvbmVHcm91cC52aXNpYmxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbGlja0Nsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Bob25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZGF0YSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXJTZXRbZGF0YS52YXJpYWJsZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLmRpc3BhdGNoKHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0hlbHA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhlbHBUZXh0ID0gdGhpcy5tb2RlbEludGVyZmFjZS5nZXRWYWx1ZSh0aGlzLmRhdGEuaGVscFZhcmlhYmxlKTtcclxuICAgICAgICAgICAgdGhpcy5oaWRlT2JqZWN0aXZlcygpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLnRoZW1lLnBob25lLmJ1dHRvblNvdW5kIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lXCI6IFwiaGVscFwifSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0hlbHAoIGhlbHBUZXh0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2tNdXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNNdXRlZCA9ICF0aGlzLmlzTXV0ZWQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLnRoZW1lLnBob25lLmJ1dHRvblNvdW5kICwgXCJwcmlvcml0eVwiOiBcInNmeFwifTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICBldmVudERhdGEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhclNldCA9IHtcIm11dGVfZ2FtZVwiIDogdGhpcy5pc011dGVkID8gXCJtdXRlX29uXCIgOiBcIm11dGVfb2ZmXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goIHRoaXMuZGF0YS5uYW1lLCB2YXJTZXQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzTXV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmFuaW1hdGlvbnMucGxheSgndmlicmF0ZScsIDI0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUljb24uYW5pbWF0aW9ucy5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9mZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja09iamVjdGl2ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVIZWxwKCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMudGhlbWUucGhvbmUuYnV0dG9uU291bmQgLCBcInByaW9yaXR5XCI6IFwic2Z4XCJ9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd09iamVjdGl2ZXModGhpcy5kYXRhLm9iamVjdGl2ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZGlzYWJsZVBvd2VyID09PSB0cnVlIHx8IHRoaXMuZGF0YS5kaXNhYmxlUG93ZXIgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNsb3NlIGlzIHR1cm5lZCBvZmYgYnkgdGhpcyBmZWF0dXJlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy50aGVtZS5waG9uZS5idXR0b25Tb3VuZCAsIFwicHJpb3JpdHlcIjogXCJzZnhcIn07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy50aGVtZS5waG9uZS5idXR0b25Tb3VuZCAsIFwicHJpb3JpdHlcIjogXCJzdG9wYWxsXCJ9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwge1wicGhvbmVcIjogXCJjbG9zZWRcIn0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlUGhvbmVCdXR0b246IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSBuZXcgUGhhc2VyLkJ1dHRvbih0aGlzLmdhbWUsIDAsIDAsIHRoaXMudGhlbWUudGV4dHVyZUtleSxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZS5waG9uZS5pY29uc1trZXldWzFdLCB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBob25lLmljb25zW2tleV1bMV0sIHRoaXMudGhlbWUucGhvbmUuaWNvbnNba2V5XVswXSk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbnB1dC51c2VIYW5kQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3dpbmcgdGhlIHBob25lIGlzIGEgYml0IGNvbXBsaWNhdGVkLiBFdmVyeXRoaW5nIGhhcyB0byBiZSBicm91Z2h0IHRvIHRoZSB0b3AgaW5cclxuICAgICAgICAgKiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dQaG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEhvbWVTY3JlZW5Hcm91cCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0SGVscFdpbmRvd0dyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPYmplY3RpdmVzV2luZG93R3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZGVtb01vZGUgPT09IHRydWUgfHwgdGhpcy5kYXRhLmRlbW9Nb2RlID09PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdERlbW9WaWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEJsb2NraW5nR3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmJsb2NraW5nU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1Nwcml0ZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdTcHJpdGUuYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMucGhvbmVHcm91cCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMuaGVscEdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLndvcmxkLmJyaW5nVG9Ub3AodGhpcy5vYmplY3RpdmVzR3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2godGhpcy5kYXRhLm5hbWUsIHtcInBob25lXCI6IFwib3BlblwifSk7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzTXV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmFuaW1hdGlvbnMucGxheSgndmlicmF0ZScsIDI0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUljb24uYW5pbWF0aW9ucy5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVJY29uLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9mZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuZGF0YS5vYmplY3RpdmVzLCBmdW5jdGlvbiggb2JqZWN0aXZlLCBvYmplY3RpdmVLZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKFwiJFwiICsgb2JqZWN0aXZlS2V5KTtcclxuICAgICAgICAgICAgICAgIGlmKCBjb21wbGV0ZWQgPT09IHRydWUgfHwgY29tcGxldGVkID09PSBcInRydWVcIiB8fCBjb21wbGV0ZWQgPT09IFwiY29tcGxldGVcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdGl2ZU1hcmtlcnNbb2JqZWN0aXZlS2V5XS5mcmFtZU5hbWUgPSB0aGlzLnRoZW1lLnBob25lLmNoZWNrQm94ZXNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcInRleHRcIjogXCJcIiwgXCJhdWRpb1wiIDogdGhpcy5kYXRhLm9iamVjdGl2ZUF1ZGlvIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCAgZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXREZW1vVmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5zY2FsZS5zZXQoIDAuNSwgMC41KTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLnggPSAyOTU7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC55ID0gMTUwO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBHcm91cC55ICs9IDE0NTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAueCAtPSAzNTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAueSArPSAxNDU7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnggLT0gMzU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnNjYWxlLnNldCgwLjUsIDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnNjYWxlLnNldCgwLjUsIDAuNSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIG1haW4gc2NyZWVuLCBpbmNsdWRpbmcgYWxsIG9mIHRoZSBidXR0b25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXRIb21lU2NyZWVuR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC54ID0gdGhpcy5nYW1lLndvcmxkLmNlbnRlclg7XHJcbiAgICAgICAgICAgIHZhciBidXR0b25ZID0gMzY1O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5waG9uZUJnID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUucGhvbmUuYmFja2dyb3VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVCZy5hbmNob3Iuc2V0VG8oMC41LCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMucGhvbmVCZyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ211dGVPbicsIHRoaXMub25DbGlja011dGUsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMubXV0ZU9uQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24ueCA9IC0xMDA7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9uQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPbkJ1dHRvbi5hbmNob3Iuc2V0VG8oMC41LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT25CdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uID0gdGhpcy5jcmVhdGVQaG9uZUJ1dHRvbignbXV0ZU9mZicsIHRoaXMub25DbGlja011dGUsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMubXV0ZU9mZkJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi54ID0gLTEwMDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlT2ZmQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLm11dGVPZmZCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZU9mZkJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm11dGVJY29uID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCBTQ1JFRU5fWSArIDIsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5waG9uZS5yaW5nTW9kZS5tdXRlT2ZmKTtcclxuICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmFkZCh0aGlzLm11dGVJY29uKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRlSWNvbi5hbmltYXRpb25zLmFkZCgndmlicmF0ZScsIHRoaXMudGhlbWUucGhvbmUucmluZ01vZGUubXV0ZU9uICk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0ZUljb24ueCA9IDIyMDtcclxuICAgICAgICAgICAgdGhpcy5tdXRlSWNvbi5icmluZ1RvVG9wKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdoZWxwJywgdGhpcy5vbkNsaWNrSGVscCwgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5oZWxwQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnggPSAxMDtcclxuICAgICAgICAgICAgdGhpcy5oZWxwQnV0dG9uLnkgPSBidXR0b25ZO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEJ1dHRvbi5icmluZ1RvVG9wKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNCdXR0b24gPSB0aGlzLmNyZWF0ZVBob25lQnV0dG9uKCdvYmplY3RpdmVzJywgdGhpcy5vbkNsaWNrT2JqZWN0aXZlcywgdGhpcywgMik7XHJcbiAgICAgICAgICAgIHRoaXMucGhvbmVHcm91cC5hZGQodGhpcy5vYmplY3RpdmVzQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzQnV0dG9uLnggPSAxNTA7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0J1dHRvbi55ID0gYnV0dG9uWTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzQnV0dG9uLmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbiA9IHRoaXMuY3JlYXRlUGhvbmVCdXR0b24oJ3Bvd2VyJywgdGhpcy5vbkNsaWNrQ2xvc2UsIHRoaXMsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAuYWRkKHRoaXMuY2xvc2VCdXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLnggPSAyODA7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24ueSA9IGJ1dHRvblk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYW5jaG9yLnNldFRvKDAuNSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uYnJpbmdUb1RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnBob25lR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdEJsb2NraW5nR3JvdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlID0gdGhpcy5jcmVhdGVCbG9ja2luZ1Nwcml0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMuYmxvY2tpbmdTcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRIZWxwV2luZG93R3JvdXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gU0NSRUVOX0VORF9YIC0gU0NSRUVOX1g7XHJcbiAgICAgICAgICAgIHZhciBtYXJnaW5YID0gNTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBHcm91cC54ID0gU0NSRUVOX1g7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLnkgPSBTQ1JFRU5fWTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoZWFkaW5nVGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblgsIDEwLCBcIkhlbHBcIiwgdGhpcy5mb250SGVhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keS53b3JkV3JhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEJvZHkud29yZFdyYXBXaWR0aCA9IHdpZHRoICogMC45NTtcclxuICAgICAgICAgICAgdGhpcy5oZWxwVGV4dCA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIG1hcmdpblgsIGhlYWRpbmdUZXh0LmhlaWdodCArIDE1LCBcIkJPRFkgVEVTVFwiLCB0aGlzLmZvbnRCb2R5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLmFkZChoZWFkaW5nVGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscEdyb3VwLmFkZCh0aGlzLmhlbHBUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUhlbHAoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3dIZWxwOiBmdW5jdGlvbiAoIGJvZHkpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscFRleHQuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscFRleHQuc2V0VGV4dCggYm9keSApO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1widGV4dFwiOiBcIlwiLCBcImF1ZGlvXCIgOiB0aGlzLmRhdGEuaGVscEF1ZGlvIH07XHJcbiAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKCBldmVudERhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZUhlbHA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdE9iamVjdGl2ZXNXaW5kb3dHcm91cDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBTQ1JFRU5fRU5EX1ggLSBTQ1JFRU5fWDtcclxuICAgICAgICAgICAgdmFyIG1hcmdpblggPSA1LCBtYXJnaW5ZID0gMTA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAueCA9IFNDUkVFTl9YO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cC55ID0gU0NSRUVOX1k7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGVhZGluZ1RleHQgPSBuZXcgUGhhc2VyLlRleHQodGhpcy5nYW1lLCBtYXJnaW5YLCBtYXJnaW5ZLCBcIk9iamVjdGl2ZXNcIiwgdGhpcy5mb250SGVhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAuYWRkKGhlYWRpbmdUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxpc3Qgb3V0IHRoZSBvYmplY3RpdmVzLCB3aXRoIGljb25zLlxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGljb25zIHdoZW4gdGhlIHBob25lIGlzIHNob3duXHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBvbkdhbWVDaG9pY2UsIHdhdGNoIGZvciBvYmplY3RpdmVzLlxyXG4gICAgICAgICAgICB2YXIgZWFjaFRleHRJdGVtO1xyXG4gICAgICAgICAgICB2YXIgZWFjaENoZWNrQm94O1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFkgPSBoZWFkaW5nVGV4dC55ICsgaGVhZGluZ1RleHQuaGVpZ2h0ICsgbWFyZ2luWTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5kYXRhLm9iamVjdGl2ZXMsIGZ1bmN0aW9uKCBvYmplY3RpdmUsIG9iamVjdGl2ZUtleSkge1xyXG4gICAgICAgICAgICAgICAgZWFjaENoZWNrQm94ID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCBjdXJyZW50WSAtIDIsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5waG9uZS5jaGVja0JveGVzWzBdKTtcclxuICAgICAgICAgICAgICAgIGVhY2hUZXh0SXRlbSA9IG5ldyBQaGFzZXIuVGV4dCh0aGlzLmdhbWUsIGVhY2hDaGVja0JveC53aWR0aCArIG1hcmdpblgsIGN1cnJlbnRZLCB0aGlzLm1vZGVsSW50ZXJmYWNlLmdldFZhbHVlKG9iamVjdGl2ZSksIHRoaXMuZm9udEJvZHkpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFkgKz0gZWFjaFRleHRJdGVtLmhlaWdodCArIG1hcmdpblk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdGl2ZXNHcm91cC5hZGQoZWFjaENoZWNrQm94KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLmFkZChlYWNoVGV4dEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVNYXJrZXJzW29iamVjdGl2ZUtleV0gPSBlYWNoQ2hlY2tCb3g7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd09iamVjdGl2ZXM6IGZ1bmN0aW9uICggb2JqZWN0aXZlcyApIHtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XCJ0ZXh0XCI6IFwiXCIsIFwiYXVkaW9cIiA6IHRoaXMuZGF0YS5vYmplY3RpdmVBdWRpbyB9O1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlBdWRpbyggZXZlbnREYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhpZGVPYmplY3RpdmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0aXZlc0dyb3VwLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250SGVhZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mb250Qm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5waG9uZUdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waG9uZUdyb3VwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaGVscEdyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwR3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2JqZWN0aXZlc0dyb3VwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RpdmVzR3JvdXAuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYmxvY2tpbmdTcHJpdGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nU3ByaXRlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUJhc2VBY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSXRzVXJDaG9pY2VQaG9uZTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIElVQyBwb3B1cCBhY3Rvci4gUG9wcyB1cCBhbiBhbGVydCwgdGhhdCBkb2VzIG5vdCBibG9jayB0aGUgc2NyZWVuLiBBbGVydCBjYW4gYmUgY2xvc2VkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHBob25lIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwicG9wdXAxMVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWNwb3B1cFwiLCAvLyB0aGUgcmVxdWlyZWQgdHlwZS4qXHJcbiAqICAgICBcImhlYWRpbmdcIjogXCJUaGlzIGFyZWEgaXMgY2xvc2VkLlwiLFxyXG4gKiAgICAgXCJ0ZXh0XCI6IFwiV2UncmUgYnVzeSBib29raW5nIHNvbWVvbmUuIENvbWUgYmFjayBhbm90aGVyIGRheS5cIixcclxuICogICAgIFwiYmFja2dyb3VuZFwiOiBcIm15aW1hZ2VcIixcclxuICogICAgIFwidmFyaWFibGVcIjogXCJ4XCJcclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciB3aW5YID0gMjAwLCB3aW5ZID0gMjUwO1xyXG4gICAgdmFyIGNsb3NlWCA9IDU1MCwgY2xvc2VZID0gMzAwO1xyXG5cclxuICAgIHZhciBJdHNVckNob2ljZVBvcHVwQWN0b3IgPSBBY3Rvci5leHRlbmQoIHtcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvciBpbiBwYXJlbnQuXHJcbiAgICAgICAgZ2V0UmVxdWlyZWRGaWVsZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWyBcImhlYWRpbmdcIiwgXCJ0ZXh0XCIsIFwidmFyaWFibGVcIiBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBY3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRBY3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3B1cEdyb3VwLnggPSB3aW5YO1xyXG4gICAgICAgICAgICB0aGlzLnBvcHVwR3JvdXAueSA9IHdpblk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmdGcmFtZSA9IHRoaXMudGhlbWUucG9wdXAuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICkge1xyXG4gICAgICAgICAgICAgICAgYmdGcmFtZSA9IHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmJhY2tncm91bmQsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCBiZ0ZyYW1lICk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5iZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCAwLCA5ICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUucG9wdXAuY2xvc2VCdXR0b25bMF0sIHRoaXMudGhlbWUucG9wdXAuY2xvc2VCdXR0b25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnBvcHVwLmNsb3NlQnV0dG9uWzJdLCB0aGlzLnRoZW1lLnBvcHVwLmNsb3NlQnV0dG9uWzNdICk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5idXR0b24pO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi54ID0gdGhpcy5iZy53aWR0aCAtIHRoaXMuYnV0dG9uLndpZHRoIC0gODtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgaGVhZGluZ1N0eWxlID0gdGhpcy5nZXRGb250KCBcInBvcHVwSGVhZGluZ1wiKTtcclxuICAgICAgICAgICAgdmFyIGJvZHlTdHlsZSA9IHRoaXMuZ2V0Rm9udCggXCJwb3B1cEJvZHlcIik7XHJcblxyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmZvbnRCb2R5ICkge1xyXG4gICAgICAgICAgICAgICAgYm9keVN0eWxlID0gdGhpcy5nZXRGb250KHRoaXMuZGF0YS5mb250Qm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuZm9udEhlYWRpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nU3R5bGUgPSB0aGlzLmdldEZvbnQodGhpcy5kYXRhLmZvbnRIZWFkaW5nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRCb2R5WSA9IDUwO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmhlYWRpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLmdhbWUuYWRkLnRleHQoMTAsIDEyLCB0aGlzLmRhdGEuaGVhZGluZywgaGVhZGluZ1N0eWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5oZWFkaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRCb2R5WSA9IDY1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2FtZS5hZGQudGV4dCggMTUsIGNvbnRlbnRCb2R5WSwgdGhpcy5kYXRhLnRleHQsIGJvZHlTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5hZGQodGhpcy5ib2R5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnkgZ2FtZSBjaG9pY2UgZHVyaW5nIGFuIGFsZXJ0IHdpbGwgY2F1c2UgdGhlIHBob25lIHRvICd2aWJyYXRlJyBvbiBzY3JlZW4uXHJcbiAgICAgICAgICogQHBhcmFtIGNob2ljZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uR2FtZUNob2ljZTogZnVuY3Rpb24oIGNob2ljZSApIHsgfSxcclxuICAgICAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCggdGhpcy5kYXRhLm5hbWUsIHZhclNldCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXBHcm91cC5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVCYXNlQWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEl0c1VyQ2hvaWNlUG9wdXBBY3RvcjtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBjcmVhdGlvbiAwNy8wMS8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIElVQyBwb3B1cCBhY3Rvci4gUG9wcyB1cCBhbiBhbGVydCwgdGhhdCBkb2VzIG5vdCBibG9jayB0aGUgc2NyZWVuLiBBbGVydCBjYW4gYmUgY2xvc2VkLlxyXG4gKlxyXG4gKiBDcmVhdGluZyBhIHBob25lIGJ1dHRvbiBhY3RvcjpcclxuICoge1xyXG4gKiAgICAgXCJuYW1lXCI6IFwid2luZG93MVwiLCAvLyBhIHVuaXF1ZSBpZGVudGlmaWVyXHJcbiAqICAgICBcInR5cGVcIjogXCJpdWN3aW5kb3dcIiwgLy8gdGhlIHJlcXVpcmVkIHR5cGUuKlxyXG4gKiAgICAgXCJoZWFkaW5nXCI6IFwiRGF5IDMgQ29tcGxldGVcIixcclxuICogICAgIFwiYXVkaW9cIjogXCJhdWRpb2tleVwiLCAvLyBQbGF5IHdoZW4gd2luZG93IGlzIGluaXRpYWxsIG9wZW5lZCwgb3IgbWF4aW1pbWl6ZWQgZnJvbSBtaW4uXHJcbiAqICAgICBcInRleHRcIjogXCJXZSdyZSBidXN5IGJvb2tpbmcgc29tZW9uZS4gQ29tZSBiYWNrIGFub3RoZXIgZGF5LlwiLFxyXG4gKiAgICAgXCJ2YXJpYWJsZVwiOiBcInhcIixcclxuICogICAgIFwic2hvd0Nsb3NlXCI6IGZhbHNlfHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS5cclxuICogfVxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xyXG5cclxuICAgIHZhciBNQVhJTUlaRSA9IFwiTUFYXCI7XHJcbiAgICB2YXIgTUlOSU1JWkUgPSBcIk1JTlwiO1xyXG4gICAgdmFyIENMT1NFID0gXCJDTE9TRVwiO1xyXG5cclxuICAgIHZhciBJdHNVckNob2ljZVdpbmRvd0FjdG9yID0gQWN0b3IuZXh0ZW5kKCB7XHJcbiAgICAgICAgLy8gY29uc3RydWN0b3IgaW4gcGFyZW50LlxyXG4gICAgICAgIGdldFJlcXVpcmVkRmllbGRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsgXCJoZWFkaW5nXCIsIFwidGV4dFwiIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlclNjZW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFjdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkQWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLnkgPSAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlID0gbmV3IFBoYXNlci5TcHJpdGUodGhpcy5nYW1lLCAwLCAwKTtcclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IFBoYXNlci5HcmFwaGljcyh0aGlzLmdhbWUsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuYWRkQ2hpbGQoZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoIDB4RUZFRkVGLCAwLjc1ICk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmRyYXdSZWN0KCAwLCAwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrZXJTcHJpdGUuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLmJyaW5nVG9Ub3AoKTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5ibG9ja2VyU3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBiZ0ZyYW1lID0gdGhpcy50aGVtZS53aW5kb3cuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICkge1xyXG4gICAgICAgICAgICAgICAgYmdGcmFtZSA9IHRoaXMuZ2V0SW1hZ2UodGhpcy5kYXRhLmJhY2tncm91bmQsIHRoaXMuZGF0YS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSggMCwgMCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCBiZ0ZyYW1lICk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuYWRkKHRoaXMuYmcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb2dvID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIHRoaXMuZ2FtZS53b3JsZC53aWR0aCAtIDI1LCB0aGlzLmdhbWUud29ybGQuaGVpZ2h0IC0gMjUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUud2luZG93LmxvZ28gKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dvLmFuY2hvci5zZXRUbyggMS4wLCAxLjApO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmFkZCh0aGlzLmxvZ28pO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbkJ1dHRvblkgPSAyMDtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5zaG93Q2xvc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uID0gdGhpcy5nYW1lLmFkZC5idXR0b24odGhpcy5nYW1lLndvcmxkLndpZHRoIC0gMjUsIDIwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlQnV0dG9uLCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93LmNsb3NlQnV0dG9uWzBdLCB0aGlzLnRoZW1lLndpbmRvdy5jbG9zZUJ1dHRvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5jbG9zZUJ1dHRvblsyXSwgdGhpcy50aGVtZS53aW5kb3cuY2xvc2VCdXR0b25bM10pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5jbG9zZUJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uLmFuY2hvci5zZXRUbyggMS4wLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24uaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG1pbkJ1dHRvblkgKz0gdGhpcy5jbG9zZUJ1dHRvbi55ICsgdGhpcy5jbG9zZUJ1dHRvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemVCdXR0b24gPSB0aGlzLmdhbWUuYWRkLmJ1dHRvbiggdGhpcy5nYW1lLndvcmxkLndpZHRoIC0gMjUsXHJcbiAgICAgICAgICAgICAgICBtaW5CdXR0b25ZLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWluaW1pemVCdXR0b24sIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5taW5pbWl6ZUJ1dHRvblswXSwgdGhpcy50aGVtZS53aW5kb3cubWluaW1pemVCdXR0b25bMV0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lLndpbmRvdy5taW5pbWl6ZUJ1dHRvblsyXSwgdGhpcy50aGVtZS53aW5kb3cubWluaW1pemVCdXR0b25bM10gKTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5taW5pbWl6ZUJ1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1pemVCdXR0b24uYW5jaG9yLnNldFRvKCAxLjAsIDApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbiA9IHRoaXMuZ2FtZS5hZGQuYnV0dG9uKCB0aGlzLmdhbWUud29ybGQud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMub25NYXhpbWl6ZUJ1dHRvbiwgdGhpcyxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93Lm1heGltaXplQnV0dG9uWzBdLCB0aGlzLnRoZW1lLndpbmRvdy5tYXhpbWl6ZUJ1dHRvblsxXSxcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWUud2luZG93Lm1heGltaXplQnV0dG9uWzJdLCB0aGlzLnRoZW1lLndpbmRvdy5tYXhpbWl6ZUJ1dHRvblszXSApO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmFkZCh0aGlzLm1heGltaXplQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi5hbmNob3Iuc2V0VG8oIDEuMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4aW1pemVCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGhlYWRpbmdTdHlsZSA9IHRoaXMuZ2V0Rm9udCggXCJ3aW5kb3dIZWFkaW5nXCIpO1xyXG4gICAgICAgICAgICB2YXIgYm9keVN0eWxlID0gdGhpcy5nZXRGb250KCBcIndpbmRvd0JvZHlcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLmdhbWUuYWRkLnRleHQoIHRoaXMuZ2FtZS53b3JsZC53aWR0aCAvIDIsIDEyMCwgdGhpcy5kYXRhLmhlYWRpbmcsIGhlYWRpbmdTdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZy5hbmNob3Iuc2V0VG8oIDAuNSwgMC41KTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5hZGQodGhpcy5oZWFkaW5nKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2FtZS5hZGQudGV4dCggdGhpcy5nYW1lLndvcmxkLndpZHRoIC8gMiwgMTYwLCB0aGlzLmRhdGEudGV4dCwgYm9keVN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmFuY2hvci5zZXRUbyggMC41LCAwICk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuYWRkKHRoaXMuYm9keSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1pbmltaXplQnV0dG9uLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggY2hvaWNlICkgeyB9LFxyXG4gICAgICAgIG9uQ2xvc2VCdXR0b246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChDTE9TRSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1pbmltaXplQnV0dG9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goTUlOSU1JWkUpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltaXplKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1heGltaXplQnV0dG9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goTUFYSU1JWkUpO1xyXG4gICAgICAgICAgICB0aGlzLm1heGltaXplKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaW5pbWl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ29udGVudChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMub25NaW5Ud2VlbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk1pblR3ZWVuQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJnLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5hdWRpbyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUF1ZGlvKHsgYXVkaW86IHRoaXMuZGF0YS5hdWRpbywga2V5OiBudWxsLCBcInByaW9yaXR5XCI6IFwic3RvcFwifSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1heGltaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS53b3JsZC5icmluZ1RvVG9wKHRoaXMud2luZG93R3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLmJnLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWF4VHdlZW5Db21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25NYXhUd2VlbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVDb250ZW50KHRydWUpO1xyXG4gICAgICAgICAgICBpZiggdGhpcy5kYXRhLmF1ZGlvICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QXVkaW8oICB7IGF1ZGlvOiB0aGlzLmRhdGEuYXVkaW8sIGtleTogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGVDb250ZW50OiBmdW5jdGlvbiggdmlzaWJsZSApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkaW5nLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMubG9nby52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5jbG9zZUJ1dHRvbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24udmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5taW5pbWl6ZUJ1dHRvbi52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja2VyU3ByaXRlLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFyU2V0ID0ge307XHJcbiAgICAgICAgICAgIHZhclNldFt0aGlzLmRhdGEudmFyaWFibGVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwYXRjaCh0aGlzLmRhdGEubmFtZSwgdmFyU2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMud2luZG93R3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0dyb3VwLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmVlQmFzZUFjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJdHNVckNob2ljZVdpbmRvd0FjdG9yO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgTGFyZ2VCaXJkID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCB0aGVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMb2MgPSBbIC0xNTAsIDEwMF07XHJcbiAgICAgICAgICAgIHRoaXMuZW5kTG9jID0gWyA4NTAsIDIzNV07XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLm1hcEluZm8ubGFyZ2VCaXJkRnJhbWVzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2ZseScsIHRoaXMudGhlbWUubWFwSW5mby5sYXJnZUJpcmRGcmFtZXMgKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUuc2V0VG8oMC4zLDAuMyk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZSkudG8oIHsgeDogdGhpcy5lbmRMb2NbMF0gfSwgNDAwMCwgJ0xpbmVhcicsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3ByaXRlKS50byggeyB5OiB0aGlzLmVuZExvY1sxXSB9LCAzNTAwLCBQaGFzZXIuRWFzaW5nLkN1YmljLkluLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIHBsYXlBdWRpbzogbmV3IFBoYXNlci5TaWduYWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGxheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzUGxheWluZyApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBjcm93U291bmQgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDEsIDEwMCk7XHJcbiAgICAgICAgICAgIHZhciB3aGljaFNvdW5kID0gJ2Nyb3cnO1xyXG4gICAgICAgICAgICBpZiggY3Jvd1NvdW5kID4gMzAgKSB7XHJcbiAgICAgICAgICAgICAgICB3aGljaFNvdW5kICs9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMSwgMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcGF0Y2goXCJMYXJnZUJpcmRcIiwge3RleHQ6XCJcIiwgYXVkaW86IHdoaWNoU291bmQsIGtleTogbnVsbCwgcHJpb3JpdHk6ICdsb3cnfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuc3RhcnRMb2NbMF07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25zLnBsYXkoJ2ZseScsIDE0LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjEuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5wbGF5QXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExhcmdlQmlyZDtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFNtYWxsQmlyZCA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGFydExvYyA9IFsgODA1LCAyNV07XHJcbiAgICAgICAgICAgIHRoaXMuZW5kTG9jID0gWyAtMTAwLCA3NV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCB0aGlzLnN0YXJ0TG9jWzBdLCB0aGlzLnN0YXJ0TG9jWzFdICwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LCB0aGlzLnRoZW1lLm1hcEluZm8uc21hbGxCaXJkRnJhbWVzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYW5pbWF0aW9ucy5hZGQoJ2ZseScsIHRoaXMudGhlbWUubWFwSW5mby5zbWFsbEJpcmRGcmFtZXMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnNwcml0ZSkudG8oIHsgeDogdGhpcy5lbmRMb2NbMF0gfSwgMzAwMCwgJ0xpbmVhcicsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50d2VlbjIgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMuc3ByaXRlKS50byggeyB5OiB0aGlzLmVuZExvY1sxXSB9LCAzMDAwLCBQaGFzZXIuRWFzaW5nLkN1YmljLkluT3V0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4xLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25zLnBsYXkoJ2ZseScsIDE0LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5QXVkaW86IG5ldyBQaGFzZXIuU2lnbmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc1BsYXlpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYmlyZFNvdW5kID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgxLCAxMDApO1xyXG4gICAgICAgICAgICB2YXIgd2hpY2hTb3VuZCA9ICdiaXJkQ2hpcnAnO1xyXG4gICAgICAgICAgICBpZiggYmlyZFNvdW5kID4gMzAgKSB7XHJcbiAgICAgICAgICAgICAgICB3aGljaFNvdW5kICs9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMSwgNCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcGF0Y2goXCJzbWFsbEJpcmRcIiwge3RleHQ6XCJcIiwgYXVkaW86IHdoaWNoU291bmQsIGtleTogbnVsbCwgcHJpb3JpdHk6ICdsb3cnfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUueCA9IHRoaXMuc3RhcnRMb2NbMF07XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnN0YXJ0TG9jWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuMS5zdGFydCgpO1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuMi5zdGFydCgpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5wbGF5QXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnBsYXlBdWRpby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNtYWxsQmlyZDtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgR2VvcmdlIEZyaWNrXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyk7XHJcblxyXG4gICAgdmFyIFJBTkRPTV9DQVJfWSA9IFsgMjM5LCAyMzYsIDIyMSwgMjEwIF07XHJcbiAgICB2YXIgUkFORE9NX0NBUl9YID0gWyA4MDEsIDY2MCwgMjc3LCAtNTAgXTtcclxuXHJcbiAgICB2YXIgTGFyZ2VCaXJkID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCB0aGVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhciA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCA4MDEsIDcwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUubWFwSW5mby52ZWhpY2xlc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyLnNjYWxlLnNldFRvKDAuOCwgMC44KTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuYW5jaG9yLnNldFRvKCAwLCAxLjApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMSAgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMucmFuZG9tQ2FyKS50byggeyB5OiBSQU5ET01fQ0FSX1lbMV0sIHg6IFJBTkRPTV9DQVJfWFsxXSB9LCA1NTAwLCAgUGhhc2VyLkVhc2luZy5RdWludGljLk91dCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjIgID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnJhbmRvbUNhcikudG8oIHsgeTogUkFORE9NX0NBUl9ZWzJdLCB4OiBSQU5ET01fQ0FSX1hbMl0gfSwgNzAwMCwgIFBoYXNlci5FYXNpbmcuUXVpbnRpYy5Jbk91dCwgZmFsc2UsIDIwMDApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMS5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMyAgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMucmFuZG9tQ2FyKS50byggeyB5OiBSQU5ET01fQ0FSX1lbM10sIHg6IFJBTkRPTV9DQVJfWFszXSB9LCA0MDAwLCAgXCJMaW5lYXJcIiwgZmFsc2UsIDIwMDApO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMi5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMyk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyVHdlZW4zLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMWIgID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzLnJhbmRvbUNhcikudG8oIHsgeTogUkFORE9NX0NBUl9ZWzFdLCB4OiBSQU5ET01fQ0FSX1hbMV0gfSwgNjAwMCwgIFBoYXNlci5FYXNpbmcuUXVpbnRpYy5PdXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjJiICA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy5yYW5kb21DYXIpLnRvKCB7IHk6IFJBTkRPTV9DQVJfWVszXSwgeDogUkFORE9NX0NBUl9YWzNdIH0sIDkwMDAsICBcIkxpbmVhclwiLCBmYWxzZSwgMjAwMCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tQ2FyVHdlZW4xYi5jaGFpbih0aGlzLnJhbmRvbUNhclR3ZWVuMmIpO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMmIub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgcGxheUF1ZGlvOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNQbGF5aW5nICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIueSA9IFJBTkRPTV9DQVJfWVswXTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIueCA9IFJBTkRPTV9DQVJfWFswXTtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnZlaGljbGVzW3RoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMCwgNyldO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUNhci52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDEsIDMpID09PSAyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5kb21DYXJUd2VlbjFiLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmRvbUNhclR3ZWVuMS5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5yYW5kb21DYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMucGxheUF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8ucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wbGF5QXVkaW8uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMYXJnZUJpcmQ7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIC8vIFRoaXMgZGVmaW5lcyB0aGUgc3RhcnRpbmcgcG9pbnQgYW5kIHRoZW4gNCBzdG9wcGluZyBwb2ludHMgZm9yIHRoZSB5ZWxsb3cgY2FyLlxyXG4gICAgdmFyIFlFTExPV19DQVJfWSA9IFsgNjUwLCAyNjQsIDI0NSwgMjM3LCAyNTUgXTtcclxuICAgIHZhciBZRUxMT1dfQ0FSX1ggPSBbIDUsIDU2OSwgNTkyLCA2MDcsIDg1MCBdO1xyXG5cclxuICAgIHZhciBZZWxsb3dDYXIgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGdhbWUsIHRoZW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyID0gdGhpcy5nYW1lLmFkZC5zcHJpdGUoIDE4MCwgNzAsIHRoaXMudGhlbWUudGV4dHVyZUtleSwgdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1swXSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHdlZW5TY2FsZSA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIuc2NhbGUpLnRvKCB7eDogMC43NDYsIHk6IDAuNzN9ICwgOTAwMCwgUGhhc2VyLkVhc2luZy5RdWludGljLk91dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMSA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVsxXSwgeDogWUVMTE9XX0NBUl9YWzFdIH0sIDkwMDAsICBQaGFzZXIuRWFzaW5nLlF1aW50aWMuT3V0LCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVsyXSwgeDogWUVMTE9XX0NBUl9YWzJdIH0sIDc1MCwgIFwiTGluZWFyXCIsIGZhbHNlLCAxMDAwKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjIub25Db21wbGV0ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllbGxvd0Nhci5zY2FsZS5zZXRUbyggMS4wLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmZyYW1lTmFtZSA9IHRoaXMudGhlbWUubWFwSW5mby55ZWxsb3dDYXJGcmFtZXNbMV07XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjEuY2hhaW4odGhpcy55ZWxsb3dDYXJUd2VlbjIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjMgPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMueWVsbG93Q2FyKS50byggeyB5OiBZRUxMT1dfQ0FSX1lbM10sIHg6IFlFTExPV19DQVJfWFszXSB9LCA1MDAsICBcIkxpbmVhclwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4zLm9uQ29tcGxldGUuYWRkKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1syXTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuMi5jaGFpbih0aGlzLnllbGxvd0NhclR3ZWVuMyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnllbGxvd0NhclR3ZWVuNCA9IHRoaXMuZ2FtZS5hZGQudHdlZW4odGhpcy55ZWxsb3dDYXIpLnRvKCB7IHk6IFlFTExPV19DQVJfWVs0XSwgeDogWUVMTE9XX0NBUl9YWzRdIH0sIDMwMDAsICBcIkxpbmVhclwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4zLmNoYWluKHRoaXMueWVsbG93Q2FyVHdlZW40KTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXJUd2VlbjQub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgcGxheUF1ZGlvOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoIHRoaXMuaXNQbGF5aW5nICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5tYXBJbmZvLnllbGxvd0NhckZyYW1lc1swXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIueSA9IFlFTExPV19DQVJfWVswXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIueCA9IFlFTExPV19DQVJfWFswXTtcclxuICAgICAgICAgICAgdGhpcy55ZWxsb3dDYXIudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyVHdlZW4xLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW5TY2FsZS5zdGFydCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMueWVsbG93Q2FyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLnBsYXlBdWRpbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucGxheUF1ZGlvLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucGxheUF1ZGlvLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gWWVsbG93Q2FyO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzIxLzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIHdpbGwgY3JlYXRlIGEgdGV4dCBidWJibGUgd2l0aCBhIGdyYWRpZW50IGJhY2sgZmlsbC4gSXQgcmVwcm9kdWNlcyBhIHNlcmllcyBvZiB0ZXh0IGJ1YmJsZSBpbWFnZXNcclxuICogZnJvbSBGbGFzaCB0aGF0IHdlcmUgbmluZS1zbGljZWQuIEluIHRoaXMgY2FzZSwgdGhlIG5pbmUtc2xpY2UgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmQgd2UganVzdCByZW5kZXIgYVxyXG4gKiByb3VuZGVkIHJlY3RhbmdsZSBhcyBhIG1hc2suXHJcbiAqXHJcbiAqIFRoZSByZWN0YW5nbGUgd2lsbCBiZSBwYWRkZWQgYXJvdW5kIHRoZSBmb250LlxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZShcImJhc2Vqc1wiKTtcclxuXHJcbiAgICB2YXIgUm91bmRlZENoYXRSZWN0ID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZ2FtZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJvdW5kbmVzcyA9IDI4O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSA0NDAsIGhlaWdodCA9IDIwMDtcclxuICAgICAgICAgICAgdmFyIHggPSAxNSwgeSA9IDEwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1ggPSA2MCwgcGFkZGluZ1kgPSAyMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBidWJibGVHcm91cCA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5idWJibGUgPSBidWJibGVHcm91cDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dCwgd2hpY2ggaXMgd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlIGZvbnQuXHJcbiAgICAgICAgICAgIHZhciBmb250SGVhZGluZyA9IF8uY2xvbmVEZWVwKHRoaXMudGhlbWUuZm9udHMuY2hhdFRleHQpO1xyXG4gICAgICAgICAgICBmb250SGVhZGluZy53b3JkV3JhcFdpZHRoID0gNDYwO1xyXG4gICAgICAgICAgICB2YXIgYnViYmxlVGV4dCA9IGdhbWUuYWRkLnRleHQoKHdpZHRoLzIpICsgcGFkZGluZ1ggLCB5ICsgcGFkZGluZ1kgLCBcIk5vIHRleHQgeWV0LlwiLCBmb250SGVhZGluZyApO1xyXG4gICAgICAgICAgICBidWJibGVUZXh0LmFuY2hvci5zZXRUbygwLjUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVRleHQgPSBidWJibGVUZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVRleHQubGluZVNwYWNpbmcgPSAtNDtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudHMgPSBbJyNmZmZmZmYnLCAnI2ZmZmZmZiddO1xyXG5cclxuICAgICAgICAgICAgLy8gdmFyIGJ1YmJsZUJvcmRlclRoaW4gPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKDAsIDApO1xyXG4gICAgICAgICAgICAvLyBidWJibGVCb3JkZXJUaGluLmxpbmVTdHlsZSgyLCAweDAwMDAwMCwgMSk7XHJcbiAgICAgICAgICAgIC8vIGJ1YmJsZUJvcmRlclRoaW4uZHJhd1JvdW5kZWRSZWN0KHgrMSwgeSsxLCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpO1xyXG4gICAgICAgICAgICAvLyBidWJibGVCb3JkZXJUaGluLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGJ1YmJsZUJvcmRlclRoaW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyB0aGUgc2hhcGUgdGhhdCBjb250YWlucyB0aGUgZ3JhZGllbnRcclxuICAgICAgICAgICAgLy8gdmFyIGdyYWRpZW50Qm1wID0gdGhpcy5nYW1lLmFkZC5iaXRtYXBEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB2YXIgZ3JhZGllbnRGaWxsID0gZ3JhZGllbnRCbXAuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XHJcbiAgICAgICAgICAgIC8vIGdyYWRpZW50RmlsbC5hZGRDb2xvclN0b3AoMCwgdGhpcy5ncmFkaWVudHNbMF0pO1xyXG4gICAgICAgICAgICAvLyBncmFkaWVudEZpbGwuYWRkQ29sb3JTdG9wKDEsIHRoaXMuZ3JhZGllbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRCbXAuY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudEZpbGw7XHJcbiAgICAgICAgICAgIC8vIGdyYWRpZW50Qm1wLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIHZhciBncmFkaWVudFNwcml0ZSA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKHgsIHksIGdyYWRpZW50Qm1wKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGdyYWRpZW50U3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHZhciBncmFkaWVudE1hc2sgPSB0aGlzLmdhbWUuYWRkLmdyYXBoaWNzKDAsIDApO1xyXG4gICAgICAgICAgICAvLyBncmFkaWVudE1hc2suYmVnaW5GaWxsKDB4MDAwMDAwKTtcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRNYXNrLmRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByb3VuZG5lc3MpOyAvLyBkcmF3IGEgcm91bmRlZCByZWN0IG1hc2tcclxuICAgICAgICAgICAgLy8gZ3JhZGllbnRNYXNrLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKGdyYWRpZW50TWFzayk7XHJcblxyXG4gICAgICAgICAgICAvLyBncmFkaWVudFNwcml0ZS5tYXNrID0gZ3JhZGllbnRNYXNrOyAvLyBhcHBseSB0aGUgbWFza1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNhcnJvdCA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKCA0NTQsIDE1MCwgdGhpcy50aGVtZS50ZXh0dXJlS2V5LFwic3BlZWNoX2Fycm93LnBuZ1wiKTtcclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZUdyb3VwLmFkZChidWJibGVUZXh0KTtcclxuICAgICAgICAgICAgYnViYmxlR3JvdXAuYnJpbmdUb1RvcChidWJibGVUZXh0KTtcclxuICAgICAgICAgICAgLy8gYnViYmxlR3JvdXAuYWRkKHRoaXMuY2Fycm90KTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93UmVzcG9uc2U6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcclxuICAgICAgICAgICAgdGhpcy5idWJibGVUZXh0LnNldFRleHQoIHJlc3BvbnNlLnRleHQudGV4dCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idWJibGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUm91bmRlZENoYXRSZWN0O1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIFBhdWwgS25lbGxcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDEwLzIzLzIwMThcclxuICogQ29weXJpZ2h0IDIwMTggQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IHN1cHBvcnRzIHNldHRpbmcgdXAgVHdlZW4uICBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IEFjdG9ycy5cclxuICpcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIHZhciBUd2VlbkhlbHBlciA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZ2FtZSwgYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYoICFnYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUd2VlbkhlbHBlciByZXF1aXJlcyBnYW1lIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCAhYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlR3ZWVuSGVscGVyIHJlcXVpcmVzIGFjdG9yIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFR3ZWVuczogZnVuY3Rpb24odHdlZW5EYXRhQXJyYXksIHNwcml0ZSkge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHR3ZWVuRGF0YUFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVuRGF0YUFycmF5LCBmdW5jdGlvbih0d2VlbkRhdGEpIHsgdGhpcy5hZGRUd2Vlbih0d2VlbkRhdGEsIHNwcml0ZSk7IH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUd2Vlbih0d2VlbkRhdGFBcnJheSwgc3ByaXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVHdlZW46IGZ1bmN0aW9uKHR3ZWVuRGF0YSwgc3ByaXRlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHdlZW5zID0ge307XHJcblxyXG4gICAgICAgICAgICB2YXIgY29uZmlndXJlVHdlZW5zID0gZnVuY3Rpb24odHdlZW5EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSB0d2VlbkRhdGEuZGVsYXkgPyB0d2VlbkRhdGEuZGVsYXkgOiAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9IHR3ZWVuRGF0YS5lYXNpbmcgfHwgXCJMaW5lYXJcIjtcclxuICAgICAgICAgICAgICAgIGlmICh0d2VlbnMuc3ByaXRlVHdlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR3ZWVuRGF0YS5sb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueCA9IHR3ZWVuRGF0YS5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLnkgPSB0d2VlbkRhdGEubG9jYXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIHR3ZWVuRGF0YS5sb2NhdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgdHdlZW5EYXRhLnggYW5kIHR3ZWVuRGF0YS55IGhhcyBiZWVuIGFkZGVkIHNvIHRoYXQgZWFjaCBkaW1lbnNpb24gY2FuIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXBlbmRlbnRseSBcInR3ZWVuZWRcIiBpZiBkZXNpcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0d2VlbkRhdGEueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueCA9IHR3ZWVuRGF0YS54O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW5EYXRhLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLnkgPSB0d2VlbkRhdGEueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS5hbHBoYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLmFscGhhID0gdHdlZW5EYXRhLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLmFuZ2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuYW5nbGUgPSB0d2VlbkRhdGEuYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEucm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5yb3RhdGlvbiA9IHR3ZWVuRGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5zLnNwcml0ZVR3ZWVuLnRvKG5ld1ZhbHVlcywgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgZmFsc2UsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0d2VlbnMuc2NhbGVUd2Vlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW5EYXRhLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy54ID0gdHdlZW5EYXRhLnNjYWxlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMueSA9IHR3ZWVuRGF0YS5zY2FsZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5zLnNjYWxlVHdlZW4udG8oIG5ld1ZhbHVlcywgdHdlZW5EYXRhLnRpbWUsIGVhc2luZywgZmFsc2UsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEubG9jYXRpb24gfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLmFscGhhKVxyXG4gICAgICAgICAgICAgICAgfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLnJvdGF0aW9uKSB8fCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEuYW5nbGUpXHJcbiAgICAgICAgICAgICAgICB8fCAhXy5pc1VuZGVmaW5lZCh0d2VlbkRhdGEueCkgfHwgIV8uaXNVbmRlZmluZWQodHdlZW5EYXRhLnkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdHdlZW5zLnNwcml0ZVR3ZWVuID0gdGhpcy5nYW1lLmFkZC50d2VlbihzcHJpdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuc2NhbGUgJiYgc3ByaXRlLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0d2VlbnMuc2NhbGVUd2VlbiA9IHRoaXMuZ2FtZS5hZGQudHdlZW4oc3ByaXRlLnNjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlndXJlVHdlZW5zKHR3ZWVuRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHdlZW5EYXRhLmNoYWluZWRUd2VlbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodHdlZW5EYXRhLmNoYWluZWRUd2VlbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVuRGF0YS5jaGFpbmVkVHdlZW5zLCBjb25maWd1cmVUd2VlbnMsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZVR3ZWVucyh0d2VlbkRhdGEuY2hhaW5lZFR3ZWVucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEubG9vcCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVucywgZnVuY3Rpb24odHdlZW4pIHsgdHdlZW4ubG9vcCgpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS55b3lvKSkge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHR3ZWVucywgZnVuY3Rpb24odHdlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gTnVtYmVyKHR3ZWVuRGF0YS55b3lvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1pbGxpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ueW95byh0cnVlLCBtaWxsaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5EYXRhLnlveW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ueW95byh0cnVlLCAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR3ZWVuRGF0YS52YXJpYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IHR3ZWVucy5zcHJpdGVUd2VlbiB8fCB0d2VlbnMuc2NhbGVUd2VlbjtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJTZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXJTZXRbdHdlZW5EYXRhLnZhcmlhYmxlXSA9ICdjb21wbGV0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5kaXNwYXRjaEdhbWVDaG9pY2UodmFyU2V0KTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfLmVhY2godHdlZW5zLCBmdW5jdGlvbih0d2VlbikgeyB0d2Vlbi5zdGFydCgpOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZVR3ZWVuczogZnVuY3Rpb24oc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS50d2VlbnMucmVtb3ZlRnJvbShzcHJpdGUpO1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3ByaXRlLnNjYWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnR3ZWVucy5yZW1vdmVGcm9tKHNwcml0ZS5zY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFR3ZWVuSGVscGVyO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBGb3Igbm93LCBqdXN0IHNlcnZlIGFzIGEgcmVnaXN0cnkgZm9yIGFjdGlvbnNcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIENob2ljZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9nYW1lLWNob2ljZScpLFxyXG4gICAgICAgIFJlbW92ZUFjdG9yQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL3JlbW92ZS1hY3RvcicpLFxyXG4gICAgICAgIEFkZEFjdG9yQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL2FkZC1hY3RvcicpLFxyXG4gICAgICAgIENoZWNrT3V0Y29tZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9jaGVjay1vdXRjb21lcycpLFxyXG4gICAgICAgIENoYW5nZU9iamVjdGl2ZUFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy9jaGFuZ2Utb2JqZWN0aXZlJyksXHJcbiAgICAgICAgTWFya0NvbXBsZXRlQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL21hcmstY29tcGxldGUnKSxcclxuICAgICAgICBWYXJpYWJsZUluY3JlbWVudEFjdGlvbiA9IHJlcXVpcmUoJy4vYWN0aW9ucy92YXJpYWJsZS1pbmNyZW1lbnQnKSxcclxuICAgICAgICBNaFNjZW5lQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL21oL21oLWNoYW5nZS1zY2VuZScpLFxyXG4gICAgICAgIFNjZW5lQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb25zL2NoYW5nZS1zY2VuZScpO1xyXG5cclxuICAgIHZhciBQbGF5QWN0aW9uID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJBY3Rpb246IGZ1bmN0aW9uKCB0eXBlLCBhY3Rpb24gKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1t0eXBlXSA9IGFjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEFjdGlvbjogZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIGlmKCAhZGF0YSB8fCAhZGF0YS50eXBlIHx8ICF0aGlzLmFjdGlvbnNbZGF0YS50eXBlXSApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IHJldHJpZXZlIGFuIGFjdGlvbiB3aXRob3V0IGFuIGFjdGlvbiB0eXBlLiB7IHR5cGU6ICcuLicsIGFyZ3M6IFsuLi5dfSBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2xhenogPSB0aGlzLmFjdGlvbnNbZGF0YS50eXBlXTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjbGF6eiggZGF0YS5hcmdzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIEFjdGlvbkZhY3RvcnkgPSBuZXcgUGxheUFjdGlvbigpO1xyXG4gICAgQWN0aW9uRmFjdG9yeS5yZWdpc3RlckFjdGlvbihcImFkZC1hY3RvclwiLCBBZGRBY3RvckFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwiY2hlY2stb3V0Y29tZXNcIiwgQ2hlY2tPdXRjb21lQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJjaG9pY2VcIiwgQ2hvaWNlQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJtYXJrLWNvbXBsZXRlXCIsIE1hcmtDb21wbGV0ZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwib2JqZWN0aXZlXCIsIENoYW5nZU9iamVjdGl2ZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwicmVtb3ZlLWFjdG9yXCIsIFJlbW92ZUFjdG9yQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJzY2VuZVwiLCBTY2VuZUFjdGlvbik7XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwidmFyaWFibGVcIiwgQ2hvaWNlQWN0aW9uKTtcclxuICAgIEFjdGlvbkZhY3RvcnkucmVnaXN0ZXJBY3Rpb24oXCJ2YXJpYWJsZS1pbmNyZW1lbnRcIiwgVmFyaWFibGVJbmNyZW1lbnRBY3Rpb24pO1xyXG5cclxuICAgIC8vIE1pc3Npb24tSGVhbHRoIHNwZWNpZmljIGFjdGlvbnM6XHJcbiAgICBBY3Rpb25GYWN0b3J5LnJlZ2lzdGVyQWN0aW9uKFwibWgtc2NlbmVcIiwgTWhTY2VuZUFjdGlvbik7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBY3Rpb25GYWN0b3J5O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTUsIDA5LzA3LzIwMTdcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgcmVnaXN0cnkgYW5kIGNvbnN0cnVjdGlvbiBmYWN0b3J5IGZvciBBY3RvcnM7IHdoaWNoIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIG9uIHRoZWlyIG93biwgb25seVxyXG4gKiBmcm9tIHRoaXMgY3JlYXRpb24gcG9pbnQuIFRoaXMgY3JlYXRpb24gcG9pbnQgYWxzbyB3b3JrcyBmb3IgdmFsaWRhdGlvbiBwdXJwb3Nlcy5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpO1xyXG5cclxuICAgIC8qIEdlbmVyYWwgQWN0b3JzLCBvciByZXVzYWJsZSBhY3Jvc3MgY291cnNlcyAqL1xyXG4gICAgdmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWFuaW1hdGlvbicpO1xyXG4gICAgdmFyIEF1ZGlvID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItYXVkaW8nKTtcclxuICAgIHZhciBCbG9ja2VyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItYmxvY2tlcicpO1xyXG4gICAgdmFyIEJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWJ1dHRvbicpO1xyXG4gICAgdmFyIEJ1dHRvbkNoYXJhY3RlciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWJ1dHRvbi1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBDaGFyYWN0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBDbGlja0FuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWNsaWNrLWFuaW1hdGlvbicpO1xyXG4gICAgdmFyIERlY29yYXRpb24gPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1kZWNvcmF0aW9uJyk7XHJcbiAgICB2YXIgRHJhZyA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWRyYWcnKTtcclxuICAgIHZhciBEcmF3ID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItZHJhdycpO1xyXG4gICAgdmFyIERyb3AgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1kcm9wJyk7XHJcbiAgICB2YXIgRmFkZW91dCA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLWZhZGVvdXQnKTtcclxuICAgIHZhciBJbnB1dEZpZWxkID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItaW5wdXQtZmllbGQnKTtcclxuICAgIHZhciBJbnN0cnVjdGlvbnMgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1pbnN0cnVjdGlvbi1idWJibGUnKTtcclxuICAgIHZhciBMaW5lID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItbGluZScpO1xyXG4gICAgdmFyIE5vSW5wdXRDaGFyYWN0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci1uby1pbnB1dC1jaGFyYWN0ZXInKTtcclxuICAgIHZhciBRdWVzdGlvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXF1ZXN0aW9uJyk7XHJcbiAgICB2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3ItcmVjdGFuZ2xlJyk7XHJcbiAgICB2YXIgU3BlZWNoQnViYmxlID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0b3Itc3BlZWNoLWJ1YmJsZScpO1xyXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci10ZXh0Jyk7XHJcbiAgICB2YXIgVGV4dEJ1YmJsZSA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXRleHQtYnViYmxlJyk7XHJcbiAgICB2YXIgVGltZWxpbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci10aW1lbGluZScpO1xyXG4gICAgdmFyIFRvZ2dsZUJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXRvZ2dsZS1idXR0b24nKTtcclxuICAgIHZhciBVcmxCdXR0b25JbnZpc2libGUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci11cmwtYnV0dG9uLWludmlzaWJsZScpO1xyXG4gICAgdmFyIFVybEJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG9yLXVybC1idXR0b24nKTtcclxuICAgIHZhciBXaXN0aWEgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rvci13aXN0aWEnKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgc3BlY2lmaWNhbGx5IGZvciBJdCdzIFVSIENob2ljZSB1c2FnZSAqL1xyXG4gICAgdmFyIENoYXQgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItY2hhdCcpO1xyXG4gICAgdmFyIEl0c1VyQ2hvaWNlQm9vayA9IHJlcXVpcmUoJy4vYWN0b3JzL2l1Yy9hY3Rvci1ib29rJyk7XHJcbiAgICB2YXIgSXRzVXJDaG9pY2VEcmFnID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLWZpbGUtZHJhZycpO1xyXG4gICAgdmFyIEl0c1VyQ2hvaWNlUGhvbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItcGhvbmUnKTtcclxuICAgIHZhciBJdHNVckNob2ljZVBob25lQnV0dG9uID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLXBob25lLWJ1dHRvbicpO1xyXG4gICAgdmFyIE1hcEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcnMvaXVjL2FjdG9yLW1hcCcpO1xyXG4gICAgdmFyIFBvcHVwQWN0b3IgPSByZXF1aXJlKCcuL2FjdG9ycy9pdWMvYWN0b3ItcG9wdXAnKTtcclxuICAgIHZhciBXaW5kb3dBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3JzL2l1Yy9hY3Rvci13aW5kb3cnKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgc3BlY2lmaWNhbGx5IGZvciBBY3QgTm93ISB1c2FnZSAqL1xyXG4gICAgdmFyIEFubm91bmNlciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1hbm5vdW5jZXInKTtcclxuICAgIHZhciBDaG9pY2UgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3ItY2hvaWNlJyk7XHJcbiAgICB2YXIgQWN0Tm93UGhvbmUgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3ItcGhvbmUnKTtcclxuICAgIHZhciBQaG9uZUJ1dHRvbiA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1waG9uZS1idXR0b24nKTtcclxuICAgIHZhciBTcGlubmVyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0bm93L2FjdG9yLXNwaW5uZXInKTtcclxuICAgIHZhciBDaG9vc2VyID0gcmVxdWlyZSgnLi9hY3RvcnMvYWN0bm93L2FjdG9yLWNob29zZXInKTtcclxuICAgIHZhciBaaW5rQ29tcHV0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3Itemluay1jb21wdXRlcicpO1xyXG4gICAgdmFyIFppbmtQb3N0ZXIgPSByZXF1aXJlKCcuL2FjdG9ycy9hY3Rub3cvYWN0b3Itemluay1wb3N0ZXInKTtcclxuXHJcbiAgICB2YXIgUGxheUFjdG9yID0gQmFzZS5leHRlbmQoIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JUeXBlcyA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJBY3RvcjogZnVuY3Rpb24oIHR5cGUsIGFjdG9yICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JUeXBlcywgZnVuY3Rpb24oa25vd25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgIGlmKCBrbm93blR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBcIllvdSBhcmUgcmVnaXN0ZXJpbmcgYW4gYWN0b3IgdHlwZSB0aGF0IGFscmVhZHkgZXhpc3RzOiBcIiArIHR5cGU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JUeXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9yc1t0eXBlXSA9IGFjdG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QWN0b3I6IGZ1bmN0aW9uKCB0eXBlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RvcnNbdHlwZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0F2YWlsYWJsZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hY3RvclR5cGVzLCBmdW5jdGlvbihrbm93blR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCBrbm93blR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QXZhaWxhYmxlVHlwZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBjbG9uZSwgdG8gbWFrZSBpdCByZWFkIG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuYWN0b3JUeXBlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIEFjdG9yRmFjdG9yeSA9IG5ldyBQbGF5QWN0b3IoKTtcclxuXHJcbiAgICAvKiBHZW5lcmFsIEFjdG9ycywgb3IgcmV1c2FibGUgYWNyb3NzIGNvdXJzZXMgKi9cclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiYW5pbWF0aW9uXCIsIEFuaW1hdGlvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJhdWRpb1wiLCBBdWRpbyApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJibG9ja2VyXCIsIEJsb2NrZXIgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiYnV0dG9uXCIsIEJ1dHRvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJidXR0b24tY2hhcmFjdGVyXCIsIEJ1dHRvbkNoYXJhY3RlciApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJjaGFyYWN0ZXJcIiwgQ2hhcmFjdGVyKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiY2xpY2stYW5pbWF0aW9uXCIsIENsaWNrQW5pbWF0aW9uKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiZGVjb3JhdGlvblwiLCBEZWNvcmF0aW9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImRyYWdcIiwgRHJhZyApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJkcmF3XCIsIERyYXcgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiZHJvcFwiLCBEcm9wICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImZhZGVvdXRcIiwgRmFkZW91dCApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpbnB1dC1maWVsZFwiLCBJbnB1dEZpZWxkICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImluc3RydWN0aW9uc1wiLCBJbnN0cnVjdGlvbnMgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwibGluZVwiLCBMaW5lICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcIm5vLWlucHV0LWNoYXJhY3RlclwiLCBOb0lucHV0Q2hhcmFjdGVyICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInJlY3RhbmdsZVwiLCBSZWN0YW5nbGUpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJzcGVlY2gtYnViYmxlXCIsIFNwZWVjaEJ1YmJsZSk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRleHRcIiwgVGV4dCk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRleHQtYnViYmxlXCIsIFRleHRCdWJibGUpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJ0aW1lbGluZVwiLCBUaW1lbGluZSk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInRvZ2dsZS1idXR0b25cIiwgVG9nZ2xlQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInVybC1idXR0b25cIiwgVXJsQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInVybC1idXR0b24taW52aXNpYmxlXCIsIFVybEJ1dHRvbkludmlzaWJsZSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJxdWVzdGlvblwiLCBRdWVzdGlvbik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInZpZGVvXCIsIFdpc3RpYSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJ3aXN0aWFcIiwgV2lzdGlhICk7XHJcblxyXG4gICAgLyogQWN0b3JzIHNwZWNpZmljYWxseSBmb3IgSXQncyBVUiBDaG9pY2UgdXNhZ2UgKi9cclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiY2hhdFwiLCBDaGF0KTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjYm9va1wiLCBJdHNVckNob2ljZUJvb2sgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjZHJhZ1wiLCBJdHNVckNob2ljZURyYWcgKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjcGhvbmVcIiwgSXRzVXJDaG9pY2VQaG9uZSApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNwaG9uZS1idXR0b25cIiwgSXRzVXJDaG9pY2VQaG9uZUJ1dHRvbiApO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNtYXBcIiwgTWFwQWN0b3IpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJpdWNwb3B1cFwiLCBQb3B1cEFjdG9yKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwiaXVjd2luZG93XCIsIFdpbmRvd0FjdG9yKTtcclxuXHJcbiAgICAvKiBBY3RvcnMgZm9yIEFjdCBOb3chIHVzYWdlICovXHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImFubm91bmNlclwiLCBBbm5vdW5jZXIpO1xyXG4gICAgQWN0b3JGYWN0b3J5LnJlZ2lzdGVyQWN0b3IoXCJjaG9pY2VcIiwgQ2hvaWNlKTtcclxuICAgIEFjdG9yRmFjdG9yeS5yZWdpc3RlckFjdG9yKFwicGhvbmUtYnV0dG9uXCIsIFBob25lQnV0dG9uICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInBob25lXCIsIEFjdE5vd1Bob25lICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInNwaW5uZXJcIiwgU3Bpbm5lcik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcImNob29zZXJcIiwgQ2hvb3Nlcik7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInppbmstY29tcHV0ZXJcIiwgWmlua0NvbXB1dGVyICk7XHJcbiAgICBBY3RvckZhY3RvcnkucmVnaXN0ZXJBY3RvcihcInppbmstcG9zdGVyXCIsIFppbmtQb3N0ZXIpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQWN0b3JGYWN0b3J5O1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA3LzAxLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBSZXByZXNlbnQgYSBcIlNjZW5lXCIgYXMgcGFydCBvZiBhbiBcIkFjdFwiLiBUaGUgc2NlbmUgY29udGFpbnMgYW4gYXJyYXkgb2YgYWN0b3JzIGFuZCBkZWFscyB3aXRoIGJyb2tlcmluZyBldmVudHMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICAgICAgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZSgnYmFzZWpzJyksXHJcbiAgICAgICAgUGxheUFjdG9yID0gcmVxdWlyZSgnLi9wbGF5LWFjdG9yJyksXHJcbiAgICAgICAgUGxheVRocm91Z2hBY3RvciA9IHJlcXVpcmUoJy4vYWN0b3JzL2FjdG5vdy9hY3Rvci1wbGF5dGhyb3VnaCcpO1xyXG5cclxuICAgIHZhciBQbGF5U2NlbmUgPSBCYXNlLmV4dGVuZCgge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihnYW1lLCBkYXRhLCBtb2RlbEludGVyZmFjZSwgdGhlbWUpIHtcclxuICAgICAgICAgICAgaWYoICFnYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJQbGF5U2NlbmUgcmVxdWlyZXMgZ2FtZSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggIWRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlBsYXlTY2VuZSByZXF1aXJlcyBkYXRhIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFNjZW5lKGdhbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIG9uR2FtZUNob2ljZTogbmV3IFBoYXNlci5TaWduYWwoKSxcclxuICAgICAgICAgICAgICAgIG9uR2FtZVNwZWVjaDogbmV3IFBoYXNlci5TaWduYWwoKSxcclxuICAgICAgICAgICAgICAgIG9uR2FtZU11c2ljOiBuZXcgUGhhc2VyLlNpZ25hbCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxJbnRlcmZhY2UgPSBtb2RlbEludGVyZmFjZTtcclxuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5pc1Nob3dQbGF5VGhyb3VnaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXl0aHJvdWdoQWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5pdFNjZW5lOiBmdW5jdGlvbihnYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvciA9IHRoaXMuZ2FtZS5hZGQuZ3JhcGhpY3MoMCwwKTtcclxuICAgICAgICAgICAgdGhpcy5iZ0NvbG9yLmJlZ2luRmlsbChcIjB4RkZGRkZGXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZHJhd1JlY3QoMCwwLCB0aGlzLmdhbWUud29ybGQud2lkdGgsIHRoaXMuZ2FtZS53b3JsZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuX2Nod19uYW1lID0gXCJTY2VuZUJhY2tncm91bmRHcmFwaGljc1wiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd05ld1NjZW5lRGF0YTogZnVuY3Rpb24oIG5ld0RhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnBsYXl0aHJvdWdoQWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXl0aHJvdWdoQWN0b3IuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVJZCA9IG5ld0RhdGEuaWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBzY2VuZSB0byB0aGUgcGxheWVyIGJ5IHNldHRpbmcgdGhlIGJhY2tncm91bmQgYW5kIGhhdmluZyBhbGwgYWN0b3JzIGVudGVyIHRoZSBzY2VuZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaG93U2NlbmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYoIHRoaXMuZGF0YS5iYWNrZ3JvdW5kICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYmFja2dyb3VuZCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuZnJhbWVOYW1lID0gdGhpcy50aGVtZS5zY2VuZUltYWdlc1t0aGlzLmRhdGEuYmFja2dyb3VuZF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCB0aGlzLnRoZW1lLnRleHR1cmVLZXksIHRoaXMudGhlbWUuc2NlbmVJbWFnZXNbdGhpcy5kYXRhLmJhY2tncm91bmRdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmlucHV0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lLmlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmJhY2tncm91bmQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmdDb2xvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmRhdGEuYWN0b3JzLCB0aGlzLmFkZEFjdG9yLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RhbnQgJ3BsYXktdGhyb3VnaCcgYWN0b3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc1Nob3dQbGF5VGhyb3VnaCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheXRocm91Z2hBY3Rvci5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmRhdGEuYmFja2dyb3VuZE11c2ljICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lTXVzaWMuZGlzcGF0Y2goIHRoaXMuZGF0YS5iYWNrZ3JvdW5kTXVzaWMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3dQbGF5VGhyb3VnaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCAhdGhpcy5wbGF5dGhyb3VnaEFjdG9yICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheXRocm91Z2hBY3RvciAgPSBuZXcgUGxheVRocm91Z2hBY3Rvcih0aGlzLmdhbWUsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5dGhyb3VnaEFjdG9yLnNldE1vZGVsSW50ZXJmYWNlKHRoaXMubW9kZWxJbnRlcmZhY2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5dGhyb3VnaEFjdG9yLmVudGVyU2NlbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzU2hvd1BsYXlUaHJvdWdoID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhbiBpbmRpdmlkdWFsIGFjdG9yIHRvIHRoZSBzY2VuZS4gVGhlIG9yZGVyaW5nIGlzIGltcG9ydGFudCwgdGhlIGFjdG9yIGlzIGNyZWF0ZWQsIHRoZW4gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICogYXJlIGFkZGVkLCBhbmQgdGhlbiB0aGUgYWN0b3IgaXMgYWxsb3dlZCB0byBlbnRlciB0aGUgc2NlbmUuIFdlIGRvbid0IHdhbnQgYW4gYWN0b3IgdGhhdCBpbW1lZGlhdGVseSBhY3RzXHJcbiAgICAgICAgICogdG8gaGF2ZSBpdHMgZXZlbnRzIGlnbm9yZWQgYmVjYXVzZSB0aGUgbGlzdGVuZXJzIHdlcmVuJ3QgeWV0IGluIHBsYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvckRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRBY3RvcjogZnVuY3Rpb24oYWN0b3JEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RvckNsYXNzLCBhY3RvciwgbmV3QWN0b3JEYXRhID0gYWN0b3JEYXRhO1xyXG4gICAgICAgICAgICAvLyBBY3RvcnMgY2FuIGFsc28gYmUgb2YgdHlwZSByZWZlcmVuY2UsIG1lYW5pbmcgdGhleSBsb2FkIGFuIGFjdG9yIGZyb20gdGhlIHNldCBvZiBhY3RvcnMgb3V0c2lkZSBzY2VuZXMuXHJcbiAgICAgICAgICAgIGlmKCBhY3RvckRhdGEudHlwZSA9PT0gXCJyZWZlcmVuY2VcIiApIHtcclxuICAgICAgICAgICAgICAgIG5ld0FjdG9yRGF0YSA9IHRoaXMubW9kZWxJbnRlcmZhY2UuZ2V0QWN0b3JCeVJlZiggYWN0b3JEYXRhLm5hbWUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWN0b3JDbGFzcyA9IFBsYXlBY3Rvci5nZXRBY3RvcihuZXdBY3RvckRhdGEudHlwZSk7XHJcbiAgICAgICAgICAgIGFjdG9yID0gbmV3IGFjdG9yQ2xhc3ModGhpcy5nYW1lLCBuZXdBY3RvckRhdGEsIHRoaXMudGhlbWUpO1xyXG4gICAgICAgICAgICBhY3Rvci5zZXRNb2RlbEludGVyZmFjZSh0aGlzLm1vZGVsSW50ZXJmYWNlKTtcclxuICAgICAgICAgICAgYWN0b3IuY2xlYXJWYXJpYWJsZXMoKTtcclxuICAgICAgICAgICAgLy8gQW55IGdpdmVuIGFjdG9yIG1heSBvciBtYXkgbm90IHB1Ymxpc2ggdGhlc2UgZXZlbnRzLlxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuZXZlbnRzLm9uR2FtZUNob2ljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50cy5vbkdhbWVDaG9pY2UuYWRkKHRoaXMub25HYW1lQ2hvaWNlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5ldmVudHMub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnRzLm9uR2FtZVNwZWVjaC5hZGQodGhpcy5vbkdhbWVTcGVlY2gsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0FjdG9yRGF0YS5zdGFydERlbGF5ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLmVudGVyU2NlbmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxheUFjdG9yID0gW107XHJcbiAgICAgICAgICAgICAgICBkZWxheUFjdG9yWzBdID0gLTE7IC8vIHN0YXJ0IHRpbWUgaW4gdGlja3MsIHRvIGJlIHNldCBpbiB0aWNrVXBkYXRlKClcclxuICAgICAgICAgICAgICAgIGRlbGF5QWN0b3JbMV0gPSBuZXdBY3RvckRhdGEuc3RhcnREZWxheTsgLy8gaW4gdGlja3MgKGEgdGljayBpcyBkZWZpbmVkIGluIG1haW4pXHJcbiAgICAgICAgICAgICAgICBkZWxheUFjdG9yWzJdID0gYWN0b3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMucHVzaChkZWxheUFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYWN0b3IgaGFzIG1hZGUgYSBjaG9pY2UsIGJ1YmJsZSB0aGlzIGV2ZW50IHVwIHRvIHRoZSAnYWN0JywgYW5kIGluZm9ybSBhbGwgb3RoZXJcclxuICAgICAgICAgKiBhY3RvcnMgb2YgdGhlIGNob2ljZSBzbyB0aGF0IHRoZXkgY2FuIGFkanVzdCBhbnkgaW50ZXJuYWwgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gY2hvaWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25HYW1lQ2hvaWNlOiBmdW5jdGlvbiggbmFtZSwgY2hvaWNlICkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVDaG9pY2UuZGlzcGF0Y2goICBjaG9pY2UgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wVmFycyA9IF8ucGFpcnMoY2hvaWNlKVswXTtcclxuICAgICAgICAgICAgY2hvaWNlLmNvbnN1bWVkID0gdGhpcy5zY2VuZUNvbW1hbmQobmFtZSwgdGVtcFZhcnNbMF0sIHRlbXBWYXJzWzFdKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCAhY2hvaWNlLmNvbnN1bWVkICkge1xyXG4gICAgICAgICAgICAgdGhpcy5zZW5kR2FtZUNob2ljZVRvQWN0b3JzKG5hbWUsIGNob2ljZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbmRHYW1lQ2hvaWNlVG9BY3RvcnM6IGZ1bmN0aW9uKG5hbWUsIGNob2ljZSkge1xyXG4gICAgICAgICAgICAvLyBUZWxsIGFueSBhY3RvcnMgd2l0aCBhIG1ldGhvZCB0byBoYW5kbGUgY2hvaWNlcy5cclxuICAgICAgICAgICAgXy5lYWNoKHRoaXMuYWN0b3JzLCBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5nZXROYW1lKCkgIT09IG5hbWUgJiYgYWN0b3Iub25HYW1lQ2hvaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3Iub25HYW1lQ2hvaWNlKGNob2ljZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUnVuIGFuIFNjZW5lIGxldmVsIGNvbW1hbmQuIFJldHVybiB0cnVlIGlmIGEgY29tbWFuZCBoYXBwZW5lZCwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb21tYW5kXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjb21tYW5kIHdhcyBjb25zdW1lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzY2VuZUNvbW1hbmQ6IGZ1bmN0aW9uKCBhY3Rvck5hbWUsIGNvbW1hbmQsIGFyZykge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIlNjZW5lIGNvbW1hbmQ6IFwiICsgY29tbWFuZCArIFwiIC8gXCIgKyBhcmcpO1xyXG4gICAgICAgICAgICBpZiggY29tbWFuZCA9PT0gXCJkcm9wcGVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiggYWN0b3IxICYmIGFjdG9yMS5nZXRUeXBlKCkgPT09IFwiZHJvcFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBhY3RvcjIuZ2V0VHlwZSgpID09PSBcImRyYWdcIiB8fCBhY3RvcjIuZ2V0VHlwZSgpID09PSBcIml1Y2RyYWdcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5nYW1lLnBoeXNpY3MuYXJjYWRlLm92ZXJsYXAoIGFjdG9yMS5nZXRQcmltYXJ5U3ByaXRlKCksIGFjdG9yMi5nZXRQcmltYXJ5U3ByaXRlKCkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjEub25SZWNlaXZlRHJvcChhY3RvcjIuZ2V0TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGxvb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBjb21tYW5kID09PSBcIm11dGVfZ2FtZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5hY3RvcnMsIGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYWN0b3IuZGF0YS5uYW1lICE9PSBhY3Rvck5hbWUgJiYgYWN0b3IuZGF0YS50eXBlID09PSBcIndpc3RpYVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5vbldpc3RpYU11dGUodGhpcy5nYW1lLnNvdW5kLm11dGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFjdG9yIGlzIHNob3dpbmcgbmV3IHRleHQgKGFuZCBwb3NzaWJseSBwbGF5aW5nIG5ldyBhdWRpbykuIHNvbWUgYWN0b3JzIGFuaW1hdGUgb3RoZXJzIHNwZWFraW5nLCBvclxyXG4gICAgICAgICAqIHNob3cgdGhlIHRleHQvYXVkaW8gdGhhdCBhbiBhY3RvciBpcyBzcGVha2luZy4gU28gYnViYmxlIHRoZSBldmVudCBhbmQgYWxzbyB0ZWxsIHRoZSBvdGhlciBhY3RvcnMuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25HYW1lU3BlZWNoOiBmdW5jdGlvbiggbmFtZSwgc3BlZWNoLCBzb3VyY2VBY3RvciApIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lU3BlZWNoLmRpc3BhdGNoKCBzcGVlY2ggKTtcclxuICAgICAgICAgICAgaWYoIHNvdXJjZUFjdG9yICYmIHNvdXJjZUFjdG9yLmlzU291bmRFdmVudEludmVyc2UoKSAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggc291cmNlQWN0b3Iub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQWN0b3Iub25HYW1lU3BlZWNoKHNwZWVjaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxsIGFueSBhY3RvcnMgd2l0aCBhIG1ldGhvZCB0byBoYW5kbGUgc3BlZWNoIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5hY3RvcnMsIGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5kYXRhLm5hbWUgIT09IG5hbWUgJiYgYWN0b3Iub25HYW1lU3BlZWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLm9uR2FtZVNwZWVjaChzcGVlY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFjdG9yLmRhdGEudHlwZSA9PT0gXCJ3aXN0aWFcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3Iub25HYW1lU3BlZWNoKHNwZWVjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3BlZWNoIHN0b3AgYWN0aW9uIGhhcyBvY2N1cmVkIGZyb20gZnVydGhlciB1cCB0aGUgY2hhaW4sIGNvbnRpbnVlIHBhc3NpbmcgaXQgZG93biB0byBlYWNoIGFjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlY2hcclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkdhbWVTcGVlY2hTdG9wOiBmdW5jdGlvbiggc3BlZWNoICkge1xyXG4gICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggYWN0b3IgJiYgYWN0b3Iub25HYW1lU3BlZWNoU3RvcCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5vbkdhbWVTcGVlY2hTdG9wKCBzcGVlY2ggKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVBY3RvckJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yKCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpbmRleCsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYWN0b3JzW2luZGV4XS5kYXRhLm5hbWUgPT09IG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IgPSB0aGlzLmFjdG9yc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKHRoaXMuYWN0b3JzW2luZGV4XS5kYXRhLm5hbWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QWN0b3IoYWN0b3IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgZGVsYXllZCBhY3RvciB0aGF0IGhhc24ndCBiZWVuIHRyaWdnZXJlZCB5ZXRcclxuICAgICAgICAgICAgICAgIGZvciggaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuZGVsYXllZEFjdG9ycy5sZW5ndGg7IGluZGV4KysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ZWRBY3RvciA9IHRoaXMuZGVsYXllZEFjdG9yc1tpbmRleF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGRlbGF5ZWRBY3Rvci5kYXRhLm5hbWUgPT09IG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yID0gZGVsYXllZEFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihkZWxheWVkQWN0b3IuZGF0YS5uYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIGFjdG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgZm9yIGRlbGF5ZWQgYWN0b3JzLiBJZiBhIGRlbGF5ZWQgYWN0b3IncyBzdGFydCB0aW1lICBpbiB0aWNrcyBoYXMgYXJyaXZlZCwgYWRkIGl0IHRvIHRoZSBzY2VuZSBhbmRcclxuICAgICAgICAgKiByZW1vdmUgaXQgZnJvbSB0aGUgZGVsYXllZCBhY3RvcnMgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFNUUk9ORyBXQVJOSU5HOiBEb24ndCBkbyBtdWNoIGhlcmUgLSBpdCdzIGNhbGxlZCBmcm9tIHRoZSBtYWluIHVwZGF0ZSBsb29wLiBBbnkgZXh0ZW5zaXZlIG9wZXJhdGlvbnMgd2lsbFxyXG4gICAgICAgICAqIGNhdXNlIHRoZSB1c2VyIGludGVyZmFjZSB0byBsYWcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGlja1VwZGF0ZTogZnVuY3Rpb24gKHRpY2spIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZGVsYXllZEFjdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXllZEFjdG9yc1tpXVswXSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFjdG9yJ3Mgc3RhcnQgdGltZSBoYXNuJ3QgYmVlbiBzZXQgeWV0LiBTZXQgaXRzIHN0YXJ0IHRpbWUgdG8gY3VycmVudCB0aWNrIHBsdXMgaXRzIGRlbGF5LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEFjdG9yc1tpXVswXSA9IHRpY2sgKyB0aGlzLmRlbGF5ZWRBY3RvcnNbaV1bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGljayA+PSB0aGlzLmRlbGF5ZWRBY3RvcnNbaV1bMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yID0gdGhpcy5kZWxheWVkQWN0b3JzW2ldWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuZGVsYXllZEFjdG9yc1tpXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgICAgICAvL2xvZy53YXJuKFwiZGVsYXllZCBhY3RvclwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgKyAoKCh0eXBlb2YgYWN0b3IuZGF0YSAhPSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIGFjdG9yLmRhdGEubmFtZSAhPSBcInVuZGVmaW5lZFwiKSkgPyAoXCIgbmFtZWQgXFxcIlwiICsgYWN0b3IuZGF0YS5uYW1lICsgXCJcXFwiXCIpIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICArICgoKHR5cGVvZiBhY3Rvci5kYXRhICE9IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgYWN0b3IuZGF0YS50eXBlICE9IFwidW5kZWZpbmVkXCIpKSA/IChcIiBvZiB0eXBlIFxcXCJcIiArIGFjdG9yLmRhdGEudHlwZSArIFwiXFxcIlwiKSA6IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgKyBcIiBlbnRlcmluZyBzY2VuZSBhZnRlciBcIiArIGRlbGF5ICsgXCIgdGlja3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZW50ZXJTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5hY3RvcnMsIGZ1bmN0aW9uKGFjdG9yMSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIGFjdG9yMS5nZXRUeXBlKCkgPT09IFwiZHJvcFwiICApIHtcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goIHRoaXMuYWN0b3JzLCBmdW5jdGlvbihhY3RvcjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGFjdG9yMi5nZXRUeXBlKCkgPT09IFwiZHJhZ1wiIHx8IGFjdG9yMi5nZXRUeXBlKCkgPT09IFwiaXVjZHJhZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHRoaXMuZ2FtZS5waHlzaWNzLmFyY2FkZS5vdmVybGFwKCBhY3RvcjEuZ2V0UHJpbWFyeVNwcml0ZSgpLCBhY3RvcjIuZ2V0UHJpbWFyeVNwcml0ZSgpKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjEub25PdmVybGFwcGluZyhhY3RvcjIuZ2V0TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yMS5vbk92ZXJsYXBwaW5nKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QWN0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuYWN0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBrZXlzIG9mIGFueSBhZGRpdGlvbmFsIGF1ZGlvIHRoaXMgc2NlbmUgd2FudHMuXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFkZGl0aW9uYWxBdWRpbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQXVkaW8gPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKCB0aGlzLmRhdGEuYWN0b3JzLCBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiggYWN0b3IuYXVkaW9LZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEF1ZGlvLnB1c2goIGFjdG9yLmF1ZGlvS2V5ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbEF1ZGlvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveUFjdG9yOiBmdW5jdGlvbiggYWN0b3IgKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyRm9yUmV1c2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0b3I7XHJcbiAgICAgICAgICAgIHdoaWxlKCBhY3RvciA9IHRoaXMuYWN0b3JzLnBvcCgpICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QWN0b3IoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgYWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIHZhciBkZWxheWVkQWN0b3JEYXRhO1xyXG4gICAgICAgICAgICB3aGlsZSggZGVsYXllZEFjdG9yRGF0YSA9IHRoaXMuZGVsYXllZEFjdG9ycy5wb3AoKSApIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gZGVsYXllZEFjdG9yRGF0YVsyXTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMub25HYW1lQ2hvaWNlLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbkdhbWVTcGVlY2gucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZU11c2ljLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJGb3JSZXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29sb3IuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuaW5wdXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZUNob2ljZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZVNwZWVjaC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uR2FtZU11c2ljLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGxheVNjZW5lO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzEwLzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBhbiBpbnRlcmZhY2UgdG8gdGhlIFNDT1JNIEFQSSBwcm92aWRlZCB2aWEgL21haW4vc2Nvcm0vQVBJV3JhcHBlci5qc1xyXG4gKiBVc2VycyBvZiB0aGlzIG1vZHVsZSBhcmUgZXhwZWN0ZWQgdG8gY2FsbCBpbml0aWFsaXplIHdpdGggYSBzZXR0aW5ncyBvYmplY3Qgb2YgYXQgbGVhc3Q6XHJcbiAqIHtcclxuICogICAgIHNjb3JtRW5hYmxlZDogdHJ1ZXxmYWxzZVxyXG4gKiB9XHJcbiAqIFlvdSBkbyBub3QgaGF2ZSB0byBlbmFibGUgU2Nvcm0gdG8gdXNlIHRoaXMgY2xhc3MsIGl0IHdpbGwgaG9sZCBhbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBmb3IgZGVidWdnaW5nXHJcbiAqIHB1cnBvc2VzLlxyXG4gKlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2VqcycpLFxyXG4gICAgICAgIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJyksXHJcbiAgICAgICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxuICAgIC8vIEBUT0RPLCBpbmplY3Qgc2Nvcm0gaW50ZXJmYWNlIGluc3RlYWQgb2YgYXNzdW1pbmcgd2luZG93LlxyXG4gICAgdmFyIFNjb3JtID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2Nvcm1JbnRlcmZhY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zY29ybUludGVyZmFjZSA9IHNjb3JtSW50ZXJmYWNlIHx8IHdpbmRvdztcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nvcm1BdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pbml0U3VjY2VzcyA9IFwiXCI7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgaW5jb21wbGV0ZTogXCJpbmNvbXBsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICBub3RBdHRlbXB0ZWQ6IFwibm90IGF0dGVtcHRlZFwiLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IFwiY29tcGxldGVkXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBTZWUgU2Nvcm0gUnVudGltZSBFTlYgUERGIFNlY3Rpb24gMy40XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLkxNU0tleXMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZXNzb25TdGF0dXM6IFwiY21pLmNvcmUubGVzc29uX3N0YXR1c1wiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Db3VudDogXCJjbWkuaW50ZXJhY3Rpb25zLl9jb3VudFwiLFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuZERhdGE6IFwiY21pLnN1c3BlbmRfZGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25JZDogXCJjbWkuaW50ZXJhY3Rpb25zLiMuaWRcIixcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uVHlwZTogXCJjbWkuaW50ZXJhY3Rpb25zLiMudHlwZVwiLCAvLyBAU0VFIExNU0ludGVyYWN0aW9uVHlwZXMgYmVsb3cuXHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkNvcnJlY3RQYXR0ZXJuOiBcImNtaS5pbnRlcmFjdGlvbnMuIy5jb3JyZWN0X3Jlc3BvbnNlcy4wLnBhdHRlcm5cIixcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uQWN0dWFsUGF0dGVybjogXCJjbWkuaW50ZXJhY3Rpb25zLiMuc3R1ZGVudF9yZXNwb25zZVwiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25SZXN1bHQ6IFwiY21pLmludGVyYWN0aW9ucy4jLnJlc3VsdFwiLCAvLyBAU0VFIExNU1Jlc3VsdFR5cGVzIGJlbG93XHJcbiAgICAgICAgICAgICAgICByYXdTY29yZTogXCJjbWkuY29yZS5zY29yZS5yYXdcIixcclxuICAgICAgICAgICAgICAgIHNlc3Npb25UaW1lOiBcImNtaS5jb3JlLnNlc3Npb25fdGltZVwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0aXZlSWQ6IFwiY21pLm9iamVjdGl2ZXMuIy5pZFwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0aXZlU3RhdHVzOiBcImNtaS5vYmplY3RpdmVzLiMuc3RhdHVzXCIgLy8gQFNFRSBMTVNPYmplY3RpdmVTdGF0dXNWYWx1ZXMgYmVsb3dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB2YWxpZCBcInN0YXR1c1wiIGZpZWxkIHdoZW4gd29ya2luZyB3aXRoIGNtaSBvYmplY3RpdmVzXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuTE1TT2JqZWN0aXZlU3RhdHVzVmFsdWVzID0gW1xyXG4gICAgICAgICAgICAgICAgXCJwYXNzZWRcIiwgXCJjb21wbGV0ZWRcIiwgXCJmYWlsZWRcIiwgXCJpbmNvbXBsZXRlXCIsIFwiYnJvd3NlZFwiLCBcIm5vdCBhdHRlbXB0ZWRcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZhbGlkIFwidHlwZVwiIGZpZWxkIHdoZW4gY3JlYXRpbmcgYW4gaW50ZXJhY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEBTZWUgU2Nvcm0gUnVudGltZSBFbnYgUERGIFNlY3Rpb24gMy40LjRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuTE1TSW50ZXJhY3Rpb25UeXBlcyA9IFtcclxuICAgICAgICAgICAgICAgIFwidHJ1ZS1mYWxzZVwiLCBcImNob2ljZVwiLCBcImZpbGwtaW5cIiwgXCJtYXRjaGluZ1wiLCBcInBlcmZvcm1hbmNlXCIsIFwic2VxdWVuY2luZ1wiLCBcImxpa2VydFwiLCBcIm51bWVyaWNcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZhbGlkIFwicmVzdWx0XCIgZmllbGQgd2hlbiBjcmVhdGluZyBhbiBpbnRlcmFjdGlvbi5cclxuICAgICAgICAgICAgICogQFNlZSBTY29ybSBSdW50aW1lIEVudiBQREYgU2VjdGlvbiAzLjQuNFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5MTVNSZXN1bHRUeXBlcyA9IFtcclxuICAgICAgICAgICAgICAgIFwiY29ycmVjdFwiLCBcIndyb25nXCIsIFwidW5hbnRpY2lwYXRlZFwiLCBcIm5ldXRyYWxcIiAvLyBhbmQgeC54XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHRoaXMuTE1TUmVzdWx0VHlwZU51bWJlciA9IC9bMC05XStcXC5bMC05XSsvOyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gZm9yICMuI1xyXG4gICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGEgPSB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsb2cuZGVidWcoXCJJbml0aWFsaXppbmcgU0NPUk0gQ0ggQVBJXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3Muc2Nvcm1FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJzY29ybUVuYWJsZWQgPT09IHRydWUsIGluaXRpYWxpemluZyBTQ09STVwiKTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9MTVNJbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiVGhlIExNUyBXcmFwcGVyIGFwcGVhcnMgdG8gYmUgbWlzc2luZy4gU2tpcHBpbmcgU0NPUk0gSW5pdGlhbGl6YXRpb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFN1Y2Nlc3MgPSBkb0xNU0luaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIC8vIGVycm9yIGluIGVhcmx5IElFLiBHSkYgY29uc29sZS5sb2coXCJpbml0aWFsaXplIHN1Y2Nlc3M/OiBcIiArIHN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdFN1Y2Nlc3MgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29ybUF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiU0NPUk0gaW5pdGlhbGl6ZWQgZnJvbSBTQ09STSBDSCBBUEkgc3VjY2Vzc2Z1bGx5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBcInRoYXRcIiBjbG9zdXJlIGZvciB0aGUgd2luZG93IGZ1bmN0aW9uLiBHSkYuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvTE1TRmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU0NPUk0gaW5pdGlhbGl6ZSBmcm9tIFNDT1JNIENIIEFQSSwgRkFJTEVEIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIkNvdWxkIG5vdCBpbml0aWFsaXplIFNDT1JNIEFQSS5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihcInNjb3JtRW5hYmxlZCA9PT0gZmFsc2UsIHNraXBwaW5nIFNDT1JNXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbml0aWFsaXplU3RhdHVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gZG9MTVNHZXRWYWx1ZSh0aGlzLkxNU0tleXMubGVzc29uU3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gdGhpcy5jb25zdGFudHMubm90QXR0ZW1wdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMZXNzb25TdGF0dXModGhpcy5jb25zdGFudHMuaW5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldExlc3NvblN0YXR1cyh0aGlzLmNvbnN0YW50cy5pbmNvbXBsZXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0TGVzc29uU3RhdHVzOiBmdW5jdGlvbiAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuY29tcHV0ZVNlc3Npb25UaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5zZXNzaW9uVGltZSwgZm9ybWF0dGVkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXMsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdID0gc3RhdHVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMZXNzb25TdGF0dXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBkb0xNU0dldFZhbHVlKHRoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0xlc3NvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExlc3NvblN0YXR1cygpID09PSB0aGlzLmNvbnN0YW50cy5jb21wbGV0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE9iamVjdGl2ZTogZnVuY3Rpb24oIGluZGV4ICkge1xyXG4gICAgICAgICAgICB2YXIgaWQsIHN0YXR1cztcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlkID0gZG9MTVNHZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZUlkKS5yZXBsYWNlKFwiI1wiLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gZG9MTVNHZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlkID0gdGhpcy5sZXNzb25EYXRhWyh0aGlzLkxNU0tleXMub2JqZWN0aXZlSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV07XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5vYmplY3RpdmVTdGF0dXMpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsb2cuZGVidWcodGVtcCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0T2JqZWN0aXZlOiBmdW5jdGlvbiggaW5kZXgsIGlkLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgbG9nLmRlYnVnKFwiU2V0IG9iamVjdGl2ZSBcIiArIGluZGV4ICsgXCIgXCIgKyBpZCArIFwiIFwiICsgc3RhdHVzICk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JtQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuY29tcHV0ZVNlc3Npb25UaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKHRoaXMuTE1TS2V5cy5zZXNzaW9uVGltZSwgZm9ybWF0dGVkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMub2JqZWN0aXZlSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNDb21taXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5vYmplY3RpdmVJZCkucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IGlkO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLm9iamVjdGl2ZVN0YXR1cykucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SW50ZXJhY3Rpb25Db3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSBkb0xNU0dldFZhbHVlKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvdW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvdW50XSB8fCAwOyAvLyBkZWZhdWx0IHRvIDAuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjb3VudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVJbnRlcmFjdGlvbjogZnVuY3Rpb24gKGluZGV4LCBpZCwgdHlwZSwgY29ycmVjdFJlc3BvbnNlLCBzdHVkZW50UmVzcG9uc2UsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBwYXNzIGluIGFuIG9iamVjdCB3aXRoIHRoZXNlIHZhbHVlcyBpbnN0ZWFkIG9mIGFsbCBvZiB0aGUgdmFsdWVzIGRpcmVjdGx5LlxyXG4gICAgICAgICAgICBsb2cuZGVidWcoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZCA9IGluZGV4LmlkO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IGluZGV4LnR5cGU7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0UmVzcG9uc2UgPSBpbmRleC5jb3JyZWN0UmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICBzdHVkZW50UmVzcG9uc2UgPSBpbmRleC5zdHVkZW50UmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlICYmICEoXy5jb250YWlucyh0aGlzLkxNU0ludGVyYWN0aW9uVHlwZXMsIHR5cGUpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIExNU0ludGVyYWN0aW9uVHlwZTogXCIgKyB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgISggXy5jb250YWlucyh0aGlzLkxNU1Jlc3VsdFR5cGVzLHJlc3VsdCkpICYmICFyZXN1bHQubWF0Y2godGhpcy5MTVNSZXN1bHRUeXBlTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIExNU1Jlc3VsdFR5cGU6IFwiICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlkID0gdGhpcy50cmltU3RyaW5nKGlkLCAyNTUpO1xyXG4gICAgICAgICAgICBpZCA9IHRoaXMucmVwbGFjZVNwYWNlcyhpZCwgXCJfXCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uSWQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSgodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uVHlwZSkucmVwbGFjZShcIiNcIiwgaW5kZXgpLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUoKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbkNvcnJlY3RQYXR0ZXJuKS5yZXBsYWNlKFwiI1wiLCBpbmRleCksIGNvcnJlY3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25BY3R1YWxQYXR0ZXJuKS5yZXBsYWNlKFwiI1wiLCBpbmRleCksIHN0dWRlbnRSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU1NldFZhbHVlKCh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25SZXN1bHQpLnJlcGxhY2UoXCIjXCIsIGluZGV4KSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGRvTE1TQ29tbWl0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvbklkKS5yZXBsYWNlKFwiI1wiLCBpbmRleCldID0gaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlc3NvbkRhdGFbKHRoaXMuTE1TS2V5cy5pbnRlcmFjdGlvblR5cGUpLnJlcGxhY2UoXCIjXCIsIGluZGV4KV0gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhWyh0aGlzLkxNU0tleXMuaW50ZXJhY3Rpb25Db3JyZWN0UGF0dGVybikucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IGNvcnJlY3RSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uQWN0dWFsUGF0dGVybikucmVwbGFjZShcIiNcIiwgaW5kZXgpXSA9IHN0dWRlbnRSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVsodGhpcy5MTVNLZXlzLmludGVyYWN0aW9uUmVzdWx0KS5yZXBsYWNlKFwiI1wiLCBpbmRleCldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTdXNwZW5kRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNldHRpbmcgc3VzcGVuZCBkYXRhXCIpO1xyXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc3VzcGVuZERhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNDb21taXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzc29uRGF0YVt0aGlzLkxNU0tleXMuc3VzcGVuZERhdGFdID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3VzcGVuZERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBcIlwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRvTE1TR2V0VmFsdWUodGhpcy5MTVNLZXlzLnN1c3BlbmREYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlc3NvbkRhdGFbdGhpcy5MTVNLZXlzLnN1c3BlbmREYXRhXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcmtDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29ybUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmNvbXB1dGVTZXNzaW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMuc2Vzc2lvblRpbWUsIGZvcm1hdHRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9MTVNTZXRWYWx1ZSh0aGlzLkxNU0tleXMubGVzc29uU3RhdHVzLCB0aGlzLmNvbnN0YW50cy5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5sZXNzb25TdGF0dXNdID0gdGhpcy5jb25zdGFudHMuY29tcGxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFJhd1Njb3JlOiBmdW5jdGlvbiAoc2NvcmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gdGhpcy5jb21wdXRlU2Vzc2lvblRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUodGhpcy5MTVNLZXlzLnNlc3Npb25UaW1lLCBmb3JtYXR0ZWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGRvTE1TU2V0VmFsdWUodGhpcy5MTVNLZXlzLnJhd1Njb3JlLCBzY29yZSk7XHJcbiAgICAgICAgICAgICAgICBkb0xNU0NvbW1pdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXNzb25EYXRhW3RoaXMuTE1TS2V5cy5yYXdTY29yZV0gPSBzY29yZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmF3U2NvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNjb3JlID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nvcm1BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHNjb3JlID0gZG9MTVNHZXRWYWx1ZSh0aGlzLkxNU0tleXMucmF3U2NvcmUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2NvcmUgPSB0aGlzLmxlc3NvbkRhdGFbdGhpcy5MTVNLZXlzLnJhd1Njb3JlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlU2Vzc2lvblRpbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVOb3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGltZURpZmZlcmVuY2UgPSB0aW1lTm93LmdldFRpbWUoKSAtIHRoaXMuc2Vzc2lvblN0YXJ0VGltZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlRGlmZmVyZW5jZSA9IG5ldyBEYXRlKHRpbWVEaWZmZXJlbmNlKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNlc3Npb24gdGltZSBzZXQgdG86IFwiICsgZm9ybWF0dGVkVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0RGF0ZUZvclNDT1JNKGRhdGVEaWZmZXJlbmNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdERhdGVGb3JTQ09STTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsVGltZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBociA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICB2YXIgc2VjID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaHIgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxUaW1lID0gdG90YWxUaW1lICsgXCIwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG90YWxUaW1lID0gdG90YWxUaW1lICsgaHIgKyBcIjpcIjtcclxuICAgICAgICAgICAgaWYgKG1pbiA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBcIjBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBtaW4gKyBcIjpcIjtcclxuICAgICAgICAgICAgaWYgKHNlYyA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBcIjBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFRpbWUgPSB0b3RhbFRpbWUgKyBzZWM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG90YWxUaW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgdG9MZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiB0b0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCB0b0xlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VTcGFjZXM6IGZ1bmN0aW9uIChzdHIsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzL2csIHJlcGxhY2VtZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldExlc3NvbkRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVzc29uRGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjb3JtO1xyXG59KCkpOyIsIi8qKlxyXG4gKiBAYXV0aG9yIEdlb3JnZSBGcmlja1xyXG4gKiBAdmVyc2lvbiAxLjEuMCBAIDA5LzIxLzE1XHJcbiAqIEBjcmVhdGlvbiAwNi8wNC8yMDE1XHJcbiAqIENvcHlyaWdodCAyMDE1IENoaWxkcmVuJ3MgSG9zcGl0YWxcclxuICogVGhpcyBzb2Z0d2FyZSBpcyB0aGUgcHJvcGVydHkgb2YgQ2hpbGRyZW4ncyBIb3NwaXRhbC5cclxuICpcclxuICogVGhlIGJvb3Qgc3RhdGUgY29uZmlndXJlcyB0aGUgZ2FtZSBiYXNlZCBvbiB0aGUgZGV2aWNlIGxvYWRpbmcgaXQuIFRoZSBiYXNpYyBnYW1lIGRhdGEgaXMgbG9hZGVkIHNvXHJcbiAqIHRoYXQgdGhlIHByZWxvYWQgc3RhdGUgaGFzIGFsbCBwcmVyZXF1aXNpdGVzLiBUaGUgc2V0dGluZ3NcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0dmFyIEJhc2UgPSByZXF1aXJlKFwiYmFzZWpzXCIpO1xyXG5cclxuXHR2YXIgQm9vdFN0YXRlID0gQmFzZS5leHRlbmQoe1xyXG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0IXNldHRpbmdzIHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5IHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLmxvYWRpbmdfaW1hZ2VfdXJsIHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLnBsYXlfanNvbl9rZXkgfHxcclxuXHRcdFx0XHQhc2V0dGluZ3MucGxheV9qc29uX3VybCB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5wcmVsb2FkX3N0YXRlX25hbWVcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhyb3cgXCJCb290IFN0YXRlIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkLlwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNhbGxlZCBmaXJzdCBiZWZvcmUgcHJlbG9hZC5cclxuXHRcdCAqL1xyXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLnJlYWR5ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2FtZS5pbnB1dC5tYXhQb2ludGVycyA9IDE7XHJcblx0XHRcdC8vIERvbid0IHBhdXNlIHRoZSBnYW1lIHdoZW4gdGhlIG1vdXNlIGxlYXZlcy5cclxuXHRcdFx0dGhpcy5nYW1lLnN0YWdlLmRpc2FibGVWaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcclxuXHRcdFx0Ly90aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nYW1lLnNjYWxlLnJlZnJlc2goKTtcclxuXHJcblx0XHRcdGlmICh0eXBlb2YgUGhhc2VySW5wdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHR0aGlzLmdhbWUucGx1Z2lucy5hZGQoUGhhc2VySW5wdXQuUGx1Z2luKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSW4gb3JkZXIgdG8gc2hvdyB0aGUgbG9hZGluZyBpbWFnZSB3aGlsZSBhbGwgb2YgdGhlIHJlc291cmNlcyBsb2FkLCBpdCBnZXRzIGxvYWRlZCBkdXJpbmcgdGhlXHJcblx0XHQgKiBib290IHN0YXRlLCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBkdXJpbmcgcHJlbG9hZCBvZiB0aGUgcHJlbG9hZCBzdGF0ZS5cclxuXHRcdCAqL1xyXG5cdFx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUubG9hZC5pbWFnZShcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5LFxyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubG9hZGluZ19pbWFnZV91cmxcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQudGV4dChcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnBsYXlfanNvbl9rZXksXHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5wbGF5X2pzb25fdXJsXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5sb2FkLm9uTG9hZENvbXBsZXRlLmFkZE9uY2UodGhpcy5sb2FkQ29tcGxldGUsIHRoaXMpO1xyXG5cdFx0fSxcclxuXHRcdGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgcGxheUpzb25EYXRhID0gdGhpcy5nYW1lLmNhY2hlLmdldFRleHQodGhpcy5zZXR0aW5ncy5wbGF5X2pzb25fa2V5KTtcclxuXHRcdFx0dmFyIGNvbmZpZyA9IEpTT04ucGFyc2UocGxheUpzb25EYXRhKTtcclxuXHRcdFx0LyppZihjb25maWcuYXV0b1NjYWxlKXtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XHJcbiAgICAgICAgICAgIH0qL1xyXG5cdFx0XHR0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuXHRcdFx0dGhpcy5nYW1lLnNjYWxlLmZ1bGxTY3JlZW5TY2FsZU1vZGUgPSBQaGFzZXIuU2NhbGVNYW5hZ2VyLlNIT1dfQUxMO1xyXG5cclxuXHRcdFx0dGhpcy5nYW1lLnN0YXRlLnN0YXJ0KHRoaXMuc2V0dGluZ3MucHJlbG9hZF9zdGF0ZV9uYW1lKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFNjYWxlcyB0aGUgZ2FtZUNvbnRhaW5lciBzbyB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGUgaW5uZXIgYnJvd3NlciB3aWR0aCBvciBoZWlnaHRcclxuXHRcdCAqL1xyXG5cdFx0LypvblJlc2l6ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dSYXRpbyA9IHdpbmRvd1dpZHRoIC8gd2luZG93SGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZ2FtZUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZ2FtZUNvbnRhaW5lclwiKTtcclxuICAgICAgICAgICAgdmFyIGJveFJhdGlvID0gdGhpcy5nYW1lLndvcmxkLndpZHRoIC8gdGhpcy5nYW1lLndvcmxkLmhlaWdodDtcclxuICAgICAgICAgICAgaWYod2luZG93UmF0aW8gPCBib3hSYXRpbyl7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2luZG93V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICh3aW5kb3dXaWR0aCAvIGJveFJhdGlvKSArIFwicHhcIjtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gKHdpbmRvd0hlaWdodCAqIGJveFJhdGlvKSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIGdhbWVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gd2luZG93SGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSovXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gQm9vdFN0YXRlO1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjAgQCAwOS8yMi8xNVxyXG4gKiBAY3JlYXRpb24gMDcvMDEvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIG1haW4gc3RhdGUuIEl0IHdpbGwgYmUgcmVzdGFydGVkIGV2ZXJ5IHRpbWUgYW4gQWN0IGNoYW5nZXMuIFRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIHN0YXRlIGlzIHRvXHJcbiAqIGFsbG93IHRoZSBjdXJyZW50IEFjdCB0byBsb2FkIG1lZGlhIGJlZm9yZSBzdGFydGluZy4gRXZlcnl0aGluZyBpcyBkb25lIHZpYSB0aGUgUGxheSwgbm8gYWN0IHNob3VsZCBiZVxyXG4gKiByZWZlcmVuY2VkIG9yIGluc3RhbnRpYXRlZCBoZXJlLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLFxyXG4gICAgICAgIExvYWRpbmdTY3JlZW4gPSByZXF1aXJlKCcuLi9sb2FkaW5nLXNjcmVlbicpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKCdiYXNlanMnKTtcclxuXHJcbiAgICB2YXIgTWFpblN0YXRlID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgfHwgIXNldHRpbmdzLmxvYWRpbmdfaW1hZ2Vfa2V5ICkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNYWluIHN0YXRlIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkLlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYmVmb3JlIHByZWxvYWQsIGR1cmluZyBlYWNoIHJlc3RhcnQuXHJcbiAgICAgICAgICogQHBhcmFtIGlzUmVzdGFydCB0cnVlIGlmIGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIGEgcmVzdGFydC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoaXNSZXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGxvZy5pbmZvKFwiTWFpbiBzdGF0ZSBjcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiggIXRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLmxvYWRpbmdTY3JlZW4gPSBuZXcgTG9hZGluZ1NjcmVlbih0aGlzLmdhbWUsIHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc1Jlc3RhcnQgPSBpc1Jlc3RhcnQ7IC8vIHdlIGFyZSByZXN0YXJ0aW5nIHRoaXMgc3RhdGUgZHVlIHRvIGFjdCBjaGFuZ2UuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYWZ0ZXIgaW5pdC4gVGhpcyBpcyB3aGVyZSBtZWRpYSBjYW4gYmUgZG93bmxvYWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkucHJlbG9hZEFjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMubG9hZENvbXBsZXRlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWRDb21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5sb2FkaW5nU2NyZWVuLnNob3dDb21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gcHJlbG9hZCBpcyBjb21wbGV0ZSwgYWxsIG1lZGlhIGlzIGRvd25sb2FkZWQuIChCdXQgd2UnbGwgY2hlY2sgb3Vyc2VsdmVzIGFueXdheXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXIgaXMgY2FsbGVkIGVhY2ggZ2FtZSB0aWNrIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byByZW5kZXIgYW55dGhpbmcgJ29uIHRvcCcgc3VjaCBhcyBhIEhVRC5cclxuICAgICAgICAgKiBVc2VkIGhlcmUgZm9yIGRlYnVnZ2luZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkucmVuZGVyRGVidWcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBlYWNoIGdhbWUgdGljaywgdXNlZCB0byBtYW51YWxseSBjaGVjayB0aGUgbWVkaWEgc3RhdGUgYW5kIHRoZW4gc3RhcnQuIE90aGVyd2lzZSBpdCBwYXNzZXMgdGhlXHJcbiAgICAgICAgICogdXBkYXRlIGFsb25nIHRvIHRoZSBQbGF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkudGlja1VwZGF0ZSh0aGlzLmdhbWUudGltZS5ub3cpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZS5wbGF5LmlzUHJlbG9hZEFjdENvbXBsZXRlKCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkuc2hvd05leHRBY3QodGhpcy5pc1Jlc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnBsYXkuc2VuZENyb3NzQWN0VmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWUubG9hZGluZ1NjcmVlbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1haW5TdGF0ZTtcclxufSgpKTsiLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4xLjAgQCAwOS8yMS8xNVxyXG4gKiBAY3JlYXRpb24gMDYvMDQvMjAxNVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBDaGlsZHJlbidzIEhvc3BpdGFsXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgdGhlIHByb3BlcnR5IG9mIENoaWxkcmVuJ3MgSG9zcGl0YWwuXHJcbiAqXHJcbiAqIFRoZSBwcmVsb2FkIHN0YXRlIHNob3dzIHRoZSBsb2FkaW5nIHNjcmVlbiB3aGlsZSBpdCBwcm9jZXNzZXMgYWxsIG9mIHRoZSB0aGVtZXMgYW5kIHNjZW5lIGRhdGEgZm9yIGVhY2hcclxuICogYWN0IGVudHJ5IGluIHRoZSBwbGF5LlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgbG9nID0gcmVxdWlyZShcImxvZ2xldmVsXCIpLFxyXG5cdFx0QmFzZSA9IHJlcXVpcmUoXCJiYXNlanNcIiksXHJcblx0XHRQbGF5ID0gcmVxdWlyZShcIi4uL3BsYXkvcGxheVwiKSxcclxuXHRcdExvYWRpbmdTY3JlZW4gPSByZXF1aXJlKFwiLi4vbG9hZGluZy1zY3JlZW5cIiksXHJcblx0XHRfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcclxuXHJcblx0dmFyIFByZWxvYWRTdGF0ZSA9IEJhc2UuZXh0ZW5kKHtcclxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdCFzZXR0aW5ncyB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5sb2FkaW5nX2ltYWdlX2tleSB8fFxyXG5cdFx0XHRcdCFzZXR0aW5ncy5wbGF5X2pzb25fa2V5IHx8XHJcblx0XHRcdFx0IXNldHRpbmdzLm1haW5fc3RhdGVfbmFtZVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHR0aHJvdyBcIlByZWxvYWQgc3RhdGUgaXMgbWlzc2luZyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gZmllbGQuXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSBwcmVsb2FkLiBKdXN0IHJlY29yZCB0aGF0IHRoaW5ncyBhcmVuJ3QgY29tcGxldGUgeWV0LlxyXG5cdFx0ICovXHJcblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMubG9hZGluZ1NjcmVlbiA9IG5ldyBMb2FkaW5nU2NyZWVuKHRoaXMuZ2FtZSwgdGhpcy5zZXR0aW5ncyk7XHJcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBwbGF5SnNvbkRhdGEgPSB0aGlzLmdhbWUuY2FjaGUuZ2V0VGV4dCh0aGlzLnNldHRpbmdzLnBsYXlfanNvbl9rZXkpO1xyXG5cdFx0XHRpZiAoIXBsYXlKc29uRGF0YSkge1xyXG5cdFx0XHRcdHRocm93IFwiRXJyb3IgaW4gUHJlbG9hZDogRGlkIG5vdCBmaW5kIHBsYXkganNvbiBkYXRhIGluIGNhY2hlLlwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2FtZS5wbGF5ID0gbmV3IFBsYXkoXHJcblx0XHRcdFx0dGhpcy5nYW1lLFxyXG5cdFx0XHRcdEpTT04ucGFyc2UocGxheUpzb25EYXRhKSxcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTaG93IHRoZSBwcmVsb2FkIGltYWdlLCBhbGxvdyB0aGUgUGxheSB0byBsb2FkIGRhdGEuXHJcblx0XHQgKi9cclxuXHRcdHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuZ2FtZS5wbGF5LmlzTG9nZ2luZygpID09PSB0cnVlKSB7XHJcblx0XHRcdFx0bG9nLmVuYWJsZUFsbCgpO1xyXG5cdFx0XHRcdGxvZy53YXJuKFwiTG9nZ2luZyBFbmFibGVkXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxvZy5kaXNhYmxlQWxsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5sb2FkaW5nU2NyZWVuLnNob3coKTtcclxuXHRcdFx0dmFyIHByZWxvYWRTZXQgPSB0aGlzLmdhbWUucGxheS5nZXRSZXF1aXJlZFJlc291cmNlTGlzdCgpO1xyXG5cdFx0XHRfLmVhY2goXHJcblx0XHRcdFx0cHJlbG9hZFNldCxcclxuXHRcdFx0XHRmdW5jdGlvbiAocHJlbG9hZEl0ZW0pIHtcclxuXHRcdFx0XHRcdHRoaXMuZ2FtZS5sb2FkLnRleHQocHJlbG9hZEl0ZW0ua2V5LCBwcmVsb2FkSXRlbS5maWxlKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQuYXVkaW8oXCJhdWRpb0ZpeFwiLCBbXHJcblx0XHRcdFx0dGhpcy5nYW1lLmNvbmZpZy5hc3NldFBhdGggKyBcImVuZ2luZS9zaWxlbmNlLW00YS5tNGFcIixcclxuXHRcdFx0XHR0aGlzLmdhbWUuY29uZmlnLmFzc2V0UGF0aCArIFwiZW5naW5lL3NpbGVuY2Utb2dnLm9nZ1wiLFxyXG5cdFx0XHRdKTtcclxuXHRcdFx0dGhpcy5nYW1lLmxvYWQub25Mb2FkQ29tcGxldGUuYWRkT25jZSh0aGlzLmxvYWRDb21wbGV0ZSwgdGhpcyk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDYWxsZWQgd2hlbiBwcmVsb2FkIGlzIGNvbXBsZXRlLCBhbGwgbWVkaWEgaXMgZG93bmxvYWRlZC4gKEJ1dCB3ZSdsbCBjaGVjayBvdXJzZWx2ZXMgYW55d2F5cylcclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMubG9hZGluZ1NjcmVlbi5zaG93Q2xpY2t0aHJvdWdoKCk7XHJcblx0XHRcdC8vIHRoaXMubG9hZGluZ1NjcmVlbi5zaG93Q29tcGxldGUoKTtcclxuXHRcdFx0Ly90aGlzLmxvYWRpbmdTY3JlZW4uZGVzdHJveSgpO1xyXG5cdFx0fSxcclxuXHRcdGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmdhbWUuc2Nvcm0uaW5pdGlhbGl6ZSh7XHJcblx0XHRcdFx0c2Nvcm1FbmFibGVkOiBfZW52aXJvbm1lbnRTZXR0aW5ncy5zY29ybUVuYWJsZWQsXHJcblx0XHRcdFx0Ly9zY29ybUVuYWJsZWQ6IHRoaXMuZ2FtZS5wbGF5LmlzU2Nvcm1FbmFibGVkKCksXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLmdhbWUuc2Nvcm0uaW5pdGlhbGl6ZVN0YXR1cygpO1xyXG5cdFx0XHR0aGlzLmdhbWUucGxheS5sb2FkU2Nvcm1EYXRhKCk7XHJcblx0XHRcdHRoaXMuZ2FtZS5wbGF5LnNlbGVjdERlZmF1bHRBY3QoKTtcclxuXHRcdFx0dmFyIGF1ZGlvRml4ID0gdGhpcy5nYW1lLmFkZC5hdWRpbyhcImF1ZGlvRml4XCIpO1xyXG5cdFx0XHR0aGlzLmdhbWUuaW5wdXQub25UYXAuYWRkKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRhdWRpb0ZpeC5wbGF5KCk7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5zdGFydCh0aGlzLnNldHRpbmdzLm1haW5fc3RhdGVfbmFtZSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHQvL3RoaXMuc3RhdGUuc3RhcnQodGhpcy5zZXR0aW5ncy5tYWluX3N0YXRlX25hbWUpOyAvLyBUaGUgXCJQbGF5XCIgY2FuIGFsc28gZG8gdGhpcy5cclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gUHJlbG9hZFN0YXRlO1xyXG59KSgpO1xyXG4iLCIvKipcclxuICogQGF1dGhvciBHZW9yZ2UgRnJpY2tcclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGNyZWF0aW9uIDA2LzA0LzIwMTVcclxuICogQ29weXJpZ2h0IDIwMTUgQ2hpbGRyZW4ncyBIb3NwaXRhbFxyXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHRoZSBwcm9wZXJ0eSBvZiBDaGlsZHJlbidzIEhvc3BpdGFsLlxyXG4gKlxyXG4gKiBUaGlzIGZpbGUgZXhpc3RzIHNvIHRoYXQgc3RhcnR1cCBvZiBhbiBlbmdpbmUgY2FuIGJlIGNvbnRyb2xsZWQuIFRoaXMgZmlsZSBpcyBzaW1wbHkgYSBzdHViIHRoYXQgd29ya3MgdG9cclxuICogYnVpbGQgdGhlIGVuZ2luZSBhbmQgdGhlbiBzdGFydCBpdC4gVGhpcyBtZWFucyB0aGF0IHRoZSBlbmdpbmUgY2FuIGJlIGxvYWRlZCB3aXRob3V0IGl0IHN0YXJ0aW5nIGZvclxyXG4gKiBwdXJwb3NlcyBvZiB0ZXN0aW5nLCBkZWJ1Z2dpbmcsIGFuZCBhZGRpbmcgYW55IGNvZGUgdGhhdCBjb21lcyB1cCB0aGF0IGhhcHBlbnMgYmVmb3JlL2FmdGVyIHRoZSBlbmdpbmUgaXNcclxuICogZG9uZS5cclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZW5naW5lL3NjZW5lLWVuZ2luZScpO1xyXG5cclxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXHJcbiAgICAgICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7fVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcbiAgICAgICAgICAgIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggJiYgdG9TdHJpbmcuY2FsbChzZWFyY2gpID09PSAnW29iamVjdCBSZWdFeHBdJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgLy8gYFRvSW50ZWdlcmBcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyAhPT0gcG9zKSB7IC8vIGJldHRlciBgaXNOYU5gXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB0aGUgYGluZGV4T2ZgIGNhbGwgaWYgbm8gbWF0Y2ggaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IHN0cmluZ0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzZWFyY2hMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoc3RhcnQgKyBpbmRleCkgIT09IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogc3RhcnRzV2l0aCxcclxuICAgICAgICAgICAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpO1xyXG4gICAgfVxyXG59KCkpO1xyXG4iXX0=
